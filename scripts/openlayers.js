var ol = (function () {
  "use strict";
  function t(t) {
    t.stopPropagation();
  }
  var e = class {
      constructor(t) {
        this.propagationStopped,
          this.defaultPrevented,
          (this.type = t),
          (this.target = null);
      }
      preventDefault() {
        this.defaultPrevented = !0;
      }
      stopPropagation() {
        this.propagationStopped = !0;
      }
    },
    i = "propertychange";
  var n = class {
    constructor() {
      this.disposed = !1;
    }
    dispose() {
      this.disposed || ((this.disposed = !0), this.disposeInternal());
    }
    disposeInternal() {}
  };
  function r(t, e, i) {
    let n, r;
    i = i || s;
    let o = 0,
      a = t.length,
      l = !1;
    for (; o < a; )
      (n = o + ((a - o) >> 1)),
        (r = +i(t[n], e)),
        r < 0 ? (o = n + 1) : ((a = n), (l = !r));
    return l ? o : ~o;
  }
  function s(t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }
  function o(t, e) {
    return t < e ? 1 : t > e ? -1 : 0;
  }
  function a(t, e, i) {
    if (t[0] <= e) return 0;
    const n = t.length;
    if (e <= t[n - 1]) return n - 1;
    if ("function" == typeof i) {
      for (let r = 1; r < n; ++r) {
        const n = t[r];
        if (n === e) return r;
        if (n < e) return i(e, t[r - 1], n) > 0 ? r - 1 : r;
      }
      return n - 1;
    }
    if (i > 0) {
      for (let i = 1; i < n; ++i) if (t[i] < e) return i - 1;
      return n - 1;
    }
    if (i < 0) {
      for (let i = 1; i < n; ++i) if (t[i] <= e) return i;
      return n - 1;
    }
    for (let i = 1; i < n; ++i) {
      if (t[i] == e) return i;
      if (t[i] < e) return t[i - 1] - e < e - t[i] ? i - 1 : i;
    }
    return n - 1;
  }
  function l(t, e, i) {
    for (; e < i; ) {
      const n = t[e];
      (t[e] = t[i]), (t[i] = n), ++e, --i;
    }
  }
  function h(t, e) {
    const i = Array.isArray(e) ? e : [e],
      n = i.length;
    for (let e = 0; e < n; e++) t[t.length] = i[e];
  }
  function c(t, e) {
    const i = t.length;
    if (i !== e.length) return !1;
    for (let n = 0; n < i; n++) if (t[n] !== e[n]) return !1;
    return !0;
  }
  function u(t, e, i) {
    const n = e || s;
    return t.every(function (e, r) {
      if (0 === r) return !0;
      const s = n(t[r - 1], e);
      return !(s > 0 || (i && 0 === s));
    });
  }
  function d() {
    return !0;
  }
  function g() {
    return !1;
  }
  function f() {}
  function p(t) {
    let e,
      i,
      n,
      r = !1;
    return function () {
      const s = Array.prototype.slice.call(arguments);
      return (
        (r && this === n && c(s, i)) ||
          ((r = !0), (n = this), (i = s), (e = t.apply(this, arguments))),
        e
      );
    };
  }
  function m(t) {
    return (function () {
      let e;
      try {
        e = t();
      } catch (t) {
        return Promise.reject(t);
      }
      return e instanceof Promise ? e : Promise.resolve(e);
    })();
  }
  function _(t) {
    for (const e in t) delete t[e];
  }
  function y(t) {
    let e;
    for (e in t) return !1;
    return !e;
  }
  var x = class extends n {
      constructor(t) {
        super(),
          (this.eventTarget_ = t),
          (this.pendingRemovals_ = null),
          (this.dispatching_ = null),
          (this.listeners_ = null);
      }
      addEventListener(t, e) {
        if (!t || !e) return;
        const i = this.listeners_ || (this.listeners_ = {}),
          n = i[t] || (i[t] = []);
        n.includes(e) || n.push(e);
      }
      dispatchEvent(t) {
        const i = "string" == typeof t,
          n = i ? t : t.type,
          r = this.listeners_ && this.listeners_[n];
        if (!r) return;
        const s = i ? new e(t) : t;
        s.target || (s.target = this.eventTarget_ || this);
        const o = this.dispatching_ || (this.dispatching_ = {}),
          a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        let l;
        n in o || ((o[n] = 0), (a[n] = 0)), ++o[n];
        for (let t = 0, e = r.length; t < e; ++t)
          if (
            ((l =
              "handleEvent" in r[t] ? r[t].handleEvent(s) : r[t].call(this, s)),
            !1 === l || s.propagationStopped)
          ) {
            l = !1;
            break;
          }
        if (0 == --o[n]) {
          let t = a[n];
          for (delete a[n]; t--; ) this.removeEventListener(n, f);
          delete o[n];
        }
        return l;
      }
      disposeInternal() {
        this.listeners_ && _(this.listeners_);
      }
      getListeners(t) {
        return (this.listeners_ && this.listeners_[t]) || void 0;
      }
      hasListener(t) {
        return (
          !!this.listeners_ &&
          (t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0)
        );
      }
      removeEventListener(t, e) {
        const i = this.listeners_ && this.listeners_[t];
        if (i) {
          const n = i.indexOf(e);
          -1 !== n &&
            (this.pendingRemovals_ && t in this.pendingRemovals_
              ? ((i[n] = f), ++this.pendingRemovals_[t])
              : (i.splice(n, 1), 0 === i.length && delete this.listeners_[t]));
        }
      }
    },
    v = "change",
    S = "error",
    C = "contextmenu",
    w = "click",
    W = "dblclick",
    E = "dragenter",
    R = "dragover",
    T = "drop",
    P = "keydown",
    b = "keypress",
    F = "load",
    I = "touchmove",
    L = "wheel";
  function M(t, e, i, n, r) {
    if ((n && n !== t && (i = i.bind(n)), r)) {
      const n = i;
      i = function () {
        t.removeEventListener(e, i), n.apply(this, arguments);
      };
    }
    const s = { target: t, type: e, listener: i };
    return t.addEventListener(e, i), s;
  }
  function O(t, e, i, n) {
    return M(t, e, i, n, !0);
  }
  function k(t) {
    t && t.target && (t.target.removeEventListener(t.type, t.listener), _(t));
  }
  class A extends x {
    constructor() {
      super(),
        (this.on = this.onInternal),
        (this.once = this.onceInternal),
        (this.un = this.unInternal),
        (this.revision_ = 0);
    }
    changed() {
      ++this.revision_, this.dispatchEvent(v);
    }
    getRevision() {
      return this.revision_;
    }
    onInternal(t, e) {
      if (Array.isArray(t)) {
        const i = t.length,
          n = new Array(i);
        for (let r = 0; r < i; ++r) n[r] = M(this, t[r], e);
        return n;
      }
      return M(this, t, e);
    }
    onceInternal(t, e) {
      let i;
      if (Array.isArray(t)) {
        const n = t.length;
        i = new Array(n);
        for (let r = 0; r < n; ++r) i[r] = O(this, t[r], e);
      } else i = O(this, t, e);
      return (e.ol_key = i), i;
    }
    unInternal(t, e) {
      const i = e.ol_key;
      if (i) N(i);
      else if (Array.isArray(t))
        for (let i = 0, n = t.length; i < n; ++i)
          this.removeEventListener(t[i], e);
      else this.removeEventListener(t, e);
    }
  }
  function N(t) {
    if (Array.isArray(t)) for (let e = 0, i = t.length; e < i; ++e) k(t[e]);
    else k(t);
  }
  A.prototype.on, A.prototype.once, A.prototype.un;
  var D = A;
  function G() {
    throw new Error("Unimplemented abstract method.");
  }
  let B = 0;
  function j(t) {
    return t.ol_uid || (t.ol_uid = String(++B));
  }
  class z extends e {
    constructor(t, e, i) {
      super(t), (this.key = e), (this.oldValue = i);
    }
  }
  var U = class extends D {
      constructor(t) {
        super(),
          this.on,
          this.once,
          this.un,
          j(this),
          (this.values_ = null),
          void 0 !== t && this.setProperties(t);
      }
      get(t) {
        let e;
        return (
          this.values_ &&
            this.values_.hasOwnProperty(t) &&
            (e = this.values_[t]),
          e
        );
      }
      getKeys() {
        return (this.values_ && Object.keys(this.values_)) || [];
      }
      getProperties() {
        return (this.values_ && Object.assign({}, this.values_)) || {};
      }
      getPropertiesInternal() {
        return this.values_;
      }
      hasProperties() {
        return !!this.values_;
      }
      notify(t, e) {
        let n;
        (n = `change:${t}`),
          this.hasListener(n) && this.dispatchEvent(new z(n, t, e)),
          (n = i),
          this.hasListener(n) && this.dispatchEvent(new z(n, t, e));
      }
      addChangeListener(t, e) {
        this.addEventListener(`change:${t}`, e);
      }
      removeChangeListener(t, e) {
        this.removeEventListener(`change:${t}`, e);
      }
      set(t, e, i) {
        const n = this.values_ || (this.values_ = {});
        if (i) n[t] = e;
        else {
          const i = n[t];
          (n[t] = e), i !== e && this.notify(t, i);
        }
      }
      setProperties(t, e) {
        for (const i in t) this.set(i, t[i], e);
      }
      applyProperties(t) {
        t.values_ &&
          Object.assign(this.values_ || (this.values_ = {}), t.values_);
      }
      unset(t, e) {
        if (this.values_ && t in this.values_) {
          const i = this.values_[t];
          delete this.values_[t],
            y(this.values_) && (this.values_ = null),
            e || this.notify(t, i);
        }
      }
    },
    q = "add",
    V = "remove";
  const X = "length";
  class Z extends e {
    constructor(t, e, i) {
      super(t), (this.element = e), (this.index = i);
    }
  }
  class K extends U {
    constructor(t, e) {
      if (
        (super(),
        this.on,
        this.once,
        this.un,
        (e = e || {}),
        (this.unique_ = !!e.unique),
        (this.array_ = t || []),
        this.unique_)
      )
        for (let t = 0, e = this.array_.length; t < e; ++t)
          this.assertUnique_(this.array_[t], t);
      this.updateLength_();
    }
    clear() {
      for (; this.getLength() > 0; ) this.pop();
    }
    extend(t) {
      for (let e = 0, i = t.length; e < i; ++e) this.push(t[e]);
      return this;
    }
    forEach(t) {
      const e = this.array_;
      for (let i = 0, n = e.length; i < n; ++i) t(e[i], i, e);
    }
    getArray() {
      return this.array_;
    }
    item(t) {
      return this.array_[t];
    }
    getLength() {
      return this.get(X);
    }
    insertAt(t, e) {
      if (t < 0 || t > this.getLength())
        throw new Error("Index out of bounds: " + t);
      this.unique_ && this.assertUnique_(e),
        this.array_.splice(t, 0, e),
        this.updateLength_(),
        this.dispatchEvent(new Z(q, e, t));
    }
    pop() {
      return this.removeAt(this.getLength() - 1);
    }
    push(t) {
      this.unique_ && this.assertUnique_(t);
      const e = this.getLength();
      return this.insertAt(e, t), this.getLength();
    }
    remove(t) {
      const e = this.array_;
      for (let i = 0, n = e.length; i < n; ++i)
        if (e[i] === t) return this.removeAt(i);
    }
    removeAt(t) {
      if (t < 0 || t >= this.getLength()) return;
      const e = this.array_[t];
      return (
        this.array_.splice(t, 1),
        this.updateLength_(),
        this.dispatchEvent(new Z(V, e, t)),
        e
      );
    }
    setAt(t, e) {
      if (t >= this.getLength()) return void this.insertAt(t, e);
      if (t < 0) throw new Error("Index out of bounds: " + t);
      this.unique_ && this.assertUnique_(e, t);
      const i = this.array_[t];
      (this.array_[t] = e),
        this.dispatchEvent(new Z(V, i, t)),
        this.dispatchEvent(new Z(q, e, t));
    }
    updateLength_() {
      this.set(X, this.array_.length);
    }
    assertUnique_(t, e) {
      for (let i = 0, n = this.array_.length; i < n; ++i)
        if (this.array_[i] === t && i !== e)
          throw new Error("Duplicate item added to a unique collection");
    }
  }
  var H = 0,
    Y = 1,
    Q = 2,
    $ = 3,
    J = 4;
  function tt(t) {
    return Math.pow(t, 3);
  }
  function et(t) {
    return 1 - tt(1 - t);
  }
  function it(t) {
    return 3 * t * t - 2 * t * t * t;
  }
  function nt(t) {
    return t;
  }
  var rt = class extends x {
    constructor(t, e, i) {
      super(),
        (i = i || {}),
        (this.tileCoord = t),
        (this.state = e),
        (this.interimTile = null),
        (this.key = ""),
        (this.transition_ = void 0 === i.transition ? 250 : i.transition),
        (this.transitionStarts_ = {}),
        (this.interpolate = !!i.interpolate);
    }
    changed() {
      this.dispatchEvent(v);
    }
    release() {
      this.state === $ && this.setState(J);
    }
    getKey() {
      return this.key + "/" + this.tileCoord;
    }
    getInterimTile() {
      if (!this.interimTile) return this;
      let t = this.interimTile;
      do {
        if (t.getState() == Q) return (this.transition_ = 0), t;
        t = t.interimTile;
      } while (t);
      return this;
    }
    refreshInterimChain() {
      if (!this.interimTile) return;
      let t = this.interimTile,
        e = this;
      do {
        if (t.getState() == Q) {
          t.interimTile = null;
          break;
        }
        t.getState() == Y
          ? (e = t)
          : t.getState() == H
          ? (e.interimTile = t.interimTile)
          : (e = t),
          (t = e.interimTile);
      } while (t);
    }
    getTileCoord() {
      return this.tileCoord;
    }
    getState() {
      return this.state;
    }
    setState(t) {
      if (this.state !== $ && this.state > t)
        throw new Error("Tile load sequence violation");
      (this.state = t), this.changed();
    }
    load() {
      G();
    }
    getAlpha(t, e) {
      if (!this.transition_) return 1;
      let i = this.transitionStarts_[t];
      if (i) {
        if (-1 === i) return 1;
      } else (i = e), (this.transitionStarts_[t] = i);
      const n = e - i + 1e3 / 60;
      return n >= this.transition_ ? 1 : tt(n / this.transition_);
    }
    inTransition(t) {
      return !!this.transition_ && -1 !== this.transitionStarts_[t];
    }
    endTransition(t) {
      this.transition_ && (this.transitionStarts_[t] = -1);
    }
  };
  const st =
      "undefined" != typeof navigator && void 0 !== navigator.userAgent
        ? navigator.userAgent.toLowerCase()
        : "",
    ot = st.includes("firefox"),
    at = st.includes("safari") && !st.includes("chrom"),
    lt =
      at &&
      (st.includes("version/15.4") ||
        /cpu (os|iphone os) 15_4 like mac os x/.test(st)),
    ht = st.includes("webkit") && !st.includes("edge"),
    ct = st.includes("macintosh"),
    ut = "undefined" != typeof devicePixelRatio ? devicePixelRatio : 1,
    dt =
      "undefined" != typeof WorkerGlobalScope &&
      "undefined" != typeof OffscreenCanvas &&
      self instanceof WorkerGlobalScope,
    gt = "undefined" != typeof Image && Image.prototype.decode,
    ft = "function" == typeof createImageBitmap,
    pt = (function () {
      let t = !1;
      try {
        const e = Object.defineProperty({}, "passive", {
          get: function () {
            t = !0;
          },
        });
        window.addEventListener("_", null, e),
          window.removeEventListener("_", null, e);
      } catch (t) {}
      return t;
    })();
  function mt(t, e, i, n) {
    let r;
    return (
      (r =
        i && i.length
          ? i.shift()
          : dt
          ? new OffscreenCanvas(t || 300, e || 300)
          : document.createElement("canvas")),
      t && (r.width = t),
      e && (r.height = e),
      r.getContext("2d", n)
    );
  }
  function _t(t) {
    const e = t.canvas;
    (e.width = 1), (e.height = 1), t.clearRect(0, 0, 1, 1);
  }
  function yt(t) {
    let e = t.offsetWidth;
    const i = getComputedStyle(t);
    return (e += parseInt(i.marginLeft, 10) + parseInt(i.marginRight, 10)), e;
  }
  function xt(t) {
    let e = t.offsetHeight;
    const i = getComputedStyle(t);
    return (e += parseInt(i.marginTop, 10) + parseInt(i.marginBottom, 10)), e;
  }
  function vt(t, e) {
    const i = e.parentNode;
    i && i.replaceChild(t, e);
  }
  function St(t) {
    return t && t.parentNode ? t.parentNode.removeChild(t) : null;
  }
  function Ct(t) {
    for (; t.lastChild; ) t.removeChild(t.lastChild);
  }
  function wt(t, e) {
    const i = t.childNodes;
    for (let n = 0; ; ++n) {
      const r = i[n],
        s = e[n];
      if (!r && !s) break;
      r !== s &&
        (r
          ? s
            ? t.insertBefore(s, r)
            : (t.removeChild(r), --n)
          : t.appendChild(s));
    }
  }
  function Wt(t) {
    return t instanceof Image ||
      t instanceof HTMLCanvasElement ||
      t instanceof HTMLVideoElement ||
      t instanceof ImageBitmap
      ? t
      : null;
  }
  function Et(t) {
    return t instanceof Uint8Array ||
      t instanceof Uint8ClampedArray ||
      t instanceof Float32Array ||
      t instanceof DataView
      ? t
      : null;
  }
  let Rt = null;
  function Tt(t) {
    Rt || (Rt = mt(t.width, t.height, void 0, { willReadFrequently: !0 }));
    const e = Rt.canvas,
      i = t.width;
    e.width !== i && (e.width = i);
    const n = t.height;
    return (
      e.height !== n && (e.height = n),
      Rt.clearRect(0, 0, i, n),
      Rt.drawImage(t, 0, 0),
      Rt.getImageData(0, 0, i, n).data
    );
  }
  const Pt = [256, 256];
  var bt = class extends rt {
    constructor(t) {
      const e = H;
      super(t.tileCoord, e, {
        transition: t.transition,
        interpolate: t.interpolate,
      }),
        (this.loader_ = t.loader),
        (this.data_ = null),
        (this.error_ = null),
        (this.size_ = t.size || null);
    }
    getSize() {
      if (this.size_) return this.size_;
      const t = Wt(this.data_);
      return t ? [t.width, t.height] : Pt;
    }
    getData() {
      return this.data_;
    }
    getError() {
      return this.error_;
    }
    load() {
      if (this.state !== H && this.state !== $) return;
      (this.state = Y), this.changed();
      const t = this;
      this.loader_()
        .then(function (e) {
          (t.data_ = e), (t.state = Q), t.changed();
        })
        .catch(function (e) {
          (t.error_ = e), (t.state = $), t.changed();
        });
    }
  };
  function Ft(t, e) {
    if (!t) throw new Error(e);
  }
  class It extends U {
    constructor(t) {
      if (
        (super(),
        this.on,
        this.once,
        this.un,
        (this.id_ = void 0),
        (this.geometryName_ = "geometry"),
        (this.style_ = null),
        (this.styleFunction_ = void 0),
        (this.geometryChangeKey_ = null),
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
        t)
      )
        if ("function" == typeof t.getSimplifiedGeometry) {
          const e = t;
          this.setGeometry(e);
        } else {
          const e = t;
          this.setProperties(e);
        }
    }
    clone() {
      const t = new It(this.hasProperties() ? this.getProperties() : null);
      t.setGeometryName(this.getGeometryName());
      const e = this.getGeometry();
      e && t.setGeometry(e.clone());
      const i = this.getStyle();
      return i && t.setStyle(i), t;
    }
    getGeometry() {
      return this.get(this.geometryName_);
    }
    getId() {
      return this.id_;
    }
    getGeometryName() {
      return this.geometryName_;
    }
    getStyle() {
      return this.style_;
    }
    getStyleFunction() {
      return this.styleFunction_;
    }
    handleGeometryChange_() {
      this.changed();
    }
    handleGeometryChanged_() {
      this.geometryChangeKey_ &&
        (k(this.geometryChangeKey_), (this.geometryChangeKey_ = null));
      const t = this.getGeometry();
      t &&
        (this.geometryChangeKey_ = M(t, v, this.handleGeometryChange_, this)),
        this.changed();
    }
    setGeometry(t) {
      this.set(this.geometryName_, t);
    }
    setStyle(t) {
      (this.style_ = t),
        (this.styleFunction_ = t ? Lt(t) : void 0),
        this.changed();
    }
    setId(t) {
      (this.id_ = t), this.changed();
    }
    setGeometryName(t) {
      this.removeChangeListener(
        this.geometryName_,
        this.handleGeometryChanged_
      ),
        (this.geometryName_ = t),
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
        this.handleGeometryChanged_();
    }
  }
  function Lt(t) {
    if ("function" == typeof t) return t;
    let e;
    if (Array.isArray(t)) e = t;
    else {
      Ft(
        "function" == typeof t.getZIndex,
        "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
      );
      e = [t];
    }
    return function () {
      return e;
    };
  }
  var Mt = It;
  const Ot = new Array(6);
  function kt() {
    return [1, 0, 0, 1, 0, 0];
  }
  function At(t) {
    return Dt(t, 1, 0, 0, 1, 0, 0);
  }
  function Nt(t, e) {
    const i = t[0],
      n = t[1],
      r = t[2],
      s = t[3],
      o = t[4],
      a = t[5],
      l = e[0],
      h = e[1],
      c = e[2],
      u = e[3],
      d = e[4],
      g = e[5];
    return (
      (t[0] = i * l + r * h),
      (t[1] = n * l + s * h),
      (t[2] = i * c + r * u),
      (t[3] = n * c + s * u),
      (t[4] = i * d + r * g + o),
      (t[5] = n * d + s * g + a),
      t
    );
  }
  function Dt(t, e, i, n, r, s, o) {
    return (
      (t[0] = e), (t[1] = i), (t[2] = n), (t[3] = r), (t[4] = s), (t[5] = o), t
    );
  }
  function Gt(t, e) {
    return (
      (t[0] = e[0]),
      (t[1] = e[1]),
      (t[2] = e[2]),
      (t[3] = e[3]),
      (t[4] = e[4]),
      (t[5] = e[5]),
      t
    );
  }
  function Bt(t, e) {
    const i = e[0],
      n = e[1];
    return (
      (e[0] = t[0] * i + t[2] * n + t[4]),
      (e[1] = t[1] * i + t[3] * n + t[5]),
      e
    );
  }
  function jt(t, e) {
    const i = Math.cos(e),
      n = Math.sin(e);
    return Nt(t, Dt(Ot, i, n, -n, i, 0, 0));
  }
  function zt(t, e, i) {
    return Nt(t, Dt(Ot, e, 0, 0, i, 0, 0));
  }
  function Ut(t, e, i) {
    return Dt(t, e, 0, 0, i, 0, 0);
  }
  function qt(t, e, i) {
    return Nt(t, Dt(Ot, 1, 0, 0, 1, e, i));
  }
  function Vt(t, e, i, n, r, s, o, a) {
    const l = Math.sin(s),
      h = Math.cos(s);
    return (
      (t[0] = n * h),
      (t[1] = r * l),
      (t[2] = -n * l),
      (t[3] = r * h),
      (t[4] = o * n * h - a * n * l + e),
      (t[5] = o * r * l + a * r * h + i),
      t
    );
  }
  function Xt(t, e) {
    const i = Zt(e);
    Ft(0 !== i, "Transformation matrix cannot be inverted");
    const n = e[0],
      r = e[1],
      s = e[2],
      o = e[3],
      a = e[4],
      l = e[5];
    return (
      (t[0] = o / i),
      (t[1] = -r / i),
      (t[2] = -s / i),
      (t[3] = n / i),
      (t[4] = (s * l - o * a) / i),
      (t[5] = -(n * l - r * a) / i),
      t
    );
  }
  function Zt(t) {
    return t[0] * t[3] - t[1] * t[2];
  }
  let Kt;
  function Ht(t) {
    const e = "matrix(" + t.join(", ") + ")";
    if (dt) return e;
    const i = Kt || (Kt = document.createElement("div"));
    return (i.style.transform = e), i.style.transform;
  }
  var Yt = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16,
  };
  function Qt(t) {
    const e = se();
    for (let i = 0, n = t.length; i < n; ++i) ge(e, t[i]);
    return e;
  }
  function $t(t, e, i) {
    return i
      ? ((i[0] = t[0] - e),
        (i[1] = t[1] - e),
        (i[2] = t[2] + e),
        (i[3] = t[3] + e),
        i)
      : [t[0] - e, t[1] - e, t[2] + e, t[3] + e];
  }
  function Jt(t, e) {
    return e
      ? ((e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e)
      : t.slice();
  }
  function te(t, e, i) {
    let n, r;
    return (
      (n = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0),
      (r = i < t[1] ? t[1] - i : t[3] < i ? i - t[3] : 0),
      n * n + r * r
    );
  }
  function ee(t, e) {
    return ne(t, e[0], e[1]);
  }
  function ie(t, e) {
    return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3];
  }
  function ne(t, e, i) {
    return t[0] <= e && e <= t[2] && t[1] <= i && i <= t[3];
  }
  function re(t, e) {
    const i = t[0],
      n = t[1],
      r = t[2],
      s = t[3],
      o = e[0],
      a = e[1];
    let l = Yt.UNKNOWN;
    return (
      o < i ? (l |= Yt.LEFT) : o > r && (l |= Yt.RIGHT),
      a < n ? (l |= Yt.BELOW) : a > s && (l |= Yt.ABOVE),
      l === Yt.UNKNOWN && (l = Yt.INTERSECTING),
      l
    );
  }
  function se() {
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  }
  function oe(t, e, i, n, r) {
    return r
      ? ((r[0] = t), (r[1] = e), (r[2] = i), (r[3] = n), r)
      : [t, e, i, n];
  }
  function ae(t) {
    return oe(1 / 0, 1 / 0, -1 / 0, -1 / 0, t);
  }
  function le(t, e) {
    const i = t[0],
      n = t[1];
    return oe(i, n, i, n, e);
  }
  function he(t, e, i, n, r) {
    return pe(ae(r), t, e, i, n);
  }
  function ce(t, e) {
    return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3];
  }
  function ue(t, e, i) {
    return (
      Math.abs(t[0] - e[0]) < i &&
      Math.abs(t[2] - e[2]) < i &&
      Math.abs(t[1] - e[1]) < i &&
      Math.abs(t[3] - e[3]) < i
    );
  }
  function de(t, e) {
    return (
      e[0] < t[0] && (t[0] = e[0]),
      e[2] > t[2] && (t[2] = e[2]),
      e[1] < t[1] && (t[1] = e[1]),
      e[3] > t[3] && (t[3] = e[3]),
      t
    );
  }
  function ge(t, e) {
    e[0] < t[0] && (t[0] = e[0]),
      e[0] > t[2] && (t[2] = e[0]),
      e[1] < t[1] && (t[1] = e[1]),
      e[1] > t[3] && (t[3] = e[1]);
  }
  function fe(t, e) {
    for (let i = 0, n = e.length; i < n; ++i) ge(t, e[i]);
    return t;
  }
  function pe(t, e, i, n, r) {
    for (; i < n; i += r) _e(t, e[i], e[i + 1]);
    return t;
  }
  function me(t, e) {
    for (let i = 0, n = e.length; i < n; ++i) fe(t, e[i]);
    return t;
  }
  function _e(t, e, i) {
    (t[0] = Math.min(t[0], e)),
      (t[1] = Math.min(t[1], i)),
      (t[2] = Math.max(t[2], e)),
      (t[3] = Math.max(t[3], i));
  }
  function ye(t, e) {
    let i;
    return (
      (i = e(ve(t))),
      i ||
        ((i = e(Se(t))), i || ((i = e(be(t))), i || ((i = e(Pe(t))), i || !1)))
    );
  }
  function xe(t) {
    let e = 0;
    return Le(t) || (e = Fe(t) * Re(t)), e;
  }
  function ve(t) {
    return [t[0], t[1]];
  }
  function Se(t) {
    return [t[2], t[1]];
  }
  function Ce(t) {
    return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2];
  }
  function we(t, e) {
    let i;
    if ("bottom-left" === e) i = ve(t);
    else if ("bottom-right" === e) i = Se(t);
    else if ("top-left" === e) i = Pe(t);
    else {
      if ("top-right" !== e) throw new Error("Invalid corner");
      i = be(t);
    }
    return i;
  }
  function We(t, e, i, n, r) {
    const [s, o, a, l, h, c, u, d] = Ee(t, e, i, n);
    return oe(
      Math.min(s, a, h, u),
      Math.min(o, l, c, d),
      Math.max(s, a, h, u),
      Math.max(o, l, c, d),
      r
    );
  }
  function Ee(t, e, i, n) {
    const r = (e * n[0]) / 2,
      s = (e * n[1]) / 2,
      o = Math.cos(i),
      a = Math.sin(i),
      l = r * o,
      h = r * a,
      c = s * o,
      u = s * a,
      d = t[0],
      g = t[1];
    return [
      d - l + u,
      g - h - c,
      d - l - u,
      g - h + c,
      d + l - u,
      g + h + c,
      d + l + u,
      g + h - c,
      d - l + u,
      g - h - c,
    ];
  }
  function Re(t) {
    return t[3] - t[1];
  }
  function Te(t, e, i) {
    const n = i || [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return (
      Ie(t, e)
        ? (t[0] > e[0] ? (n[0] = t[0]) : (n[0] = e[0]),
          t[1] > e[1] ? (n[1] = t[1]) : (n[1] = e[1]),
          t[2] < e[2] ? (n[2] = t[2]) : (n[2] = e[2]),
          t[3] < e[3] ? (n[3] = t[3]) : (n[3] = e[3]))
        : ae(n),
      n
    );
  }
  function Pe(t) {
    return [t[0], t[3]];
  }
  function be(t) {
    return [t[2], t[3]];
  }
  function Fe(t) {
    return t[2] - t[0];
  }
  function Ie(t, e) {
    return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1];
  }
  function Le(t) {
    return t[2] < t[0] || t[3] < t[1];
  }
  function Me(t, e) {
    return e
      ? ((e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e)
      : t;
  }
  function Oe(t, e) {
    const i = ((t[2] - t[0]) / 2) * (e - 1),
      n = ((t[3] - t[1]) / 2) * (e - 1);
    (t[0] -= i), (t[2] += i), (t[1] -= n), (t[3] += n);
  }
  function ke(t, e, i) {
    let n = !1;
    const r = re(t, e),
      s = re(t, i);
    if (r === Yt.INTERSECTING || s === Yt.INTERSECTING) n = !0;
    else {
      const o = t[0],
        a = t[1],
        l = t[2],
        h = t[3],
        c = e[0],
        u = e[1],
        d = i[0],
        g = i[1],
        f = (g - u) / (d - c);
      let p, m;
      s & Yt.ABOVE &&
        !(r & Yt.ABOVE) &&
        ((p = d - (g - h) / f), (n = p >= o && p <= l)),
        n ||
          !(s & Yt.RIGHT) ||
          r & Yt.RIGHT ||
          ((m = g - (d - l) * f), (n = m >= a && m <= h)),
        n ||
          !(s & Yt.BELOW) ||
          r & Yt.BELOW ||
          ((p = d - (g - a) / f), (n = p >= o && p <= l)),
        n ||
          !(s & Yt.LEFT) ||
          r & Yt.LEFT ||
          ((m = g - (d - o) * f), (n = m >= a && m <= h));
    }
    return n;
  }
  function Ae(t, e, i, n) {
    if (Le(t)) return ae(i);
    let r = [];
    if (n > 1) {
      const e = t[2] - t[0],
        i = t[3] - t[1];
      for (let s = 0; s < n; ++s)
        r.push(
          t[0] + (e * s) / n,
          t[1],
          t[2],
          t[1] + (i * s) / n,
          t[2] - (e * s) / n,
          t[3],
          t[0],
          t[3] - (i * s) / n
        );
    } else r = [t[0], t[1], t[2], t[1], t[2], t[3], t[0], t[3]];
    e(r, r, 2);
    const s = [],
      o = [];
    for (let t = 0, e = r.length; t < e; t += 2) s.push(r[t]), o.push(r[t + 1]);
    return (function (t, e, i) {
      return oe(
        Math.min.apply(null, t),
        Math.min.apply(null, e),
        Math.max.apply(null, t),
        Math.max.apply(null, e),
        i
      );
    })(s, o, i);
  }
  function Ne(t, e) {
    const i = e.getExtent(),
      n = Ce(t);
    if (e.canWrapX() && (n[0] < i[0] || n[0] >= i[2])) {
      const e = Fe(i),
        r = Math.floor((n[0] - i[0]) / e) * e;
      (t[0] -= r), (t[2] -= r);
    }
    return t;
  }
  function De(t, e) {
    if (e.canWrapX()) {
      const i = e.getExtent();
      if (!isFinite(t[0]) || !isFinite(t[2])) return [[i[0], t[1], i[2], t[3]]];
      Ne(t, e);
      const n = Fe(i);
      if (Fe(t) > n) return [[i[0], t[1], i[2], t[3]]];
      if (t[0] < i[0])
        return [
          [t[0] + n, t[1], i[2], t[3]],
          [i[0], t[1], t[2], t[3]],
        ];
      if (t[2] > i[2])
        return [
          [t[0], t[1], i[2], t[3]],
          [i[0], t[1], t[2] - n, t[3]],
        ];
    }
    return [t];
  }
  const Ge = {
    9001: "m",
    9002: "ft",
    9003: "us-ft",
    9101: "radians",
    9102: "degrees",
  };
  function Be(t) {
    return Ge[t];
  }
  const je = {
    radians: 6370997 / (2 * Math.PI),
    degrees: (2 * Math.PI * 6370997) / 360,
    ft: 0.3048,
    m: 1,
    "us-ft": 1200 / 3937,
  };
  var ze = class {
    constructor(t) {
      (this.code_ = t.code),
        (this.units_ = t.units),
        (this.extent_ = void 0 !== t.extent ? t.extent : null),
        (this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null),
        (this.axisOrientation_ =
          void 0 !== t.axisOrientation ? t.axisOrientation : "enu"),
        (this.global_ = void 0 !== t.global && t.global),
        (this.canWrapX_ = !(!this.global_ || !this.extent_)),
        (this.getPointResolutionFunc_ = t.getPointResolution),
        (this.defaultTileGrid_ = null),
        (this.metersPerUnit_ = t.metersPerUnit);
    }
    canWrapX() {
      return this.canWrapX_;
    }
    getCode() {
      return this.code_;
    }
    getExtent() {
      return this.extent_;
    }
    getUnits() {
      return this.units_;
    }
    getMetersPerUnit() {
      return this.metersPerUnit_ || je[this.units_];
    }
    getWorldExtent() {
      return this.worldExtent_;
    }
    getAxisOrientation() {
      return this.axisOrientation_;
    }
    isGlobal() {
      return this.global_;
    }
    setGlobal(t) {
      (this.global_ = t), (this.canWrapX_ = !(!t || !this.extent_));
    }
    getDefaultTileGrid() {
      return this.defaultTileGrid_;
    }
    setDefaultTileGrid(t) {
      this.defaultTileGrid_ = t;
    }
    setExtent(t) {
      (this.extent_ = t), (this.canWrapX_ = !(!this.global_ || !t));
    }
    setWorldExtent(t) {
      this.worldExtent_ = t;
    }
    setGetPointResolution(t) {
      this.getPointResolutionFunc_ = t;
    }
    getPointResolutionFunc() {
      return this.getPointResolutionFunc_;
    }
  };
  const Ue = 6378137,
    qe = Math.PI * Ue,
    Ve = [-qe, -qe, qe, qe],
    Xe = [-180, -85, 180, 85],
    Ze = Ue * Math.log(Math.tan(Math.PI / 2));
  class Ke extends ze {
    constructor(t) {
      super({
        code: t,
        units: "m",
        extent: Ve,
        global: !0,
        worldExtent: Xe,
        getPointResolution: function (t, e) {
          return t / Math.cosh(e[1] / Ue);
        },
      });
    }
  }
  const He = [
    new Ke("EPSG:3857"),
    new Ke("EPSG:102100"),
    new Ke("EPSG:102113"),
    new Ke("EPSG:900913"),
    new Ke("http://www.opengis.net/def/crs/EPSG/0/3857"),
    new Ke("http://www.opengis.net/gml/srs/epsg.xml#3857"),
  ];
  function Ye(t, e, i) {
    const n = t.length;
    (i = i > 1 ? i : 2), void 0 === e && (e = i > 2 ? t.slice() : new Array(n));
    for (let r = 0; r < n; r += i) {
      e[r] = (qe * t[r]) / 180;
      let i = Ue * Math.log(Math.tan((Math.PI * (+t[r + 1] + 90)) / 360));
      i > Ze ? (i = Ze) : i < -Ze && (i = -Ze), (e[r + 1] = i);
    }
    return e;
  }
  function Qe(t, e, i) {
    const n = t.length;
    (i = i > 1 ? i : 2), void 0 === e && (e = i > 2 ? t.slice() : new Array(n));
    for (let r = 0; r < n; r += i)
      (e[r] = (180 * t[r]) / qe),
        (e[r + 1] = (360 * Math.atan(Math.exp(t[r + 1] / Ue))) / Math.PI - 90);
    return e;
  }
  const $e = 6378137,
    Je = [-180, -90, 180, 90],
    ti = (Math.PI * $e) / 180;
  class ei extends ze {
    constructor(t, e) {
      super({
        code: t,
        units: "degrees",
        extent: Je,
        axisOrientation: e,
        global: !0,
        metersPerUnit: ti,
        worldExtent: Je,
      });
    }
  }
  const ii = [
    new ei("CRS:84"),
    new ei("EPSG:4326", "neu"),
    new ei("urn:ogc:def:crs:OGC:1.3:CRS84"),
    new ei("urn:ogc:def:crs:OGC:2:84"),
    new ei("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
    new ei("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
    new ei("http://www.opengis.net/def/crs/EPSG/0/4326", "neu"),
  ];
  let ni = {};
  function ri() {
    ni = {};
  }
  function si(t) {
    return (
      ni[t] ||
      ni[t.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] ||
      null
    );
  }
  function oi(t, e) {
    ni[t] = e;
  }
  let ai = {};
  function li() {
    ai = {};
  }
  function hi(t, e, i) {
    const n = t.getCode(),
      r = e.getCode();
    n in ai || (ai[n] = {}), (ai[n][r] = i);
  }
  function ci(t, e) {
    let i;
    return t in ai && e in ai[t] && (i = ai[t][e]), i;
  }
  function ui(t, e, i) {
    return Math.min(Math.max(t, e), i);
  }
  function di(t, e, i, n, r, s) {
    const o = r - i,
      a = s - n;
    if (0 !== o || 0 !== a) {
      const l = ((t - i) * o + (e - n) * a) / (o * o + a * a);
      l > 1 ? ((i = r), (n = s)) : l > 0 && ((i += o * l), (n += a * l));
    }
    return gi(t, e, i, n);
  }
  function gi(t, e, i, n) {
    const r = i - t,
      s = n - e;
    return r * r + s * s;
  }
  function fi(t) {
    const e = t.length;
    for (let i = 0; i < e; i++) {
      let n = i,
        r = Math.abs(t[i][i]);
      for (let s = i + 1; s < e; s++) {
        const e = Math.abs(t[s][i]);
        e > r && ((r = e), (n = s));
      }
      if (0 === r) return null;
      const s = t[n];
      (t[n] = t[i]), (t[i] = s);
      for (let n = i + 1; n < e; n++) {
        const r = -t[n][i] / t[i][i];
        for (let s = i; s < e + 1; s++)
          i == s ? (t[n][s] = 0) : (t[n][s] += r * t[i][s]);
      }
    }
    const i = new Array(e);
    for (let n = e - 1; n >= 0; n--) {
      i[n] = t[n][e] / t[n][n];
      for (let r = n - 1; r >= 0; r--) t[r][e] -= t[r][n] * i[n];
    }
    return i;
  }
  function pi(t) {
    return (180 * t) / Math.PI;
  }
  function mi(t) {
    return (t * Math.PI) / 180;
  }
  function _i(t, e) {
    const i = t % e;
    return i * e < 0 ? i + e : i;
  }
  function yi(t, e, i) {
    return t + i * (e - t);
  }
  function xi(t, e) {
    const i = Math.pow(10, e);
    return Math.round(t * i) / i;
  }
  function vi(t, e) {
    return Math.round(xi(t, e));
  }
  function Si(t, e) {
    return Math.floor(xi(t, e));
  }
  function Ci(t, e) {
    return Math.ceil(xi(t, e));
  }
  function wi(t, e, i) {
    const n = void 0 !== i ? t.toFixed(i) : "" + t;
    let r = n.indexOf(".");
    return (
      (r = -1 === r ? n.length : r),
      r > e ? n : new Array(1 + e - r).join("0") + n
    );
  }
  function Wi(t, e) {
    const i = ("" + t).split("."),
      n = ("" + e).split(".");
    for (let t = 0; t < Math.max(i.length, n.length); t++) {
      const e = parseInt(i[t] || "0", 10),
        r = parseInt(n[t] || "0", 10);
      if (e > r) return 1;
      if (r > e) return -1;
    }
    return 0;
  }
  function Ei(t, e) {
    return (t[0] += +e[0]), (t[1] += +e[1]), t;
  }
  function Ri(t, e) {
    const i = e.getRadius(),
      n = e.getCenter(),
      r = n[0],
      s = n[1];
    let o = t[0] - r;
    const a = t[1] - s;
    0 === o && 0 === a && (o = 1);
    const l = Math.sqrt(o * o + a * a);
    return [r + (i * o) / l, s + (i * a) / l];
  }
  function Ti(t, e) {
    const i = t[0],
      n = t[1],
      r = e[0],
      s = e[1],
      o = r[0],
      a = r[1],
      l = s[0],
      h = s[1],
      c = l - o,
      u = h - a,
      d =
        0 === c && 0 === u
          ? 0
          : (c * (i - o) + u * (n - a)) / (c * c + u * u || 0);
    let g, f;
    return (
      d <= 0
        ? ((g = o), (f = a))
        : d >= 1
        ? ((g = l), (f = h))
        : ((g = o + d * c), (f = a + d * u)),
      [g, f]
    );
  }
  function Pi(t, e, i) {
    const n = _i(e + 180, 360) - 180,
      r = Math.abs(3600 * n),
      s = i || 0;
    let o = Math.floor(r / 3600),
      a = Math.floor((r - 3600 * o) / 60),
      l = xi(r - 3600 * o - 60 * a, s);
    l >= 60 && ((l = 0), (a += 1)), a >= 60 && ((a = 0), (o += 1));
    let h = o + "°";
    return (
      (0 === a && 0 === l) || (h += " " + wi(a, 2) + "′"),
      0 !== l && (h += " " + wi(l, 2, s) + "″"),
      0 !== n && (h += " " + t.charAt(n < 0 ? 1 : 0)),
      h
    );
  }
  function bi(t, e, i) {
    return t
      ? e.replace("{x}", t[0].toFixed(i)).replace("{y}", t[1].toFixed(i))
      : "";
  }
  function Fi(t, e) {
    let i = !0;
    for (let n = t.length - 1; n >= 0; --n)
      if (t[n] != e[n]) {
        i = !1;
        break;
      }
    return i;
  }
  function Ii(t, e) {
    const i = Math.cos(e),
      n = Math.sin(e),
      r = t[0] * i - t[1] * n,
      s = t[1] * i + t[0] * n;
    return (t[0] = r), (t[1] = s), t;
  }
  function Li(t, e) {
    return (t[0] *= e), (t[1] *= e), t;
  }
  function Mi(t, e) {
    const i = t[0] - e[0],
      n = t[1] - e[1];
    return i * i + n * n;
  }
  function Oi(t, e) {
    return Math.sqrt(Mi(t, e));
  }
  function ki(t, e) {
    return Mi(t, Ti(t, e));
  }
  function Ai(t, e) {
    return bi(t, "{x}, {y}", e);
  }
  function Ni(t, e) {
    if (e.canWrapX()) {
      const i = Fe(e.getExtent()),
        n = Di(t, e, i);
      n && (t[0] -= n * i);
    }
    return t;
  }
  function Di(t, e, i) {
    const n = e.getExtent();
    let r = 0;
    return (
      e.canWrapX() &&
        (t[0] < n[0] || t[0] > n[2]) &&
        ((i = i || Fe(n)), (r = Math.floor((t[0] - n[0]) / i))),
      r
    );
  }
  const Gi = 6371008.8;
  function Bi(t, e, i) {
    i = i || Gi;
    const n = mi(t[1]),
      r = mi(e[1]),
      s = (r - n) / 2,
      o = mi(e[0] - t[0]) / 2,
      a =
        Math.sin(s) * Math.sin(s) +
        Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(r);
    return 2 * i * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }
  function ji(t, e) {
    let i = 0;
    for (let n = 0, r = t.length; n < r - 1; ++n) i += Bi(t[n], t[n + 1], e);
    return i;
  }
  function zi(t, e) {
    let i = 0;
    const n = t.length;
    let r = t[n - 1][0],
      s = t[n - 1][1];
    for (let e = 0; e < n; e++) {
      const n = t[e][0],
        o = t[e][1];
      (i += mi(n - r) * (2 + Math.sin(mi(s)) + Math.sin(mi(o)))),
        (r = n),
        (s = o);
    }
    return (i * e * e) / 2;
  }
  function Ui(t, e, i, n) {
    n = n || Gi;
    const r = mi(t[1]),
      s = mi(t[0]),
      o = e / n,
      a = Math.asin(
        Math.sin(r) * Math.cos(o) + Math.cos(r) * Math.sin(o) * Math.cos(i)
      );
    return [
      pi(
        s +
          Math.atan2(
            Math.sin(i) * Math.sin(o) * Math.cos(r),
            Math.cos(o) - Math.sin(r) * Math.sin(a)
          )
      ),
      pi(a),
    ];
  }
  const qi = { info: 1, warn: 2, error: 3, none: 4 };
  let Vi = qi.info;
  function Xi(...t) {
    Vi > qi.warn || console.warn(...t);
  }
  function Zi(...t) {
    Vi > qi.error || console.error(...t);
  }
  let Ki = !0;
  function Hi(t) {
    Ki = !(void 0 === t || t);
  }
  function Yi(t, e) {
    if (void 0 !== e) for (let i = 0, n = t.length; i < n; ++i) e[i] = t[i];
    else e = t.slice();
    return e;
  }
  function Qi(t, e) {
    if (void 0 !== e && t !== e) {
      for (let i = 0, n = t.length; i < n; ++i) e[i] = t[i];
      t = e;
    }
    return t;
  }
  function $i(t) {
    oi(t.getCode(), t), hi(t, t, Yi);
  }
  function Ji(t) {
    t.forEach($i);
  }
  function tn(t) {
    return "string" == typeof t ? si(t) : t || null;
  }
  function en(t, e, i, n) {
    let r;
    const s = (t = tn(t)).getPointResolutionFunc();
    if (s) {
      if (((r = s(e, i)), n && n !== t.getUnits())) {
        const e = t.getMetersPerUnit();
        e && (r = (r * e) / je[n]);
      }
    } else {
      const s = t.getUnits();
      if (("degrees" == s && !n) || "degrees" == n) r = e;
      else {
        const o = hn(t, tn("EPSG:4326"));
        if (o === Qi && "degrees" !== s) r = e * t.getMetersPerUnit();
        else {
          let t = [
            i[0] - e / 2,
            i[1],
            i[0] + e / 2,
            i[1],
            i[0],
            i[1] - e / 2,
            i[0],
            i[1] + e / 2,
          ];
          t = o(t, t, 2);
          r =
            (Bi(t.slice(0, 2), t.slice(2, 4)) +
              Bi(t.slice(4, 6), t.slice(6, 8))) /
            2;
        }
        const a = n ? je[n] : t.getMetersPerUnit();
        void 0 !== a && (r /= a);
      }
    }
    return r;
  }
  function nn(t) {
    Ji(t),
      t.forEach(function (e) {
        t.forEach(function (t) {
          e !== t && hi(e, t, Yi);
        });
      });
  }
  function rn(t, e, i, n) {
    t.forEach(function (t) {
      e.forEach(function (e) {
        hi(t, e, i), hi(e, t, n);
      });
    });
  }
  function sn(t, e) {
    return t ? ("string" == typeof t ? tn(t) : t) : tn(e);
  }
  function on(t) {
    return function (e, i, n) {
      const r = e.length;
      (n = void 0 !== n ? n : 2), (i = void 0 !== i ? i : new Array(r));
      for (let s = 0; s < r; s += n) {
        const r = t(e.slice(s, s + n)),
          o = r.length;
        for (let t = 0, a = n; t < a; ++t) i[s + t] = t >= o ? e[s + t] : r[t];
      }
      return i;
    };
  }
  function an(t, e, i, n) {
    const r = tn(t),
      s = tn(e);
    hi(r, s, on(i)), hi(s, r, on(n));
  }
  function ln(t, e) {
    if (t === e) return !0;
    const i = t.getUnits() === e.getUnits();
    if (t.getCode() === e.getCode()) return i;
    return hn(t, e) === Yi && i;
  }
  function hn(t, e) {
    let i = ci(t.getCode(), e.getCode());
    return i || (i = Qi), i;
  }
  function cn(t, e) {
    return hn(tn(t), tn(e));
  }
  function un(t, e, i) {
    return cn(e, i)(t, void 0, t.length);
  }
  function dn(t, e, i, n) {
    return Ae(t, cn(e, i), void 0, n);
  }
  let gn = null;
  function fn(t) {
    gn = tn(t);
  }
  function pn() {
    return gn;
  }
  function mn(t, e) {
    return gn ? un(t, e, gn) : t;
  }
  function _n(t, e) {
    return gn
      ? un(t, gn, e)
      : (Ki &&
          !Fi(t, [0, 0]) &&
          t[0] >= -180 &&
          t[0] <= 180 &&
          t[1] >= -90 &&
          t[1] <= 90 &&
          ((Ki = !1),
          Xi(
            "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
          )),
        t);
  }
  function yn(t, e) {
    return gn ? dn(t, e, gn) : t;
  }
  function xn(t, e) {
    return gn ? dn(t, gn, e) : t;
  }
  function vn(t, e) {
    if (!gn) return t;
    const i = tn(e).getUnits(),
      n = gn.getUnits();
    return i && n ? (t * je[i]) / je[n] : t;
  }
  function Sn(t, e) {
    if (!gn) return t;
    const i = tn(e).getUnits(),
      n = gn.getUnits();
    return i && n ? (t * je[n]) / je[i] : t;
  }
  function Cn(t, e, i) {
    return function (n) {
      let r, s;
      if (t.canWrapX()) {
        const e = t.getExtent(),
          o = Fe(e);
        (s = Di((n = n.slice(0)), t, o)),
          s && (n[0] = n[0] - s * o),
          (n[0] = ui(n[0], e[0], e[2])),
          (n[1] = ui(n[1], e[1], e[3])),
          (r = i(n));
      } else r = i(n);
      return s && e.canWrapX() && (r[0] += s * Fe(e.getExtent())), r;
    };
  }
  function wn() {
    nn(He), nn(ii), rn(ii, He, Ye, Qe);
  }
  function Wn(t, e, i, n, r, s) {
    s = s || [];
    let o = 0;
    for (let a = e; a < i; a += n) {
      const e = t[a],
        i = t[a + 1];
      (s[o++] = r[0] * e + r[2] * i + r[4]),
        (s[o++] = r[1] * e + r[3] * i + r[5]);
    }
    return s && s.length != o && (s.length = o), s;
  }
  function En(t, e, i, n, r, s, o) {
    o = o || [];
    const a = Math.cos(r),
      l = Math.sin(r),
      h = s[0],
      c = s[1];
    let u = 0;
    for (let r = e; r < i; r += n) {
      const e = t[r] - h,
        i = t[r + 1] - c;
      (o[u++] = h + e * a - i * l), (o[u++] = c + e * l + i * a);
      for (let e = r + 2; e < r + n; ++e) o[u++] = t[e];
    }
    return o && o.length != u && (o.length = u), o;
  }
  function Rn(t, e, i, n, r, s, o, a) {
    a = a || [];
    const l = o[0],
      h = o[1];
    let c = 0;
    for (let o = e; o < i; o += n) {
      const e = t[o] - l,
        i = t[o + 1] - h;
      (a[c++] = l + r * e), (a[c++] = h + s * i);
      for (let e = o + 2; e < o + n; ++e) a[c++] = t[e];
    }
    return a && a.length != c && (a.length = c), a;
  }
  function Tn(t, e, i, n, r, s, o) {
    o = o || [];
    let a = 0;
    for (let l = e; l < i; l += n) {
      (o[a++] = t[l] + r), (o[a++] = t[l + 1] + s);
      for (let e = l + 2; e < l + n; ++e) o[a++] = t[e];
    }
    return o && o.length != a && (o.length = a), o;
  }
  wn();
  const Pn = [1, 0, 0, 1, 0, 0];
  var bn = class extends U {
    constructor() {
      super(),
        (this.extent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        (this.extentRevision_ = -1),
        (this.simplifiedGeometryMaxMinSquaredTolerance = 0),
        (this.simplifiedGeometryRevision = 0),
        (this.simplifyTransformedInternal = p(function (t, e, i) {
          if (!i) return this.getSimplifiedGeometry(e);
          const n = this.clone();
          return n.applyTransform(i), n.getSimplifiedGeometry(e);
        }));
    }
    simplifyTransformed(t, e) {
      return this.simplifyTransformedInternal(this.getRevision(), t, e);
    }
    clone() {
      return G();
    }
    closestPointXY(t, e, i, n) {
      return G();
    }
    containsXY(t, e) {
      const i = this.getClosestPoint([t, e]);
      return i[0] === t && i[1] === e;
    }
    getClosestPoint(t, e) {
      return (
        (e = e || [NaN, NaN]), this.closestPointXY(t[0], t[1], e, 1 / 0), e
      );
    }
    intersectsCoordinate(t) {
      return this.containsXY(t[0], t[1]);
    }
    computeExtent(t) {
      return G();
    }
    getExtent(t) {
      if (this.extentRevision_ != this.getRevision()) {
        const t = this.computeExtent(this.extent_);
        (isNaN(t[0]) || isNaN(t[1])) && ae(t),
          (this.extentRevision_ = this.getRevision());
      }
      return Me(this.extent_, t);
    }
    rotate(t, e) {
      G();
    }
    scale(t, e, i) {
      G();
    }
    simplify(t) {
      return this.getSimplifiedGeometry(t * t);
    }
    getSimplifiedGeometry(t) {
      return G();
    }
    getType() {
      return G();
    }
    applyTransform(t) {
      G();
    }
    intersectsExtent(t) {
      return G();
    }
    translate(t, e) {
      G();
    }
    transform(t, e) {
      const i = tn(t),
        n =
          "tile-pixels" == i.getUnits()
            ? function (t, n, r) {
                const s = i.getExtent(),
                  o = i.getWorldExtent(),
                  a = Re(o) / Re(s);
                return (
                  Vt(Pn, o[0], o[3], a, -a, 0, 0, 0),
                  Wn(t, 0, t.length, r, Pn, n),
                  cn(i, e)(t, n, r)
                );
              }
            : cn(i, e);
      return this.applyTransform(n), this;
    }
  };
  function Fn(t) {
    let e;
    return (
      "XY" == t
        ? (e = 2)
        : "XYZ" == t || "XYM" == t
        ? (e = 3)
        : "XYZM" == t && (e = 4),
      e
    );
  }
  function In(t, e, i) {
    const n = t.getFlatCoordinates();
    if (!n) return null;
    const r = t.getStride();
    return Wn(n, 0, n.length, r, e, i);
  }
  var Ln = class extends bn {
    constructor() {
      super(),
        (this.layout = "XY"),
        (this.stride = 2),
        (this.flatCoordinates = null);
    }
    computeExtent(t) {
      return he(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    getCoordinates() {
      return G();
    }
    getFirstCoordinate() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    getFlatCoordinates() {
      return this.flatCoordinates;
    }
    getLastCoordinate() {
      return this.flatCoordinates.slice(
        this.flatCoordinates.length - this.stride
      );
    }
    getLayout() {
      return this.layout;
    }
    getSimplifiedGeometry(t) {
      if (
        (this.simplifiedGeometryRevision !== this.getRevision() &&
          ((this.simplifiedGeometryMaxMinSquaredTolerance = 0),
          (this.simplifiedGeometryRevision = this.getRevision())),
        t < 0 ||
          (0 !== this.simplifiedGeometryMaxMinSquaredTolerance &&
            t <= this.simplifiedGeometryMaxMinSquaredTolerance))
      )
        return this;
      const e = this.getSimplifiedGeometryInternal(t);
      return e.getFlatCoordinates().length < this.flatCoordinates.length
        ? e
        : ((this.simplifiedGeometryMaxMinSquaredTolerance = t), this);
    }
    getSimplifiedGeometryInternal(t) {
      return this;
    }
    getStride() {
      return this.stride;
    }
    setFlatCoordinates(t, e) {
      (this.stride = Fn(t)), (this.layout = t), (this.flatCoordinates = e);
    }
    setCoordinates(t, e) {
      G();
    }
    setLayout(t, e, i) {
      let n;
      if (t) n = Fn(t);
      else {
        for (let t = 0; t < i; ++t) {
          if (0 === e.length)
            return (this.layout = "XY"), void (this.stride = 2);
          e = e[0];
        }
        (n = e.length),
          (t = (function (t) {
            let e;
            2 == t ? (e = "XY") : 3 == t ? (e = "XYZ") : 4 == t && (e = "XYZM");
            return e;
          })(n));
      }
      (this.layout = t), (this.stride = n);
    }
    applyTransform(t) {
      this.flatCoordinates &&
        (t(this.flatCoordinates, this.flatCoordinates, this.stride),
        this.changed());
    }
    rotate(t, e) {
      const i = this.getFlatCoordinates();
      if (i) {
        const n = this.getStride();
        En(i, 0, i.length, n, t, e, i), this.changed();
      }
    }
    scale(t, e, i) {
      void 0 === e && (e = t), i || (i = Ce(this.getExtent()));
      const n = this.getFlatCoordinates();
      if (n) {
        const r = this.getStride();
        Rn(n, 0, n.length, r, t, e, i, n), this.changed();
      }
    }
    translate(t, e) {
      const i = this.getFlatCoordinates();
      if (i) {
        const n = this.getStride();
        Tn(i, 0, i.length, n, t, e, i), this.changed();
      }
    }
  };
  function Mn(t, e, i, n, r, s, o) {
    const a = t[e],
      l = t[e + 1],
      h = t[i] - a,
      c = t[i + 1] - l;
    let u;
    if (0 === h && 0 === c) u = e;
    else {
      const d = ((r - a) * h + (s - l) * c) / (h * h + c * c);
      if (d > 1) u = i;
      else {
        if (d > 0) {
          for (let r = 0; r < n; ++r) o[r] = yi(t[e + r], t[i + r], d);
          return void (o.length = n);
        }
        u = e;
      }
    }
    for (let e = 0; e < n; ++e) o[e] = t[u + e];
    o.length = n;
  }
  function On(t, e, i, n, r) {
    let s = t[e],
      o = t[e + 1];
    for (e += n; e < i; e += n) {
      const i = t[e],
        n = t[e + 1],
        a = gi(s, o, i, n);
      a > r && (r = a), (s = i), (o = n);
    }
    return r;
  }
  function kn(t, e, i, n, r) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s];
      (r = On(t, e, o, n, r)), (e = o);
    }
    return r;
  }
  function An(t, e, i, n, r) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s];
      (r = kn(t, e, o, n, r)), (e = o[o.length - 1]);
    }
    return r;
  }
  function Nn(t, e, i, n, r, s, o, a, l, h, c) {
    if (e == i) return h;
    let u, d;
    if (0 === r) {
      if (((d = gi(o, a, t[e], t[e + 1])), d < h)) {
        for (u = 0; u < n; ++u) l[u] = t[e + u];
        return (l.length = n), d;
      }
      return h;
    }
    c = c || [NaN, NaN];
    let g = e + n;
    for (; g < i; )
      if ((Mn(t, g - n, g, n, o, a, c), (d = gi(o, a, c[0], c[1])), d < h)) {
        for (h = d, u = 0; u < n; ++u) l[u] = c[u];
        (l.length = n), (g += n);
      } else g += n * Math.max(((Math.sqrt(d) - Math.sqrt(h)) / r) | 0, 1);
    if (s && (Mn(t, i - n, e, n, o, a, c), (d = gi(o, a, c[0], c[1])), d < h)) {
      for (h = d, u = 0; u < n; ++u) l[u] = c[u];
      l.length = n;
    }
    return h;
  }
  function Dn(t, e, i, n, r, s, o, a, l, h, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = i.length; u < d; ++u) {
      const d = i[u];
      (h = Nn(t, e, d, n, r, s, o, a, l, h, c)), (e = d);
    }
    return h;
  }
  function Gn(t, e, i, n, r, s, o, a, l, h, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = i.length; u < d; ++u) {
      const d = i[u];
      (h = Dn(t, e, d, n, r, s, o, a, l, h, c)), (e = d[d.length - 1]);
    }
    return h;
  }
  function Bn(t, e, i, n) {
    for (let n = 0, r = i.length; n < r; ++n) t[e++] = i[n];
    return e;
  }
  function jn(t, e, i, n) {
    for (let r = 0, s = i.length; r < s; ++r) {
      const s = i[r];
      for (let i = 0; i < n; ++i) t[e++] = s[i];
    }
    return e;
  }
  function zn(t, e, i, n, r) {
    r = r || [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const a = jn(t, e, i[o], n);
      (r[s++] = a), (e = a);
    }
    return (r.length = s), r;
  }
  function Un(t, e, i, n, r) {
    r = r || [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const a = zn(t, e, i[o], n, r[s]);
      0 === a.length && (a[0] = e), (r[s++] = a), (e = a[a.length - 1]);
    }
    return (r.length = s), r;
  }
  function qn(t, e, i, n, r, s, o) {
    const a = (i - e) / n;
    if (a < 3) {
      for (; e < i; e += n) (s[o++] = t[e]), (s[o++] = t[e + 1]);
      return o;
    }
    const l = new Array(a);
    (l[0] = 1), (l[a - 1] = 1);
    const h = [e, i - n];
    let c = 0;
    for (; h.length > 0; ) {
      const i = h.pop(),
        s = h.pop();
      let o = 0;
      const a = t[s],
        u = t[s + 1],
        d = t[i],
        g = t[i + 1];
      for (let e = s + n; e < i; e += n) {
        const i = di(t[e], t[e + 1], a, u, d, g);
        i > o && ((c = e), (o = i));
      }
      o > r &&
        ((l[(c - e) / n] = 1),
        s + n < c && h.push(s, c),
        c + n < i && h.push(c, i));
    }
    for (let i = 0; i < a; ++i)
      l[i] && ((s[o++] = t[e + i * n]), (s[o++] = t[e + i * n + 1]));
    return o;
  }
  function Vn(t, e, i, n, r, s, o, a) {
    for (let l = 0, h = i.length; l < h; ++l) {
      const h = i[l];
      (o = qn(t, e, h, n, r, s, o)), a.push(o), (e = h);
    }
    return o;
  }
  function Xn(t, e, i, n, r, s, o) {
    if (i <= e + n) {
      for (; e < i; e += n) (s[o++] = t[e]), (s[o++] = t[e + 1]);
      return o;
    }
    let a = t[e],
      l = t[e + 1];
    (s[o++] = a), (s[o++] = l);
    let h = a,
      c = l;
    for (e += n; e < i; e += n)
      (h = t[e]),
        (c = t[e + 1]),
        gi(a, l, h, c) > r && ((s[o++] = h), (s[o++] = c), (a = h), (l = c));
    return (h == a && c == l) || ((s[o++] = h), (s[o++] = c)), o;
  }
  function Zn(t, e) {
    return e * Math.round(t / e);
  }
  function Kn(t, e, i, n, r, s, o) {
    if (e == i) return o;
    let a,
      l,
      h = Zn(t[e], r),
      c = Zn(t[e + 1], r);
    (e += n), (s[o++] = h), (s[o++] = c);
    do {
      if (((a = Zn(t[e], r)), (l = Zn(t[e + 1], r)), (e += n) == i))
        return (s[o++] = a), (s[o++] = l), o;
    } while (a == h && l == c);
    for (; e < i; ) {
      const i = Zn(t[e], r),
        u = Zn(t[e + 1], r);
      if (((e += n), i == a && u == l)) continue;
      const d = a - h,
        g = l - c,
        f = i - h,
        p = u - c;
      d * p == g * f &&
      ((d < 0 && f < d) || d == f || (d > 0 && f > d)) &&
      ((g < 0 && p < g) || g == p || (g > 0 && p > g))
        ? ((a = i), (l = u))
        : ((s[o++] = a), (s[o++] = l), (h = a), (c = l), (a = i), (l = u));
    }
    return (s[o++] = a), (s[o++] = l), o;
  }
  function Hn(t, e, i, n, r, s, o, a) {
    for (let l = 0, h = i.length; l < h; ++l) {
      const h = i[l];
      (o = Kn(t, e, h, n, r, s, o)), a.push(o), (e = h);
    }
    return o;
  }
  function Yn(t, e, i, n, r, s, o, a) {
    for (let l = 0, h = i.length; l < h; ++l) {
      const h = i[l],
        c = [];
      (o = Hn(t, e, h, n, r, s, o, c)), a.push(c), (e = h[h.length - 1]);
    }
    return o;
  }
  function Qn(t, e, i, n, r) {
    r = void 0 !== r ? r : [];
    let s = 0;
    for (let o = e; o < i; o += n) r[s++] = t.slice(o, o + n);
    return (r.length = s), r;
  }
  function $n(t, e, i, n, r) {
    r = void 0 !== r ? r : [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const a = i[o];
      (r[s++] = Qn(t, e, a, n, r[s])), (e = a);
    }
    return (r.length = s), r;
  }
  function Jn(t, e, i, n, r) {
    r = void 0 !== r ? r : [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const a = i[o];
      (r[s++] = 1 === a.length && a[0] === e ? [] : $n(t, e, a, n, r[s])),
        (e = a[a.length - 1]);
    }
    return (r.length = s), r;
  }
  function tr(t, e, i, n) {
    let r = 0,
      s = t[i - n],
      o = t[i - n + 1];
    for (; e < i; e += n) {
      const i = t[e],
        n = t[e + 1];
      (r += o * i - s * n), (s = i), (o = n);
    }
    return r / 2;
  }
  function er(t, e, i, n) {
    let r = 0;
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s];
      (r += tr(t, e, o, n)), (e = o);
    }
    return r;
  }
  function ir(t, e, i, n) {
    let r = 0;
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s];
      (r += er(t, e, o, n)), (e = o[o.length - 1]);
    }
    return r;
  }
  class nr extends Ln {
    constructor(t, e) {
      super(),
        (this.maxDelta_ = -1),
        (this.maxDeltaRevision_ = -1),
        void 0 === e || Array.isArray(t[0])
          ? this.setCoordinates(t, e)
          : this.setFlatCoordinates(e, t);
    }
    clone() {
      return new nr(this.flatCoordinates.slice(), this.layout);
    }
    closestPointXY(t, e, i, n) {
      return n < te(this.getExtent(), t, e)
        ? n
        : (this.maxDeltaRevision_ != this.getRevision() &&
            ((this.maxDelta_ = Math.sqrt(
              On(
                this.flatCoordinates,
                0,
                this.flatCoordinates.length,
                this.stride,
                0
              )
            )),
            (this.maxDeltaRevision_ = this.getRevision())),
          Nn(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride,
            this.maxDelta_,
            !0,
            t,
            e,
            i,
            n
          ));
    }
    getArea() {
      return tr(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    getCoordinates() {
      return Qn(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    getSimplifiedGeometryInternal(t) {
      const e = [];
      return (
        (e.length = qn(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          t,
          e,
          0
        )),
        new nr(e, "XY")
      );
    }
    getType() {
      return "LinearRing";
    }
    intersectsExtent(t) {
      return !1;
    }
    setCoordinates(t, e) {
      this.setLayout(e, t, 1),
        this.flatCoordinates || (this.flatCoordinates = []),
        (this.flatCoordinates.length = jn(
          this.flatCoordinates,
          0,
          t,
          this.stride
        )),
        this.changed();
    }
  }
  var rr = nr;
  class sr extends Ln {
    constructor(t, e) {
      super(), this.setCoordinates(t, e);
    }
    clone() {
      const t = new sr(this.flatCoordinates.slice(), this.layout);
      return t.applyProperties(this), t;
    }
    closestPointXY(t, e, i, n) {
      const r = this.flatCoordinates,
        s = gi(t, e, r[0], r[1]);
      if (s < n) {
        const t = this.stride;
        for (let e = 0; e < t; ++e) i[e] = r[e];
        return (i.length = t), s;
      }
      return n;
    }
    getCoordinates() {
      return this.flatCoordinates ? this.flatCoordinates.slice() : [];
    }
    computeExtent(t) {
      return le(this.flatCoordinates, t);
    }
    getType() {
      return "Point";
    }
    intersectsExtent(t) {
      return ne(t, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    setCoordinates(t, e) {
      this.setLayout(e, t, 0),
        this.flatCoordinates || (this.flatCoordinates = []),
        (this.flatCoordinates.length = Bn(
          this.flatCoordinates,
          0,
          t,
          this.stride
        )),
        this.changed();
    }
  }
  var or = sr;
  function ar(t, e, i, n, r) {
    return !ye(r, function (r) {
      return !lr(t, e, i, n, r[0], r[1]);
    });
  }
  function lr(t, e, i, n, r, s) {
    let o = 0,
      a = t[i - n],
      l = t[i - n + 1];
    for (; e < i; e += n) {
      const i = t[e],
        n = t[e + 1];
      l <= s
        ? n > s && (i - a) * (s - l) - (r - a) * (n - l) > 0 && o++
        : n <= s && (i - a) * (s - l) - (r - a) * (n - l) < 0 && o--,
        (a = i),
        (l = n);
    }
    return 0 !== o;
  }
  function hr(t, e, i, n, r, s) {
    if (0 === i.length) return !1;
    if (!lr(t, e, i[0], n, r, s)) return !1;
    for (let e = 1, o = i.length; e < o; ++e)
      if (lr(t, i[e - 1], i[e], n, r, s)) return !1;
    return !0;
  }
  function cr(t, e, i, n, r, s) {
    if (0 === i.length) return !1;
    for (let o = 0, a = i.length; o < a; ++o) {
      const a = i[o];
      if (hr(t, e, a, n, r, s)) return !0;
      e = a[a.length - 1];
    }
    return !1;
  }
  function ur(t, e, i, n, r, o, a) {
    let l, h, c, u, d, g, f;
    const p = r[o + 1],
      m = [];
    for (let r = 0, s = i.length; r < s; ++r) {
      const s = i[r];
      for (u = t[s - n], g = t[s - n + 1], l = e; l < s; l += n)
        (d = t[l]),
          (f = t[l + 1]),
          ((p <= g && f <= p) || (g <= p && p <= f)) &&
            ((c = ((p - g) / (f - g)) * (d - u) + u), m.push(c)),
          (u = d),
          (g = f);
    }
    let _ = NaN,
      y = -1 / 0;
    for (m.sort(s), u = m[0], l = 1, h = m.length; l < h; ++l) {
      d = m[l];
      const r = Math.abs(d - u);
      r > y && ((c = (u + d) / 2), hr(t, e, i, n, c, p) && ((_ = c), (y = r))),
        (u = d);
    }
    return isNaN(_) && (_ = r[o]), a ? (a.push(_, p, y), a) : [_, p, y];
  }
  function dr(t, e, i, n, r) {
    let s = [];
    for (let o = 0, a = i.length; o < a; ++o) {
      const a = i[o];
      (s = ur(t, e, a, n, r, 2 * o, s)), (e = a[a.length - 1]);
    }
    return s;
  }
  function gr(t, e, i, n, r) {
    let s;
    for (e += n; e < i; e += n)
      if (((s = r(t.slice(e - n, e), t.slice(e, e + n))), s)) return s;
    return !1;
  }
  function fr(t, e, i, n, r) {
    const s = pe([1 / 0, 1 / 0, -1 / 0, -1 / 0], t, e, i, n);
    return (
      !!Ie(r, s) &&
      (!!ie(r, s) ||
        (s[0] >= r[0] && s[2] <= r[2]) ||
        (s[1] >= r[1] && s[3] <= r[3]) ||
        gr(t, e, i, n, function (t, e) {
          return ke(r, t, e);
        }))
    );
  }
  function pr(t, e, i, n, r) {
    for (let s = 0, o = i.length; s < o; ++s) {
      if (fr(t, e, i[s], n, r)) return !0;
      e = i[s];
    }
    return !1;
  }
  function mr(t, e, i, n, r) {
    return (
      !!fr(t, e, i, n, r) ||
      !!lr(t, e, i, n, r[0], r[1]) ||
      !!lr(t, e, i, n, r[0], r[3]) ||
      !!lr(t, e, i, n, r[2], r[1]) ||
      !!lr(t, e, i, n, r[2], r[3])
    );
  }
  function _r(t, e, i, n, r) {
    if (!mr(t, e, i[0], n, r)) return !1;
    if (1 === i.length) return !0;
    for (let e = 1, s = i.length; e < s; ++e)
      if (ar(t, i[e - 1], i[e], n, r) && !fr(t, i[e - 1], i[e], n, r))
        return !1;
    return !0;
  }
  function yr(t, e, i, n, r) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s];
      if (_r(t, e, o, n, r)) return !0;
      e = o[o.length - 1];
    }
    return !1;
  }
  function xr(t, e, i, n) {
    for (; e < i - n; ) {
      for (let r = 0; r < n; ++r) {
        const s = t[e + r];
        (t[e + r] = t[i - n + r]), (t[i - n + r] = s);
      }
      (e += n), (i -= n);
    }
  }
  function vr(t, e, i, n) {
    let r = 0,
      s = t[i - n],
      o = t[i - n + 1];
    for (; e < i; e += n) {
      const i = t[e],
        n = t[e + 1];
      (r += (i - s) * (n + o)), (s = i), (o = n);
    }
    return 0 === r ? void 0 : r > 0;
  }
  function Sr(t, e, i, n, r) {
    r = void 0 !== r && r;
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s],
        a = vr(t, e, o, n);
      if (0 === s) {
        if ((r && a) || (!r && !a)) return !1;
      } else if ((r && !a) || (!r && a)) return !1;
      e = o;
    }
    return !0;
  }
  function Cr(t, e, i, n, r) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s];
      if (!Sr(t, e, o, n, r)) return !1;
      o.length && (e = o[o.length - 1]);
    }
    return !0;
  }
  function wr(t, e, i, n, r) {
    r = void 0 !== r && r;
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s],
        a = vr(t, e, o, n);
      (0 === s ? (r && a) || (!r && !a) : (r && !a) || (!r && a)) &&
        xr(t, e, o, n),
        (e = o);
    }
    return e;
  }
  function Wr(t, e, i, n, r) {
    for (let s = 0, o = i.length; s < o; ++s) e = wr(t, e, i[s], n, r);
    return e;
  }
  function Er(t, e) {
    const i = [];
    let n = 0,
      r = 0;
    for (let s = 0, o = e.length; s < o; ++s) {
      const o = e[s];
      if (vr(t, n, o, 2)) {
        if (0 === i.length) continue;
        i[i.length - 1].push(e[r]);
      } else i.push(e.slice(r, s + 1));
      (r = s + 1), (n = o);
    }
    return i;
  }
  class Rr extends Ln {
    constructor(t, e, i) {
      super(),
        (this.ends_ = []),
        (this.flatInteriorPointRevision_ = -1),
        (this.flatInteriorPoint_ = null),
        (this.maxDelta_ = -1),
        (this.maxDeltaRevision_ = -1),
        (this.orientedRevision_ = -1),
        (this.orientedFlatCoordinates_ = null),
        void 0 !== e && i
          ? (this.setFlatCoordinates(e, t), (this.ends_ = i))
          : this.setCoordinates(t, e);
    }
    appendLinearRing(t) {
      this.flatCoordinates
        ? h(this.flatCoordinates, t.getFlatCoordinates())
        : (this.flatCoordinates = t.getFlatCoordinates().slice()),
        this.ends_.push(this.flatCoordinates.length),
        this.changed();
    }
    clone() {
      const t = new Rr(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return t.applyProperties(this), t;
    }
    closestPointXY(t, e, i, n) {
      return n < te(this.getExtent(), t, e)
        ? n
        : (this.maxDeltaRevision_ != this.getRevision() &&
            ((this.maxDelta_ = Math.sqrt(
              kn(this.flatCoordinates, 0, this.ends_, this.stride, 0)
            )),
            (this.maxDeltaRevision_ = this.getRevision())),
          Dn(
            this.flatCoordinates,
            0,
            this.ends_,
            this.stride,
            this.maxDelta_,
            !0,
            t,
            e,
            i,
            n
          ));
    }
    containsXY(t, e) {
      return hr(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t,
        e
      );
    }
    getArea() {
      return er(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    }
    getCoordinates(t) {
      let e;
      return (
        void 0 !== t
          ? ((e = this.getOrientedFlatCoordinates().slice()),
            wr(e, 0, this.ends_, this.stride, t))
          : (e = this.flatCoordinates),
        $n(e, 0, this.ends_, this.stride)
      );
    }
    getEnds() {
      return this.ends_;
    }
    getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        const t = Ce(this.getExtent());
        (this.flatInteriorPoint_ = ur(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          t,
          0
        )),
          (this.flatInteriorPointRevision_ = this.getRevision());
      }
      return this.flatInteriorPoint_;
    }
    getInteriorPoint() {
      return new or(this.getFlatInteriorPoint(), "XYM");
    }
    getLinearRingCount() {
      return this.ends_.length;
    }
    getLinearRing(t) {
      return t < 0 || this.ends_.length <= t
        ? null
        : new rr(
            this.flatCoordinates.slice(
              0 === t ? 0 : this.ends_[t - 1],
              this.ends_[t]
            ),
            this.layout
          );
    }
    getLinearRings() {
      const t = this.layout,
        e = this.flatCoordinates,
        i = this.ends_,
        n = [];
      let r = 0;
      for (let s = 0, o = i.length; s < o; ++s) {
        const o = i[s],
          a = new rr(e.slice(r, o), t);
        n.push(a), (r = o);
      }
      return n;
    }
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const t = this.flatCoordinates;
        Sr(t, 0, this.ends_, this.stride)
          ? (this.orientedFlatCoordinates_ = t)
          : ((this.orientedFlatCoordinates_ = t.slice()),
            (this.orientedFlatCoordinates_.length = wr(
              this.orientedFlatCoordinates_,
              0,
              this.ends_,
              this.stride
            ))),
          (this.orientedRevision_ = this.getRevision());
      }
      return this.orientedFlatCoordinates_;
    }
    getSimplifiedGeometryInternal(t) {
      const e = [],
        i = [];
      return (
        (e.length = Hn(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          Math.sqrt(t),
          e,
          0,
          i
        )),
        new Rr(e, "XY", i)
      );
    }
    getType() {
      return "Polygon";
    }
    intersectsExtent(t) {
      return _r(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        t
      );
    }
    setCoordinates(t, e) {
      this.setLayout(e, t, 2),
        this.flatCoordinates || (this.flatCoordinates = []);
      const i = zn(this.flatCoordinates, 0, t, this.stride, this.ends_);
      (this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1]),
        this.changed();
    }
  }
  var Tr = Rr;
  function Pr(t, e, i, n) {
    i = i || 32;
    const r = [];
    for (let s = 0; s < i; ++s) h(r, Ui(t, e, (2 * Math.PI * s) / i, n));
    return r.push(r[0], r[1]), new Rr(r, "XY", [r.length]);
  }
  function br(t) {
    if (Le(t)) throw new Error("Cannot create polygon from empty extent");
    const e = t[0],
      i = t[1],
      n = t[2],
      r = t[3],
      s = [e, i, e, r, n, r, n, i, e, i];
    return new Rr(s, "XY", [s.length]);
  }
  function Fr(t, e, i) {
    e = e || 32;
    const n = t.getStride(),
      r = t.getLayout(),
      s = t.getCenter(),
      o = n * (e + 1),
      a = new Array(o);
    for (let t = 0; t < o; t += n) {
      (a[t] = 0), (a[t + 1] = 0);
      for (let e = 2; e < n; e++) a[t + e] = s[e];
    }
    const l = [a.length],
      h = new Rr(a, r, l);
    return Ir(h, s, t.getRadius(), i), h;
  }
  function Ir(t, e, i, n) {
    const r = t.getFlatCoordinates(),
      s = t.getStride(),
      o = r.length / s - 1,
      a = n || 0;
    for (let t = 0; t <= o; ++t) {
      const n = t * s,
        l = a + (2 * _i(t, o) * Math.PI) / o;
      (r[n] = e[0] + i * Math.cos(l)), (r[n + 1] = e[1] + i * Math.sin(l));
    }
    t.changed();
  }
  const Lr = "accuracy",
    Mr = "accuracyGeometry",
    Or = "altitude",
    kr = "altitudeAccuracy",
    Ar = "heading",
    Nr = "position",
    Dr = "projection",
    Gr = "speed",
    Br = "tracking",
    jr = "trackingOptions",
    zr = "error";
  class Ur extends e {
    constructor(t) {
      super(zr), (this.code = t.code), (this.message = t.message);
    }
  }
  var qr = class extends U {
      constructor(t) {
        super(),
          this.on,
          this.once,
          this.un,
          (t = t || {}),
          (this.position_ = null),
          (this.transform_ = Qi),
          (this.watchId_ = void 0),
          this.addChangeListener(Dr, this.handleProjectionChanged_),
          this.addChangeListener(Br, this.handleTrackingChanged_),
          void 0 !== t.projection && this.setProjection(t.projection),
          void 0 !== t.trackingOptions &&
            this.setTrackingOptions(t.trackingOptions),
          this.setTracking(void 0 !== t.tracking && t.tracking);
      }
      disposeInternal() {
        this.setTracking(!1), super.disposeInternal();
      }
      handleProjectionChanged_() {
        const t = this.getProjection();
        t &&
          ((this.transform_ = hn(tn("EPSG:4326"), t)),
          this.position_ && this.set(Nr, this.transform_(this.position_)));
      }
      handleTrackingChanged_() {
        if ("geolocation" in navigator) {
          const t = this.getTracking();
          t && void 0 === this.watchId_
            ? (this.watchId_ = navigator.geolocation.watchPosition(
                this.positionChange_.bind(this),
                this.positionError_.bind(this),
                this.getTrackingOptions()
              ))
            : t ||
              void 0 === this.watchId_ ||
              (navigator.geolocation.clearWatch(this.watchId_),
              (this.watchId_ = void 0));
        }
      }
      positionChange_(t) {
        const e = t.coords;
        this.set(Lr, e.accuracy),
          this.set(Or, null === e.altitude ? void 0 : e.altitude),
          this.set(
            kr,
            null === e.altitudeAccuracy ? void 0 : e.altitudeAccuracy
          ),
          this.set(Ar, null === e.heading ? void 0 : mi(e.heading)),
          this.position_
            ? ((this.position_[0] = e.longitude),
              (this.position_[1] = e.latitude))
            : (this.position_ = [e.longitude, e.latitude]);
        const i = this.transform_(this.position_);
        this.set(Nr, i.slice()),
          this.set(Gr, null === e.speed ? void 0 : e.speed);
        const n = Pr(this.position_, e.accuracy);
        n.applyTransform(this.transform_), this.set(Mr, n), this.changed();
      }
      positionError_(t) {
        this.dispatchEvent(new Ur(t));
      }
      getAccuracy() {
        return this.get(Lr);
      }
      getAccuracyGeometry() {
        return this.get(Mr) || null;
      }
      getAltitude() {
        return this.get(Or);
      }
      getAltitudeAccuracy() {
        return this.get(kr);
      }
      getHeading() {
        return this.get(Ar);
      }
      getPosition() {
        return this.get(Nr);
      }
      getProjection() {
        return this.get(Dr);
      }
      getSpeed() {
        return this.get(Gr);
      }
      getTracking() {
        return this.get(Br);
      }
      getTrackingOptions() {
        return this.get(jr);
      }
      setProjection(t) {
        this.set(Dr, tn(t));
      }
      setTracking(t) {
        this.set(Br, t);
      }
      setTrackingOptions(t) {
        this.set(jr, t);
      }
    },
    Vr = 0,
    Xr = 1,
    Zr = 2,
    Kr = 3,
    Hr = 4;
  function Yr(t, e, i) {
    const n = t;
    let r = !0,
      s = !1,
      o = !1;
    const a = [
      O(n, F, function () {
        (o = !0), s || e();
      }),
    ];
    return (
      n.src && gt
        ? ((s = !0),
          n
            .decode()
            .then(function () {
              r && e();
            })
            .catch(function (t) {
              r && (o ? e() : i());
            }))
        : a.push(O(n, S, i)),
      function () {
        (r = !1), a.forEach(k);
      }
    );
  }
  function Qr(t, e) {
    return new Promise((i, n) => {
      function r() {
        o(), i(t);
      }
      function s() {
        o(), n(new Error("Image load error"));
      }
      function o() {
        t.removeEventListener("load", r), t.removeEventListener("error", s);
      }
      t.addEventListener("load", r),
        t.addEventListener("error", s),
        e && (t.src = e);
    });
  }
  function $r(t, e) {
    return (
      e && (t.src = e),
      gt ? new Promise((e, i) => t.decode().then(() => e(t), i)) : Qr(t)
    );
  }
  function Jr(t, e) {
    return (
      e && (t.src = e),
      gt && ft ? t.decode().then(() => createImageBitmap(t)) : $r(t)
    );
  }
  var ts = class extends x {
    constructor(t, e, i, n) {
      super(),
        (this.extent = t),
        (this.pixelRatio_ = i),
        (this.resolution = e),
        (this.state = "function" == typeof n ? Vr : n),
        (this.image_ = null),
        (this.loader = "function" == typeof n ? n : null);
    }
    changed() {
      this.dispatchEvent(v);
    }
    getExtent() {
      return this.extent;
    }
    getImage() {
      return this.image_;
    }
    getPixelRatio() {
      return this.pixelRatio_;
    }
    getResolution() {
      return this.resolution;
    }
    getState() {
      return this.state;
    }
    load() {
      if (this.state == Vr && this.loader) {
        (this.state = Xr), this.changed();
        const t = this.getResolution(),
          e = Array.isArray(t) ? t[0] : t;
        m(() => this.loader(this.getExtent(), e, this.getPixelRatio()))
          .then((t) => {
            "image" in t && (this.image_ = t.image),
              "extent" in t && (this.extent = t.extent),
              "resolution" in t && (this.resolution = t.resolution),
              "pixelRatio" in t && (this.pixelRatio_ = t.pixelRatio),
              (t instanceof HTMLImageElement ||
                t instanceof ImageBitmap ||
                t instanceof HTMLCanvasElement ||
                t instanceof HTMLVideoElement) &&
                (this.image_ = t),
              (this.state = Zr);
          })
          .catch((t) => {
            (this.state = Kr), console.error(t);
          })
          .finally(() => this.changed());
      }
    }
    setImage(t) {
      this.image_ = t;
    }
    setResolution(t) {
      this.resolution = t;
    }
  };
  var es = class extends ts {
    constructor(t, e, i, n, r) {
      super(t, e, i, void 0 !== r ? Vr : Zr),
        (this.loader_ = void 0 !== r ? r : null),
        (this.canvas_ = n),
        (this.error_ = null);
    }
    getError() {
      return this.error_;
    }
    handleLoad_(t) {
      t ? ((this.error_ = t), (this.state = Kr)) : (this.state = Zr),
        this.changed();
    }
    load() {
      this.state == Vr &&
        ((this.state = Xr),
        this.changed(),
        this.loader_(this.handleLoad_.bind(this)));
    }
    getImage() {
      return this.canvas_;
    }
  };
  var is = class extends rt {
    constructor(t, e, i, n, r, s) {
      super(t, e, s),
        (this.crossOrigin_ = n),
        (this.src_ = i),
        (this.key = i),
        (this.image_ = new Image()),
        null !== n && (this.image_.crossOrigin = n),
        (this.unlisten_ = null),
        (this.tileLoadFunction_ = r);
    }
    getImage() {
      return this.image_;
    }
    setImage(t) {
      (this.image_ = t),
        (this.state = Q),
        this.unlistenImage_(),
        this.changed();
    }
    handleImageError_() {
      (this.state = $),
        this.unlistenImage_(),
        (this.image_ = (function () {
          const t = mt(1, 1);
          return (
            (t.fillStyle = "rgba(0,0,0,0)"), t.fillRect(0, 0, 1, 1), t.canvas
          );
        })()),
        this.changed();
    }
    handleImageLoad_() {
      const t = this.image_;
      t.naturalWidth && t.naturalHeight ? (this.state = Q) : (this.state = J),
        this.unlistenImage_(),
        this.changed();
    }
    load() {
      this.state == $ &&
        ((this.state = H),
        (this.image_ = new Image()),
        null !== this.crossOrigin_ &&
          (this.image_.crossOrigin = this.crossOrigin_)),
        this.state == H &&
          ((this.state = Y),
          this.changed(),
          this.tileLoadFunction_(this, this.src_),
          (this.unlisten_ = Yr(
            this.image_,
            this.handleImageLoad_.bind(this),
            this.handleImageError_.bind(this)
          )));
    }
    unlistenImage_() {
      this.unlisten_ && (this.unlisten_(), (this.unlisten_ = null));
    }
  };
  var ns = class {
    constructor(t, e, i) {
      (this.decay_ = t),
        (this.minVelocity_ = e),
        (this.delay_ = i),
        (this.points_ = []),
        (this.angle_ = 0),
        (this.initialVelocity_ = 0);
    }
    begin() {
      (this.points_.length = 0), (this.angle_ = 0), (this.initialVelocity_ = 0);
    }
    update(t, e) {
      this.points_.push(t, e, Date.now());
    }
    end() {
      if (this.points_.length < 6) return !1;
      const t = Date.now() - this.delay_,
        e = this.points_.length - 3;
      if (this.points_[e + 2] < t) return !1;
      let i = e - 3;
      for (; i > 0 && this.points_[i + 2] > t; ) i -= 3;
      const n = this.points_[e + 2] - this.points_[i + 2];
      if (n < 1e3 / 60) return !1;
      const r = this.points_[e] - this.points_[i],
        s = this.points_[e + 1] - this.points_[i + 1];
      return (
        (this.angle_ = Math.atan2(s, r)),
        (this.initialVelocity_ = Math.sqrt(r * r + s * s) / n),
        this.initialVelocity_ > this.minVelocity_
      );
    }
    getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    getAngle() {
      return this.angle_;
    }
  };
  const rs = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i,
    ss = /^([a-z]*)$|^hsla?\(.*\)$/i;
  function os(t) {
    return "string" == typeof t ? t : us(t);
  }
  function as(t) {
    const e = document.createElement("div");
    if (((e.style.color = t), "" !== e.style.color)) {
      document.body.appendChild(e);
      const t = getComputedStyle(e).color;
      return document.body.removeChild(e), t;
    }
    return "";
  }
  const ls = (function () {
    const t = {};
    let e = 0;
    return function (i) {
      let n;
      if (t.hasOwnProperty(i)) n = t[i];
      else {
        if (e >= 1024) {
          let i = 0;
          for (const n in t) 0 == (3 & i++) && (delete t[n], --e);
        }
        (n = (function (t) {
          let e, i, n, r, s;
          ss.exec(t) && (t = as(t));
          if (rs.exec(t)) {
            const o = t.length - 1;
            let a;
            a = o <= 4 ? 1 : 2;
            const l = 4 === o || 8 === o;
            (e = parseInt(t.substr(1 + 0 * a, a), 16)),
              (i = parseInt(t.substr(1 + 1 * a, a), 16)),
              (n = parseInt(t.substr(1 + 2 * a, a), 16)),
              (r = l ? parseInt(t.substr(1 + 3 * a, a), 16) : 255),
              1 == a &&
                ((e = (e << 4) + e),
                (i = (i << 4) + i),
                (n = (n << 4) + n),
                l && (r = (r << 4) + r)),
              (s = [e, i, n, r / 255]);
          } else if (t.startsWith("rgba("))
            (s = t.slice(5, -1).split(",").map(Number)), cs(s);
          else {
            if (!t.startsWith("rgb(")) throw new Error("Invalid color");
            (s = t.slice(4, -1).split(",").map(Number)), s.push(1), cs(s);
          }
          return s;
        })(i)),
          (t[i] = n),
          ++e;
      }
      return n;
    };
  })();
  function hs(t) {
    return Array.isArray(t) ? t : ls(t);
  }
  function cs(t) {
    return (
      (t[0] = ui((t[0] + 0.5) | 0, 0, 255)),
      (t[1] = ui((t[1] + 0.5) | 0, 0, 255)),
      (t[2] = ui((t[2] + 0.5) | 0, 0, 255)),
      (t[3] = ui(t[3], 0, 1)),
      t
    );
  }
  function us(t) {
    let e = t[0];
    e != (0 | e) && (e = (e + 0.5) | 0);
    let i = t[1];
    i != (0 | i) && (i = (i + 0.5) | 0);
    let n = t[2];
    n != (0 | n) && (n = (n + 0.5) | 0);
    return (
      "rgba(" +
      e +
      "," +
      i +
      "," +
      n +
      "," +
      (void 0 === t[3] ? 1 : Math.round(100 * t[3]) / 100) +
      ")"
    );
  }
  function ds(t) {
    return (
      ss.test(t) && (t = as(t)),
      rs.test(t) || t.startsWith("rgba(") || t.startsWith("rgb(")
    );
  }
  class gs {
    constructor() {
      (this.cache_ = {}), (this.cacheSize_ = 0), (this.maxCacheSize_ = 32);
    }
    clear() {
      (this.cache_ = {}), (this.cacheSize_ = 0);
    }
    canExpireCache() {
      return this.cacheSize_ > this.maxCacheSize_;
    }
    expire() {
      if (this.canExpireCache()) {
        let t = 0;
        for (const e in this.cache_) {
          const i = this.cache_[e];
          0 != (3 & t++) ||
            i.hasListener() ||
            (delete this.cache_[e], --this.cacheSize_);
        }
      }
    }
    get(t, e, i) {
      const n = fs(t, e, i);
      return n in this.cache_ ? this.cache_[n] : null;
    }
    set(t, e, i, n) {
      const r = fs(t, e, i);
      (this.cache_[r] = n), ++this.cacheSize_;
    }
    setSize(t) {
      (this.maxCacheSize_ = t), this.expire();
    }
  }
  function fs(t, e, i) {
    return e + ":" + t + ":" + (i ? os(i) : "null");
  }
  var ps = gs;
  const ms = new gs();
  var _s = "opacity",
    ys = "visible",
    xs = "extent",
    vs = "zIndex",
    Ss = "maxResolution",
    Cs = "minResolution",
    ws = "maxZoom",
    Ws = "minZoom",
    Es = "source",
    Rs = "map";
  var Ts = class extends U {
      constructor(t) {
        super(), this.on, this.once, this.un, (this.background_ = t.background);
        const e = Object.assign({}, t);
        "object" == typeof t.properties &&
          (delete e.properties, Object.assign(e, t.properties)),
          (e[_s] = void 0 !== t.opacity ? t.opacity : 1),
          Ft("number" == typeof e[_s], "Layer opacity must be a number"),
          (e[ys] = void 0 === t.visible || t.visible),
          (e[vs] = t.zIndex),
          (e[Ss] = void 0 !== t.maxResolution ? t.maxResolution : 1 / 0),
          (e[Cs] = void 0 !== t.minResolution ? t.minResolution : 0),
          (e[Ws] = void 0 !== t.minZoom ? t.minZoom : -1 / 0),
          (e[ws] = void 0 !== t.maxZoom ? t.maxZoom : 1 / 0),
          (this.className_ = void 0 !== e.className ? e.className : "ol-layer"),
          delete e.className,
          this.setProperties(e),
          (this.state_ = null);
      }
      getBackground() {
        return this.background_;
      }
      getClassName() {
        return this.className_;
      }
      getLayerState(t) {
        const e = this.state_ || { layer: this, managed: void 0 === t || t },
          i = this.getZIndex();
        return (
          (e.opacity = ui(Math.round(100 * this.getOpacity()) / 100, 0, 1)),
          (e.visible = this.getVisible()),
          (e.extent = this.getExtent()),
          (e.zIndex = void 0 !== i || e.managed ? i : 1 / 0),
          (e.maxResolution = this.getMaxResolution()),
          (e.minResolution = Math.max(this.getMinResolution(), 0)),
          (e.minZoom = this.getMinZoom()),
          (e.maxZoom = this.getMaxZoom()),
          (this.state_ = e),
          e
        );
      }
      getLayersArray(t) {
        return G();
      }
      getLayerStatesArray(t) {
        return G();
      }
      getExtent() {
        return this.get(xs);
      }
      getMaxResolution() {
        return this.get(Ss);
      }
      getMinResolution() {
        return this.get(Cs);
      }
      getMinZoom() {
        return this.get(Ws);
      }
      getMaxZoom() {
        return this.get(ws);
      }
      getOpacity() {
        return this.get(_s);
      }
      getSourceState() {
        return G();
      }
      getVisible() {
        return this.get(ys);
      }
      getZIndex() {
        return this.get(vs);
      }
      setBackground(t) {
        (this.background_ = t), this.changed();
      }
      setExtent(t) {
        this.set(xs, t);
      }
      setMaxResolution(t) {
        this.set(Ss, t);
      }
      setMinResolution(t) {
        this.set(Cs, t);
      }
      setMaxZoom(t) {
        this.set(ws, t);
      }
      setMinZoom(t) {
        this.set(Ws, t);
      }
      setOpacity(t) {
        Ft("number" == typeof t, "Layer opacity must be a number"),
          this.set(_s, t);
      }
      setVisible(t) {
        this.set(ys, t);
      }
      setZIndex(t) {
        this.set(vs, t);
      }
      disposeInternal() {
        this.state_ && ((this.state_.layer = null), (this.state_ = null)),
          super.disposeInternal();
      }
    },
    Ps = "prerender",
    bs = "postrender",
    Fs = "precompose",
    Is = "postcompose",
    Ls = "rendercomplete",
    Ms = 0,
    Os = 1,
    ks = { CENTER: "center", RESOLUTION: "resolution", ROTATION: "rotation" };
  const As = 42,
    Ns = 256;
  function Ds(t, e, i) {
    return function (n, r, s, o, a) {
      if (!n) return;
      if (!r && !e) return n;
      const l = e ? 0 : s[0] * r,
        h = e ? 0 : s[1] * r,
        c = a ? a[0] : 0,
        u = a ? a[1] : 0;
      let d = t[0] + l / 2 + c,
        g = t[2] - l / 2 + c,
        f = t[1] + h / 2 + u,
        p = t[3] - h / 2 + u;
      d > g && ((d = (g + d) / 2), (g = d)),
        f > p && ((f = (p + f) / 2), (p = f));
      let m = ui(n[0], d, g),
        _ = ui(n[1], f, p);
      if (o && i && r) {
        const t = 30 * r;
        (m +=
          -t * Math.log(1 + Math.max(0, d - n[0]) / t) +
          t * Math.log(1 + Math.max(0, n[0] - g) / t)),
          (_ +=
            -t * Math.log(1 + Math.max(0, f - n[1]) / t) +
            t * Math.log(1 + Math.max(0, n[1] - p) / t));
      }
      return [m, _];
    };
  }
  function Gs(t) {
    return t;
  }
  function Bs(t, e, i, n) {
    const r = Fe(e) / i[0],
      s = Re(e) / i[1];
    return n ? Math.min(t, Math.max(r, s)) : Math.min(t, Math.min(r, s));
  }
  function js(t, e, i) {
    let n = Math.min(t, e);
    return (
      (n *= Math.log(1 + 50 * Math.max(0, t / e - 1)) / 50 + 1),
      i &&
        ((n = Math.max(n, i)),
        (n /= Math.log(1 + 50 * Math.max(0, i / t - 1)) / 50 + 1)),
      ui(n, i / 2, 2 * e)
    );
  }
  function zs(t, e, i, n) {
    return (
      (e = void 0 === e || e),
      function (r, s, o, l) {
        if (void 0 !== r) {
          const h = t[0],
            c = t[t.length - 1],
            u = i ? Bs(h, i, o, n) : h;
          if (l) return e ? js(r, u, c) : ui(r, c, u);
          const d = Math.min(u, r),
            g = Math.floor(a(t, d, s));
          return t[g] > u && g < t.length - 1 ? t[g + 1] : t[g];
        }
      }
    );
  }
  function Us(t, e, i, n, r, s) {
    return (
      (n = void 0 === n || n),
      (i = void 0 !== i ? i : 0),
      function (o, a, l, h) {
        if (void 0 !== o) {
          const c = r ? Bs(e, r, l, s) : e;
          if (h) return n ? js(o, c, i) : ui(o, i, c);
          const u = 1e-9,
            d = Math.ceil(Math.log(e / c) / Math.log(t) - u),
            g = -a * (0.5 - u) + 0.5,
            f = Math.min(c, o),
            p = Math.floor(Math.log(e / f) / Math.log(t) + g),
            m = Math.max(d, p);
          return ui(e / Math.pow(t, m), i, c);
        }
      }
    );
  }
  function qs(t, e, i, n, r) {
    return (
      (i = void 0 === i || i),
      function (s, o, a, l) {
        if (void 0 !== s) {
          const o = n ? Bs(t, n, a, r) : t;
          return i && l ? js(s, o, e) : ui(s, e, o);
        }
      }
    );
  }
  function Vs(t) {
    if (void 0 !== t) return 0;
  }
  function Xs(t) {
    if (void 0 !== t) return t;
  }
  function Zs(t) {
    const e = (2 * Math.PI) / t;
    return function (t, i) {
      return i ? t : void 0 !== t ? (t = Math.floor(t / e + 0.5) * e) : void 0;
    };
  }
  function Ks(t) {
    return (
      (t = t || mi(5)),
      function (e, i) {
        return i ? e : void 0 !== e ? (Math.abs(e) <= t ? 0 : e) : void 0;
      }
    );
  }
  function Hs(t, e) {
    setTimeout(function () {
      t(e);
    }, 0);
  }
  function Ys(t) {
    if (void 0 !== t.extent) {
      const e = void 0 === t.smoothExtentConstraint || t.smoothExtentConstraint;
      return Ds(t.extent, t.constrainOnlyCenter, e);
    }
    const e = sn(t.projection, "EPSG:3857");
    if (!0 !== t.multiWorld && e.isGlobal()) {
      const t = e.getExtent().slice();
      return (t[0] = -1 / 0), (t[2] = 1 / 0), Ds(t, !1, !1);
    }
    return Gs;
  }
  function Qs(t) {
    let e, i, n;
    let r = void 0 !== t.minZoom ? t.minZoom : 0,
      s = void 0 !== t.maxZoom ? t.maxZoom : 28;
    const o = void 0 !== t.zoomFactor ? t.zoomFactor : 2,
      a = void 0 !== t.multiWorld && t.multiWorld,
      l =
        void 0 === t.smoothResolutionConstraint || t.smoothResolutionConstraint,
      h = void 0 !== t.showFullExtent && t.showFullExtent,
      c = sn(t.projection, "EPSG:3857"),
      u = c.getExtent();
    let d = t.constrainOnlyCenter,
      g = t.extent;
    if (
      (a || g || !c.isGlobal() || ((d = !1), (g = u)), void 0 !== t.resolutions)
    ) {
      const o = t.resolutions;
      (i = o[r]),
        (n = void 0 !== o[s] ? o[s] : o[o.length - 1]),
        (e = t.constrainResolution
          ? zs(o, l, !d && g, h)
          : qs(i, n, l, !d && g, h));
    } else {
      const a =
          (u
            ? Math.max(Fe(u), Re(u))
            : (360 * je.degrees) / c.getMetersPerUnit()) /
          Ns /
          Math.pow(2, 0),
        f = a / Math.pow(2, 28);
      (i = t.maxResolution),
        void 0 !== i ? (r = 0) : (i = a / Math.pow(o, r)),
        (n = t.minResolution),
        void 0 === n &&
          (n =
            void 0 !== t.maxZoom
              ? void 0 !== t.maxResolution
                ? i / Math.pow(o, s)
                : a / Math.pow(o, s)
              : f),
        (s = r + Math.floor(Math.log(i / n) / Math.log(o))),
        (n = i / Math.pow(o, s - r)),
        (e = t.constrainResolution
          ? Us(o, i, n, l, !d && g, h)
          : qs(i, n, l, !d && g, h));
    }
    return {
      constraint: e,
      maxResolution: i,
      minResolution: n,
      minZoom: r,
      zoomFactor: o,
    };
  }
  function $s(t) {
    if (void 0 === t.enableRotation || t.enableRotation) {
      const e = t.constrainRotation;
      return void 0 === e || !0 === e
        ? Ks()
        : !1 === e
        ? Xs
        : "number" == typeof e
        ? Zs(e)
        : Xs;
    }
    return Vs;
  }
  function Js(t) {
    return (
      !(
        t.sourceCenter &&
        t.targetCenter &&
        !Fi(t.sourceCenter, t.targetCenter)
      ) &&
      t.sourceResolution === t.targetResolution &&
      t.sourceRotation === t.targetRotation
    );
  }
  function to(t, e, i, n, r) {
    const s = Math.cos(-r);
    let o = Math.sin(-r),
      a = t[0] * s - t[1] * o,
      l = t[1] * s + t[0] * o;
    (a += (e[0] / 2 - i[0]) * n), (l += (i[1] - e[1] / 2) * n), (o = -o);
    return [a * s - l * o, l * s + a * o];
  }
  var eo = class extends U {
    constructor(t) {
      super(),
        this.on,
        this.once,
        this.un,
        (t = Object.assign({}, t)),
        (this.hints_ = [0, 0]),
        (this.animations_ = []),
        this.updateAnimationKey_,
        (this.projection_ = sn(t.projection, "EPSG:3857")),
        (this.viewportSize_ = [100, 100]),
        (this.targetCenter_ = null),
        this.targetResolution_,
        this.targetRotation_,
        (this.nextCenter_ = null),
        this.nextResolution_,
        this.nextRotation_,
        (this.cancelAnchor_ = void 0),
        t.projection && Hi(),
        t.center && (t.center = _n(t.center, this.projection_)),
        t.extent && (t.extent = xn(t.extent, this.projection_)),
        this.applyOptions_(t);
    }
    applyOptions_(t) {
      const e = Object.assign({}, t);
      for (const t in ks) delete e[t];
      this.setProperties(e, !0);
      const i = Qs(t);
      (this.maxResolution_ = i.maxResolution),
        (this.minResolution_ = i.minResolution),
        (this.zoomFactor_ = i.zoomFactor),
        (this.resolutions_ = t.resolutions),
        (this.padding_ = t.padding),
        (this.minZoom_ = i.minZoom);
      const n = Ys(t),
        r = i.constraint,
        s = $s(t);
      (this.constraints_ = { center: n, resolution: r, rotation: s }),
        this.setRotation(void 0 !== t.rotation ? t.rotation : 0),
        this.setCenterInternal(void 0 !== t.center ? t.center : null),
        void 0 !== t.resolution
          ? this.setResolution(t.resolution)
          : void 0 !== t.zoom && this.setZoom(t.zoom);
    }
    get padding() {
      return this.padding_;
    }
    set padding(t) {
      let e = this.padding_;
      this.padding_ = t;
      const i = this.getCenterInternal();
      if (i) {
        const n = t || [0, 0, 0, 0];
        e = e || [0, 0, 0, 0];
        const r = this.getResolution(),
          s = (r / 2) * (n[3] - e[3] + e[1] - n[1]),
          o = (r / 2) * (n[0] - e[0] + e[2] - n[2]);
        this.setCenterInternal([i[0] + s, i[1] - o]);
      }
    }
    getUpdatedOptions_(t) {
      const e = this.getProperties();
      return (
        void 0 !== e.resolution
          ? (e.resolution = this.getResolution())
          : (e.zoom = this.getZoom()),
        (e.center = this.getCenterInternal()),
        (e.rotation = this.getRotation()),
        Object.assign({}, e, t)
      );
    }
    animate(t) {
      this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
      const e = new Array(arguments.length);
      for (let t = 0; t < e.length; ++t) {
        let i = arguments[t];
        i.center &&
          ((i = Object.assign({}, i)),
          (i.center = _n(i.center, this.getProjection()))),
          i.anchor &&
            ((i = Object.assign({}, i)),
            (i.anchor = _n(i.anchor, this.getProjection()))),
          (e[t] = i);
      }
      this.animateInternal.apply(this, e);
    }
    animateInternal(t) {
      let e,
        i = arguments.length;
      i > 1 &&
        "function" == typeof arguments[i - 1] &&
        ((e = arguments[i - 1]), --i);
      let n = 0;
      for (; n < i && !this.isDef(); ++n) {
        const t = arguments[n];
        t.center && this.setCenterInternal(t.center),
          void 0 !== t.zoom
            ? this.setZoom(t.zoom)
            : t.resolution && this.setResolution(t.resolution),
          void 0 !== t.rotation && this.setRotation(t.rotation);
      }
      if (n === i) return void (e && Hs(e, !0));
      let r = Date.now(),
        s = this.targetCenter_.slice(),
        o = this.targetResolution_,
        a = this.targetRotation_;
      const l = [];
      for (; n < i; ++n) {
        const t = arguments[n],
          i = {
            start: r,
            complete: !1,
            anchor: t.anchor,
            duration: void 0 !== t.duration ? t.duration : 1e3,
            easing: t.easing || it,
            callback: e,
          };
        if (
          (t.center &&
            ((i.sourceCenter = s),
            (i.targetCenter = t.center.slice()),
            (s = i.targetCenter)),
          void 0 !== t.zoom
            ? ((i.sourceResolution = o),
              (i.targetResolution = this.getResolutionForZoom(t.zoom)),
              (o = i.targetResolution))
            : t.resolution &&
              ((i.sourceResolution = o),
              (i.targetResolution = t.resolution),
              (o = i.targetResolution)),
          void 0 !== t.rotation)
        ) {
          i.sourceRotation = a;
          const e = _i(t.rotation - a + Math.PI, 2 * Math.PI) - Math.PI;
          (i.targetRotation = a + e), (a = i.targetRotation);
        }
        Js(i) ? (i.complete = !0) : (r += i.duration), l.push(i);
      }
      this.animations_.push(l), this.setHint(Ms, 1), this.updateAnimations_();
    }
    getAnimating() {
      return this.hints_[Ms] > 0;
    }
    getInteracting() {
      return this.hints_[Os] > 0;
    }
    cancelAnimations() {
      let t;
      this.setHint(Ms, -this.hints_[Ms]);
      for (let e = 0, i = this.animations_.length; e < i; ++e) {
        const i = this.animations_[e];
        if ((i[0].callback && Hs(i[0].callback, !1), !t))
          for (let e = 0, n = i.length; e < n; ++e) {
            const n = i[e];
            if (!n.complete) {
              t = n.anchor;
              break;
            }
          }
      }
      (this.animations_.length = 0),
        (this.cancelAnchor_ = t),
        (this.nextCenter_ = null),
        (this.nextResolution_ = NaN),
        (this.nextRotation_ = NaN);
    }
    updateAnimations_() {
      if (
        (void 0 !== this.updateAnimationKey_ &&
          (cancelAnimationFrame(this.updateAnimationKey_),
          (this.updateAnimationKey_ = void 0)),
        !this.getAnimating())
      )
        return;
      const t = Date.now();
      let e = !1;
      for (let i = this.animations_.length - 1; i >= 0; --i) {
        const n = this.animations_[i];
        let r = !0;
        for (let i = 0, s = n.length; i < s; ++i) {
          const s = n[i];
          if (s.complete) continue;
          const o = t - s.start;
          let a = s.duration > 0 ? o / s.duration : 1;
          a >= 1 ? ((s.complete = !0), (a = 1)) : (r = !1);
          const l = s.easing(a);
          if (s.sourceCenter) {
            const t = s.sourceCenter[0],
              e = s.sourceCenter[1],
              i = s.targetCenter[0],
              n = s.targetCenter[1];
            this.nextCenter_ = s.targetCenter;
            const r = t + l * (i - t),
              o = e + l * (n - e);
            this.targetCenter_ = [r, o];
          }
          if (s.sourceResolution && s.targetResolution) {
            const t =
              1 === l
                ? s.targetResolution
                : s.sourceResolution +
                  l * (s.targetResolution - s.sourceResolution);
            if (s.anchor) {
              const e = this.getViewportSize_(this.getRotation()),
                i = this.constraints_.resolution(t, 0, e, !0);
              this.targetCenter_ = this.calculateCenterZoom(i, s.anchor);
            }
            (this.nextResolution_ = s.targetResolution),
              (this.targetResolution_ = t),
              this.applyTargetState_(!0);
          }
          if (void 0 !== s.sourceRotation && void 0 !== s.targetRotation) {
            const t =
              1 === l
                ? _i(s.targetRotation + Math.PI, 2 * Math.PI) - Math.PI
                : s.sourceRotation + l * (s.targetRotation - s.sourceRotation);
            if (s.anchor) {
              const e = this.constraints_.rotation(t, !0);
              this.targetCenter_ = this.calculateCenterRotate(e, s.anchor);
            }
            (this.nextRotation_ = s.targetRotation), (this.targetRotation_ = t);
          }
          if ((this.applyTargetState_(!0), (e = !0), !s.complete)) break;
        }
        if (r) {
          (this.animations_[i] = null),
            this.setHint(Ms, -1),
            (this.nextCenter_ = null),
            (this.nextResolution_ = NaN),
            (this.nextRotation_ = NaN);
          const t = n[0].callback;
          t && Hs(t, !0);
        }
      }
      (this.animations_ = this.animations_.filter(Boolean)),
        e &&
          void 0 === this.updateAnimationKey_ &&
          (this.updateAnimationKey_ = requestAnimationFrame(
            this.updateAnimations_.bind(this)
          ));
    }
    calculateCenterRotate(t, e) {
      let i;
      const n = this.getCenterInternal();
      return (
        void 0 !== n &&
          ((i = [n[0] - e[0], n[1] - e[1]]),
          Ii(i, t - this.getRotation()),
          Ei(i, e)),
        i
      );
    }
    calculateCenterZoom(t, e) {
      let i;
      const n = this.getCenterInternal(),
        r = this.getResolution();
      if (void 0 !== n && void 0 !== r) {
        i = [e[0] - (t * (e[0] - n[0])) / r, e[1] - (t * (e[1] - n[1])) / r];
      }
      return i;
    }
    getViewportSize_(t) {
      const e = this.viewportSize_;
      if (t) {
        const i = e[0],
          n = e[1];
        return [
          Math.abs(i * Math.cos(t)) + Math.abs(n * Math.sin(t)),
          Math.abs(i * Math.sin(t)) + Math.abs(n * Math.cos(t)),
        ];
      }
      return e;
    }
    setViewportSize(t) {
      (this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100]),
        this.getAnimating() || this.resolveConstraints(0);
    }
    getCenter() {
      const t = this.getCenterInternal();
      return t ? mn(t, this.getProjection()) : t;
    }
    getCenterInternal() {
      return this.get(ks.CENTER);
    }
    getConstraints() {
      return this.constraints_;
    }
    getConstrainResolution() {
      return this.get("constrainResolution");
    }
    getHints(t) {
      return void 0 !== t
        ? ((t[0] = this.hints_[0]), (t[1] = this.hints_[1]), t)
        : this.hints_.slice();
    }
    calculateExtent(t) {
      return yn(this.calculateExtentInternal(t), this.getProjection());
    }
    calculateExtentInternal(t) {
      t = t || this.getViewportSizeMinusPadding_();
      const e = this.getCenterInternal();
      Ft(e, "The view center is not defined");
      const i = this.getResolution();
      Ft(void 0 !== i, "The view resolution is not defined");
      const n = this.getRotation();
      return (
        Ft(void 0 !== n, "The view rotation is not defined"), We(e, i, n, t)
      );
    }
    getMaxResolution() {
      return this.maxResolution_;
    }
    getMinResolution() {
      return this.minResolution_;
    }
    getMaxZoom() {
      return this.getZoomForResolution(this.minResolution_);
    }
    setMaxZoom(t) {
      this.applyOptions_(this.getUpdatedOptions_({ maxZoom: t }));
    }
    getMinZoom() {
      return this.getZoomForResolution(this.maxResolution_);
    }
    setMinZoom(t) {
      this.applyOptions_(this.getUpdatedOptions_({ minZoom: t }));
    }
    setConstrainResolution(t) {
      this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: t }));
    }
    getProjection() {
      return this.projection_;
    }
    getResolution() {
      return this.get(ks.RESOLUTION);
    }
    getResolutions() {
      return this.resolutions_;
    }
    getResolutionForExtent(t, e) {
      return this.getResolutionForExtentInternal(
        xn(t, this.getProjection()),
        e
      );
    }
    getResolutionForExtentInternal(t, e) {
      e = e || this.getViewportSizeMinusPadding_();
      const i = Fe(t) / e[0],
        n = Re(t) / e[1];
      return Math.max(i, n);
    }
    getResolutionForValueFunction(t) {
      t = t || 2;
      const e = this.getConstrainedResolution(this.maxResolution_),
        i = this.minResolution_,
        n = Math.log(e / i) / Math.log(t);
      return function (i) {
        return e / Math.pow(t, i * n);
      };
    }
    getRotation() {
      return this.get(ks.ROTATION);
    }
    getValueForResolutionFunction(t) {
      const e = Math.log(t || 2),
        i = this.getConstrainedResolution(this.maxResolution_),
        n = this.minResolution_,
        r = Math.log(i / n) / e;
      return function (t) {
        return Math.log(i / t) / e / r;
      };
    }
    getViewportSizeMinusPadding_(t) {
      let e = this.getViewportSize_(t);
      const i = this.padding_;
      return i && (e = [e[0] - i[1] - i[3], e[1] - i[0] - i[2]]), e;
    }
    getState() {
      const t = this.getProjection(),
        e = this.getResolution(),
        i = this.getRotation();
      let n = this.getCenterInternal();
      const r = this.padding_;
      if (r) {
        const t = this.getViewportSizeMinusPadding_();
        n = to(
          n,
          this.getViewportSize_(),
          [t[0] / 2 + r[3], t[1] / 2 + r[0]],
          e,
          i
        );
      }
      return {
        center: n.slice(0),
        projection: void 0 !== t ? t : null,
        resolution: e,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation: i,
        zoom: this.getZoom(),
      };
    }
    getViewStateAndExtent() {
      return { viewState: this.getState(), extent: this.calculateExtent() };
    }
    getZoom() {
      let t;
      const e = this.getResolution();
      return void 0 !== e && (t = this.getZoomForResolution(e)), t;
    }
    getZoomForResolution(t) {
      let e,
        i,
        n = this.minZoom_ || 0;
      if (this.resolutions_) {
        const r = a(this.resolutions_, t, 1);
        (n = r),
          (e = this.resolutions_[r]),
          (i =
            r == this.resolutions_.length - 1
              ? 2
              : e / this.resolutions_[r + 1]);
      } else (e = this.maxResolution_), (i = this.zoomFactor_);
      return n + Math.log(e / t) / Math.log(i);
    }
    getResolutionForZoom(t) {
      if (this.resolutions_) {
        if (this.resolutions_.length <= 1) return 0;
        const e = ui(Math.floor(t), 0, this.resolutions_.length - 2),
          i = this.resolutions_[e] / this.resolutions_[e + 1];
        return this.resolutions_[e] / Math.pow(i, ui(t - e, 0, 1));
      }
      return (
        this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_)
      );
    }
    fit(t, e) {
      let i;
      if (
        (Ft(
          Array.isArray(t) || "function" == typeof t.getSimplifiedGeometry,
          "Invalid extent or geometry provided as `geometry`"
        ),
        Array.isArray(t))
      ) {
        Ft(!Le(t), "Cannot fit empty extent provided as `geometry`");
        i = br(xn(t, this.getProjection()));
      } else if ("Circle" === t.getType()) {
        const e = xn(t.getExtent(), this.getProjection());
        (i = br(e)), i.rotate(this.getRotation(), Ce(e));
      } else {
        const e = pn();
        i = e ? t.clone().transform(e, this.getProjection()) : t;
      }
      this.fitInternal(i, e);
    }
    rotatedExtentForGeometry(t) {
      const e = this.getRotation(),
        i = Math.cos(e),
        n = Math.sin(-e),
        r = t.getFlatCoordinates(),
        s = t.getStride();
      let o = 1 / 0,
        a = 1 / 0,
        l = -1 / 0,
        h = -1 / 0;
      for (let t = 0, e = r.length; t < e; t += s) {
        const e = r[t] * i - r[t + 1] * n,
          s = r[t] * n + r[t + 1] * i;
        (o = Math.min(o, e)),
          (a = Math.min(a, s)),
          (l = Math.max(l, e)),
          (h = Math.max(h, s));
      }
      return [o, a, l, h];
    }
    fitInternal(t, e) {
      let i = (e = e || {}).size;
      i || (i = this.getViewportSizeMinusPadding_());
      const n = void 0 !== e.padding ? e.padding : [0, 0, 0, 0],
        r = void 0 !== e.nearest && e.nearest;
      let s;
      s =
        void 0 !== e.minResolution
          ? e.minResolution
          : void 0 !== e.maxZoom
          ? this.getResolutionForZoom(e.maxZoom)
          : 0;
      const o = this.rotatedExtentForGeometry(t);
      let a = this.getResolutionForExtentInternal(o, [
        i[0] - n[1] - n[3],
        i[1] - n[0] - n[2],
      ]);
      (a = isNaN(a) ? s : Math.max(a, s)),
        (a = this.getConstrainedResolution(a, r ? 0 : 1));
      const l = this.getRotation(),
        h = Math.sin(l),
        c = Math.cos(l),
        u = Ce(o);
      (u[0] += ((n[1] - n[3]) / 2) * a), (u[1] += ((n[0] - n[2]) / 2) * a);
      const d = u[0] * c - u[1] * h,
        g = u[1] * c + u[0] * h,
        p = this.getConstrainedCenter([d, g], a),
        m = e.callback ? e.callback : f;
      void 0 !== e.duration
        ? this.animateInternal(
            {
              resolution: a,
              center: p,
              duration: e.duration,
              easing: e.easing,
            },
            m
          )
        : ((this.targetResolution_ = a),
          (this.targetCenter_ = p),
          this.applyTargetState_(!1, !0),
          Hs(m, !0));
    }
    centerOn(t, e, i) {
      this.centerOnInternal(_n(t, this.getProjection()), e, i);
    }
    centerOnInternal(t, e, i) {
      this.setCenterInternal(
        to(t, e, i, this.getResolution(), this.getRotation())
      );
    }
    calculateCenterShift(t, e, i, n) {
      let r;
      const s = this.padding_;
      if (s && t) {
        const o = this.getViewportSizeMinusPadding_(-i),
          a = to(t, n, [o[0] / 2 + s[3], o[1] / 2 + s[0]], e, i);
        r = [t[0] - a[0], t[1] - a[1]];
      }
      return r;
    }
    isDef() {
      return !!this.getCenterInternal() && void 0 !== this.getResolution();
    }
    adjustCenter(t) {
      const e = mn(this.targetCenter_, this.getProjection());
      this.setCenter([e[0] + t[0], e[1] + t[1]]);
    }
    adjustCenterInternal(t) {
      const e = this.targetCenter_;
      this.setCenterInternal([e[0] + t[0], e[1] + t[1]]);
    }
    adjustResolution(t, e) {
      (e = e && _n(e, this.getProjection())),
        this.adjustResolutionInternal(t, e);
    }
    adjustResolutionInternal(t, e) {
      const i = this.getAnimating() || this.getInteracting(),
        n = this.getViewportSize_(this.getRotation()),
        r = this.constraints_.resolution(this.targetResolution_ * t, 0, n, i);
      e && (this.targetCenter_ = this.calculateCenterZoom(r, e)),
        (this.targetResolution_ *= t),
        this.applyTargetState_();
    }
    adjustZoom(t, e) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -t), e);
    }
    adjustRotation(t, e) {
      e && (e = _n(e, this.getProjection())), this.adjustRotationInternal(t, e);
    }
    adjustRotationInternal(t, e) {
      const i = this.getAnimating() || this.getInteracting(),
        n = this.constraints_.rotation(this.targetRotation_ + t, i);
      e && (this.targetCenter_ = this.calculateCenterRotate(n, e)),
        (this.targetRotation_ += t),
        this.applyTargetState_();
    }
    setCenter(t) {
      this.setCenterInternal(t ? _n(t, this.getProjection()) : t);
    }
    setCenterInternal(t) {
      (this.targetCenter_ = t), this.applyTargetState_();
    }
    setHint(t, e) {
      return (this.hints_[t] += e), this.changed(), this.hints_[t];
    }
    setResolution(t) {
      (this.targetResolution_ = t), this.applyTargetState_();
    }
    setRotation(t) {
      (this.targetRotation_ = t), this.applyTargetState_();
    }
    setZoom(t) {
      this.setResolution(this.getResolutionForZoom(t));
    }
    applyTargetState_(t, e) {
      const i = this.getAnimating() || this.getInteracting() || e,
        n = this.constraints_.rotation(this.targetRotation_, i),
        r = this.getViewportSize_(n),
        s = this.constraints_.resolution(this.targetResolution_, 0, r, i),
        o = this.constraints_.center(
          this.targetCenter_,
          s,
          r,
          i,
          this.calculateCenterShift(this.targetCenter_, s, n, r)
        );
      this.get(ks.ROTATION) !== n && this.set(ks.ROTATION, n),
        this.get(ks.RESOLUTION) !== s &&
          (this.set(ks.RESOLUTION, s), this.set("zoom", this.getZoom(), !0)),
        (o && this.get(ks.CENTER) && Fi(this.get(ks.CENTER), o)) ||
          this.set(ks.CENTER, o),
        this.getAnimating() && !t && this.cancelAnimations(),
        (this.cancelAnchor_ = void 0);
    }
    resolveConstraints(t, e, i) {
      t = void 0 !== t ? t : 200;
      const n = e || 0,
        r = this.constraints_.rotation(this.targetRotation_),
        s = this.getViewportSize_(r),
        o = this.constraints_.resolution(this.targetResolution_, n, s),
        a = this.constraints_.center(
          this.targetCenter_,
          o,
          s,
          !1,
          this.calculateCenterShift(this.targetCenter_, o, r, s)
        );
      if (0 === t && !this.cancelAnchor_)
        return (
          (this.targetResolution_ = o),
          (this.targetRotation_ = r),
          (this.targetCenter_ = a),
          void this.applyTargetState_()
        );
      (i = i || (0 === t ? this.cancelAnchor_ : void 0)),
        (this.cancelAnchor_ = void 0),
        (this.getResolution() === o &&
          this.getRotation() === r &&
          this.getCenterInternal() &&
          Fi(this.getCenterInternal(), a)) ||
          (this.getAnimating() && this.cancelAnimations(),
          this.animateInternal({
            rotation: r,
            center: a,
            resolution: o,
            duration: t,
            easing: et,
            anchor: i,
          }));
    }
    beginInteraction() {
      this.resolveConstraints(0), this.setHint(Os, 1);
    }
    endInteraction(t, e, i) {
      (i = i && _n(i, this.getProjection())),
        this.endInteractionInternal(t, e, i);
    }
    endInteractionInternal(t, e, i) {
      this.getInteracting() &&
        (this.setHint(Os, -1), this.resolveConstraints(t, e, i));
    }
    getConstrainedCenter(t, e) {
      const i = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(t, e || this.getResolution(), i);
    }
    getConstrainedZoom(t, e) {
      const i = this.getResolutionForZoom(t);
      return this.getZoomForResolution(this.getConstrainedResolution(i, e));
    }
    getConstrainedResolution(t, e) {
      e = e || 0;
      const i = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(t, e, i);
    }
  };
  function io(t, e) {
    if (!t || !t.visible) return !1;
    const i = e.resolution;
    if (i < t.minResolution || i >= t.maxResolution) return !1;
    const n = e.zoom;
    return n > t.minZoom && n <= t.maxZoom;
  }
  var no = class extends Ts {
    constructor(t) {
      const e = Object.assign({}, t);
      delete e.source,
        super(e),
        this.on,
        this.once,
        this.un,
        (this.mapPrecomposeKey_ = null),
        (this.mapRenderKey_ = null),
        (this.sourceChangeKey_ = null),
        (this.renderer_ = null),
        (this.sourceReady_ = !1),
        (this.rendered = !1),
        t.render && (this.render = t.render),
        t.map && this.setMap(t.map),
        this.addChangeListener(Es, this.handleSourcePropertyChange_);
      const i = t.source ? t.source : null;
      this.setSource(i);
    }
    getLayersArray(t) {
      return (t = t || []).push(this), t;
    }
    getLayerStatesArray(t) {
      return (t = t || []).push(this.getLayerState()), t;
    }
    getSource() {
      return this.get(Es) || null;
    }
    getRenderSource() {
      return this.getSource();
    }
    getSourceState() {
      const t = this.getSource();
      return t ? t.getState() : "undefined";
    }
    handleSourceChange_() {
      this.changed(),
        this.sourceReady_ ||
          "ready" !== this.getSource().getState() ||
          ((this.sourceReady_ = !0), this.dispatchEvent("sourceready"));
    }
    handleSourcePropertyChange_() {
      this.sourceChangeKey_ &&
        (k(this.sourceChangeKey_), (this.sourceChangeKey_ = null)),
        (this.sourceReady_ = !1);
      const t = this.getSource();
      t &&
        ((this.sourceChangeKey_ = M(t, v, this.handleSourceChange_, this)),
        "ready" === t.getState() &&
          ((this.sourceReady_ = !0),
          setTimeout(() => {
            this.dispatchEvent("sourceready");
          }, 0))),
        this.changed();
    }
    getFeatures(t) {
      return this.renderer_
        ? this.renderer_.getFeatures(t)
        : Promise.resolve([]);
    }
    getData(t) {
      return this.renderer_ && this.rendered ? this.renderer_.getData(t) : null;
    }
    isVisible(t) {
      let e;
      const i = this.getMapInternal();
      let n;
      !t && i && (t = i.getView()),
        (e =
          t instanceof eo
            ? { viewState: t.getState(), extent: t.calculateExtent() }
            : t),
        !e.layerStatesArray &&
          i &&
          (e.layerStatesArray = i.getLayerGroup().getLayerStatesArray()),
        (n = e.layerStatesArray
          ? e.layerStatesArray.find((t) => t.layer === this)
          : this.getLayerState());
      const r = this.getExtent();
      return io(n, e.viewState) && (!r || Ie(r, e.extent));
    }
    getAttributions(t) {
      if (!this.isVisible(t)) return [];
      let e;
      const i = this.getSource();
      if ((i && (e = i.getAttributions()), !e)) return [];
      let n = e(t instanceof eo ? t.getViewStateAndExtent() : t);
      return Array.isArray(n) || (n = [n]), n;
    }
    render(t, e) {
      const i = this.getRenderer();
      return i.prepareFrame(t)
        ? ((this.rendered = !0), i.renderFrame(t, e))
        : null;
    }
    unrender() {
      this.rendered = !1;
    }
    setMapInternal(t) {
      t || this.unrender(), this.set(Rs, t);
    }
    getMapInternal() {
      return this.get(Rs);
    }
    setMap(t) {
      this.mapPrecomposeKey_ &&
        (k(this.mapPrecomposeKey_), (this.mapPrecomposeKey_ = null)),
        t || this.changed(),
        this.mapRenderKey_ &&
          (k(this.mapRenderKey_), (this.mapRenderKey_ = null)),
        t &&
          ((this.mapPrecomposeKey_ = M(
            t,
            Fs,
            function (t) {
              const e = t.frameState.layerStatesArray,
                i = this.getLayerState(!1);
              Ft(
                !e.some(function (t) {
                  return t.layer === i.layer;
                }),
                "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
              ),
                e.push(i);
            },
            this
          )),
          (this.mapRenderKey_ = M(this, v, t.render, t)),
          this.changed());
    }
    setSource(t) {
      this.set(Es, t);
    }
    getRenderer() {
      return (
        this.renderer_ || (this.renderer_ = this.createRenderer()),
        this.renderer_
      );
    }
    hasRenderer() {
      return !!this.renderer_;
    }
    createRenderer() {
      return null;
    }
    disposeInternal() {
      this.renderer_ && (this.renderer_.dispose(), delete this.renderer_),
        this.setSource(null),
        super.disposeInternal();
    }
  };
  function ro(t, e) {
    ms.expire();
  }
  var so = class extends n {
    constructor(t) {
      super(), (this.map_ = t);
    }
    dispatchRenderEvent(t, e) {
      G();
    }
    calculateMatrices2D(t) {
      const e = t.viewState,
        i = t.coordinateToPixelTransform,
        n = t.pixelToCoordinateTransform;
      Vt(
        i,
        t.size[0] / 2,
        t.size[1] / 2,
        1 / e.resolution,
        -1 / e.resolution,
        -e.rotation,
        -e.center[0],
        -e.center[1]
      ),
        Xt(n, i);
    }
    forEachFeatureAtCoordinate(t, e, i, n, r, s, o, a) {
      let l;
      const h = e.viewState;
      function c(t, e, i, n) {
        return r.call(s, e, t ? i : null, n);
      }
      const u = h.projection,
        d = Ni(t.slice(), u),
        g = [[0, 0]];
      if (u.canWrapX() && n) {
        const t = Fe(u.getExtent());
        g.push([-t, 0], [t, 0]);
      }
      const f = e.layerStatesArray,
        p = f.length,
        m = [],
        _ = [];
      for (let n = 0; n < g.length; n++)
        for (let r = p - 1; r >= 0; --r) {
          const s = f[r],
            u = s.layer;
          if (u.hasRenderer() && io(s, h) && o.call(a, u)) {
            const r = u.getRenderer(),
              o = u.getSource();
            if (r && o) {
              const a = o.getWrapX() ? d : t,
                h = c.bind(null, s.managed);
              (_[0] = a[0] + g[n][0]),
                (_[1] = a[1] + g[n][1]),
                (l = r.forEachFeatureAtCoordinate(_, e, i, h, m));
            }
            if (l) return l;
          }
        }
      if (0 === m.length) return;
      const y = 1 / m.length;
      return (
        m.forEach((t, e) => (t.distanceSq += e * y)),
        m.sort((t, e) => t.distanceSq - e.distanceSq),
        m.some((t) => (l = t.callback(t.feature, t.layer, t.geometry))),
        l
      );
    }
    hasFeatureAtCoordinate(t, e, i, n, r, s) {
      return (
        void 0 !== this.forEachFeatureAtCoordinate(t, e, i, n, d, this, r, s)
      );
    }
    getMap() {
      return this.map_;
    }
    renderFrame(t) {
      G();
    }
    flushDeclutterItems(t) {}
    scheduleExpireIconCache(t) {
      ms.canExpireCache() && t.postRenderFunctions.push(ro);
    }
  };
  var oo = class extends e {
    constructor(t, e, i, n) {
      super(t),
        (this.inversePixelTransform = e),
        (this.frameState = i),
        (this.context = n);
    }
  };
  const ao = "ol-hidden",
    lo = "ol-selectable",
    ho = "ol-unselectable",
    co = "ol-unsupported",
    uo = "ol-control",
    go = "ol-collapsed",
    fo = new RegExp(
      [
        "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
        "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
        "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
        "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
        "?\\s*([-,\\\"\\'\\sa-z]+?)\\s*$",
      ].join(""),
      "i"
    ),
    po = ["style", "variant", "weight", "size", "lineHeight", "family"],
    mo = function (t) {
      const e = t.match(fo);
      if (!e) return null;
      const i = {
        lineHeight: "normal",
        size: "1.2em",
        style: "normal",
        weight: "normal",
        variant: "normal",
      };
      for (let t = 0, n = po.length; t < n; ++t) {
        const n = e[t + 1];
        void 0 !== n && (i[po[t]] = n);
      }
      return (i.families = i.family.split(/,\s?/)), i;
    },
    _o = "10px sans-serif",
    yo = "#000",
    xo = "round",
    vo = [],
    So = "round",
    Co = 10,
    wo = "#000",
    Wo = "center",
    Eo = "middle",
    Ro = [0, 0, 0, 0],
    To = new U();
  let Po,
    bo = null;
  const Fo = {},
    Io = (function () {
      const t = "32px ",
        e = ["monospace", "serif"],
        i = e.length,
        n = "wmytzilWMYTZIL@#/&?$%10";
      let r, s;
      function o(r, o, a) {
        let l = !0;
        for (let h = 0; h < i; ++h) {
          const i = e[h];
          if (((s = Oo(r + " " + o + " " + t + i, n)), a != i)) {
            const e = Oo(r + " " + o + " " + t + a + "," + i, n);
            l = l && e != s;
          }
        }
        return !!l;
      }
      function a() {
        let t = !0;
        const e = To.getKeys();
        for (let i = 0, n = e.length; i < n; ++i) {
          const n = e[i];
          To.get(n) < 100 &&
            (o.apply(this, n.split("\n"))
              ? (_(Fo), (bo = null), (Po = void 0), To.set(n, 100))
              : (To.set(n, To.get(n) + 1, !0), (t = !1)));
        }
        t && (clearInterval(r), (r = void 0));
      }
      return function (t) {
        const e = mo(t);
        if (!e) return;
        const i = e.families;
        for (let t = 0, n = i.length; t < n; ++t) {
          const n = i[t],
            s = e.style + "\n" + e.weight + "\n" + n;
          void 0 === To.get(s) &&
            (To.set(s, 100, !0),
            o(e.style, e.weight, n) ||
              (To.set(s, 0, !0), void 0 === r && (r = setInterval(a, 32))));
        }
      };
    })(),
    Lo = (function () {
      let t;
      return function (e) {
        let i = Fo[e];
        if (null == i) {
          if (dt) {
            const t = mo(e),
              n = Mo(e, "Žg");
            i =
              (isNaN(Number(t.lineHeight)) ? 1.2 : Number(t.lineHeight)) *
              (n.actualBoundingBoxAscent + n.actualBoundingBoxDescent);
          } else
            t ||
              ((t = document.createElement("div")),
              (t.innerHTML = "M"),
              (t.style.minHeight = "0"),
              (t.style.maxHeight = "none"),
              (t.style.height = "auto"),
              (t.style.padding = "0"),
              (t.style.border = "none"),
              (t.style.position = "absolute"),
              (t.style.display = "block"),
              (t.style.left = "-99999px")),
              (t.style.font = e),
              document.body.appendChild(t),
              (i = t.offsetHeight),
              document.body.removeChild(t);
          Fo[e] = i;
        }
        return i;
      };
    })();
  function Mo(t, e) {
    return (
      bo || (bo = mt(1, 1)),
      t != Po && ((bo.font = t), (Po = bo.font)),
      bo.measureText(e)
    );
  }
  function Oo(t, e) {
    return Mo(t, e).width;
  }
  function ko(t, e, i) {
    if (e in i) return i[e];
    const n = e.split("\n").reduce((e, i) => Math.max(e, Oo(t, i)), 0);
    return (i[e] = n), n;
  }
  function Ao(t, e) {
    const i = [],
      n = [],
      r = [];
    let s = 0,
      o = 0,
      a = 0,
      l = 0;
    for (let h = 0, c = e.length; h <= c; h += 2) {
      const u = e[h];
      if ("\n" === u || h === c) {
        (s = Math.max(s, o)), r.push(o), (o = 0), (a += l);
        continue;
      }
      const d = e[h + 1] || t.font,
        g = Oo(d, u);
      i.push(g), (o += g);
      const f = Lo(d);
      n.push(f), (l = Math.max(l, f));
    }
    return { width: s, height: a, widths: i, heights: n, lineWidths: r };
  }
  function No(t, e, i, n, r, s, o, a, l, h, c) {
    t.save(),
      1 !== i && (t.globalAlpha *= i),
      e && t.transform.apply(t, e),
      n.contextInstructions
        ? (t.translate(l, h),
          t.scale(c[0], c[1]),
          (function (t, e) {
            const i = t.contextInstructions;
            for (let t = 0, n = i.length; t < n; t += 2)
              Array.isArray(i[t + 1])
                ? e[i[t]].apply(e, i[t + 1])
                : (e[i[t]] = i[t + 1]);
          })(n, t))
        : c[0] < 0 || c[1] < 0
        ? (t.translate(l, h),
          t.scale(c[0], c[1]),
          t.drawImage(n, r, s, o, a, 0, 0, o, a))
        : t.drawImage(n, r, s, o, a, l, h, o * c[0], a * c[1]),
      t.restore();
  }
  var Do = class extends so {
    constructor(t) {
      super(t),
        (this.fontChangeListenerKey_ = M(To, i, t.redrawText.bind(t))),
        (this.element_ = document.createElement("div"));
      const e = this.element_.style;
      (e.position = "absolute"),
        (e.width = "100%"),
        (e.height = "100%"),
        (e.zIndex = "0"),
        (this.element_.className = ho + " ol-layers");
      const n = t.getViewport();
      n.insertBefore(this.element_, n.firstChild || null),
        (this.children_ = []),
        (this.renderedVisible_ = !0),
        (this.declutterLayers_ = []);
    }
    dispatchRenderEvent(t, e) {
      const i = this.getMap();
      if (i.hasListener(t)) {
        const n = new oo(t, void 0, e);
        i.dispatchEvent(n);
      }
    }
    disposeInternal() {
      k(this.fontChangeListenerKey_),
        this.element_.parentNode.removeChild(this.element_),
        super.disposeInternal();
    }
    renderFrame(t) {
      if (!t)
        return void (
          this.renderedVisible_ &&
          ((this.element_.style.display = "none"), (this.renderedVisible_ = !1))
        );
      this.calculateMatrices2D(t), this.dispatchRenderEvent(Fs, t);
      const e = t.layerStatesArray.sort(function (t, e) {
          return t.zIndex - e.zIndex;
        }),
        i = t.viewState;
      this.children_.length = 0;
      const n = this.declutterLayers_;
      n.length = 0;
      let r = null;
      for (let s = 0, o = e.length; s < o; ++s) {
        const o = e[s];
        t.layerIndex = s;
        const a = o.layer,
          l = a.getSourceState();
        if (!io(o, i) || ("ready" != l && "undefined" != l)) {
          a.unrender();
          continue;
        }
        const h = a.render(t, r);
        h &&
          (h !== r && (this.children_.push(h), (r = h)),
          "getDeclutter" in a && n.push(a));
      }
      this.flushDeclutterItems(t),
        wt(this.element_, this.children_),
        this.dispatchRenderEvent(Is, t),
        this.renderedVisible_ ||
          ((this.element_.style.display = ""), (this.renderedVisible_ = !0)),
        this.scheduleExpireIconCache(t);
    }
    flushDeclutterItems(t) {
      const e = this.declutterLayers_;
      for (let i = e.length - 1; i >= 0; --i) e[i].renderDeclutter(t);
      e.length = 0;
    }
  };
  class Go extends e {
    constructor(t, e) {
      super(t), (this.layer = e);
    }
  }
  const Bo = "layers";
  class jo extends Ts {
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.layers;
      let i = t.layers;
      super(e),
        this.on,
        this.once,
        this.un,
        (this.layersListenerKeys_ = []),
        (this.listenerKeys_ = {}),
        this.addChangeListener(Bo, this.handleLayersChanged_),
        i
          ? Array.isArray(i)
            ? (i = new K(i.slice(), { unique: !0 }))
            : Ft(
                "function" == typeof i.getArray,
                "Expected `layers` to be an array or a `Collection`"
              )
          : (i = new K(void 0, { unique: !0 })),
        this.setLayers(i);
    }
    handleLayerChange_() {
      this.changed();
    }
    handleLayersChanged_() {
      this.layersListenerKeys_.forEach(k),
        (this.layersListenerKeys_.length = 0);
      const t = this.getLayers();
      this.layersListenerKeys_.push(
        M(t, q, this.handleLayersAdd_, this),
        M(t, V, this.handleLayersRemove_, this)
      );
      for (const t in this.listenerKeys_) this.listenerKeys_[t].forEach(k);
      _(this.listenerKeys_);
      const e = t.getArray();
      for (let t = 0, i = e.length; t < i; t++) {
        const i = e[t];
        this.registerLayerListeners_(i),
          this.dispatchEvent(new Go("addlayer", i));
      }
      this.changed();
    }
    registerLayerListeners_(t) {
      const e = [
        M(t, i, this.handleLayerChange_, this),
        M(t, v, this.handleLayerChange_, this),
      ];
      t instanceof jo &&
        e.push(
          M(t, "addlayer", this.handleLayerGroupAdd_, this),
          M(t, "removelayer", this.handleLayerGroupRemove_, this)
        ),
        (this.listenerKeys_[j(t)] = e);
    }
    handleLayerGroupAdd_(t) {
      this.dispatchEvent(new Go("addlayer", t.layer));
    }
    handleLayerGroupRemove_(t) {
      this.dispatchEvent(new Go("removelayer", t.layer));
    }
    handleLayersAdd_(t) {
      const e = t.element;
      this.registerLayerListeners_(e),
        this.dispatchEvent(new Go("addlayer", e)),
        this.changed();
    }
    handleLayersRemove_(t) {
      const e = t.element,
        i = j(e);
      this.listenerKeys_[i].forEach(k),
        delete this.listenerKeys_[i],
        this.dispatchEvent(new Go("removelayer", e)),
        this.changed();
    }
    getLayers() {
      return this.get(Bo);
    }
    setLayers(t) {
      const e = this.getLayers();
      if (e) {
        const t = e.getArray();
        for (let e = 0, i = t.length; e < i; ++e)
          this.dispatchEvent(new Go("removelayer", t[e]));
      }
      this.set(Bo, t);
    }
    getLayersArray(t) {
      return (
        (t = void 0 !== t ? t : []),
        this.getLayers().forEach(function (e) {
          e.getLayersArray(t);
        }),
        t
      );
    }
    getLayerStatesArray(t) {
      const e = void 0 !== t ? t : [],
        i = e.length;
      this.getLayers().forEach(function (t) {
        t.getLayerStatesArray(e);
      });
      const n = this.getLayerState();
      let r = n.zIndex;
      t || void 0 !== n.zIndex || (r = 0);
      for (let t = i, s = e.length; t < s; t++) {
        const i = e[t];
        (i.opacity *= n.opacity),
          (i.visible = i.visible && n.visible),
          (i.maxResolution = Math.min(i.maxResolution, n.maxResolution)),
          (i.minResolution = Math.max(i.minResolution, n.minResolution)),
          (i.minZoom = Math.max(i.minZoom, n.minZoom)),
          (i.maxZoom = Math.min(i.maxZoom, n.maxZoom)),
          void 0 !== n.extent &&
            (void 0 !== i.extent
              ? (i.extent = Te(i.extent, n.extent))
              : (i.extent = n.extent)),
          void 0 === i.zIndex && (i.zIndex = r);
      }
      return e;
    }
    getSourceState() {
      return "ready";
    }
  }
  var zo = jo;
  var Uo = class extends e {
    constructor(t, e, i) {
      super(t), (this.map = e), (this.frameState = void 0 !== i ? i : null);
    }
  };
  var qo = class extends Uo {
      constructor(t, e, i, n, r, s) {
        super(t, e, r),
          (this.originalEvent = i),
          (this.pixel_ = null),
          (this.coordinate_ = null),
          (this.dragging = void 0 !== n && n),
          (this.activePointers = s);
      }
      get pixel() {
        return (
          this.pixel_ ||
            (this.pixel_ = this.map.getEventPixel(this.originalEvent)),
          this.pixel_
        );
      }
      set pixel(t) {
        this.pixel_ = t;
      }
      get coordinate() {
        return (
          this.coordinate_ ||
            (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)),
          this.coordinate_
        );
      }
      set coordinate(t) {
        this.coordinate_ = t;
      }
      preventDefault() {
        super.preventDefault(),
          "preventDefault" in this.originalEvent &&
            this.originalEvent.preventDefault();
      }
      stopPropagation() {
        super.stopPropagation(),
          "stopPropagation" in this.originalEvent &&
            this.originalEvent.stopPropagation();
      }
    },
    Vo = {
      SINGLECLICK: "singleclick",
      CLICK: w,
      DBLCLICK: W,
      POINTERDRAG: "pointerdrag",
      POINTERMOVE: "pointermove",
      POINTERDOWN: "pointerdown",
      POINTERUP: "pointerup",
      POINTEROVER: "pointerover",
      POINTEROUT: "pointerout",
      POINTERENTER: "pointerenter",
      POINTERLEAVE: "pointerleave",
      POINTERCANCEL: "pointercancel",
    },
    Xo = "pointermove",
    Zo = "pointerdown",
    Ko = "pointerup",
    Ho = "pointerout";
  var Yo = class extends x {
      constructor(t, e) {
        super(t),
          (this.map_ = t),
          this.clickTimeoutId_,
          (this.emulateClicks_ = !1),
          (this.dragging_ = !1),
          (this.dragListenerKeys_ = []),
          (this.moveTolerance_ = void 0 === e ? 1 : e),
          (this.down_ = null);
        const i = this.map_.getViewport();
        (this.activePointers_ = []),
          (this.trackedTouches_ = {}),
          (this.element_ = i),
          (this.pointerdownListenerKey_ = M(
            i,
            Zo,
            this.handlePointerDown_,
            this
          )),
          this.originalPointerMoveEvent_,
          (this.relayedListenerKey_ = M(i, Xo, this.relayMoveEvent_, this)),
          (this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this)),
          this.element_.addEventListener(
            I,
            this.boundHandleTouchMove_,
            !!pt && { passive: !1 }
          );
      }
      emulateClick_(t) {
        let e = new qo(Vo.CLICK, this.map_, t);
        this.dispatchEvent(e),
          void 0 !== this.clickTimeoutId_
            ? (clearTimeout(this.clickTimeoutId_),
              (this.clickTimeoutId_ = void 0),
              (e = new qo(Vo.DBLCLICK, this.map_, t)),
              this.dispatchEvent(e))
            : (this.clickTimeoutId_ = setTimeout(() => {
                this.clickTimeoutId_ = void 0;
                const e = new qo(Vo.SINGLECLICK, this.map_, t);
                this.dispatchEvent(e);
              }, 250));
      }
      updateActivePointers_(t) {
        const e = t,
          i = e.pointerId;
        if (e.type == Vo.POINTERUP || e.type == Vo.POINTERCANCEL) {
          delete this.trackedTouches_[i];
          for (const t in this.trackedTouches_)
            if (this.trackedTouches_[t].target !== e.target) {
              delete this.trackedTouches_[t];
              break;
            }
        } else
          (e.type != Vo.POINTERDOWN && e.type != Vo.POINTERMOVE) ||
            (this.trackedTouches_[i] = e);
        this.activePointers_ = Object.values(this.trackedTouches_);
      }
      handlePointerUp_(t) {
        this.updateActivePointers_(t);
        const e = new qo(
          Vo.POINTERUP,
          this.map_,
          t,
          void 0,
          void 0,
          this.activePointers_
        );
        this.dispatchEvent(e),
          this.emulateClicks_ &&
            !e.defaultPrevented &&
            !this.dragging_ &&
            this.isMouseActionButton_(t) &&
            this.emulateClick_(this.down_),
          0 === this.activePointers_.length &&
            (this.dragListenerKeys_.forEach(k),
            (this.dragListenerKeys_.length = 0),
            (this.dragging_ = !1),
            (this.down_ = null));
      }
      isMouseActionButton_(t) {
        return 0 === t.button;
      }
      handlePointerDown_(t) {
        (this.emulateClicks_ = 0 === this.activePointers_.length),
          this.updateActivePointers_(t);
        const e = new qo(
          Vo.POINTERDOWN,
          this.map_,
          t,
          void 0,
          void 0,
          this.activePointers_
        );
        if (
          (this.dispatchEvent(e),
          (this.down_ = new PointerEvent(t.type, t)),
          Object.defineProperty(this.down_, "target", {
            writable: !1,
            value: t.target,
          }),
          0 === this.dragListenerKeys_.length)
        ) {
          const t = this.map_.getOwnerDocument();
          this.dragListenerKeys_.push(
            M(t, Vo.POINTERMOVE, this.handlePointerMove_, this),
            M(t, Vo.POINTERUP, this.handlePointerUp_, this),
            M(this.element_, Vo.POINTERCANCEL, this.handlePointerUp_, this)
          ),
            this.element_.getRootNode &&
              this.element_.getRootNode() !== t &&
              this.dragListenerKeys_.push(
                M(
                  this.element_.getRootNode(),
                  Vo.POINTERUP,
                  this.handlePointerUp_,
                  this
                )
              );
        }
      }
      handlePointerMove_(t) {
        if (this.isMoving_(t)) {
          this.updateActivePointers_(t), (this.dragging_ = !0);
          const e = new qo(
            Vo.POINTERDRAG,
            this.map_,
            t,
            this.dragging_,
            void 0,
            this.activePointers_
          );
          this.dispatchEvent(e);
        }
      }
      relayMoveEvent_(t) {
        this.originalPointerMoveEvent_ = t;
        const e = !(!this.down_ || !this.isMoving_(t));
        this.dispatchEvent(new qo(Vo.POINTERMOVE, this.map_, t, e));
      }
      handleTouchMove_(t) {
        const e = this.originalPointerMoveEvent_;
        (e && !e.defaultPrevented) ||
          ("boolean" == typeof t.cancelable && !0 !== t.cancelable) ||
          t.preventDefault();
      }
      isMoving_(t) {
        return (
          this.dragging_ ||
          Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ ||
          Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_
        );
      }
      disposeInternal() {
        this.relayedListenerKey_ &&
          (k(this.relayedListenerKey_), (this.relayedListenerKey_ = null)),
          this.element_.removeEventListener(I, this.boundHandleTouchMove_),
          this.pointerdownListenerKey_ &&
            (k(this.pointerdownListenerKey_),
            (this.pointerdownListenerKey_ = null)),
          this.dragListenerKeys_.forEach(k),
          (this.dragListenerKeys_.length = 0),
          (this.element_ = null),
          super.disposeInternal();
      }
    },
    Qo = "postrender",
    $o = "movestart",
    Jo = "moveend",
    ta = "loadstart",
    ea = "loadend",
    ia = "layergroup",
    na = "size",
    ra = "target",
    sa = "view";
  const oa = 1 / 0;
  var aa = class {
    constructor(t, e) {
      (this.priorityFunction_ = t),
        (this.keyFunction_ = e),
        (this.elements_ = []),
        (this.priorities_ = []),
        (this.queuedElements_ = {});
    }
    clear() {
      (this.elements_.length = 0),
        (this.priorities_.length = 0),
        _(this.queuedElements_);
    }
    dequeue() {
      const t = this.elements_,
        e = this.priorities_,
        i = t[0];
      1 == t.length
        ? ((t.length = 0), (e.length = 0))
        : ((t[0] = t.pop()), (e[0] = e.pop()), this.siftUp_(0));
      const n = this.keyFunction_(i);
      return delete this.queuedElements_[n], i;
    }
    enqueue(t) {
      Ft(
        !(this.keyFunction_(t) in this.queuedElements_),
        "Tried to enqueue an `element` that was already added to the queue"
      );
      const e = this.priorityFunction_(t);
      return (
        e != oa &&
        (this.elements_.push(t),
        this.priorities_.push(e),
        (this.queuedElements_[this.keyFunction_(t)] = !0),
        this.siftDown_(0, this.elements_.length - 1),
        !0)
      );
    }
    getCount() {
      return this.elements_.length;
    }
    getLeftChildIndex_(t) {
      return 2 * t + 1;
    }
    getRightChildIndex_(t) {
      return 2 * t + 2;
    }
    getParentIndex_(t) {
      return (t - 1) >> 1;
    }
    heapify_() {
      let t;
      for (t = (this.elements_.length >> 1) - 1; t >= 0; t--) this.siftUp_(t);
    }
    isEmpty() {
      return 0 === this.elements_.length;
    }
    isKeyQueued(t) {
      return t in this.queuedElements_;
    }
    isQueued(t) {
      return this.isKeyQueued(this.keyFunction_(t));
    }
    siftUp_(t) {
      const e = this.elements_,
        i = this.priorities_,
        n = e.length,
        r = e[t],
        s = i[t],
        o = t;
      for (; t < n >> 1; ) {
        const r = this.getLeftChildIndex_(t),
          s = this.getRightChildIndex_(t),
          o = s < n && i[s] < i[r] ? s : r;
        (e[t] = e[o]), (i[t] = i[o]), (t = o);
      }
      (e[t] = r), (i[t] = s), this.siftDown_(o, t);
    }
    siftDown_(t, e) {
      const i = this.elements_,
        n = this.priorities_,
        r = i[e],
        s = n[e];
      for (; e > t; ) {
        const t = this.getParentIndex_(e);
        if (!(n[t] > s)) break;
        (i[e] = i[t]), (n[e] = n[t]), (e = t);
      }
      (i[e] = r), (n[e] = s);
    }
    reprioritize() {
      const t = this.priorityFunction_,
        e = this.elements_,
        i = this.priorities_;
      let n = 0;
      const r = e.length;
      let s, o, a;
      for (o = 0; o < r; ++o)
        (s = e[o]),
          (a = t(s)),
          a == oa
            ? delete this.queuedElements_[this.keyFunction_(s)]
            : ((i[n] = a), (e[n++] = s));
      (e.length = n), (i.length = n), this.heapify_();
    }
  };
  var la = class extends aa {
    constructor(t, e) {
      super(
        function (e) {
          return t.apply(null, e);
        },
        function (t) {
          return t[0].getKey();
        }
      ),
        (this.boundHandleTileChange_ = this.handleTileChange.bind(this)),
        (this.tileChangeCallback_ = e),
        (this.tilesLoading_ = 0),
        (this.tilesLoadingKeys_ = {});
    }
    enqueue(t) {
      const e = super.enqueue(t);
      if (e) {
        t[0].addEventListener(v, this.boundHandleTileChange_);
      }
      return e;
    }
    getTilesLoading() {
      return this.tilesLoading_;
    }
    handleTileChange(t) {
      const e = t.target,
        i = e.getState();
      if (i === Q || i === $ || i === J) {
        i !== $ && e.removeEventListener(v, this.boundHandleTileChange_);
        const t = e.getKey();
        t in this.tilesLoadingKeys_ &&
          (delete this.tilesLoadingKeys_[t], --this.tilesLoading_),
          this.tileChangeCallback_();
      }
    }
    loadMoreTiles(t, e) {
      let i,
        n,
        r,
        s = 0;
      for (; this.tilesLoading_ < t && s < e && this.getCount() > 0; )
        (n = this.dequeue()[0]),
          (r = n.getKey()),
          (i = n.getState()),
          i !== H ||
            r in this.tilesLoadingKeys_ ||
            ((this.tilesLoadingKeys_[r] = !0),
            ++this.tilesLoading_,
            ++s,
            n.load());
    }
  };
  function ha(t, e, i, n, r) {
    if (!t || !(i in t.wantedTiles)) return oa;
    if (!t.wantedTiles[i][e.getKey()]) return oa;
    const s = t.viewState.center,
      o = n[0] - s[0],
      a = n[1] - s[1];
    return 65536 * Math.log(r) + Math.sqrt(o * o + a * a) / r;
  }
  var ca = class extends U {
    constructor(t) {
      super();
      const e = t.element;
      !e ||
        t.target ||
        e.style.pointerEvents ||
        (e.style.pointerEvents = "auto"),
        (this.element = e || null),
        (this.target_ = null),
        (this.map_ = null),
        (this.listenerKeys = []),
        t.render && (this.render = t.render),
        t.target && this.setTarget(t.target);
    }
    disposeInternal() {
      St(this.element), super.disposeInternal();
    }
    getMap() {
      return this.map_;
    }
    setMap(t) {
      this.map_ && St(this.element);
      for (let t = 0, e = this.listenerKeys.length; t < e; ++t)
        k(this.listenerKeys[t]);
      if (((this.listenerKeys.length = 0), (this.map_ = t), t)) {
        (this.target_
          ? this.target_
          : t.getOverlayContainerStopEvent()
        ).appendChild(this.element),
          this.render !== f &&
            this.listenerKeys.push(M(t, Qo, this.render, this)),
          t.render();
      }
    }
    render(t) {}
    setTarget(t) {
      this.target_ = "string" == typeof t ? document.getElementById(t) : t;
    }
  };
  var ua = class extends ca {
    constructor(t) {
      (t = t || {}),
        super({
          element: document.createElement("div"),
          render: t.render,
          target: t.target,
        }),
        (this.ulElement_ = document.createElement("ul")),
        (this.collapsed_ = void 0 === t.collapsed || t.collapsed),
        (this.userCollapsed_ = this.collapsed_),
        (this.overrideCollapsible_ = void 0 !== t.collapsible),
        (this.collapsible_ = void 0 === t.collapsible || t.collapsible),
        this.collapsible_ || (this.collapsed_ = !1);
      const e = void 0 !== t.className ? t.className : "ol-attribution",
        i = void 0 !== t.tipLabel ? t.tipLabel : "Attributions",
        n = void 0 !== t.expandClassName ? t.expandClassName : e + "-expand",
        r = void 0 !== t.collapseLabel ? t.collapseLabel : "›",
        s =
          void 0 !== t.collapseClassName
            ? t.collapseClassName
            : e + "-collapse";
      "string" == typeof r
        ? ((this.collapseLabel_ = document.createElement("span")),
          (this.collapseLabel_.textContent = r),
          (this.collapseLabel_.className = s))
        : (this.collapseLabel_ = r);
      const o = void 0 !== t.label ? t.label : "i";
      "string" == typeof o
        ? ((this.label_ = document.createElement("span")),
          (this.label_.textContent = o),
          (this.label_.className = n))
        : (this.label_ = o);
      const a =
        this.collapsible_ && !this.collapsed_
          ? this.collapseLabel_
          : this.label_;
      (this.toggleButton_ = document.createElement("button")),
        this.toggleButton_.setAttribute("type", "button"),
        this.toggleButton_.setAttribute(
          "aria-expanded",
          String(!this.collapsed_)
        ),
        (this.toggleButton_.title = i),
        this.toggleButton_.appendChild(a),
        this.toggleButton_.addEventListener(
          w,
          this.handleClick_.bind(this),
          !1
        );
      const l =
          e +
          " " +
          ho +
          " " +
          uo +
          (this.collapsed_ && this.collapsible_ ? " " + go : "") +
          (this.collapsible_ ? "" : " ol-uncollapsible"),
        h = this.element;
      (h.className = l),
        h.appendChild(this.toggleButton_),
        h.appendChild(this.ulElement_),
        (this.renderedAttributions_ = []),
        (this.renderedVisible_ = !0);
    }
    collectSourceAttributions_(t) {
      const e = Array.from(
          new Set(
            this.getMap()
              .getAllLayers()
              .flatMap((e) => e.getAttributions(t))
          )
        ),
        i = !this.getMap()
          .getAllLayers()
          .some(
            (t) =>
              t.getSource() && !1 === t.getSource().getAttributionsCollapsible()
          );
      return this.overrideCollapsible_ || this.setCollapsible(i), e;
    }
    updateElement_(t) {
      if (!t)
        return void (
          this.renderedVisible_ &&
          ((this.element.style.display = "none"), (this.renderedVisible_ = !1))
        );
      const e = this.collectSourceAttributions_(t),
        i = e.length > 0;
      if (
        (this.renderedVisible_ != i &&
          ((this.element.style.display = i ? "" : "none"),
          (this.renderedVisible_ = i)),
        !c(e, this.renderedAttributions_))
      ) {
        Ct(this.ulElement_);
        for (let t = 0, i = e.length; t < i; ++t) {
          const i = document.createElement("li");
          (i.innerHTML = e[t]), this.ulElement_.appendChild(i);
        }
        this.renderedAttributions_ = e;
      }
    }
    handleClick_(t) {
      t.preventDefault(),
        this.handleToggle_(),
        (this.userCollapsed_ = this.collapsed_);
    }
    handleToggle_() {
      this.element.classList.toggle(go),
        this.collapsed_
          ? vt(this.collapseLabel_, this.label_)
          : vt(this.label_, this.collapseLabel_),
        (this.collapsed_ = !this.collapsed_),
        this.toggleButton_.setAttribute(
          "aria-expanded",
          String(!this.collapsed_)
        );
    }
    getCollapsible() {
      return this.collapsible_;
    }
    setCollapsible(t) {
      this.collapsible_ !== t &&
        ((this.collapsible_ = t),
        this.element.classList.toggle("ol-uncollapsible"),
        this.userCollapsed_ && this.handleToggle_());
    }
    setCollapsed(t) {
      (this.userCollapsed_ = t),
        this.collapsible_ && this.collapsed_ !== t && this.handleToggle_();
    }
    getCollapsed() {
      return this.collapsed_;
    }
    render(t) {
      this.updateElement_(t.frameState);
    }
  };
  var da = class extends ca {
    constructor(t) {
      (t = t || {}),
        super({
          element: document.createElement("div"),
          render: t.render,
          target: t.target,
        });
      const e = void 0 !== t.className ? t.className : "ol-rotate",
        i = void 0 !== t.label ? t.label : "⇧",
        n = void 0 !== t.compassClassName ? t.compassClassName : "ol-compass";
      (this.label_ = null),
        "string" == typeof i
          ? ((this.label_ = document.createElement("span")),
            (this.label_.className = n),
            (this.label_.textContent = i))
          : ((this.label_ = i), this.label_.classList.add(n));
      const r = t.tipLabel ? t.tipLabel : "Reset rotation",
        s = document.createElement("button");
      (s.className = e + "-reset"),
        s.setAttribute("type", "button"),
        (s.title = r),
        s.appendChild(this.label_),
        s.addEventListener(w, this.handleClick_.bind(this), !1);
      const o = e + " " + ho + " " + uo,
        a = this.element;
      (a.className = o),
        a.appendChild(s),
        (this.callResetNorth_ = t.resetNorth ? t.resetNorth : void 0),
        (this.duration_ = void 0 !== t.duration ? t.duration : 250),
        (this.autoHide_ = void 0 === t.autoHide || t.autoHide),
        (this.rotation_ = void 0),
        this.autoHide_ && this.element.classList.add(ao);
    }
    handleClick_(t) {
      t.preventDefault(),
        void 0 !== this.callResetNorth_
          ? this.callResetNorth_()
          : this.resetNorth_();
    }
    resetNorth_() {
      const t = this.getMap().getView();
      if (!t) return;
      const e = t.getRotation();
      void 0 !== e &&
        (this.duration_ > 0 && e % (2 * Math.PI) != 0
          ? t.animate({ rotation: 0, duration: this.duration_, easing: et })
          : t.setRotation(0));
    }
    render(t) {
      const e = t.frameState;
      if (!e) return;
      const i = e.viewState.rotation;
      if (i != this.rotation_) {
        const t = "rotate(" + i + "rad)";
        if (this.autoHide_) {
          const t = this.element.classList.contains(ao);
          t || 0 !== i
            ? t && 0 !== i && this.element.classList.remove(ao)
            : this.element.classList.add(ao);
        }
        this.label_.style.transform = t;
      }
      this.rotation_ = i;
    }
  };
  var ga = class extends ca {
    constructor(t) {
      (t = t || {}),
        super({ element: document.createElement("div"), target: t.target });
      const e = void 0 !== t.className ? t.className : "ol-zoom",
        i = void 0 !== t.delta ? t.delta : 1,
        n = void 0 !== t.zoomInClassName ? t.zoomInClassName : e + "-in",
        r = void 0 !== t.zoomOutClassName ? t.zoomOutClassName : e + "-out",
        s = void 0 !== t.zoomInLabel ? t.zoomInLabel : "+",
        o = void 0 !== t.zoomOutLabel ? t.zoomOutLabel : "–",
        a = void 0 !== t.zoomInTipLabel ? t.zoomInTipLabel : "Zoom in",
        l = void 0 !== t.zoomOutTipLabel ? t.zoomOutTipLabel : "Zoom out",
        h = document.createElement("button");
      (h.className = n),
        h.setAttribute("type", "button"),
        (h.title = a),
        h.appendChild("string" == typeof s ? document.createTextNode(s) : s),
        h.addEventListener(w, this.handleClick_.bind(this, i), !1);
      const c = document.createElement("button");
      (c.className = r),
        c.setAttribute("type", "button"),
        (c.title = l),
        c.appendChild("string" == typeof o ? document.createTextNode(o) : o),
        c.addEventListener(w, this.handleClick_.bind(this, -i), !1);
      const u = e + " " + ho + " " + uo,
        d = this.element;
      (d.className = u),
        d.appendChild(h),
        d.appendChild(c),
        (this.duration_ = void 0 !== t.duration ? t.duration : 250);
    }
    handleClick_(t, e) {
      e.preventDefault(), this.zoomByDelta_(t);
    }
    zoomByDelta_(t) {
      const e = this.getMap().getView();
      if (!e) return;
      const i = e.getZoom();
      if (void 0 !== i) {
        const n = e.getConstrainedZoom(i + t);
        this.duration_ > 0
          ? (e.getAnimating() && e.cancelAnimations(),
            e.animate({ zoom: n, duration: this.duration_, easing: et }))
          : e.setZoom(n);
      }
    }
  };
  function fa(t) {
    t = t || {};
    const e = new K();
    (void 0 === t.zoom || t.zoom) && e.push(new ga(t.zoomOptions));
    (void 0 === t.rotate || t.rotate) && e.push(new da(t.rotateOptions));
    return (
      (void 0 === t.attribution || t.attribution) &&
        e.push(new ua(t.attributionOptions)),
      e
    );
  }
  var pa = "active";
  function ma(t, e, i) {
    const n = t.getCenterInternal();
    if (n) {
      const r = [n[0] + e[0], n[1] + e[1]];
      t.animateInternal({
        duration: void 0 !== i ? i : 250,
        easing: nt,
        center: t.getConstrainedCenter(r),
      });
    }
  }
  function _a(t, e, i, n) {
    const r = t.getZoom();
    if (void 0 === r) return;
    const s = t.getConstrainedZoom(r + e),
      o = t.getResolutionForZoom(s);
    t.getAnimating() && t.cancelAnimations(),
      t.animate({
        resolution: o,
        anchor: i,
        duration: void 0 !== n ? n : 250,
        easing: et,
      });
  }
  var ya = class extends U {
    constructor(t) {
      super(),
        this.on,
        this.once,
        this.un,
        t && t.handleEvent && (this.handleEvent = t.handleEvent),
        (this.map_ = null),
        this.setActive(!0);
    }
    getActive() {
      return this.get(pa);
    }
    getMap() {
      return this.map_;
    }
    handleEvent(t) {
      return !0;
    }
    setActive(t) {
      this.set(pa, t);
    }
    setMap(t) {
      this.map_ = t;
    }
  };
  var xa = class extends ya {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.delta_ = t.delta ? t.delta : 1),
        (this.duration_ = void 0 !== t.duration ? t.duration : 250);
    }
    handleEvent(t) {
      let e = !1;
      if (t.type == Vo.DBLCLICK) {
        const i = t.originalEvent,
          n = t.map,
          r = t.coordinate,
          s = i.shiftKey ? -this.delta_ : this.delta_;
        _a(n.getView(), s, r, this.duration_), i.preventDefault(), (e = !0);
      }
      return !e;
    }
  };
  function va(t) {
    const e = t.length;
    let i = 0,
      n = 0;
    for (let r = 0; r < e; r++) (i += t[r].clientX), (n += t[r].clientY);
    return { clientX: i / e, clientY: n / e };
  }
  var Sa = class extends ya {
    constructor(t) {
      super((t = t || {})),
        t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent),
        t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent),
        t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent),
        t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent),
        t.stopDown && (this.stopDown = t.stopDown),
        (this.handlingDownUpSequence = !1),
        (this.targetPointers = []);
    }
    getPointerCount() {
      return this.targetPointers.length;
    }
    handleDownEvent(t) {
      return !1;
    }
    handleDragEvent(t) {}
    handleEvent(t) {
      if (!t.originalEvent) return !0;
      let e = !1;
      if ((this.updateTrackedPointers_(t), this.handlingDownUpSequence)) {
        if (t.type == Vo.POINTERDRAG)
          this.handleDragEvent(t), t.originalEvent.preventDefault();
        else if (t.type == Vo.POINTERUP) {
          const e = this.handleUpEvent(t);
          this.handlingDownUpSequence = e && this.targetPointers.length > 0;
        }
      } else if (t.type == Vo.POINTERDOWN) {
        const i = this.handleDownEvent(t);
        (this.handlingDownUpSequence = i), (e = this.stopDown(i));
      } else t.type == Vo.POINTERMOVE && this.handleMoveEvent(t);
      return !e;
    }
    handleMoveEvent(t) {}
    handleUpEvent(t) {
      return !1;
    }
    stopDown(t) {
      return t;
    }
    updateTrackedPointers_(t) {
      t.activePointers && (this.targetPointers = t.activePointers);
    }
  };
  function Ca(t) {
    const e = arguments;
    return function (t) {
      let i = !0;
      for (let n = 0, r = e.length; n < r && ((i = i && e[n](t)), i); ++n);
      return i;
    };
  }
  const wa = function (t) {
      const e = t.originalEvent;
      return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
    },
    Wa = function (t) {
      const e = t.originalEvent;
      return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
    },
    Ea = function (t) {
      const e = t.map.getTargetElement(),
        i = t.map.getOwnerDocument().activeElement;
      return e.contains(i);
    },
    Ra = function (t) {
      return !t.map.getTargetElement().hasAttribute("tabindex") || Ea(t);
    },
    Ta = d,
    Pa = function (t) {
      const e = t.originalEvent;
      return 0 == e.button && !(ht && ct && e.ctrlKey);
    },
    ba = g,
    Fa = function (t) {
      return t.type == Vo.SINGLECLICK;
    },
    Ia = function (t) {
      const e = t.originalEvent;
      return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
    },
    La = function (t) {
      const e = t.originalEvent;
      return ct ? e.metaKey : e.ctrlKey;
    },
    Ma = function (t) {
      const e = t.originalEvent;
      return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
    },
    Oa = function (t) {
      const e = t.originalEvent,
        i = e.target.tagName;
      return (
        "INPUT" !== i &&
        "SELECT" !== i &&
        "TEXTAREA" !== i &&
        !e.target.isContentEditable
      );
    },
    ka = function (t) {
      const e = t.originalEvent;
      return (
        Ft(void 0 !== e, "mapBrowserEvent must originate from a pointer event"),
        "mouse" == e.pointerType
      );
    },
    Aa = function (t) {
      const e = t.originalEvent;
      return (
        Ft(void 0 !== e, "mapBrowserEvent must originate from a pointer event"),
        e.isPrimary && 0 === e.button
      );
    };
  var Na = class extends Sa {
    constructor(t) {
      super({ stopDown: g }),
        (t = t || {}),
        (this.kinetic_ = t.kinetic),
        (this.lastCentroid = null),
        this.lastPointersCount_,
        (this.panning_ = !1);
      const e = t.condition ? t.condition : Ca(Ia, Aa);
      (this.condition_ = t.onFocusOnly ? Ca(Ra, e) : e), (this.noKinetic_ = !1);
    }
    handleDragEvent(t) {
      const e = t.map;
      this.panning_ || ((this.panning_ = !0), e.getView().beginInteraction());
      const i = this.targetPointers,
        n = e.getEventPixel(va(i));
      if (i.length == this.lastPointersCount_) {
        if (
          (this.kinetic_ && this.kinetic_.update(n[0], n[1]), this.lastCentroid)
        ) {
          const e = [this.lastCentroid[0] - n[0], n[1] - this.lastCentroid[1]],
            i = t.map.getView();
          Li(e, i.getResolution()),
            Ii(e, i.getRotation()),
            i.adjustCenterInternal(e);
        }
      } else this.kinetic_ && this.kinetic_.begin();
      (this.lastCentroid = n),
        (this.lastPointersCount_ = i.length),
        t.originalEvent.preventDefault();
    }
    handleUpEvent(t) {
      const e = t.map,
        i = e.getView();
      if (0 === this.targetPointers.length) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          const t = this.kinetic_.getDistance(),
            n = this.kinetic_.getAngle(),
            r = i.getCenterInternal(),
            s = e.getPixelFromCoordinateInternal(r),
            o = e.getCoordinateFromPixelInternal([
              s[0] - t * Math.cos(n),
              s[1] - t * Math.sin(n),
            ]);
          i.animateInternal({
            center: i.getConstrainedCenter(o),
            duration: 500,
            easing: et,
          });
        }
        return this.panning_ && ((this.panning_ = !1), i.endInteraction()), !1;
      }
      return (
        this.kinetic_ && this.kinetic_.begin(), (this.lastCentroid = null), !0
      );
    }
    handleDownEvent(t) {
      if (this.targetPointers.length > 0 && this.condition_(t)) {
        const e = t.map.getView();
        return (
          (this.lastCentroid = null),
          e.getAnimating() && e.cancelAnimations(),
          this.kinetic_ && this.kinetic_.begin(),
          (this.noKinetic_ = this.targetPointers.length > 1),
          !0
        );
      }
      return !1;
    }
  };
  var Da = class extends Sa {
    constructor(t) {
      (t = t || {}),
        super({ stopDown: g }),
        (this.condition_ = t.condition ? t.condition : Wa),
        (this.lastAngle_ = void 0),
        (this.duration_ = void 0 !== t.duration ? t.duration : 250);
    }
    handleDragEvent(t) {
      if (!ka(t)) return;
      const e = t.map,
        i = e.getView();
      if (i.getConstraints().rotation === Vs) return;
      const n = e.getSize(),
        r = t.pixel,
        s = Math.atan2(n[1] / 2 - r[1], r[0] - n[0] / 2);
      if (void 0 !== this.lastAngle_) {
        const t = s - this.lastAngle_;
        i.adjustRotationInternal(-t);
      }
      this.lastAngle_ = s;
    }
    handleUpEvent(t) {
      if (!ka(t)) return !0;
      return t.map.getView().endInteraction(this.duration_), !1;
    }
    handleDownEvent(t) {
      if (!ka(t)) return !1;
      if (Pa(t) && this.condition_(t)) {
        return (
          t.map.getView().beginInteraction(), (this.lastAngle_ = void 0), !0
        );
      }
      return !1;
    }
  };
  var Ga = class extends n {
    constructor(t) {
      super(),
        (this.geometry_ = null),
        (this.element_ = document.createElement("div")),
        (this.element_.style.position = "absolute"),
        (this.element_.style.pointerEvents = "auto"),
        (this.element_.className = "ol-box " + t),
        (this.map_ = null),
        (this.startPixel_ = null),
        (this.endPixel_ = null);
    }
    disposeInternal() {
      this.setMap(null);
    }
    render_() {
      const t = this.startPixel_,
        e = this.endPixel_,
        i = "px",
        n = this.element_.style;
      (n.left = Math.min(t[0], e[0]) + i),
        (n.top = Math.min(t[1], e[1]) + i),
        (n.width = Math.abs(e[0] - t[0]) + i),
        (n.height = Math.abs(e[1] - t[1]) + i);
    }
    setMap(t) {
      if (this.map_) {
        this.map_.getOverlayContainer().removeChild(this.element_);
        const t = this.element_.style;
        (t.left = "inherit"),
          (t.top = "inherit"),
          (t.width = "inherit"),
          (t.height = "inherit");
      }
      (this.map_ = t),
        this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
    }
    setPixels(t, e) {
      (this.startPixel_ = t),
        (this.endPixel_ = e),
        this.createOrUpdateGeometry(),
        this.render_();
    }
    createOrUpdateGeometry() {
      const t = this.startPixel_,
        e = this.endPixel_,
        i = [t, [t[0], e[1]], e, [e[0], t[1]]].map(
          this.map_.getCoordinateFromPixelInternal,
          this.map_
        );
      (i[4] = i[0].slice()),
        this.geometry_
          ? this.geometry_.setCoordinates([i])
          : (this.geometry_ = new Tr([i]));
    }
    getGeometry() {
      return this.geometry_;
    }
  };
  const Ba = "boxstart",
    ja = "boxdrag",
    za = "boxend",
    Ua = "boxcancel";
  class qa extends e {
    constructor(t, e, i) {
      super(t), (this.coordinate = e), (this.mapBrowserEvent = i);
    }
  }
  var Va = class extends Sa {
    constructor(t) {
      super(),
        this.on,
        this.once,
        this.un,
        (t = t || {}),
        (this.box_ = new Ga(t.className || "ol-dragbox")),
        (this.minArea_ = void 0 !== t.minArea ? t.minArea : 64),
        t.onBoxEnd && (this.onBoxEnd = t.onBoxEnd),
        (this.startPixel_ = null),
        (this.condition_ = t.condition ? t.condition : Pa),
        (this.boxEndCondition_ = t.boxEndCondition
          ? t.boxEndCondition
          : this.defaultBoxEndCondition);
    }
    defaultBoxEndCondition(t, e, i) {
      const n = i[0] - e[0],
        r = i[1] - e[1];
      return n * n + r * r >= this.minArea_;
    }
    getGeometry() {
      return this.box_.getGeometry();
    }
    handleDragEvent(t) {
      this.box_.setPixels(this.startPixel_, t.pixel),
        this.dispatchEvent(new qa(ja, t.coordinate, t));
    }
    handleUpEvent(t) {
      this.box_.setMap(null);
      const e = this.boxEndCondition_(t, this.startPixel_, t.pixel);
      return (
        e && this.onBoxEnd(t),
        this.dispatchEvent(new qa(e ? za : Ua, t.coordinate, t)),
        !1
      );
    }
    handleDownEvent(t) {
      return (
        !!this.condition_(t) &&
        ((this.startPixel_ = t.pixel),
        this.box_.setMap(t.map),
        this.box_.setPixels(this.startPixel_, this.startPixel_),
        this.dispatchEvent(new qa(Ba, t.coordinate, t)),
        !0)
      );
    }
    onBoxEnd(t) {}
  };
  var Xa = class extends Va {
      constructor(t) {
        super({
          condition: (t = t || {}).condition ? t.condition : Ma,
          className: t.className || "ol-dragzoom",
          minArea: t.minArea,
        }),
          (this.duration_ = void 0 !== t.duration ? t.duration : 200),
          (this.out_ = void 0 !== t.out && t.out);
      }
      onBoxEnd(t) {
        const e = this.getMap().getView();
        let i = this.getGeometry();
        if (this.out_) {
          const t = e.rotatedExtentForGeometry(i),
            n = e.getResolutionForExtentInternal(t),
            r = e.getResolution() / n;
          (i = i.clone()), i.scale(r * r);
        }
        e.fitInternal(i, { duration: this.duration_, easing: et });
      }
    },
    Za = "ArrowLeft",
    Ka = "ArrowUp",
    Ha = "ArrowRight",
    Ya = "ArrowDown";
  var Qa = class extends ya {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.defaultCondition_ = function (t) {
          return Ia(t) && Oa(t);
        }),
        (this.condition_ =
          void 0 !== t.condition ? t.condition : this.defaultCondition_),
        (this.duration_ = void 0 !== t.duration ? t.duration : 100),
        (this.pixelDelta_ = void 0 !== t.pixelDelta ? t.pixelDelta : 128);
    }
    handleEvent(t) {
      let e = !1;
      if (t.type == P) {
        const i = t.originalEvent,
          n = i.key;
        if (this.condition_(t) && (n == Ya || n == Za || n == Ha || n == Ka)) {
          const r = t.map.getView(),
            s = r.getResolution() * this.pixelDelta_;
          let o = 0,
            a = 0;
          n == Ya ? (a = -s) : n == Za ? (o = -s) : n == Ha ? (o = s) : (a = s);
          const l = [o, a];
          Ii(l, r.getRotation()),
            ma(r, l, this.duration_),
            i.preventDefault(),
            (e = !0);
        }
      }
      return !e;
    }
  };
  var $a = class extends ya {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.condition_ = t.condition
          ? t.condition
          : function (t) {
              return !La(t) && Oa(t);
            }),
        (this.delta_ = t.delta ? t.delta : 1),
        (this.duration_ = void 0 !== t.duration ? t.duration : 100);
    }
    handleEvent(t) {
      let e = !1;
      if (t.type == P || t.type == b) {
        const i = t.originalEvent,
          n = i.key;
        if (this.condition_(t) && ("+" === n || "-" === n)) {
          const r = t.map,
            s = "+" === n ? this.delta_ : -this.delta_;
          _a(r.getView(), s, void 0, this.duration_),
            i.preventDefault(),
            (e = !0);
        }
      }
      return !e;
    }
  };
  var Ja = class extends ya {
    constructor(t) {
      super((t = t || {})),
        (this.totalDelta_ = 0),
        (this.lastDelta_ = 0),
        (this.maxDelta_ = void 0 !== t.maxDelta ? t.maxDelta : 1),
        (this.duration_ = void 0 !== t.duration ? t.duration : 250),
        (this.timeout_ = void 0 !== t.timeout ? t.timeout : 80),
        (this.useAnchor_ = void 0 === t.useAnchor || t.useAnchor),
        (this.constrainResolution_ =
          void 0 !== t.constrainResolution && t.constrainResolution);
      const e = t.condition ? t.condition : Ta;
      (this.condition_ = t.onFocusOnly ? Ca(Ra, e) : e),
        (this.lastAnchor_ = null),
        (this.startTime_ = void 0),
        this.timeoutId_,
        (this.mode_ = void 0),
        (this.trackpadEventGap_ = 400),
        this.trackpadTimeoutId_,
        (this.deltaPerZoom_ = 300);
    }
    endInteraction_() {
      this.trackpadTimeoutId_ = void 0;
      const t = this.getMap();
      if (!t) return;
      t.getView().endInteraction(
        void 0,
        this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,
        this.lastAnchor_
      );
    }
    handleEvent(t) {
      if (!this.condition_(t)) return !0;
      if (t.type !== L) return !0;
      const e = t.map,
        i = t.originalEvent;
      let n;
      if (
        (i.preventDefault(),
        this.useAnchor_ && (this.lastAnchor_ = t.coordinate),
        t.type == L &&
          ((n = i.deltaY),
          ot && i.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (n /= ut),
          i.deltaMode === WheelEvent.DOM_DELTA_LINE && (n *= 40)),
        0 === n)
      )
        return !1;
      this.lastDelta_ = n;
      const r = Date.now();
      void 0 === this.startTime_ && (this.startTime_ = r),
        (!this.mode_ || r - this.startTime_ > this.trackpadEventGap_) &&
          (this.mode_ = Math.abs(n) < 4 ? "trackpad" : "wheel");
      const s = e.getView();
      if (
        "trackpad" === this.mode_ &&
        !s.getConstrainResolution() &&
        !this.constrainResolution_
      )
        return (
          this.trackpadTimeoutId_
            ? clearTimeout(this.trackpadTimeoutId_)
            : (s.getAnimating() && s.cancelAnimations(), s.beginInteraction()),
          (this.trackpadTimeoutId_ = setTimeout(
            this.endInteraction_.bind(this),
            this.timeout_
          )),
          s.adjustZoom(-n / this.deltaPerZoom_, this.lastAnchor_),
          (this.startTime_ = r),
          !1
        );
      this.totalDelta_ += n;
      const o = Math.max(this.timeout_ - (r - this.startTime_), 0);
      return (
        clearTimeout(this.timeoutId_),
        (this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, e), o)),
        !1
      );
    }
    handleWheelZoom_(t) {
      const e = t.getView();
      e.getAnimating() && e.cancelAnimations();
      let i =
        -ui(
          this.totalDelta_,
          -this.maxDelta_ * this.deltaPerZoom_,
          this.maxDelta_ * this.deltaPerZoom_
        ) / this.deltaPerZoom_;
      (e.getConstrainResolution() || this.constrainResolution_) &&
        (i = i ? (i > 0 ? 1 : -1) : 0),
        _a(e, i, this.lastAnchor_, this.duration_),
        (this.mode_ = void 0),
        (this.totalDelta_ = 0),
        (this.lastAnchor_ = null),
        (this.startTime_ = void 0),
        (this.timeoutId_ = void 0);
    }
    setMouseAnchor(t) {
      (this.useAnchor_ = t), t || (this.lastAnchor_ = null);
    }
  };
  var tl = class extends Sa {
    constructor(t) {
      const e = (t = t || {});
      e.stopDown || (e.stopDown = g),
        super(e),
        (this.anchor_ = null),
        (this.lastAngle_ = void 0),
        (this.rotating_ = !1),
        (this.rotationDelta_ = 0),
        (this.threshold_ = void 0 !== t.threshold ? t.threshold : 0.3),
        (this.duration_ = void 0 !== t.duration ? t.duration : 250);
    }
    handleDragEvent(t) {
      let e = 0;
      const i = this.targetPointers[0],
        n = this.targetPointers[1],
        r = Math.atan2(n.clientY - i.clientY, n.clientX - i.clientX);
      if (void 0 !== this.lastAngle_) {
        const t = r - this.lastAngle_;
        (this.rotationDelta_ += t),
          !this.rotating_ &&
            Math.abs(this.rotationDelta_) > this.threshold_ &&
            (this.rotating_ = !0),
          (e = t);
      }
      this.lastAngle_ = r;
      const s = t.map,
        o = s.getView();
      o.getConstraints().rotation !== Vs &&
        ((this.anchor_ = s.getCoordinateFromPixelInternal(
          s.getEventPixel(va(this.targetPointers))
        )),
        this.rotating_ &&
          (s.render(), o.adjustRotationInternal(e, this.anchor_)));
    }
    handleUpEvent(t) {
      if (this.targetPointers.length < 2) {
        return t.map.getView().endInteraction(this.duration_), !1;
      }
      return !0;
    }
    handleDownEvent(t) {
      if (this.targetPointers.length >= 2) {
        const e = t.map;
        return (
          (this.anchor_ = null),
          (this.lastAngle_ = void 0),
          (this.rotating_ = !1),
          (this.rotationDelta_ = 0),
          this.handlingDownUpSequence || e.getView().beginInteraction(),
          !0
        );
      }
      return !1;
    }
  };
  var el = class extends Sa {
    constructor(t) {
      const e = (t = t || {});
      e.stopDown || (e.stopDown = g),
        super(e),
        (this.anchor_ = null),
        (this.duration_ = void 0 !== t.duration ? t.duration : 400),
        (this.lastDistance_ = void 0),
        (this.lastScaleDelta_ = 1);
    }
    handleDragEvent(t) {
      let e = 1;
      const i = this.targetPointers[0],
        n = this.targetPointers[1],
        r = i.clientX - n.clientX,
        s = i.clientY - n.clientY,
        o = Math.sqrt(r * r + s * s);
      void 0 !== this.lastDistance_ && (e = this.lastDistance_ / o),
        (this.lastDistance_ = o);
      const a = t.map,
        l = a.getView();
      1 != e && (this.lastScaleDelta_ = e),
        (this.anchor_ = a.getCoordinateFromPixelInternal(
          a.getEventPixel(va(this.targetPointers))
        )),
        a.render(),
        l.adjustResolutionInternal(e, this.anchor_);
    }
    handleUpEvent(t) {
      if (this.targetPointers.length < 2) {
        const e = t.map.getView(),
          i = this.lastScaleDelta_ > 1 ? 1 : -1;
        return e.endInteraction(this.duration_, i), !1;
      }
      return !0;
    }
    handleDownEvent(t) {
      if (this.targetPointers.length >= 2) {
        const e = t.map;
        return (
          (this.anchor_ = null),
          (this.lastDistance_ = void 0),
          (this.lastScaleDelta_ = 1),
          this.handlingDownUpSequence || e.getView().beginInteraction(),
          !0
        );
      }
      return !1;
    }
  };
  function il(t) {
    t = t || {};
    const e = new K(),
      i = new ns(-0.005, 0.05, 100);
    (void 0 === t.altShiftDragRotate || t.altShiftDragRotate) &&
      e.push(new Da());
    (void 0 === t.doubleClickZoom || t.doubleClickZoom) &&
      e.push(new xa({ delta: t.zoomDelta, duration: t.zoomDuration }));
    (void 0 === t.dragPan || t.dragPan) &&
      e.push(new Na({ onFocusOnly: t.onFocusOnly, kinetic: i }));
    (void 0 === t.pinchRotate || t.pinchRotate) && e.push(new tl());
    (void 0 === t.pinchZoom || t.pinchZoom) &&
      e.push(new el({ duration: t.zoomDuration }));
    (void 0 === t.keyboard || t.keyboard) &&
      (e.push(new Qa()),
      e.push(new $a({ delta: t.zoomDelta, duration: t.zoomDuration })));
    (void 0 === t.mouseWheelZoom || t.mouseWheelZoom) &&
      e.push(new Ja({ onFocusOnly: t.onFocusOnly, duration: t.zoomDuration }));
    return (
      (void 0 === t.shiftDragZoom || t.shiftDragZoom) &&
        e.push(new Xa({ duration: t.zoomDuration })),
      e
    );
  }
  function nl(t) {
    return t[0] > 0 && t[1] > 0;
  }
  function rl(t, e, i) {
    return (
      void 0 === i && (i = [0, 0]),
      (i[0] = (t[0] * e + 0.5) | 0),
      (i[1] = (t[1] * e + 0.5) | 0),
      i
    );
  }
  function sl(t, e) {
    return Array.isArray(t)
      ? t
      : (void 0 === e ? (e = [t, t]) : ((e[0] = t), (e[1] = t)), e);
  }
  const ol = [
      "fullscreenchange",
      "webkitfullscreenchange",
      "MSFullscreenChange",
    ],
    al = "enterfullscreen",
    ll = "leavefullscreen";
  function hl(t) {
    const e = t.body;
    return !!(
      e.webkitRequestFullscreen ||
      (e.requestFullscreen && t.fullscreenEnabled)
    );
  }
  function cl(t) {
    return !(!t.webkitIsFullScreen && !t.fullscreenElement);
  }
  function ul(t) {
    t.requestFullscreen
      ? t.requestFullscreen()
      : t.webkitRequestFullscreen && t.webkitRequestFullscreen();
  }
  var dl = class extends ca {
    constructor(t) {
      (t = t || {}),
        super({ element: document.createElement("div"), target: t.target }),
        this.on,
        this.once,
        this.un,
        (this.keys_ = void 0 !== t.keys && t.keys),
        (this.source_ = t.source),
        (this.isInFullscreen_ = !1),
        (this.boundHandleMapTargetChange_ =
          this.handleMapTargetChange_.bind(this)),
        (this.cssClassName_ =
          void 0 !== t.className ? t.className : "ol-full-screen"),
        (this.documentListeners_ = []),
        (this.activeClassName_ =
          void 0 !== t.activeClassName
            ? t.activeClassName.split(" ")
            : [this.cssClassName_ + "-true"]),
        (this.inactiveClassName_ =
          void 0 !== t.inactiveClassName
            ? t.inactiveClassName.split(" ")
            : [this.cssClassName_ + "-false"]);
      const e = void 0 !== t.label ? t.label : "⤢";
      this.labelNode_ = "string" == typeof e ? document.createTextNode(e) : e;
      const i = void 0 !== t.labelActive ? t.labelActive : "×";
      this.labelActiveNode_ =
        "string" == typeof i ? document.createTextNode(i) : i;
      const n = t.tipLabel ? t.tipLabel : "Toggle full-screen";
      (this.button_ = document.createElement("button")),
        (this.button_.title = n),
        this.button_.setAttribute("type", "button"),
        this.button_.appendChild(this.labelNode_),
        this.button_.addEventListener(w, this.handleClick_.bind(this), !1),
        this.setClassName_(this.button_, this.isInFullscreen_),
        (this.element.className = `${this.cssClassName_} ${ho} ${uo}`),
        this.element.appendChild(this.button_);
    }
    handleClick_(t) {
      t.preventDefault(), this.handleFullScreen_();
    }
    handleFullScreen_() {
      const t = this.getMap();
      if (!t) return;
      const e = t.getOwnerDocument();
      if (hl(e))
        if (cl(e))
          !(function (t) {
            t.exitFullscreen
              ? t.exitFullscreen()
              : t.webkitExitFullscreen && t.webkitExitFullscreen();
          })(e);
        else {
          let i;
          (i = this.source_
            ? "string" == typeof this.source_
              ? e.getElementById(this.source_)
              : this.source_
            : t.getTargetElement()),
            this.keys_
              ? (function (t) {
                  t.webkitRequestFullscreen
                    ? t.webkitRequestFullscreen()
                    : ul(t);
                })(i)
              : ul(i);
        }
    }
    handleFullScreenChange_() {
      const t = this.getMap();
      if (!t) return;
      const e = this.isInFullscreen_;
      (this.isInFullscreen_ = cl(t.getOwnerDocument())),
        e !== this.isInFullscreen_ &&
          (this.setClassName_(this.button_, this.isInFullscreen_),
          this.isInFullscreen_
            ? (vt(this.labelActiveNode_, this.labelNode_),
              this.dispatchEvent(al))
            : (vt(this.labelNode_, this.labelActiveNode_),
              this.dispatchEvent(ll)),
          t.updateSize());
    }
    setClassName_(t, e) {
      e
        ? (t.classList.remove(...this.inactiveClassName_),
          t.classList.add(...this.activeClassName_))
        : (t.classList.remove(...this.activeClassName_),
          t.classList.add(...this.inactiveClassName_));
    }
    setMap(t) {
      const e = this.getMap();
      e && e.removeChangeListener(ra, this.boundHandleMapTargetChange_),
        super.setMap(t),
        this.handleMapTargetChange_(),
        t && t.addChangeListener(ra, this.boundHandleMapTargetChange_);
    }
    handleMapTargetChange_() {
      const t = this.documentListeners_;
      for (let e = 0, i = t.length; e < i; ++e) k(t[e]);
      t.length = 0;
      const e = this.getMap();
      if (e) {
        const i = e.getOwnerDocument();
        hl(i)
          ? this.element.classList.remove(co)
          : this.element.classList.add(co);
        for (let e = 0, n = ol.length; e < n; ++e)
          t.push(M(i, ol[e], this.handleFullScreenChange_, this));
        this.handleFullScreenChange_();
      }
    }
  };
  const gl = "projection",
    fl = "coordinateFormat";
  var pl = class extends ca {
    constructor(t) {
      t = t || {};
      const e = document.createElement("div");
      (e.className =
        void 0 !== t.className ? t.className : "ol-mouse-position"),
        super({ element: e, render: t.render, target: t.target }),
        this.on,
        this.once,
        this.un,
        this.addChangeListener(gl, this.handleProjectionChanged_),
        t.coordinateFormat && this.setCoordinateFormat(t.coordinateFormat),
        t.projection && this.setProjection(t.projection),
        (this.renderOnMouseOut_ = void 0 !== t.placeholder),
        (this.placeholder_ = this.renderOnMouseOut_ ? t.placeholder : "&#160;"),
        (this.renderedHTML_ = e.innerHTML),
        (this.mapProjection_ = null),
        (this.transform_ = null),
        (this.wrapX_ = !1 !== t.wrapX);
    }
    handleProjectionChanged_() {
      this.transform_ = null;
    }
    getCoordinateFormat() {
      return this.get(fl);
    }
    getProjection() {
      return this.get(gl);
    }
    handleMouseMove(t) {
      const e = this.getMap();
      this.updateHTML_(e.getEventPixel(t));
    }
    handleMouseOut(t) {
      this.updateHTML_(null);
    }
    setMap(t) {
      if ((super.setMap(t), t)) {
        const e = t.getViewport();
        this.listenerKeys.push(M(e, Xo, this.handleMouseMove, this)),
          this.renderOnMouseOut_ &&
            this.listenerKeys.push(M(e, Ho, this.handleMouseOut, this)),
          this.updateHTML_(null);
      }
    }
    setCoordinateFormat(t) {
      this.set(fl, t);
    }
    setProjection(t) {
      this.set(gl, tn(t));
    }
    updateHTML_(t) {
      let e = this.placeholder_;
      if (t && this.mapProjection_) {
        if (!this.transform_) {
          const t = this.getProjection();
          this.transform_ = t ? hn(this.mapProjection_, t) : Qi;
        }
        const i = this.getMap().getCoordinateFromPixelInternal(t);
        if (i) {
          const t = pn();
          if (
            (t && (this.transform_ = hn(this.mapProjection_, t)),
            this.transform_(i, i),
            this.wrapX_)
          ) {
            Ni(i, t || this.getProjection() || this.mapProjection_);
          }
          const n = this.getCoordinateFormat();
          e = n ? n(i) : i.toString();
        }
      }
      (this.renderedHTML_ && e === this.renderedHTML_) ||
        ((this.element.innerHTML = e), (this.renderedHTML_ = e));
    }
    render(t) {
      const e = t.frameState;
      e
        ? this.mapProjection_ != e.viewState.projection &&
          ((this.mapProjection_ = e.viewState.projection),
          (this.transform_ = null))
        : (this.mapProjection_ = null);
    }
  };
  const ml = "element",
    _l = "map",
    yl = "offset",
    xl = "position",
    vl = "positioning";
  var Sl = class extends U {
    constructor(t) {
      super(),
        this.on,
        this.once,
        this.un,
        (this.options = t),
        (this.id = t.id),
        (this.insertFirst = void 0 === t.insertFirst || t.insertFirst),
        (this.stopEvent = void 0 === t.stopEvent || t.stopEvent),
        (this.element = document.createElement("div")),
        (this.element.className =
          void 0 !== t.className ? t.className : "ol-overlay-container " + lo),
        (this.element.style.position = "absolute"),
        (this.element.style.pointerEvents = "auto"),
        (this.autoPan = !0 === t.autoPan ? {} : t.autoPan || void 0),
        (this.rendered = { transform_: "", visible: !0 }),
        (this.mapPostrenderListenerKey = null),
        this.addChangeListener(ml, this.handleElementChanged),
        this.addChangeListener(_l, this.handleMapChanged),
        this.addChangeListener(yl, this.handleOffsetChanged),
        this.addChangeListener(xl, this.handlePositionChanged),
        this.addChangeListener(vl, this.handlePositioningChanged),
        void 0 !== t.element && this.setElement(t.element),
        this.setOffset(void 0 !== t.offset ? t.offset : [0, 0]),
        this.setPositioning(t.positioning || "top-left"),
        void 0 !== t.position && this.setPosition(t.position);
    }
    getElement() {
      return this.get(ml);
    }
    getId() {
      return this.id;
    }
    getMap() {
      return this.get(_l) || null;
    }
    getOffset() {
      return this.get(yl);
    }
    getPosition() {
      return this.get(xl);
    }
    getPositioning() {
      return this.get(vl);
    }
    handleElementChanged() {
      Ct(this.element);
      const t = this.getElement();
      t && this.element.appendChild(t);
    }
    handleMapChanged() {
      this.mapPostrenderListenerKey &&
        (St(this.element),
        k(this.mapPostrenderListenerKey),
        (this.mapPostrenderListenerKey = null));
      const t = this.getMap();
      if (t) {
        (this.mapPostrenderListenerKey = M(t, Qo, this.render, this)),
          this.updatePixelPosition();
        const e = this.stopEvent
          ? t.getOverlayContainerStopEvent()
          : t.getOverlayContainer();
        this.insertFirst
          ? e.insertBefore(this.element, e.childNodes[0] || null)
          : e.appendChild(this.element),
          this.performAutoPan();
      }
    }
    render() {
      this.updatePixelPosition();
    }
    handleOffsetChanged() {
      this.updatePixelPosition();
    }
    handlePositionChanged() {
      this.updatePixelPosition(), this.performAutoPan();
    }
    handlePositioningChanged() {
      this.updatePixelPosition();
    }
    setElement(t) {
      this.set(ml, t);
    }
    setMap(t) {
      this.set(_l, t);
    }
    setOffset(t) {
      this.set(yl, t);
    }
    setPosition(t) {
      this.set(xl, t);
    }
    performAutoPan() {
      this.autoPan && this.panIntoView(this.autoPan);
    }
    panIntoView(t) {
      const e = this.getMap();
      if (!e || !e.getTargetElement() || !this.get(xl)) return;
      const i = this.getRect(e.getTargetElement(), e.getSize()),
        n = this.getElement(),
        r = this.getRect(n, [yt(n), xt(n)]),
        s = void 0 === (t = t || {}).margin ? 20 : t.margin;
      if (!ie(i, r)) {
        const n = r[0] - i[0],
          o = i[2] - r[2],
          a = r[1] - i[1],
          l = i[3] - r[3],
          h = [0, 0];
        if (
          (n < 0 ? (h[0] = n - s) : o < 0 && (h[0] = Math.abs(o) + s),
          a < 0 ? (h[1] = a - s) : l < 0 && (h[1] = Math.abs(l) + s),
          0 !== h[0] || 0 !== h[1])
        ) {
          const i = e.getView().getCenterInternal(),
            n = e.getPixelFromCoordinateInternal(i);
          if (!n) return;
          const r = [n[0] + h[0], n[1] + h[1]],
            s = t.animation || {};
          e.getView().animateInternal({
            center: e.getCoordinateFromPixelInternal(r),
            duration: s.duration,
            easing: s.easing,
          });
        }
      }
    }
    getRect(t, e) {
      const i = t.getBoundingClientRect(),
        n = i.left + window.pageXOffset,
        r = i.top + window.pageYOffset;
      return [n, r, n + e[0], r + e[1]];
    }
    setPositioning(t) {
      this.set(vl, t);
    }
    setVisible(t) {
      this.rendered.visible !== t &&
        ((this.element.style.display = t ? "" : "none"),
        (this.rendered.visible = t));
    }
    updatePixelPosition() {
      const t = this.getMap(),
        e = this.getPosition();
      if (!t || !t.isRendered() || !e) return void this.setVisible(!1);
      const i = t.getPixelFromCoordinate(e),
        n = t.getSize();
      this.updateRenderedPosition(i, n);
    }
    updateRenderedPosition(t, e) {
      const i = this.element.style,
        n = this.getOffset(),
        r = this.getPositioning();
      this.setVisible(!0);
      let s = "0%",
        o = "0%";
      "bottom-right" == r || "center-right" == r || "top-right" == r
        ? (s = "-100%")
        : ("bottom-center" != r && "center-center" != r && "top-center" != r) ||
          (s = "-50%"),
        "bottom-left" == r || "bottom-center" == r || "bottom-right" == r
          ? (o = "-100%")
          : ("center-left" != r &&
              "center-center" != r &&
              "center-right" != r) ||
            (o = "-50%");
      const a = `translate(${s}, ${o}) translate(${
        Math.round(t[0] + n[0]) + "px"
      }, ${Math.round(t[1] + n[1]) + "px"})`;
      this.rendered.transform_ != a &&
        ((this.rendered.transform_ = a), (i.transform = a));
    }
    getOptions() {
      return this.options;
    }
  };
  const Cl = 0.75,
    wl = 0.1;
  var Wl = class extends ca {
    constructor(t) {
      (t = t || {}),
        super({
          element: document.createElement("div"),
          render: t.render,
          target: t.target,
        }),
        (this.boundHandleRotationChanged_ =
          this.handleRotationChanged_.bind(this)),
        (this.collapsed_ = void 0 === t.collapsed || t.collapsed),
        (this.collapsible_ = void 0 === t.collapsible || t.collapsible),
        this.collapsible_ || (this.collapsed_ = !1),
        (this.rotateWithView_ =
          void 0 !== t.rotateWithView && t.rotateWithView),
        (this.viewExtent_ = void 0);
      const e = void 0 !== t.className ? t.className : "ol-overviewmap",
        i = void 0 !== t.tipLabel ? t.tipLabel : "Overview map",
        n = void 0 !== t.collapseLabel ? t.collapseLabel : "‹";
      "string" == typeof n
        ? ((this.collapseLabel_ = document.createElement("span")),
          (this.collapseLabel_.textContent = n))
        : (this.collapseLabel_ = n);
      const r = void 0 !== t.label ? t.label : "›";
      "string" == typeof r
        ? ((this.label_ = document.createElement("span")),
          (this.label_.textContent = r))
        : (this.label_ = r);
      const s =
          this.collapsible_ && !this.collapsed_
            ? this.collapseLabel_
            : this.label_,
        o = document.createElement("button");
      o.setAttribute("type", "button"),
        (o.title = i),
        o.appendChild(s),
        o.addEventListener(w, this.handleClick_.bind(this), !1),
        (this.ovmapDiv_ = document.createElement("div")),
        (this.ovmapDiv_.className = "ol-overviewmap-map"),
        (this.view_ = t.view);
      const a = new Py({
        view: t.view,
        controls: new K(),
        interactions: new K(),
      });
      (this.ovmap_ = a),
        t.layers &&
          t.layers.forEach(function (t) {
            a.addLayer(t);
          });
      const l = document.createElement("div");
      (l.className = "ol-overviewmap-box"),
        (l.style.boxSizing = "border-box"),
        (this.boxOverlay_ = new Sl({
          position: [0, 0],
          positioning: "center-center",
          element: l,
        })),
        this.ovmap_.addOverlay(this.boxOverlay_);
      const h =
          e +
          " " +
          ho +
          " " +
          uo +
          (this.collapsed_ && this.collapsible_ ? " " + go : "") +
          (this.collapsible_ ? "" : " ol-uncollapsible"),
        c = this.element;
      (c.className = h), c.appendChild(this.ovmapDiv_), c.appendChild(o);
      const u = this,
        d = this.boxOverlay_,
        g = this.boxOverlay_.getElement(),
        f = function (t) {
          const e = { clientX: (i = t).clientX, clientY: i.clientY };
          var i;
          const n = a.getEventCoordinateInternal(e);
          d.setPosition(n);
        },
        p = function (t) {
          const e = a.getEventCoordinateInternal(t);
          u.getMap().getView().setCenterInternal(e),
            window.removeEventListener("mousemove", f),
            window.removeEventListener("mouseup", p);
        };
      g.addEventListener("mousedown", function () {
        window.addEventListener("mousemove", f),
          window.addEventListener("mouseup", p);
      });
    }
    setMap(t) {
      const e = this.getMap();
      if (t !== e) {
        if (e) {
          const t = e.getView();
          t && this.unbindView_(t), this.ovmap_.setTarget(null);
        }
        if ((super.setMap(t), t)) {
          this.ovmap_.setTarget(this.ovmapDiv_),
            this.listenerKeys.push(
              M(t, i, this.handleMapPropertyChange_, this)
            );
          const e = t.getView();
          e &&
            (this.bindView_(e),
            e.isDef() && (this.ovmap_.updateSize(), this.resetExtent_())),
            this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
        }
      }
    }
    handleMapPropertyChange_(t) {
      if (t.key === sa) {
        const e = t.oldValue;
        e && this.unbindView_(e);
        const i = this.getMap().getView();
        this.bindView_(i);
      } else
        this.ovmap_.isRendered() ||
          (t.key !== ra && t.key !== na) ||
          this.ovmap_.updateSize();
    }
    bindView_(t) {
      if (!this.view_) {
        const e = new eo({ projection: t.getProjection() });
        this.ovmap_.setView(e);
      }
      t.addChangeListener(ks.ROTATION, this.boundHandleRotationChanged_),
        this.handleRotationChanged_();
    }
    unbindView_(t) {
      t.removeChangeListener(ks.ROTATION, this.boundHandleRotationChanged_);
    }
    handleRotationChanged_() {
      this.rotateWithView_ &&
        this.ovmap_
          .getView()
          .setRotation(this.getMap().getView().getRotation());
    }
    validateExtent_() {
      const t = this.getMap(),
        e = this.ovmap_;
      if (!t.isRendered() || !e.isRendered()) return;
      const i = t.getSize(),
        n = t.getView().calculateExtentInternal(i);
      if (this.viewExtent_ && ce(n, this.viewExtent_)) return;
      this.viewExtent_ = n;
      const r = e.getSize(),
        s = e.getView().calculateExtentInternal(r),
        o = e.getPixelFromCoordinateInternal(Pe(n)),
        a = e.getPixelFromCoordinateInternal(Se(n)),
        l = Math.abs(o[0] - a[0]),
        h = Math.abs(o[1] - a[1]),
        c = r[0],
        u = r[1];
      l < c * wl || h < u * wl || l > c * Cl || h > u * Cl
        ? this.resetExtent_()
        : ie(s, n) || this.recenter_();
    }
    resetExtent_() {
      const t = this.getMap(),
        e = this.ovmap_,
        i = t.getSize(),
        n = t.getView().calculateExtentInternal(i),
        r = e.getView(),
        s = Math.log(7.5) / Math.LN2;
      Oe(n, 1 / (Math.pow(2, s / 2) * wl)), r.fitInternal(br(n));
    }
    recenter_() {
      const t = this.getMap(),
        e = this.ovmap_,
        i = t.getView();
      e.getView().setCenterInternal(i.getCenterInternal());
    }
    updateBox_() {
      const t = this.getMap(),
        e = this.ovmap_;
      if (!t.isRendered() || !e.isRendered()) return;
      const i = t.getSize(),
        n = t.getView(),
        r = e.getView(),
        s = this.rotateWithView_ ? 0 : -n.getRotation(),
        o = this.boxOverlay_,
        a = this.boxOverlay_.getElement(),
        l = n.getCenterInternal(),
        h = n.getResolution(),
        c = r.getResolution(),
        u = (i[0] * h) / c,
        d = (i[1] * h) / c;
      if ((o.setPosition(l), a)) {
        (a.style.width = u + "px"), (a.style.height = d + "px");
        const t = "rotate(" + s + "rad)";
        a.style.transform = t;
      }
    }
    updateBoxAfterOvmapIsRendered_() {
      this.ovmapPostrenderKey_ ||
        (this.ovmapPostrenderKey_ = O(
          this.ovmap_,
          Qo,
          function (t) {
            delete this.ovmapPostrenderKey_, this.updateBox_();
          },
          this
        ));
    }
    handleClick_(t) {
      t.preventDefault(), this.handleToggle_();
    }
    handleToggle_() {
      this.element.classList.toggle(go),
        this.collapsed_
          ? vt(this.collapseLabel_, this.label_)
          : vt(this.label_, this.collapseLabel_),
        (this.collapsed_ = !this.collapsed_);
      const t = this.ovmap_;
      if (!this.collapsed_) {
        if (t.isRendered()) return (this.viewExtent_ = void 0), void t.render();
        t.updateSize(),
          this.resetExtent_(),
          this.updateBoxAfterOvmapIsRendered_();
      }
    }
    getCollapsible() {
      return this.collapsible_;
    }
    setCollapsible(t) {
      this.collapsible_ !== t &&
        ((this.collapsible_ = t),
        this.element.classList.toggle("ol-uncollapsible"),
        !t && this.collapsed_ && this.handleToggle_());
    }
    setCollapsed(t) {
      this.collapsible_ && this.collapsed_ !== t && this.handleToggle_();
    }
    getCollapsed() {
      return this.collapsed_;
    }
    getRotateWithView() {
      return this.rotateWithView_;
    }
    setRotateWithView(t) {
      this.rotateWithView_ !== t &&
        ((this.rotateWithView_ = t),
        0 !== this.getMap().getView().getRotation() &&
          (this.rotateWithView_
            ? this.handleRotationChanged_()
            : this.ovmap_.getView().setRotation(0),
          (this.viewExtent_ = void 0),
          this.validateExtent_(),
          this.updateBox_()));
    }
    getOverviewMap() {
      return this.ovmap_;
    }
    render(t) {
      this.validateExtent_(), this.updateBox_();
    }
  };
  const El = "units",
    Rl = [1, 2, 5],
    Tl = 25.4 / 0.28;
  var Pl = class extends ca {
    constructor(t) {
      t = t || {};
      const e = document.createElement("div");
      (e.style.pointerEvents = "none"),
        super({ element: e, render: t.render, target: t.target }),
        this.on,
        this.once,
        this.un;
      const i =
        void 0 !== t.className
          ? t.className
          : t.bar
          ? "ol-scale-bar"
          : "ol-scale-line";
      (this.innerElement_ = document.createElement("div")),
        (this.innerElement_.className = i + "-inner"),
        (this.element.className = i + " " + ho),
        this.element.appendChild(this.innerElement_),
        (this.viewState_ = null),
        (this.minWidth_ = void 0 !== t.minWidth ? t.minWidth : 64),
        (this.maxWidth_ = t.maxWidth),
        (this.renderedVisible_ = !1),
        (this.renderedWidth_ = void 0),
        (this.renderedHTML_ = ""),
        this.addChangeListener(El, this.handleUnitsChanged_),
        this.setUnits(t.units || "metric"),
        (this.scaleBar_ = t.bar || !1),
        (this.scaleBarSteps_ = t.steps || 4),
        (this.scaleBarText_ = t.text || !1),
        (this.dpi_ = t.dpi || void 0);
    }
    getUnits() {
      return this.get(El);
    }
    handleUnitsChanged_() {
      this.updateElement_();
    }
    setUnits(t) {
      this.set(El, t);
    }
    setDpi(t) {
      this.dpi_ = t;
    }
    updateElement_() {
      const t = this.viewState_;
      if (!t)
        return void (
          this.renderedVisible_ &&
          ((this.element.style.display = "none"), (this.renderedVisible_ = !1))
        );
      const e = t.center,
        i = t.projection,
        n = this.getUnits(),
        r = "degrees" == n ? "degrees" : "m";
      let s = en(i, t.resolution, e, r);
      const o = (this.minWidth_ * (this.dpi_ || Tl)) / Tl,
        a =
          void 0 !== this.maxWidth_
            ? (this.maxWidth_ * (this.dpi_ || Tl)) / Tl
            : void 0;
      let l = o * s,
        h = "";
      if ("degrees" == n) {
        const t = je.degrees;
        (l *= t),
          l < t / 60
            ? ((h = "″"), (s *= 3600))
            : l < t
            ? ((h = "′"), (s *= 60))
            : (h = "°");
      } else if ("imperial" == n)
        l < 0.9144
          ? ((h = "in"), (s /= 0.0254))
          : l < 1609.344
          ? ((h = "ft"), (s /= 0.3048))
          : ((h = "mi"), (s /= 1609.344));
      else if ("nautical" == n) (s /= 1852), (h = "NM");
      else if ("metric" == n)
        l < 0.001
          ? ((h = "μm"), (s *= 1e6))
          : l < 1
          ? ((h = "mm"), (s *= 1e3))
          : l < 1e3
          ? (h = "m")
          : ((h = "km"), (s /= 1e3));
      else {
        if ("us" != n) throw new Error("Invalid units");
        l < 0.9144
          ? ((h = "in"), (s *= 39.37))
          : l < 1609.344
          ? ((h = "ft"), (s /= 0.30480061))
          : ((h = "mi"), (s /= 1609.3472));
      }
      let c,
        u,
        d,
        g,
        f,
        p,
        m = 3 * Math.floor(Math.log(o * s) / Math.log(10));
      for (;;) {
        d = Math.floor(m / 3);
        const t = Math.pow(10, d);
        if (
          ((c = Rl[((m % 3) + 3) % 3] * t), (u = Math.round(c / s)), isNaN(u))
        )
          return (
            (this.element.style.display = "none"),
            void (this.renderedVisible_ = !1)
          );
        if (void 0 !== a && u >= a) {
          (c = g), (u = f), (d = p);
          break;
        }
        if (u >= o) break;
        (g = c), (f = u), (p = d), ++m;
      }
      const _ = this.scaleBar_
        ? this.createScaleBar(u, c, h)
        : c.toFixed(d < 0 ? -d : 0) + " " + h;
      this.renderedHTML_ != _ &&
        ((this.innerElement_.innerHTML = _), (this.renderedHTML_ = _)),
        this.renderedWidth_ != u &&
          ((this.innerElement_.style.width = u + "px"),
          (this.renderedWidth_ = u)),
        this.renderedVisible_ ||
          ((this.element.style.display = ""), (this.renderedVisible_ = !0));
    }
    createScaleBar(t, e, i) {
      const n = this.getScaleForResolution(),
        r =
          n < 1
            ? Math.round(1 / n).toLocaleString() + " : 1"
            : "1 : " + Math.round(n).toLocaleString(),
        s = this.scaleBarSteps_,
        o = t / s,
        a = [this.createMarker("absolute")];
      for (let n = 0; n < s; ++n) {
        const r =
          n % 2 == 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
        a.push(
          `<div><div class="ol-scale-singlebar ${r}" style="width: ${o}px;"></div>` +
            this.createMarker("relative") +
            (n % 2 == 0 || 2 === s ? this.createStepText(n, t, !1, e, i) : "") +
            "</div>"
        );
      }
      a.push(this.createStepText(s, t, !0, e, i));
      return (
        (this.scaleBarText_
          ? `<div class="ol-scale-text" style="width: ${t}px;">` + r + "</div>"
          : "") + a.join("")
      );
    }
    createMarker(t) {
      return `<div class="ol-scale-step-marker" style="position: ${t}; top: ${
        "absolute" === t ? 3 : -10
      }px;"></div>`;
    }
    createStepText(t, e, i, n, r) {
      const s =
        (0 === t ? 0 : Math.round((n / this.scaleBarSteps_) * t * 100) / 100) +
        (0 === t ? "" : " " + r);
      return (
        `<div class="ol-scale-step-text" style="margin-left: ${
          0 === t ? -3 : (e / this.scaleBarSteps_) * -1
        }px;text-align: ${0 === t ? "left" : "center"};min-width: ${
          0 === t ? 0 : (e / this.scaleBarSteps_) * 2
        }px;left: ${i ? e + "px" : "unset"};">` +
        s +
        "</div>"
      );
    }
    getScaleForResolution() {
      return (
        en(
          this.viewState_.projection,
          this.viewState_.resolution,
          this.viewState_.center,
          "m"
        ) *
        (1e3 / 25.4) *
        (this.dpi_ || Tl)
      );
    }
    render(t) {
      const e = t.frameState;
      (this.viewState_ = e ? e.viewState : null), this.updateElement_();
    }
  };
  const bl = 0,
    Fl = 1;
  var Il = class extends ca {
    constructor(e) {
      super({
        target: (e = e || {}).target,
        element: document.createElement("div"),
        render: e.render,
      }),
        (this.dragListenerKeys_ = []),
        (this.currentResolution_ = void 0),
        (this.direction_ = bl),
        this.dragging_,
        (this.heightLimit_ = 0),
        (this.widthLimit_ = 0),
        this.startX_,
        this.startY_,
        (this.thumbSize_ = null),
        (this.sliderInitialized_ = !1),
        (this.duration_ = void 0 !== e.duration ? e.duration : 200);
      const i = void 0 !== e.className ? e.className : "ol-zoomslider",
        n = document.createElement("button");
      n.setAttribute("type", "button"), (n.className = i + "-thumb " + ho);
      const r = this.element;
      (r.className = i + " " + ho + " " + uo),
        r.appendChild(n),
        r.addEventListener(Zo, this.handleDraggerStart_.bind(this), !1),
        r.addEventListener(Xo, this.handleDraggerDrag_.bind(this), !1),
        r.addEventListener(Ko, this.handleDraggerEnd_.bind(this), !1),
        r.addEventListener(w, this.handleContainerClick_.bind(this), !1),
        n.addEventListener(w, t, !1);
    }
    setMap(t) {
      super.setMap(t), t && t.render();
    }
    initSlider_() {
      const t = this.element;
      let e = t.offsetWidth,
        i = t.offsetHeight;
      if (0 === e && 0 === i) return (this.sliderInitialized_ = !1);
      const n = getComputedStyle(t);
      (e -= parseFloat(n.paddingRight) + parseFloat(n.paddingLeft)),
        (i -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom));
      const r = t.firstElementChild,
        s = getComputedStyle(r),
        o =
          r.offsetWidth + parseFloat(s.marginRight) + parseFloat(s.marginLeft),
        a =
          r.offsetHeight + parseFloat(s.marginTop) + parseFloat(s.marginBottom);
      return (
        (this.thumbSize_ = [o, a]),
        e > i
          ? ((this.direction_ = Fl), (this.widthLimit_ = e - o))
          : ((this.direction_ = bl), (this.heightLimit_ = i - a)),
        (this.sliderInitialized_ = !0)
      );
    }
    handleContainerClick_(t) {
      const e = this.getMap().getView(),
        i = this.getRelativePosition_(
          t.offsetX - this.thumbSize_[0] / 2,
          t.offsetY - this.thumbSize_[1] / 2
        ),
        n = this.getResolutionForPosition_(i),
        r = e.getConstrainedZoom(e.getZoomForResolution(n));
      e.animateInternal({ zoom: r, duration: this.duration_, easing: et });
    }
    handleDraggerStart_(t) {
      if (!this.dragging_ && t.target === this.element.firstElementChild) {
        const e = this.element.firstElementChild;
        if (
          (this.getMap().getView().beginInteraction(),
          (this.startX_ = t.clientX - parseFloat(e.style.left)),
          (this.startY_ = t.clientY - parseFloat(e.style.top)),
          (this.dragging_ = !0),
          0 === this.dragListenerKeys_.length)
        ) {
          const t = this.handleDraggerDrag_,
            e = this.handleDraggerEnd_,
            i = this.getMap().getOwnerDocument();
          this.dragListenerKeys_.push(M(i, Xo, t, this), M(i, Ko, e, this));
        }
      }
    }
    handleDraggerDrag_(t) {
      if (this.dragging_) {
        const e = t.clientX - this.startX_,
          i = t.clientY - this.startY_,
          n = this.getRelativePosition_(e, i);
        (this.currentResolution_ = this.getResolutionForPosition_(n)),
          this.getMap().getView().setResolution(this.currentResolution_);
      }
    }
    handleDraggerEnd_(t) {
      if (this.dragging_) {
        this.getMap().getView().endInteraction(),
          (this.dragging_ = !1),
          (this.startX_ = void 0),
          (this.startY_ = void 0),
          this.dragListenerKeys_.forEach(k),
          (this.dragListenerKeys_.length = 0);
      }
    }
    setThumbPosition_(t) {
      const e = this.getPositionForResolution_(t),
        i = this.element.firstElementChild;
      this.direction_ == Fl
        ? (i.style.left = this.widthLimit_ * e + "px")
        : (i.style.top = this.heightLimit_ * e + "px");
    }
    getRelativePosition_(t, e) {
      let i;
      return (
        (i =
          this.direction_ === Fl
            ? t / this.widthLimit_
            : e / this.heightLimit_),
        ui(i, 0, 1)
      );
    }
    getResolutionForPosition_(t) {
      return this.getMap().getView().getResolutionForValueFunction()(1 - t);
    }
    getPositionForResolution_(t) {
      return ui(
        1 - this.getMap().getView().getValueForResolutionFunction()(t),
        0,
        1
      );
    }
    render(t) {
      if (!t.frameState) return;
      if (!this.sliderInitialized_ && !this.initSlider_()) return;
      const e = t.frameState.viewState.resolution;
      (this.currentResolution_ = e), this.setThumbPosition_(e);
    }
  };
  var Ll = class extends ca {
    constructor(t) {
      (t = t || {}),
        super({ element: document.createElement("div"), target: t.target }),
        (this.extent = t.extent ? t.extent : null);
      const e = void 0 !== t.className ? t.className : "ol-zoom-extent",
        i = void 0 !== t.label ? t.label : "E",
        n = void 0 !== t.tipLabel ? t.tipLabel : "Fit to extent",
        r = document.createElement("button");
      r.setAttribute("type", "button"),
        (r.title = n),
        r.appendChild("string" == typeof i ? document.createTextNode(i) : i),
        r.addEventListener(w, this.handleClick_.bind(this), !1);
      const s = e + " " + ho + " " + uo,
        o = this.element;
      (o.className = s), o.appendChild(r);
    }
    handleClick_(t) {
      t.preventDefault(), this.handleZoomToExtent();
    }
    handleZoomToExtent() {
      const t = this.getMap().getView(),
        e = this.extent ? this.extent : t.getProjection().getExtent();
      t.fitInternal(br(e));
    }
  };
  class Ml {
    constructor(t) {
      (t = t || {}), (this.color_ = void 0 !== t.color ? t.color : null);
    }
    clone() {
      const t = this.getColor();
      return new Ml({ color: Array.isArray(t) ? t.slice() : t || void 0 });
    }
    getColor() {
      return this.color_;
    }
    setColor(t) {
      this.color_ = t;
    }
  }
  var Ol = Ml;
  function kl(t, e, i, n, s, o, a) {
    let l, h;
    const c = (i - e) / n;
    if (1 === c) l = e;
    else if (2 === c) (l = e), (h = s);
    else if (0 !== c) {
      let o = t[e],
        a = t[e + 1],
        c = 0;
      const u = [0];
      for (let r = e + n; r < i; r += n) {
        const e = t[r],
          i = t[r + 1];
        (c += Math.sqrt((e - o) * (e - o) + (i - a) * (i - a))),
          u.push(c),
          (o = e),
          (a = i);
      }
      const d = s * c,
        g = r(u, d);
      g < 0
        ? ((h = (d - u[-g - 2]) / (u[-g - 1] - u[-g - 2])),
          (l = e + (-g - 2) * n))
        : (l = e + g * n);
    }
    (a = a > 1 ? a : 2), (o = o || new Array(a));
    for (let e = 0; e < a; ++e)
      o[e] =
        void 0 === l
          ? NaN
          : void 0 === h
          ? t[l + e]
          : yi(t[l + e], t[l + n + e], h);
    return o;
  }
  function Al(t, e, i, n, r, s) {
    if (i == e) return null;
    let o;
    if (r < t[e + n - 1])
      return s ? ((o = t.slice(e, e + n)), (o[n - 1] = r), o) : null;
    if (t[i - 1] < r)
      return s ? ((o = t.slice(i - n, i)), (o[n - 1] = r), o) : null;
    if (r == t[e + n - 1]) return t.slice(e, e + n);
    let a = e / n,
      l = i / n;
    for (; a < l; ) {
      const e = (a + l) >> 1;
      r < t[(e + 1) * n - 1] ? (l = e) : (a = e + 1);
    }
    const h = t[a * n - 1];
    if (r == h) return t.slice((a - 1) * n, (a - 1) * n + n);
    const c = (r - h) / (t[(a + 1) * n - 1] - h);
    o = [];
    for (let e = 0; e < n - 1; ++e)
      o.push(yi(t[(a - 1) * n + e], t[a * n + e], c));
    return o.push(r), o;
  }
  function Nl(t, e, i, n, r, s, o) {
    if (o) return Al(t, e, i[i.length - 1], n, r, s);
    let a;
    if (r < t[n - 1])
      return s ? ((a = t.slice(0, n)), (a[n - 1] = r), a) : null;
    if (t[t.length - 1] < r)
      return s ? ((a = t.slice(t.length - n)), (a[n - 1] = r), a) : null;
    for (let s = 0, o = i.length; s < o; ++s) {
      const o = i[s];
      if (e != o) {
        if (r < t[e + n - 1]) return null;
        if (r <= t[o - 1]) return Al(t, e, o, n, r, !1);
        e = o;
      }
    }
    return null;
  }
  function Dl(t, e, i, n) {
    let r = t[e],
      s = t[e + 1],
      o = 0;
    for (let a = e + n; a < i; a += n) {
      const e = t[a],
        i = t[a + 1];
      (o += Math.sqrt((e - r) * (e - r) + (i - s) * (i - s))), (r = e), (s = i);
    }
    return o;
  }
  class Gl extends Ln {
    constructor(t, e) {
      super(),
        (this.flatMidpoint_ = null),
        (this.flatMidpointRevision_ = -1),
        (this.maxDelta_ = -1),
        (this.maxDeltaRevision_ = -1),
        void 0 === e || Array.isArray(t[0])
          ? this.setCoordinates(t, e)
          : this.setFlatCoordinates(e, t);
    }
    appendCoordinate(t) {
      this.flatCoordinates
        ? h(this.flatCoordinates, t)
        : (this.flatCoordinates = t.slice()),
        this.changed();
    }
    clone() {
      const t = new Gl(this.flatCoordinates.slice(), this.layout);
      return t.applyProperties(this), t;
    }
    closestPointXY(t, e, i, n) {
      return n < te(this.getExtent(), t, e)
        ? n
        : (this.maxDeltaRevision_ != this.getRevision() &&
            ((this.maxDelta_ = Math.sqrt(
              On(
                this.flatCoordinates,
                0,
                this.flatCoordinates.length,
                this.stride,
                0
              )
            )),
            (this.maxDeltaRevision_ = this.getRevision())),
          Nn(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride,
            this.maxDelta_,
            !1,
            t,
            e,
            i,
            n
          ));
    }
    forEachSegment(t) {
      return gr(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    getCoordinateAtM(t, e) {
      return "XYM" != this.layout && "XYZM" != this.layout
        ? null
        : ((e = void 0 !== e && e),
          Al(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride,
            t,
            e
          ));
    }
    getCoordinates() {
      return Qn(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    getCoordinateAt(t, e) {
      return kl(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t,
        e,
        this.stride
      );
    }
    getLength() {
      return Dl(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    getFlatMidpoint() {
      return (
        this.flatMidpointRevision_ != this.getRevision() &&
          ((this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_)),
          (this.flatMidpointRevision_ = this.getRevision())),
        this.flatMidpoint_
      );
    }
    getSimplifiedGeometryInternal(t) {
      const e = [];
      return (
        (e.length = qn(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          t,
          e,
          0
        )),
        new Gl(e, "XY")
      );
    }
    getType() {
      return "LineString";
    }
    intersectsExtent(t) {
      return fr(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        t
      );
    }
    setCoordinates(t, e) {
      this.setLayout(e, t, 1),
        this.flatCoordinates || (this.flatCoordinates = []),
        (this.flatCoordinates.length = jn(
          this.flatCoordinates,
          0,
          t,
          this.stride
        )),
        this.changed();
    }
  }
  var Bl = Gl;
  class jl {
    constructor(t) {
      (t = t || {}),
        (this.color_ = void 0 !== t.color ? t.color : null),
        (this.lineCap_ = t.lineCap),
        (this.lineDash_ = void 0 !== t.lineDash ? t.lineDash : null),
        (this.lineDashOffset_ = t.lineDashOffset),
        (this.lineJoin_ = t.lineJoin),
        (this.miterLimit_ = t.miterLimit),
        (this.width_ = t.width);
    }
    clone() {
      const t = this.getColor();
      return new jl({
        color: Array.isArray(t) ? t.slice() : t || void 0,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth(),
      });
    }
    getColor() {
      return this.color_;
    }
    getLineCap() {
      return this.lineCap_;
    }
    getLineDash() {
      return this.lineDash_;
    }
    getLineDashOffset() {
      return this.lineDashOffset_;
    }
    getLineJoin() {
      return this.lineJoin_;
    }
    getMiterLimit() {
      return this.miterLimit_;
    }
    getWidth() {
      return this.width_;
    }
    setColor(t) {
      this.color_ = t;
    }
    setLineCap(t) {
      this.lineCap_ = t;
    }
    setLineDash(t) {
      this.lineDash_ = t;
    }
    setLineDashOffset(t) {
      this.lineDashOffset_ = t;
    }
    setLineJoin(t) {
      this.lineJoin_ = t;
    }
    setMiterLimit(t) {
      this.miterLimit_ = t;
    }
    setWidth(t) {
      this.width_ = t;
    }
  }
  var zl = jl;
  class Ul {
    constructor(t) {
      (this.opacity_ = t.opacity),
        (this.rotateWithView_ = t.rotateWithView),
        (this.rotation_ = t.rotation),
        (this.scale_ = t.scale),
        (this.scaleArray_ = sl(t.scale)),
        (this.displacement_ = t.displacement),
        (this.declutterMode_ = t.declutterMode);
    }
    clone() {
      const t = this.getScale();
      return new Ul({
        opacity: this.getOpacity(),
        scale: Array.isArray(t) ? t.slice() : t,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode(),
      });
    }
    getOpacity() {
      return this.opacity_;
    }
    getRotateWithView() {
      return this.rotateWithView_;
    }
    getRotation() {
      return this.rotation_;
    }
    getScale() {
      return this.scale_;
    }
    getScaleArray() {
      return this.scaleArray_;
    }
    getDisplacement() {
      return this.displacement_;
    }
    getDeclutterMode() {
      return this.declutterMode_;
    }
    getAnchor() {
      return G();
    }
    getImage(t) {
      return G();
    }
    getHitDetectionImage() {
      return G();
    }
    getPixelRatio(t) {
      return 1;
    }
    getImageState() {
      return G();
    }
    getImageSize() {
      return G();
    }
    getOrigin() {
      return G();
    }
    getSize() {
      return G();
    }
    setDisplacement(t) {
      this.displacement_ = t;
    }
    setOpacity(t) {
      this.opacity_ = t;
    }
    setRotateWithView(t) {
      this.rotateWithView_ = t;
    }
    setRotation(t) {
      this.rotation_ = t;
    }
    setScale(t) {
      (this.scale_ = t), (this.scaleArray_ = sl(t));
    }
    listenImageChange(t) {
      G();
    }
    load() {
      G();
    }
    unlistenImageChange(t) {
      G();
    }
  }
  var ql = Ul;
  function Vl(t) {
    return Array.isArray(t) ? us(t) : t;
  }
  class Xl extends ql {
    constructor(t) {
      super({
        opacity: 1,
        rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView,
        rotation: void 0 !== t.rotation ? t.rotation : 0,
        scale: void 0 !== t.scale ? t.scale : 1,
        displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
        declutterMode: t.declutterMode,
      }),
        (this.canvas_ = void 0),
        (this.hitDetectionCanvas_ = null),
        (this.fill_ = void 0 !== t.fill ? t.fill : null),
        (this.origin_ = [0, 0]),
        (this.points_ = t.points),
        (this.radius_ = void 0 !== t.radius ? t.radius : t.radius1),
        (this.radius2_ = t.radius2),
        (this.angle_ = void 0 !== t.angle ? t.angle : 0),
        (this.stroke_ = void 0 !== t.stroke ? t.stroke : null),
        (this.size_ = null),
        (this.renderOptions_ = null),
        this.render();
    }
    clone() {
      const t = this.getScale(),
        e = new Xl({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(t) ? t.slice() : t,
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode(),
        });
      return e.setOpacity(this.getOpacity()), e;
    }
    getAnchor() {
      const t = this.size_;
      if (!t) return null;
      const e = this.getDisplacement(),
        i = this.getScaleArray();
      return [t[0] / 2 - e[0] / i[0], t[1] / 2 + e[1] / i[1]];
    }
    getAngle() {
      return this.angle_;
    }
    getFill() {
      return this.fill_;
    }
    setFill(t) {
      (this.fill_ = t), this.render();
    }
    getHitDetectionImage() {
      return (
        this.hitDetectionCanvas_ ||
          this.createHitDetectionCanvas_(this.renderOptions_),
        this.hitDetectionCanvas_
      );
    }
    getImage(t) {
      let e = this.canvas_[t];
      if (!e) {
        const i = this.renderOptions_,
          n = mt(i.size * t, i.size * t);
        this.draw_(i, n, t), (e = n.canvas), (this.canvas_[t] = e);
      }
      return e;
    }
    getPixelRatio(t) {
      return t;
    }
    getImageSize() {
      return this.size_;
    }
    getImageState() {
      return Zr;
    }
    getOrigin() {
      return this.origin_;
    }
    getPoints() {
      return this.points_;
    }
    getRadius() {
      return this.radius_;
    }
    getRadius2() {
      return this.radius2_;
    }
    getSize() {
      return this.size_;
    }
    getStroke() {
      return this.stroke_;
    }
    setStroke(t) {
      (this.stroke_ = t), this.render();
    }
    listenImageChange(t) {}
    load() {}
    unlistenImageChange(t) {}
    calculateLineJoinSize_(t, e, i) {
      if (0 === e || this.points_ === 1 / 0 || ("bevel" !== t && "miter" !== t))
        return e;
      let n = this.radius_,
        r = void 0 === this.radius2_ ? n : this.radius2_;
      if (n < r) {
        const t = n;
        (n = r), (r = t);
      }
      const s = void 0 === this.radius2_ ? this.points_ : 2 * this.points_,
        o = (2 * Math.PI) / s,
        a = r * Math.sin(o),
        l = n - Math.sqrt(r * r - a * a),
        h = Math.sqrt(a * a + l * l),
        c = h / a;
      if ("miter" === t && c <= i) return c * e;
      const u = e / 2 / c,
        d = (e / 2) * (l / h),
        g = Math.sqrt((n + u) * (n + u) + d * d) - n;
      if (void 0 === this.radius2_ || "bevel" === t) return 2 * g;
      const f = n * Math.sin(o),
        p = r - Math.sqrt(n * n - f * f),
        m = Math.sqrt(f * f + p * p) / f;
      if (m <= i) {
        const t = (m * e) / 2 - r - n;
        return 2 * Math.max(g, t);
      }
      return 2 * g;
    }
    createRenderOptions() {
      let t,
        e = xo,
        i = So,
        n = 0,
        r = null,
        s = 0,
        o = 0;
      this.stroke_ &&
        ((t = this.stroke_.getColor()),
        null === t && (t = wo),
        (t = Vl(t)),
        (o = this.stroke_.getWidth()),
        void 0 === o && (o = 1),
        (r = this.stroke_.getLineDash()),
        (s = this.stroke_.getLineDashOffset()),
        (i = this.stroke_.getLineJoin()),
        void 0 === i && (i = So),
        (e = this.stroke_.getLineCap()),
        void 0 === e && (e = xo),
        (n = this.stroke_.getMiterLimit()),
        void 0 === n && (n = Co));
      const a = this.calculateLineJoinSize_(i, o, n),
        l = Math.max(this.radius_, this.radius2_ || 0);
      return {
        strokeStyle: t,
        strokeWidth: o,
        size: Math.ceil(2 * l + a),
        lineCap: e,
        lineDash: r,
        lineDashOffset: s,
        lineJoin: i,
        miterLimit: n,
      };
    }
    render() {
      this.renderOptions_ = this.createRenderOptions();
      const t = this.renderOptions_.size;
      (this.canvas_ = {}), (this.size_ = [t, t]);
    }
    draw_(t, e, i) {
      if (
        (e.scale(i, i),
        e.translate(t.size / 2, t.size / 2),
        this.createPath_(e),
        this.fill_)
      ) {
        let t = this.fill_.getColor();
        null === t && (t = yo), (e.fillStyle = Vl(t)), e.fill();
      }
      this.stroke_ &&
        ((e.strokeStyle = t.strokeStyle),
        (e.lineWidth = t.strokeWidth),
        t.lineDash &&
          (e.setLineDash(t.lineDash), (e.lineDashOffset = t.lineDashOffset)),
        (e.lineCap = t.lineCap),
        (e.lineJoin = t.lineJoin),
        (e.miterLimit = t.miterLimit),
        e.stroke());
    }
    createHitDetectionCanvas_(t) {
      if (this.fill_) {
        let e = this.fill_.getColor(),
          i = 0;
        if (
          ("string" == typeof e && (e = hs(e)),
          null === e
            ? (i = 1)
            : Array.isArray(e) && (i = 4 === e.length ? e[3] : 1),
          0 === i)
        ) {
          const e = mt(t.size, t.size);
          (this.hitDetectionCanvas_ = e.canvas),
            this.drawHitDetectionCanvas_(t, e);
        }
      }
      this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1));
    }
    createPath_(t) {
      let e = this.points_;
      const i = this.radius_;
      if (e === 1 / 0) t.arc(0, 0, i, 0, 2 * Math.PI);
      else {
        const n = void 0 === this.radius2_ ? i : this.radius2_;
        void 0 !== this.radius2_ && (e *= 2);
        const r = this.angle_ - Math.PI / 2,
          s = (2 * Math.PI) / e;
        for (let o = 0; o < e; o++) {
          const e = r + o * s,
            a = o % 2 == 0 ? i : n;
          t.lineTo(a * Math.cos(e), a * Math.sin(e));
        }
        t.closePath();
      }
    }
    drawHitDetectionCanvas_(t, e) {
      e.translate(t.size / 2, t.size / 2),
        this.createPath_(e),
        (e.fillStyle = yo),
        e.fill(),
        this.stroke_ &&
          ((e.strokeStyle = t.strokeStyle),
          (e.lineWidth = t.strokeWidth),
          t.lineDash &&
            (e.setLineDash(t.lineDash), (e.lineDashOffset = t.lineDashOffset)),
          (e.lineJoin = t.lineJoin),
          (e.miterLimit = t.miterLimit),
          e.stroke());
    }
  }
  var Zl = Xl;
  class Kl extends Zl {
    constructor(t) {
      super({
        points: 1 / 0,
        fill: (t = t || { radius: 5 }).fill,
        radius: t.radius,
        stroke: t.stroke,
        scale: void 0 !== t.scale ? t.scale : 1,
        rotation: void 0 !== t.rotation ? t.rotation : 0,
        rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView,
        displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
        declutterMode: t.declutterMode,
      });
    }
    clone() {
      const t = this.getScale(),
        e = new Kl({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          radius: this.getRadius(),
          scale: Array.isArray(t) ? t.slice() : t,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode(),
        });
      return e.setOpacity(this.getOpacity()), e;
    }
    setRadius(t) {
      (this.radius_ = t), this.render();
    }
  }
  var Hl = Kl;
  class Yl {
    constructor(t) {
      (t = t || {}),
        (this.geometry_ = null),
        (this.geometryFunction_ = eh),
        void 0 !== t.geometry && this.setGeometry(t.geometry),
        (this.fill_ = void 0 !== t.fill ? t.fill : null),
        (this.image_ = void 0 !== t.image ? t.image : null),
        (this.renderer_ = void 0 !== t.renderer ? t.renderer : null),
        (this.hitDetectionRenderer_ =
          void 0 !== t.hitDetectionRenderer ? t.hitDetectionRenderer : null),
        (this.stroke_ = void 0 !== t.stroke ? t.stroke : null),
        (this.text_ = void 0 !== t.text ? t.text : null),
        (this.zIndex_ = t.zIndex);
    }
    clone() {
      let t = this.getGeometry();
      return (
        t && "object" == typeof t && (t = t.clone()),
        new Yl({
          geometry: t,
          fill: this.getFill() ? this.getFill().clone() : void 0,
          image: this.getImage() ? this.getImage().clone() : void 0,
          renderer: this.getRenderer(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          text: this.getText() ? this.getText().clone() : void 0,
          zIndex: this.getZIndex(),
        })
      );
    }
    getRenderer() {
      return this.renderer_;
    }
    setRenderer(t) {
      this.renderer_ = t;
    }
    setHitDetectionRenderer(t) {
      this.hitDetectionRenderer_ = t;
    }
    getHitDetectionRenderer() {
      return this.hitDetectionRenderer_;
    }
    getGeometry() {
      return this.geometry_;
    }
    getGeometryFunction() {
      return this.geometryFunction_;
    }
    getFill() {
      return this.fill_;
    }
    setFill(t) {
      this.fill_ = t;
    }
    getImage() {
      return this.image_;
    }
    setImage(t) {
      this.image_ = t;
    }
    getStroke() {
      return this.stroke_;
    }
    setStroke(t) {
      this.stroke_ = t;
    }
    getText() {
      return this.text_;
    }
    setText(t) {
      this.text_ = t;
    }
    getZIndex() {
      return this.zIndex_;
    }
    setGeometry(t) {
      "function" == typeof t
        ? (this.geometryFunction_ = t)
        : "string" == typeof t
        ? (this.geometryFunction_ = function (e) {
            return e.get(t);
          })
        : t
        ? void 0 !== t &&
          (this.geometryFunction_ = function () {
            return t;
          })
        : (this.geometryFunction_ = eh),
        (this.geometry_ = t);
    }
    setZIndex(t) {
      this.zIndex_ = t;
    }
  }
  function Ql(t) {
    let e;
    if ("function" == typeof t) e = t;
    else {
      let i;
      if (Array.isArray(t)) i = t;
      else {
        Ft(
          "function" == typeof t.getZIndex,
          "Expected an `Style` or an array of `Style`"
        );
        i = [t];
      }
      e = function () {
        return i;
      };
    }
    return e;
  }
  let $l = null;
  function Jl(t, e) {
    if (!$l) {
      const t = new Ol({ color: "rgba(255,255,255,0.4)" }),
        e = new zl({ color: "#3399CC", width: 1.25 });
      $l = [
        new Yl({
          image: new Hl({ fill: t, stroke: e, radius: 5 }),
          fill: t,
          stroke: e,
        }),
      ];
    }
    return $l;
  }
  function th() {
    const t = {},
      e = [255, 255, 255, 1],
      i = [0, 153, 255, 1];
    return (
      (t.Polygon = [new Yl({ fill: new Ol({ color: [255, 255, 255, 0.5] }) })]),
      (t.MultiPolygon = t.Polygon),
      (t.LineString = [
        new Yl({ stroke: new zl({ color: e, width: 5 }) }),
        new Yl({ stroke: new zl({ color: i, width: 3 }) }),
      ]),
      (t.MultiLineString = t.LineString),
      (t.Circle = t.Polygon.concat(t.LineString)),
      (t.Point = [
        new Yl({
          image: new Hl({
            radius: 6,
            fill: new Ol({ color: i }),
            stroke: new zl({ color: e, width: 1.5 }),
          }),
          zIndex: 1 / 0,
        }),
      ]),
      (t.MultiPoint = t.Point),
      (t.GeometryCollection = t.Polygon.concat(t.LineString, t.Point)),
      t
    );
  }
  function eh(t) {
    return t.getGeometry();
  }
  var ih = Yl;
  class nh {
    constructor(t) {
      (t = t || {}),
        (this.font_ = t.font),
        (this.rotation_ = t.rotation),
        (this.rotateWithView_ = t.rotateWithView),
        (this.scale_ = t.scale),
        (this.scaleArray_ = sl(void 0 !== t.scale ? t.scale : 1)),
        (this.text_ = t.text),
        (this.textAlign_ = t.textAlign),
        (this.justify_ = t.justify),
        (this.repeat_ = t.repeat),
        (this.textBaseline_ = t.textBaseline),
        (this.fill_ = void 0 !== t.fill ? t.fill : new Ol({ color: "#333" })),
        (this.maxAngle_ = void 0 !== t.maxAngle ? t.maxAngle : Math.PI / 4),
        (this.placement_ = void 0 !== t.placement ? t.placement : "point"),
        (this.overflow_ = !!t.overflow),
        (this.stroke_ = void 0 !== t.stroke ? t.stroke : null),
        (this.offsetX_ = void 0 !== t.offsetX ? t.offsetX : 0),
        (this.offsetY_ = void 0 !== t.offsetY ? t.offsetY : 0),
        (this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null),
        (this.backgroundStroke_ = t.backgroundStroke
          ? t.backgroundStroke
          : null),
        (this.padding_ = void 0 === t.padding ? null : t.padding);
    }
    clone() {
      const t = this.getScale();
      return new nh({
        font: this.getFont(),
        placement: this.getPlacement(),
        repeat: this.getRepeat(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(t) ? t.slice() : t,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill()
          ? this.getBackgroundFill().clone()
          : void 0,
        backgroundStroke: this.getBackgroundStroke()
          ? this.getBackgroundStroke().clone()
          : void 0,
        padding: this.getPadding() || void 0,
      });
    }
    getOverflow() {
      return this.overflow_;
    }
    getFont() {
      return this.font_;
    }
    getMaxAngle() {
      return this.maxAngle_;
    }
    getPlacement() {
      return this.placement_;
    }
    getRepeat() {
      return this.repeat_;
    }
    getOffsetX() {
      return this.offsetX_;
    }
    getOffsetY() {
      return this.offsetY_;
    }
    getFill() {
      return this.fill_;
    }
    getRotateWithView() {
      return this.rotateWithView_;
    }
    getRotation() {
      return this.rotation_;
    }
    getScale() {
      return this.scale_;
    }
    getScaleArray() {
      return this.scaleArray_;
    }
    getStroke() {
      return this.stroke_;
    }
    getText() {
      return this.text_;
    }
    getTextAlign() {
      return this.textAlign_;
    }
    getJustify() {
      return this.justify_;
    }
    getTextBaseline() {
      return this.textBaseline_;
    }
    getBackgroundFill() {
      return this.backgroundFill_;
    }
    getBackgroundStroke() {
      return this.backgroundStroke_;
    }
    getPadding() {
      return this.padding_;
    }
    setOverflow(t) {
      this.overflow_ = t;
    }
    setFont(t) {
      this.font_ = t;
    }
    setMaxAngle(t) {
      this.maxAngle_ = t;
    }
    setOffsetX(t) {
      this.offsetX_ = t;
    }
    setOffsetY(t) {
      this.offsetY_ = t;
    }
    setPlacement(t) {
      this.placement_ = t;
    }
    setRepeat(t) {
      this.repeat_ = t;
    }
    setRotateWithView(t) {
      this.rotateWithView_ = t;
    }
    setFill(t) {
      this.fill_ = t;
    }
    setRotation(t) {
      this.rotation_ = t;
    }
    setScale(t) {
      (this.scale_ = t), (this.scaleArray_ = sl(void 0 !== t ? t : 1));
    }
    setStroke(t) {
      this.stroke_ = t;
    }
    setText(t) {
      this.text_ = t;
    }
    setTextAlign(t) {
      this.textAlign_ = t;
    }
    setJustify(t) {
      this.justify_ = t;
    }
    setTextBaseline(t) {
      this.textBaseline_ = t;
    }
    setBackgroundFill(t) {
      this.backgroundFill_ = t;
    }
    setBackgroundStroke(t) {
      this.backgroundStroke_ = t;
    }
    setPadding(t) {
      this.padding_ = t;
    }
  }
  var rh = nh;
  function sh(t, e, i, n, r) {
    oh(t, e, i || 0, n || t.length - 1, r || lh);
  }
  function oh(t, e, i, n, r) {
    for (; n > i; ) {
      if (n - i > 600) {
        var s = n - i + 1,
          o = e - i + 1,
          a = Math.log(s),
          l = 0.5 * Math.exp((2 * a) / 3),
          h = 0.5 * Math.sqrt((a * l * (s - l)) / s) * (o - s / 2 < 0 ? -1 : 1);
        oh(
          t,
          e,
          Math.max(i, Math.floor(e - (o * l) / s + h)),
          Math.min(n, Math.floor(e + ((s - o) * l) / s + h)),
          r
        );
      }
      var c = t[e],
        u = i,
        d = n;
      for (ah(t, i, e), r(t[n], c) > 0 && ah(t, i, n); u < d; ) {
        for (ah(t, u, d), u++, d--; r(t[u], c) < 0; ) u++;
        for (; r(t[d], c) > 0; ) d--;
      }
      0 === r(t[i], c) ? ah(t, i, d) : ah(t, ++d, n),
        d <= e && (i = d + 1),
        e <= d && (n = d - 1);
    }
  }
  function ah(t, e, i) {
    var n = t[e];
    (t[e] = t[i]), (t[i] = n);
  }
  function lh(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  let hh = class {
    constructor(t = 9) {
      (this._maxEntries = Math.max(4, t)),
        (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
        this.clear();
    }
    all() {
      return this._all(this.data, []);
    }
    search(t) {
      let e = this.data;
      const i = [];
      if (!vh(t, e)) return i;
      const n = this.toBBox,
        r = [];
      for (; e; ) {
        for (let s = 0; s < e.children.length; s++) {
          const o = e.children[s],
            a = e.leaf ? n(o) : o;
          vh(t, a) &&
            (e.leaf ? i.push(o) : xh(t, a) ? this._all(o, i) : r.push(o));
        }
        e = r.pop();
      }
      return i;
    }
    collides(t) {
      let e = this.data;
      if (!vh(t, e)) return !1;
      const i = [];
      for (; e; ) {
        for (let n = 0; n < e.children.length; n++) {
          const r = e.children[n],
            s = e.leaf ? this.toBBox(r) : r;
          if (vh(t, s)) {
            if (e.leaf || xh(t, s)) return !0;
            i.push(r);
          }
        }
        e = i.pop();
      }
      return !1;
    }
    load(t) {
      if (!t || !t.length) return this;
      if (t.length < this._minEntries) {
        for (let e = 0; e < t.length; e++) this.insert(t[e]);
        return this;
      }
      let e = this._build(t.slice(), 0, t.length - 1, 0);
      if (this.data.children.length)
        if (this.data.height === e.height) this._splitRoot(this.data, e);
        else {
          if (this.data.height < e.height) {
            const t = this.data;
            (this.data = e), (e = t);
          }
          this._insert(e, this.data.height - e.height - 1, !0);
        }
      else this.data = e;
      return this;
    }
    insert(t) {
      return t && this._insert(t, this.data.height - 1), this;
    }
    clear() {
      return (this.data = Sh([])), this;
    }
    remove(t, e) {
      if (!t) return this;
      let i = this.data;
      const n = this.toBBox(t),
        r = [],
        s = [];
      let o, a, l;
      for (; i || r.length; ) {
        if (
          (i || ((i = r.pop()), (a = r[r.length - 1]), (o = s.pop()), (l = !0)),
          i.leaf)
        ) {
          const n = ch(t, i.children, e);
          if (-1 !== n)
            return i.children.splice(n, 1), r.push(i), this._condense(r), this;
        }
        l || i.leaf || !xh(i, n)
          ? a
            ? (o++, (i = a.children[o]), (l = !1))
            : (i = null)
          : (r.push(i), s.push(o), (o = 0), (a = i), (i = i.children[0]));
      }
      return this;
    }
    toBBox(t) {
      return t;
    }
    compareMinX(t, e) {
      return t.minX - e.minX;
    }
    compareMinY(t, e) {
      return t.minY - e.minY;
    }
    toJSON() {
      return this.data;
    }
    fromJSON(t) {
      return (this.data = t), this;
    }
    _all(t, e) {
      const i = [];
      for (; t; )
        t.leaf ? e.push(...t.children) : i.push(...t.children), (t = i.pop());
      return e;
    }
    _build(t, e, i, n) {
      const r = i - e + 1;
      let s,
        o = this._maxEntries;
      if (r <= o) return (s = Sh(t.slice(e, i + 1))), uh(s, this.toBBox), s;
      n ||
        ((n = Math.ceil(Math.log(r) / Math.log(o))),
        (o = Math.ceil(r / Math.pow(o, n - 1)))),
        (s = Sh([])),
        (s.leaf = !1),
        (s.height = n);
      const a = Math.ceil(r / o),
        l = a * Math.ceil(Math.sqrt(o));
      Ch(t, e, i, l, this.compareMinX);
      for (let r = e; r <= i; r += l) {
        const e = Math.min(r + l - 1, i);
        Ch(t, r, e, a, this.compareMinY);
        for (let i = r; i <= e; i += a) {
          const r = Math.min(i + a - 1, e);
          s.children.push(this._build(t, i, r, n - 1));
        }
      }
      return uh(s, this.toBBox), s;
    }
    _chooseSubtree(t, e, i, n) {
      for (; n.push(e), !e.leaf && n.length - 1 !== i; ) {
        let i,
          n = 1 / 0,
          o = 1 / 0;
        for (let a = 0; a < e.children.length; a++) {
          const l = e.children[a],
            h = mh(l),
            c =
              ((r = t),
              (s = l),
              (Math.max(s.maxX, r.maxX) - Math.min(s.minX, r.minX)) *
                (Math.max(s.maxY, r.maxY) - Math.min(s.minY, r.minY)) -
                h);
          c < o
            ? ((o = c), (n = h < n ? h : n), (i = l))
            : c === o && h < n && ((n = h), (i = l));
        }
        e = i || e.children[0];
      }
      var r, s;
      return e;
    }
    _insert(t, e, i) {
      const n = i ? t : this.toBBox(t),
        r = [],
        s = this._chooseSubtree(n, this.data, e, r);
      for (
        s.children.push(t), gh(s, n);
        e >= 0 && r[e].children.length > this._maxEntries;

      )
        this._split(r, e), e--;
      this._adjustParentBBoxes(n, r, e);
    }
    _split(t, e) {
      const i = t[e],
        n = i.children.length,
        r = this._minEntries;
      this._chooseSplitAxis(i, r, n);
      const s = this._chooseSplitIndex(i, r, n),
        o = Sh(i.children.splice(s, i.children.length - s));
      (o.height = i.height),
        (o.leaf = i.leaf),
        uh(i, this.toBBox),
        uh(o, this.toBBox),
        e ? t[e - 1].children.push(o) : this._splitRoot(i, o);
    }
    _splitRoot(t, e) {
      (this.data = Sh([t, e])),
        (this.data.height = t.height + 1),
        (this.data.leaf = !1),
        uh(this.data, this.toBBox);
    }
    _chooseSplitIndex(t, e, i) {
      let n,
        r = 1 / 0,
        s = 1 / 0;
      for (let o = e; o <= i - e; o++) {
        const e = dh(t, 0, o, this.toBBox),
          a = dh(t, o, i, this.toBBox),
          l = yh(e, a),
          h = mh(e) + mh(a);
        l < r
          ? ((r = l), (n = o), (s = h < s ? h : s))
          : l === r && h < s && ((s = h), (n = o));
      }
      return n || i - e;
    }
    _chooseSplitAxis(t, e, i) {
      const n = t.leaf ? this.compareMinX : fh,
        r = t.leaf ? this.compareMinY : ph;
      this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, r) &&
        t.children.sort(n);
    }
    _allDistMargin(t, e, i, n) {
      t.children.sort(n);
      const r = this.toBBox,
        s = dh(t, 0, e, r),
        o = dh(t, i - e, i, r);
      let a = _h(s) + _h(o);
      for (let n = e; n < i - e; n++) {
        const e = t.children[n];
        gh(s, t.leaf ? r(e) : e), (a += _h(s));
      }
      for (let n = i - e - 1; n >= e; n--) {
        const e = t.children[n];
        gh(o, t.leaf ? r(e) : e), (a += _h(o));
      }
      return a;
    }
    _adjustParentBBoxes(t, e, i) {
      for (let n = i; n >= 0; n--) gh(e[n], t);
    }
    _condense(t) {
      for (let e, i = t.length - 1; i >= 0; i--)
        0 === t[i].children.length
          ? i > 0
            ? ((e = t[i - 1].children), e.splice(e.indexOf(t[i]), 1))
            : this.clear()
          : uh(t[i], this.toBBox);
    }
  };
  function ch(t, e, i) {
    if (!i) return e.indexOf(t);
    for (let n = 0; n < e.length; n++) if (i(t, e[n])) return n;
    return -1;
  }
  function uh(t, e) {
    dh(t, 0, t.children.length, e, t);
  }
  function dh(t, e, i, n, r) {
    r || (r = Sh(null)),
      (r.minX = 1 / 0),
      (r.minY = 1 / 0),
      (r.maxX = -1 / 0),
      (r.maxY = -1 / 0);
    for (let s = e; s < i; s++) {
      const e = t.children[s];
      gh(r, t.leaf ? n(e) : e);
    }
    return r;
  }
  function gh(t, e) {
    return (
      (t.minX = Math.min(t.minX, e.minX)),
      (t.minY = Math.min(t.minY, e.minY)),
      (t.maxX = Math.max(t.maxX, e.maxX)),
      (t.maxY = Math.max(t.maxY, e.maxY)),
      t
    );
  }
  function fh(t, e) {
    return t.minX - e.minX;
  }
  function ph(t, e) {
    return t.minY - e.minY;
  }
  function mh(t) {
    return (t.maxX - t.minX) * (t.maxY - t.minY);
  }
  function _h(t) {
    return t.maxX - t.minX + (t.maxY - t.minY);
  }
  function yh(t, e) {
    const i = Math.max(t.minX, e.minX),
      n = Math.max(t.minY, e.minY),
      r = Math.min(t.maxX, e.maxX),
      s = Math.min(t.maxY, e.maxY);
    return Math.max(0, r - i) * Math.max(0, s - n);
  }
  function xh(t, e) {
    return (
      t.minX <= e.minX &&
      t.minY <= e.minY &&
      e.maxX <= t.maxX &&
      e.maxY <= t.maxY
    );
  }
  function vh(t, e) {
    return (
      e.minX <= t.maxX &&
      e.minY <= t.maxY &&
      e.maxX >= t.minX &&
      e.maxY >= t.minY
    );
  }
  function Sh(t) {
    return {
      children: t,
      height: 1,
      leaf: !0,
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: -1 / 0,
      maxY: -1 / 0,
    };
  }
  function Ch(t, e, i, n, r) {
    const s = [e, i];
    for (; s.length; ) {
      if ((i = s.pop()) - (e = s.pop()) <= n) continue;
      const o = e + Math.ceil((i - e) / n / 2) * n;
      sh(t, o, e, i, r), s.push(e, o, o, i);
    }
  }
  let wh = null;
  class Wh extends x {
    constructor(t, e, i, n, r) {
      super(),
        (this.hitDetectionImage_ = null),
        (this.image_ = t),
        (this.crossOrigin_ = i),
        (this.canvas_ = {}),
        (this.color_ = r),
        (this.imageState_ = void 0 === n ? Vr : n),
        (this.size_ = t && t.width && t.height ? [t.width, t.height] : null),
        (this.src_ = e),
        this.tainted_;
    }
    initializeImage_() {
      (this.image_ = new Image()),
        null !== this.crossOrigin_ &&
          (this.image_.crossOrigin = this.crossOrigin_);
    }
    isTainted_() {
      if (void 0 === this.tainted_ && this.imageState_ === Zr) {
        wh || (wh = mt(1, 1, void 0, { willReadFrequently: !0 })),
          wh.drawImage(this.image_, 0, 0);
        try {
          wh.getImageData(0, 0, 1, 1), (this.tainted_ = !1);
        } catch (t) {
          (wh = null), (this.tainted_ = !0);
        }
      }
      return !0 === this.tainted_;
    }
    dispatchChangeEvent_() {
      this.dispatchEvent(v);
    }
    handleImageError_() {
      (this.imageState_ = Kr), this.dispatchChangeEvent_();
    }
    handleImageLoad_() {
      (this.imageState_ = Zr),
        (this.size_ = [this.image_.width, this.image_.height]),
        this.dispatchChangeEvent_();
    }
    getImage(t) {
      return (
        this.image_ || this.initializeImage_(),
        this.replaceColor_(t),
        this.canvas_[t] ? this.canvas_[t] : this.image_
      );
    }
    getPixelRatio(t) {
      return this.replaceColor_(t), this.canvas_[t] ? t : 1;
    }
    getImageState() {
      return this.imageState_;
    }
    getHitDetectionImage() {
      if ((this.image_ || this.initializeImage_(), !this.hitDetectionImage_))
        if (this.isTainted_()) {
          const t = this.size_[0],
            e = this.size_[1],
            i = mt(t, e);
          i.fillRect(0, 0, t, e), (this.hitDetectionImage_ = i.canvas);
        } else this.hitDetectionImage_ = this.image_;
      return this.hitDetectionImage_;
    }
    getSize() {
      return this.size_;
    }
    getSrc() {
      return this.src_;
    }
    load() {
      if (this.imageState_ === Vr) {
        this.image_ || this.initializeImage_(), (this.imageState_ = Xr);
        try {
          void 0 !== this.src_ && (this.image_.src = this.src_);
        } catch (t) {
          this.handleImageError_();
        }
        this.image_ instanceof HTMLImageElement &&
          $r(this.image_, this.src_)
            .then((t) => {
              (this.image_ = t), this.handleImageLoad_();
            })
            .catch(this.handleImageError_.bind(this));
      }
    }
    replaceColor_(t) {
      if (!this.color_ || this.canvas_[t] || this.imageState_ !== Zr) return;
      const e = this.image_,
        i = document.createElement("canvas");
      (i.width = Math.ceil(e.width * t)), (i.height = Math.ceil(e.height * t));
      const n = i.getContext("2d");
      n.scale(t, t),
        n.drawImage(e, 0, 0),
        (n.globalCompositeOperation = "multiply"),
        (n.fillStyle = os(this.color_)),
        n.fillRect(0, 0, i.width / t, i.height / t),
        (n.globalCompositeOperation = "destination-in"),
        n.drawImage(e, 0, 0),
        (this.canvas_[t] = i);
    }
  }
  function Eh(t, e, i, n, r) {
    let s = void 0 === e ? void 0 : ms.get(e, i, r);
    return (
      s ||
        ((s = new Wh(
          t,
          t instanceof HTMLImageElement ? t.src || void 0 : e,
          i,
          n,
          r
        )),
        ms.set(e, i, r, s)),
      s
    );
  }
  var Rh = Wh;
  function Th(t, e, i, n) {
    return void 0 !== i && void 0 !== n
      ? [i / t, n / e]
      : void 0 !== i
      ? i / t
      : void 0 !== n
      ? n / e
      : 1;
  }
  class Ph extends ql {
    constructor(t) {
      const e = void 0 !== (t = t || {}).opacity ? t.opacity : 1,
        i = void 0 !== t.rotation ? t.rotation : 0,
        n = void 0 !== t.scale ? t.scale : 1,
        r = void 0 !== t.rotateWithView && t.rotateWithView;
      super({
        opacity: e,
        rotation: i,
        scale: n,
        displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
        rotateWithView: r,
        declutterMode: t.declutterMode,
      }),
        (this.anchor_ = void 0 !== t.anchor ? t.anchor : [0.5, 0.5]),
        (this.normalizedAnchor_ = null),
        (this.anchorOrigin_ =
          void 0 !== t.anchorOrigin ? t.anchorOrigin : "top-left"),
        (this.anchorXUnits_ =
          void 0 !== t.anchorXUnits ? t.anchorXUnits : "fraction"),
        (this.anchorYUnits_ =
          void 0 !== t.anchorYUnits ? t.anchorYUnits : "fraction"),
        (this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null);
      const s = void 0 !== t.img ? t.img : null;
      let o,
        a = t.src;
      if (
        (Ft(
          !(void 0 !== a && s),
          "`image` and `src` cannot be provided at the same time"
        ),
        (void 0 !== a && 0 !== a.length) || !s || (a = s.src || j(s)),
        Ft(
          void 0 !== a && a.length > 0,
          "A defined and non-empty `src` or `image` must be provided"
        ),
        Ft(
          !((void 0 !== t.width || void 0 !== t.height) && void 0 !== t.scale),
          "`width` or `height` cannot be provided together with `scale`"
        ),
        void 0 !== t.src
          ? (o = Vr)
          : void 0 !== s &&
            (o =
              s instanceof HTMLImageElement
                ? s.complete
                  ? s.src
                    ? Zr
                    : Vr
                  : Xr
                : Zr),
        (this.color_ = void 0 !== t.color ? hs(t.color) : null),
        (this.iconImage_ = Eh(s, a, this.crossOrigin_, o, this.color_)),
        (this.offset_ = void 0 !== t.offset ? t.offset : [0, 0]),
        (this.offsetOrigin_ =
          void 0 !== t.offsetOrigin ? t.offsetOrigin : "top-left"),
        (this.origin_ = null),
        (this.size_ = void 0 !== t.size ? t.size : null),
        void 0 !== t.width || void 0 !== t.height)
      ) {
        let e, i;
        if (t.size) [e, i] = t.size;
        else {
          const n = this.getImage(1);
          if (n.width && n.height) (e = n.width), (i = n.height);
          else if (n instanceof HTMLImageElement) {
            this.initialOptions_ = t;
            const e = () => {
              if ((this.unlistenImageChange(e), !this.initialOptions_)) return;
              const i = this.iconImage_.getSize();
              this.setScale(Th(i[0], i[1], t.width, t.height));
            };
            return void this.listenImageChange(e);
          }
        }
        void 0 !== e && this.setScale(Th(e, i, t.width, t.height));
      }
    }
    clone() {
      let t, e, i;
      return (
        this.initialOptions_
          ? ((e = this.initialOptions_.width),
            (i = this.initialOptions_.height))
          : ((t = this.getScale()), (t = Array.isArray(t) ? t.slice() : t)),
        new Ph({
          anchor: this.anchor_.slice(),
          anchorOrigin: this.anchorOrigin_,
          anchorXUnits: this.anchorXUnits_,
          anchorYUnits: this.anchorYUnits_,
          color:
            this.color_ && this.color_.slice
              ? this.color_.slice()
              : this.color_ || void 0,
          crossOrigin: this.crossOrigin_,
          offset: this.offset_.slice(),
          offsetOrigin: this.offsetOrigin_,
          opacity: this.getOpacity(),
          rotateWithView: this.getRotateWithView(),
          rotation: this.getRotation(),
          scale: t,
          width: e,
          height: i,
          size: null !== this.size_ ? this.size_.slice() : void 0,
          src: this.getSrc(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode(),
        })
      );
    }
    getAnchor() {
      let t = this.normalizedAnchor_;
      if (!t) {
        t = this.anchor_;
        const e = this.getSize();
        if (
          "fraction" == this.anchorXUnits_ ||
          "fraction" == this.anchorYUnits_
        ) {
          if (!e) return null;
          (t = this.anchor_.slice()),
            "fraction" == this.anchorXUnits_ && (t[0] *= e[0]),
            "fraction" == this.anchorYUnits_ && (t[1] *= e[1]);
        }
        if ("top-left" != this.anchorOrigin_) {
          if (!e) return null;
          t === this.anchor_ && (t = this.anchor_.slice()),
            ("top-right" != this.anchorOrigin_ &&
              "bottom-right" != this.anchorOrigin_) ||
              (t[0] = -t[0] + e[0]),
            ("bottom-left" != this.anchorOrigin_ &&
              "bottom-right" != this.anchorOrigin_) ||
              (t[1] = -t[1] + e[1]);
        }
        this.normalizedAnchor_ = t;
      }
      const e = this.getDisplacement(),
        i = this.getScaleArray();
      return [t[0] - e[0] / i[0], t[1] + e[1] / i[1]];
    }
    setAnchor(t) {
      (this.anchor_ = t), (this.normalizedAnchor_ = null);
    }
    getColor() {
      return this.color_;
    }
    getImage(t) {
      return this.iconImage_.getImage(t);
    }
    getPixelRatio(t) {
      return this.iconImage_.getPixelRatio(t);
    }
    getImageSize() {
      return this.iconImage_.getSize();
    }
    getImageState() {
      return this.iconImage_.getImageState();
    }
    getHitDetectionImage() {
      return this.iconImage_.getHitDetectionImage();
    }
    getOrigin() {
      if (this.origin_) return this.origin_;
      let t = this.offset_;
      if ("top-left" != this.offsetOrigin_) {
        const e = this.getSize(),
          i = this.iconImage_.getSize();
        if (!e || !i) return null;
        (t = t.slice()),
          ("top-right" != this.offsetOrigin_ &&
            "bottom-right" != this.offsetOrigin_) ||
            (t[0] = i[0] - e[0] - t[0]),
          ("bottom-left" != this.offsetOrigin_ &&
            "bottom-right" != this.offsetOrigin_) ||
            (t[1] = i[1] - e[1] - t[1]);
      }
      return (this.origin_ = t), this.origin_;
    }
    getSrc() {
      return this.iconImage_.getSrc();
    }
    getSize() {
      return this.size_ ? this.size_ : this.iconImage_.getSize();
    }
    getWidth() {
      const t = this.getScaleArray();
      return this.size_
        ? this.size_[0] * t[0]
        : this.iconImage_.getImageState() == Zr
        ? this.iconImage_.getSize()[0] * t[0]
        : void 0;
    }
    getHeight() {
      const t = this.getScaleArray();
      return this.size_
        ? this.size_[1] * t[1]
        : this.iconImage_.getImageState() == Zr
        ? this.iconImage_.getSize()[1] * t[1]
        : void 0;
    }
    setScale(t) {
      delete this.initialOptions_, super.setScale(t);
    }
    listenImageChange(t) {
      this.iconImage_.addEventListener(v, t);
    }
    load() {
      this.iconImage_.load();
    }
    unlistenImageChange(t) {
      this.iconImage_.removeEventListener(v, t);
    }
  }
  var bh = Ph;
  let Fh = 0;
  const Ih = 1 << Fh++,
    Lh = 1 << Fh++,
    Mh = 1 << Fh++,
    Oh = 1 << Fh++,
    kh = 1 << Fh++,
    Ah = Math.pow(2, 5) - 1,
    Nh = {
      [Ih]: "boolean",
      [Lh]: "number",
      [Mh]: "string",
      [Oh]: "color",
      [kh]: "number[]",
    },
    Dh = Object.keys(Nh).map(Number).sort(s);
  function Gh(t) {
    const e = [];
    for (const i of Dh) Bh(t, i) && e.push(Nh[i]);
    return 0 === e.length
      ? "untyped"
      : e.length < 3
      ? e.join(" or ")
      : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
  }
  function Bh(t, e) {
    return (t & e) === e;
  }
  function jh(t, e) {
    return !!(t & e);
  }
  class zh {
    constructor(t, e) {
      (this.type = t), (this.value = e);
    }
  }
  class Uh {
    constructor(t, e, ...i) {
      (this.type = t), (this.operator = e), (this.args = i);
    }
  }
  function qh() {
    return { variables: new Set(), properties: new Set() };
  }
  function Vh(t, e) {
    switch (typeof t) {
      case "boolean":
        return new zh(Ih, t);
      case "number":
        return new zh(Lh, t);
      case "string":
        return new zh(Mh, t);
    }
    if (!Array.isArray(t))
      throw new Error("Expression must be an array or a primitive value");
    if (0 === t.length) throw new Error("Empty expression");
    if ("string" == typeof t[0])
      return (function (t, e) {
        const i = t[0],
          n = Zh[i];
        if (!n) throw new Error(`Unknown operator: ${i}`);
        return n(t, e);
      })(t, e);
    for (const e of t)
      if ("number" != typeof e) throw new Error("Expected an array of numbers");
    let i = kh;
    return (3 !== t.length && 4 !== t.length) || (i |= Oh), new zh(i, t);
  }
  const Xh = {
      Number: "number",
      String: "string",
      Get: "get",
      Var: "var",
      Any: "any",
      All: "all",
      Not: "!",
      Resolution: "resolution",
      Equal: "==",
      NotEqual: "!=",
      GreaterThan: ">",
      GreaterThanOrEqualTo: ">=",
      LessThan: "<",
      LessThanOrEqualTo: "<=",
      Multiply: "*",
      Divide: "/",
      Add: "+",
      Subtract: "-",
      Clamp: "clamp",
      Mod: "%",
      Pow: "^",
      Abs: "abs",
      Floor: "floor",
      Ceil: "ceil",
      Round: "round",
      Sin: "sin",
      Cos: "cos",
      Atan: "atan",
      Sqrt: "sqrt",
      Match: "match",
    },
    Zh = {
      [Xh.Number]: Hh(Kh(1, 1 / 0, Ah), Lh),
      [Xh.String]: Hh(Kh(1, 1 / 0, Ah), Mh),
      [Xh.Get]: Hh(function (t, e) {
        if (2 !== t.length)
          throw new Error("Expected 1 argument for get operation");
        const i = Vh(t[1], e);
        if (!(i instanceof zh))
          throw new Error("Expected a literal argument for get operation");
        if ("string" != typeof i.value)
          throw new Error("Expected a string argument for get operation");
        return e.properties.add(i.value), [i];
      }, Ah),
      [Xh.Var]: Hh(function (t, e) {
        if (2 !== t.length)
          throw new Error("Expected 1 argument for var operation");
        const i = Vh(t[1], e);
        if (!(i instanceof zh))
          throw new Error("Expected a literal argument for var operation");
        if ("string" != typeof i.value)
          throw new Error("Expected a string argument for get operation");
        return e.variables.add(i.value), [i];
      }, Ah),
      [Xh.Resolution]: Hh(function (t, e) {
        const i = t[0];
        if (1 !== t.length)
          throw new Error(`Expected no arguments for ${i} operation`);
        return [];
      }, Lh),
      [Xh.Any]: Hh(Kh(2, 1 / 0, Ih), Ih),
      [Xh.All]: Hh(Kh(2, 1 / 0, Ih), Ih),
      [Xh.Not]: Hh(Kh(1, 1, Ih), Ih),
      [Xh.Equal]: Hh(Kh(2, 2, Ah), Ih),
      [Xh.NotEqual]: Hh(Kh(2, 2, Ah), Ih),
      [Xh.GreaterThan]: Hh(Kh(2, 2, Ah), Ih),
      [Xh.GreaterThanOrEqualTo]: Hh(Kh(2, 2, Ah), Ih),
      [Xh.LessThan]: Hh(Kh(2, 2, Ah), Ih),
      [Xh.LessThanOrEqualTo]: Hh(Kh(2, 2, Ah), Ih),
      [Xh.Multiply]: Hh(Kh(2, 1 / 0, Lh), Lh),
      [Xh.Divide]: Hh(Kh(2, 2, Lh), Lh),
      [Xh.Add]: Hh(Kh(2, 1 / 0, Lh), Lh),
      [Xh.Subtract]: Hh(Kh(2, 2, Lh), Lh),
      [Xh.Clamp]: Hh(Kh(3, 3, Lh), Lh),
      [Xh.Mod]: Hh(Kh(2, 2, Lh), Lh),
      [Xh.Pow]: Hh(Kh(2, 2, Lh), Lh),
      [Xh.Abs]: Hh(Kh(1, 1, Lh), Lh),
      [Xh.Floor]: Hh(Kh(1, 1, Lh), Lh),
      [Xh.Ceil]: Hh(Kh(1, 1, Lh), Lh),
      [Xh.Round]: Hh(Kh(1, 1, Lh), Lh),
      [Xh.Sin]: Hh(Kh(1, 1, Lh), Lh),
      [Xh.Cos]: Hh(Kh(1, 1, Lh), Lh),
      [Xh.Atan]: Hh(Kh(1, 2, Lh), Lh),
      [Xh.Sqrt]: Hh(Kh(1, 1, Lh), Lh),
      [Xh.Match]: Hh(Kh(4, 1 / 0, Mh | Lh), Ah),
    };
  function Kh(t, e, i) {
    return function (n, r) {
      const s = n[0],
        o = n.length - 1;
      if (t === e) {
        if (o !== t) {
          throw new Error(
            `Expected ${t} argument${
              1 === t ? "" : "s"
            } for operation ${s}, got ${o}`
          );
        }
      } else if (o < t || o > e)
        throw new Error(
          `Expected ${t} to ${e} arguments for operation ${s}, got ${o}`
        );
      const a = new Array(o);
      for (let t = 0; t < o; ++t) {
        const e = Vh(n[t + 1], r);
        if (!jh(i, e.type)) {
          const n = Gh(i),
            r = Gh(e.type);
          throw new Error(
            `Unexpected type for argument ${t} of ${s} operation : got ${n} but expected ${r}`
          );
        }
        a[t] = e;
      }
      return a;
    };
  }
  function Hh(t, e) {
    return function (i, n) {
      const r = i[0],
        s = t(i, n);
      return new Uh(e, r, ...s);
    };
  }
  function Yh() {
    return { variables: {}, properties: {}, resolution: NaN };
  }
  function Qh(t, e, i) {
    const n = Vh(t, i);
    if (!jh(e, n.type)) {
      const t = Gh(e),
        i = Gh(n.type);
      throw new Error(`Expected expression to be of type ${t}, got ${i}`);
    }
    return $h(n);
  }
  function $h(t, e) {
    if (t instanceof zh)
      return function () {
        return t.value;
      };
    const i = t.operator;
    switch (i) {
      case Xh.Number:
      case Xh.String:
        return (function (t, e) {
          const i = t.operator,
            n = t.args.length,
            r = new Array(n);
          for (let e = 0; e < n; ++e) r[e] = $h(t.args[e]);
          switch (i) {
            case Xh.Number:
            case Xh.String:
              return (t) => {
                for (let e = 0; e < n; ++e) {
                  const n = r[e](t);
                  if (typeof n === i) return n;
                }
                throw new Error(`Expected one of the values to be a ${i}`);
              };
            default:
              throw new Error(`Unsupported assertion operator ${i}`);
          }
        })(t);
      case Xh.Get:
      case Xh.Var:
        return (function (t, e) {
          const i = t.args[0];
          if (!(i instanceof zh)) throw new Error("Expected literal name");
          const n = i.value;
          if ("string" != typeof n) throw new Error("Expected string name");
          switch (t.operator) {
            case Xh.Get:
              return (t) => t.properties[n];
            case Xh.Var:
              return (t) => t.variables[n];
            default:
              throw new Error(`Unsupported accessor operator ${t.operator}`);
          }
        })(t);
      case Xh.Resolution:
        return (t) => t.resolution;
      case Xh.Any:
      case Xh.All:
      case Xh.Not:
        return (function (t, e) {
          const i = t.operator,
            n = t.args.length,
            r = new Array(n);
          for (let e = 0; e < n; ++e) r[e] = $h(t.args[e]);
          switch (i) {
            case Xh.Any:
              return (t) => {
                for (let e = 0; e < n; ++e) if (r[e](t)) return !0;
                return !1;
              };
            case Xh.All:
              return (t) => {
                for (let e = 0; e < n; ++e) if (!r[e](t)) return !1;
                return !0;
              };
            case Xh.Not:
              return (t) => !r[0](t);
            default:
              throw new Error(`Unsupported logical operator ${i}`);
          }
        })(t);
      case Xh.Equal:
      case Xh.NotEqual:
      case Xh.LessThan:
      case Xh.LessThanOrEqualTo:
      case Xh.GreaterThan:
      case Xh.GreaterThanOrEqualTo:
        return (function (t, e) {
          const i = t.operator,
            n = $h(t.args[0]),
            r = $h(t.args[1]);
          switch (i) {
            case Xh.Equal:
              return (t) => n(t) === r(t);
            case Xh.NotEqual:
              return (t) => n(t) !== r(t);
            case Xh.LessThan:
              return (t) => n(t) < r(t);
            case Xh.LessThanOrEqualTo:
              return (t) => n(t) <= r(t);
            case Xh.GreaterThan:
              return (t) => n(t) > r(t);
            case Xh.GreaterThanOrEqualTo:
              return (t) => n(t) >= r(t);
            default:
              throw new Error(`Unsupported comparison operator ${i}`);
          }
        })(t);
      case Xh.Multiply:
      case Xh.Divide:
      case Xh.Add:
      case Xh.Subtract:
      case Xh.Clamp:
      case Xh.Mod:
      case Xh.Pow:
      case Xh.Abs:
      case Xh.Floor:
      case Xh.Ceil:
      case Xh.Round:
      case Xh.Sin:
      case Xh.Cos:
      case Xh.Atan:
      case Xh.Sqrt:
        return (function (t, e) {
          const i = t.operator,
            n = t.args.length,
            r = new Array(n);
          for (let e = 0; e < n; ++e) r[e] = $h(t.args[e]);
          switch (i) {
            case Xh.Multiply:
              return (t) => {
                let e = 1;
                for (let i = 0; i < n; ++i) e *= r[i](t);
                return e;
              };
            case Xh.Divide:
              return (t) => r[0](t) / r[1](t);
            case Xh.Add:
              return (t) => {
                let e = 0;
                for (let i = 0; i < n; ++i) e += r[i](t);
                return e;
              };
            case Xh.Subtract:
              return (t) => r[0](t) - r[1](t);
            case Xh.Clamp:
              return (t) => {
                const e = r[0](t),
                  i = r[1](t);
                if (e < i) return i;
                const n = r[2](t);
                return e > n ? n : e;
              };
            case Xh.Mod:
              return (t) => r[0](t) % r[1](t);
            case Xh.Pow:
              return (t) => Math.pow(r[0](t), r[1](t));
            case Xh.Abs:
              return (t) => Math.abs(r[0](t));
            case Xh.Floor:
              return (t) => Math.floor(r[0](t));
            case Xh.Ceil:
              return (t) => Math.ceil(r[0](t));
            case Xh.Round:
              return (t) => Math.round(r[0](t));
            case Xh.Sin:
              return (t) => Math.sin(r[0](t));
            case Xh.Cos:
              return (t) => Math.cos(r[0](t));
            case Xh.Atan:
              return 2 === n
                ? (t) => Math.atan2(r[0](t), r[1](t))
                : (t) => Math.atan(r[0](t));
            case Xh.Sqrt:
              return (t) => Math.sqrt(r[0](t));
            default:
              throw new Error(`Unsupported numeric operator ${i}`);
          }
        })(t);
      case Xh.Match:
        return (function (t, e) {
          const i = t.args.length,
            n = new Array(i);
          for (let e = 0; e < i; ++e) n[e] = $h(t.args[e]);
          return (t) => {
            const e = n[0](t);
            for (let r = 1; r < i; r += 2)
              if (e === n[r](t)) return n[r + 1](t);
            return n[i - 1](t);
          };
        })(t);
      default:
        throw new Error(`Unsupported operator ${i}`);
    }
  }
  function Jh(t) {
    return !0;
  }
  function tc(t) {
    const e = ic(t, qh()),
      i = { variables: {}, properties: {}, resolution: NaN };
    return function (t, n) {
      return (
        (i.properties = t.getPropertiesInternal()), (i.resolution = n), e(i)
      );
    };
  }
  function ec(t) {
    const e = qh(),
      i = t.length,
      n = new Array(i);
    for (let r = 0; r < i; ++r) n[r] = nc(t[r], e);
    const r = { variables: {}, properties: {}, resolution: NaN },
      s = new Array(i);
    return function (t, e) {
      (r.properties = t.getPropertiesInternal()), (r.resolution = e);
      for (let t = 0; t < i; ++t) s[t] = n[t](r);
      return s;
    };
  }
  function ic(t, e) {
    const i = t.length,
      n = new Array(i);
    for (let r = 0; r < i; ++r) {
      const i = t[r],
        s = "filter" in i ? Qh(i.filter, Ih, e) : Jh;
      let o;
      if (Array.isArray(i.style)) {
        const t = i.style.length;
        o = new Array(t);
        for (let n = 0; n < t; ++n) o[n] = nc(i.style[n], e);
      } else o = [nc(i.style, e)];
      n[r] = { filter: s, styles: o };
    }
    return function (e) {
      const r = [];
      let s = !1;
      for (let o = 0; o < i; ++o) {
        if ((0, n[o].filter)(e) && (!t[o].else || !s)) {
          s = !0;
          for (const t of n[o].styles) {
            const i = t(e);
            i && r.push(i);
          }
        }
      }
      return r;
    };
  }
  function nc(t, e) {
    const i = rc(t, "", e),
      n = sc(t, "", e),
      r = (function (t, e) {
        const i = "text-",
          n = ac(t, i + "value", e);
        if (!n) return null;
        const r = rc(t, i, e),
          s = rc(t, i + "background-", e),
          o = sc(t, i, e),
          a = sc(t, i + "background-", e),
          l = ac(t, i + "font", e),
          h = oc(t, i + "max-angle", e),
          c = oc(t, i + "offset-x", e),
          u = oc(t, i + "offset-y", e),
          d = lc(t, i + "overflow", e),
          g = ac(t, i + "placement", e),
          f = oc(t, i + "repeat", e),
          p = dc(t, i + "scale", e),
          m = lc(t, i + "rotate-with-view", e),
          _ = oc(t, i + "rotation", e),
          y = ac(t, i + "align", e),
          x = ac(t, i + "justify", e),
          v = ac(t, i + "baseline", e),
          S = cc(t, i + "padding", e),
          C = new rh({});
        return function (t) {
          if (
            (C.setText(n(t)),
            r && C.setFill(r(t)),
            s && C.setBackgroundFill(s(t)),
            o && C.setStroke(o(t)),
            a && C.setBackgroundStroke(a(t)),
            l && C.setFont(l(t)),
            h && C.setMaxAngle(h(t)),
            c && C.setOffsetX(c(t)),
            u && C.setOffsetY(u(t)),
            d && C.setOverflow(d(t)),
            g)
          ) {
            const e = g(t);
            if ("point" !== e && "line" !== e)
              throw new Error("Expected point or line for text-placement");
            C.setPlacement(e);
          }
          if (
            (f && C.setRepeat(f(t)),
            p && C.setScale(p(t)),
            m && C.setRotateWithView(m(t)),
            _ && C.setRotation(_(t)),
            y)
          ) {
            const e = y(t);
            if (
              "left" !== e &&
              "center" !== e &&
              "right" !== e &&
              "end" !== e &&
              "start" !== e
            )
              throw new Error(
                "Expected left, right, center, start, or end for text-align"
              );
            C.setTextAlign(e);
          }
          if (x) {
            const e = x(t);
            if ("left" !== e && "right" !== e && "center" !== e)
              throw new Error(
                "Expected left, right, or center for text-justify"
              );
            C.setJustify(e);
          }
          if (v) {
            const e = v(t);
            if (
              "bottom" !== e &&
              "top" !== e &&
              "middle" !== e &&
              "alphabetic" !== e &&
              "hanging" !== e
            )
              throw new Error(
                "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
              );
            C.setTextBaseline(e);
          }
          return S && C.setPadding(S(t)), C;
        };
      })(t, e),
      s = (function (t, e) {
        if ("icon-src" in t)
          return (function (t, e) {
            const i = "icon-",
              n = i + "src",
              r = yc(t[n], n),
              s = uc(t, i + "anchor", e),
              o = dc(t, i + "scale", e),
              a = oc(t, i + "opacity", e),
              l = uc(t, i + "displacement", e),
              h = oc(t, i + "rotation", e),
              c = lc(t, i + "rotate-with-view", e),
              u = fc(t, i + "anchor-origin"),
              d = pc(t, i + "anchor-x-units"),
              g = pc(t, i + "anchor-y-units"),
              f = (function (t, e) {
                const i = t[e];
                if (void 0 === i) return;
                return vc(i, e);
              })(t, i + "color"),
              p = (function (t, e) {
                const i = t[e];
                if (void 0 === i) return;
                if ("string" != typeof i)
                  throw new Error(`Expected a string for ${e}`);
                return i;
              })(t, i + "cross-origin"),
              m = (function (t, e) {
                const i = t[e];
                if (void 0 === i) return;
                return _c(i, e);
              })(t, i + "offset"),
              _ = fc(t, i + "offset-origin"),
              y = gc(t, i + "width"),
              x = gc(t, i + "height"),
              v = (function (t, e) {
                const i = t[e];
                if (void 0 === i) return;
                if ("number" == typeof i) return sl(i);
                if (!Array.isArray(i))
                  throw new Error(`Expected a number or size array for ${e}`);
                if (
                  2 !== i.length ||
                  "number" != typeof i[0] ||
                  "number" != typeof i[1]
                )
                  throw new Error(`Expected a number or size array for ${e}`);
                return i;
              })(t, i + "size"),
              S = mc(t, i + "declutter"),
              C = new bh({
                src: r,
                anchorOrigin: u,
                anchorXUnits: d,
                anchorYUnits: g,
                color: f,
                crossOrigin: p,
                offset: m,
                offsetOrigin: _,
                height: x,
                width: y,
                size: v,
                declutterMode: S,
              });
            return function (t) {
              return (
                a && C.setOpacity(a(t)),
                l && C.setDisplacement(l(t)),
                h && C.setRotation(h(t)),
                c && C.setRotateWithView(c(t)),
                o && C.setScale(o(t)),
                s && C.setAnchor(s(t)),
                C
              );
            };
          })(t, e);
        if ("shape-points" in t)
          return (function (t, e) {
            const i = "shape-",
              n = i + "points",
              r = xc(t[n], n),
              s = rc(t, i, e),
              o = sc(t, i, e),
              a = dc(t, i + "scale", e),
              l = uc(t, i + "displacement", e),
              h = oc(t, i + "rotation", e),
              c = lc(t, i + "rotate-with-view", e),
              u = gc(t, i + "radius"),
              d = gc(t, i + "radius1"),
              g = gc(t, i + "radius2"),
              f = gc(t, i + "angle"),
              p = mc(t, i + "declutter-mode"),
              m = new Zl({
                points: r,
                radius: u,
                radius1: d,
                radius2: g,
                angle: f,
                declutterMode: p,
              });
            return function (t) {
              return (
                s && m.setFill(s(t)),
                o && m.setStroke(o(t)),
                l && m.setDisplacement(l(t)),
                h && m.setRotation(h(t)),
                c && m.setRotateWithView(c(t)),
                a && m.setScale(a(t)),
                m
              );
            };
          })(t, e);
        if ("circle-radius" in t)
          return (function (t, e) {
            const i = "circle-",
              n = rc(t, i, e),
              r = sc(t, i, e),
              s = oc(t, i + "radius", e),
              o = dc(t, i + "scale", e),
              a = uc(t, i + "displacement", e),
              l = oc(t, i + "rotation", e),
              h = lc(t, i + "rotate-with-view", e),
              c = mc(t, i + "declutter-mode"),
              u = new Hl({ radius: 5, declutterMode: c });
            return function (t) {
              return (
                s && u.setRadius(s(t)),
                n && u.setFill(n(t)),
                r && u.setStroke(r(t)),
                a && u.setDisplacement(a(t)),
                l && u.setRotation(l(t)),
                h && u.setRotateWithView(h(t)),
                o && u.setScale(o(t)),
                u
              );
            };
          })(t, e);
        return null;
      })(t, e),
      o = oc(t, "z-index", e),
      a = new ih();
    return function (t) {
      let e = !0;
      if (i) {
        const n = i(t);
        n && (e = !1), a.setFill(n);
      }
      if (n) {
        const i = n(t);
        i && (e = !1), a.setStroke(i);
      }
      if (r) {
        const i = r(t);
        i && (e = !1), a.setText(i);
      }
      if (s) {
        const i = s(t);
        i && (e = !1), a.setImage(i);
      }
      return o && a.setZIndex(o(t)), e ? null : a;
    };
  }
  function rc(t, e, i) {
    const n = hc(t, e + "fill-color", i);
    if (!n) return null;
    const r = new Ol();
    return function (t) {
      const e = n(t);
      return "none" === e ? null : (r.setColor(e), r);
    };
  }
  function sc(t, e, i) {
    const n = oc(t, e + "stroke-width", i),
      r = hc(t, e + "stroke-color", i);
    if (!n && !r) return null;
    const s = ac(t, e + "stroke-line-cap", i),
      o = ac(t, e + "stroke-line-join", i),
      a = cc(t, e + "stroke-line-dash", i),
      l = oc(t, e + "stroke-line-dash-offset", i),
      h = oc(t, e + "stroke-miter-limit", i),
      c = new zl();
    return function (t) {
      if (r) {
        const e = r(t);
        if ("none" === e) return null;
        c.setColor(e);
      }
      if ((n && c.setWidth(n(t)), s)) {
        const e = s(t);
        if ("butt" !== e && "round" !== e && "square" !== e)
          throw new Error("Expected butt, round, or square line cap");
        c.setLineCap(e);
      }
      if (o) {
        const e = o(t);
        if ("bevel" !== e && "round" !== e && "miter" !== e)
          throw new Error("Expected bevel, round, or miter line join");
        c.setLineJoin(e);
      }
      return (
        a && c.setLineDash(a(t)),
        l && c.setLineDashOffset(l(t)),
        h && c.setMiterLimit(h(t)),
        c
      );
    };
  }
  function oc(t, e, i) {
    if (!(e in t)) return;
    const n = Qh(t[e], Lh, i);
    return function (t) {
      return xc(n(t), e);
    };
  }
  function ac(t, e, i) {
    if (!(e in t)) return null;
    const n = Qh(t[e], Mh, i);
    return function (t) {
      return yc(n(t), e);
    };
  }
  function lc(t, e, i) {
    if (!(e in t)) return null;
    const n = Qh(t[e], Ih, i);
    return function (t) {
      const i = n(t);
      if ("boolean" != typeof i) throw new Error(`Expected a boolean for ${e}`);
      return i;
    };
  }
  function hc(t, e, i) {
    if (!(e in t)) return null;
    const n = Qh(t[e], Oh | Mh, i);
    return function (t) {
      return vc(n(t), e);
    };
  }
  function cc(t, e, i) {
    if (!(e in t)) return null;
    const n = Qh(t[e], kh, i);
    return function (t) {
      return _c(n(t), e);
    };
  }
  function uc(t, e, i) {
    if (!(e in t)) return null;
    const n = Qh(t[e], kh, i);
    return function (t) {
      const i = _c(n(t), e);
      if (2 !== i.length) throw new Error(`Expected two numbers for ${e}`);
      return i;
    };
  }
  function dc(t, e, i) {
    if (!(e in t)) return null;
    const n = Qh(t[e], kh | Lh, i);
    return function (t) {
      return (function (t, e) {
        if ("number" == typeof t) return t;
        const i = _c(t, e);
        if (2 !== i.length)
          throw new Error(`Expected an array of two numbers for ${e}`);
        return i;
      })(n(t), e);
    };
  }
  function gc(t, e) {
    const i = t[e];
    if (void 0 !== i) {
      if ("number" != typeof i) throw new Error(`Expected a number for ${e}`);
      return i;
    }
  }
  function fc(t, e) {
    const i = t[e];
    if (void 0 !== i) {
      if (
        "bottom-left" !== i &&
        "bottom-right" !== i &&
        "top-left" !== i &&
        "top-right" !== i
      )
        throw new Error(
          `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
        );
      return i;
    }
  }
  function pc(t, e) {
    const i = t[e];
    if (void 0 !== i) {
      if ("pixels" !== i && "fraction" !== i)
        throw new Error(`Expected pixels or fraction for ${e}`);
      return i;
    }
  }
  function mc(t, e) {
    const i = t[e];
    if (void 0 !== i) {
      if ("string" != typeof i) throw new Error(`Expected a string for ${e}`);
      if ("declutter" !== i && "obstacle" !== i && "none" !== i)
        throw new Error(`Expected declutter, obstacle, or none for ${e}`);
      return i;
    }
  }
  function _c(t, e) {
    if (!Array.isArray(t)) throw new Error(`Expected an array for ${e}`);
    const i = t.length;
    for (let n = 0; n < i; ++n)
      if ("number" != typeof t[n])
        throw new Error(`Expected an array of numbers for ${e}`);
    return t;
  }
  function yc(t, e) {
    if ("string" != typeof t) throw new Error(`Expected a string for ${e}`);
    return t;
  }
  function xc(t, e) {
    if ("number" != typeof t) throw new Error(`Expected a number for ${e}`);
    return t;
  }
  function vc(t, e) {
    if ("string" == typeof t) return t;
    const i = _c(t, e),
      n = i.length;
    if (n < 3 || n > 4)
      throw new Error(`Expected a color with 3 or 4 values for ${e}`);
    return i;
  }
  const Sc = "renderOrder";
  var Cc = class extends no {
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.style,
        delete e.renderBuffer,
        delete e.updateWhileAnimating,
        delete e.updateWhileInteracting,
        super(e),
        (this.declutter_ = void 0 !== t.declutter && t.declutter),
        (this.renderBuffer_ = void 0 !== t.renderBuffer ? t.renderBuffer : 100),
        (this.style_ = null),
        (this.styleFunction_ = void 0),
        this.setStyle(t.style),
        (this.updateWhileAnimating_ =
          void 0 !== t.updateWhileAnimating && t.updateWhileAnimating),
        (this.updateWhileInteracting_ =
          void 0 !== t.updateWhileInteracting && t.updateWhileInteracting);
    }
    getDeclutter() {
      return this.declutter_;
    }
    getFeatures(t) {
      return super.getFeatures(t);
    }
    getRenderBuffer() {
      return this.renderBuffer_;
    }
    getRenderOrder() {
      return this.get(Sc);
    }
    getStyle() {
      return this.style_;
    }
    getStyleFunction() {
      return this.styleFunction_;
    }
    getUpdateWhileAnimating() {
      return this.updateWhileAnimating_;
    }
    getUpdateWhileInteracting() {
      return this.updateWhileInteracting_;
    }
    renderDeclutter(t) {
      t.declutterTree || (t.declutterTree = new hh(9)),
        this.getRenderer().renderDeclutter(t);
    }
    setRenderOrder(t) {
      this.set(Sc, t);
    }
    setStyle(t) {
      (this.style_ = (function (t) {
        if (void 0 === t) return Jl;
        if (!t) return null;
        if ("function" == typeof t) return t;
        if (t instanceof ih) return t;
        if (!Array.isArray(t)) return ec([t]);
        if (0 === t.length) return [];
        const e = t.length,
          i = t[0];
        if (i instanceof ih) {
          const i = new Array(e);
          for (let n = 0; n < e; ++n) {
            const e = t[n];
            if (!(e instanceof ih))
              throw new Error("Expected a list of style instances");
            i[n] = e;
          }
          return i;
        }
        if ("style" in i) {
          const i = new Array(e);
          for (let n = 0; n < e; ++n) {
            const e = t[n];
            if (!("style" in e))
              throw new Error("Expected a list of rules with a style property");
            i[n] = e;
          }
          return tc(i);
        }
        const n = t;
        return ec(n);
      })(t)),
        (this.styleFunction_ = null === t ? void 0 : Ql(this.style_)),
        this.changed();
    }
  };
  const wc = 0,
    Wc = 1,
    Ec = 2,
    Rc = 3,
    Tc = 4,
    Pc = 5,
    bc = 6,
    Fc = 7,
    Ic = 8,
    Lc = 9,
    Mc = 10,
    Oc = 11,
    kc = 12,
    Ac = [Ic],
    Nc = [kc],
    Dc = [Wc],
    Gc = [Rc];
  var Bc = class {
    drawCustom(t, e, i, n) {}
    drawGeometry(t) {}
    setStyle(t) {}
    drawCircle(t, e) {}
    drawFeature(t, e) {}
    drawGeometryCollection(t, e) {}
    drawLineString(t, e) {}
    drawMultiLineString(t, e) {}
    drawMultiPoint(t, e) {}
    drawMultiPolygon(t, e) {}
    drawPoint(t, e) {}
    drawPolygon(t, e) {}
    drawText(t, e) {}
    setFillStrokeStyle(t, e) {}
    setImageStyle(t, e) {}
    setTextStyle(t, e) {}
  };
  var jc = class extends Bc {
    constructor(t, e, i, n) {
      super(),
        (this.tolerance = t),
        (this.maxExtent = e),
        (this.pixelRatio = n),
        (this.maxLineWidth = 0),
        (this.resolution = i),
        (this.beginGeometryInstruction1_ = null),
        (this.beginGeometryInstruction2_ = null),
        (this.bufferedMaxExtent_ = null),
        (this.instructions = []),
        (this.coordinates = []),
        (this.tmpCoordinate_ = []),
        (this.hitDetectionInstructions = []),
        (this.state = {});
    }
    applyPixelRatio(t) {
      const e = this.pixelRatio;
      return 1 == e
        ? t
        : t.map(function (t) {
            return t * e;
          });
    }
    appendFlatPointCoordinates(t, e) {
      const i = this.getBufferedMaxExtent(),
        n = this.tmpCoordinate_,
        r = this.coordinates;
      let s = r.length;
      for (let o = 0, a = t.length; o < a; o += e)
        (n[0] = t[o]),
          (n[1] = t[o + 1]),
          ee(i, n) && ((r[s++] = n[0]), (r[s++] = n[1]));
      return s;
    }
    appendFlatLineCoordinates(t, e, i, n, r, s) {
      const o = this.coordinates;
      let a = o.length;
      const l = this.getBufferedMaxExtent();
      s && (e += n);
      let h = t[e],
        c = t[e + 1];
      const u = this.tmpCoordinate_;
      let d,
        g,
        f,
        p = !0;
      for (d = e + n; d < i; d += n)
        (u[0] = t[d]),
          (u[1] = t[d + 1]),
          (f = re(l, u)),
          f !== g
            ? (p && ((o[a++] = h), (o[a++] = c), (p = !1)),
              (o[a++] = u[0]),
              (o[a++] = u[1]))
            : f === Yt.INTERSECTING
            ? ((o[a++] = u[0]), (o[a++] = u[1]), (p = !1))
            : (p = !0),
          (h = u[0]),
          (c = u[1]),
          (g = f);
      return ((r && p) || d === e + n) && ((o[a++] = h), (o[a++] = c)), a;
    }
    drawCustomCoordinates_(t, e, i, n, r) {
      for (let s = 0, o = i.length; s < o; ++s) {
        const o = i[s],
          a = this.appendFlatLineCoordinates(t, e, o, n, !1, !1);
        r.push(a), (e = o);
      }
      return e;
    }
    drawCustom(t, e, i, n) {
      this.beginGeometry(t, e);
      const r = t.getType(),
        s = t.getStride(),
        o = this.coordinates.length;
      let a, l, h, c, u;
      switch (r) {
        case "MultiPolygon":
          (a = t.getOrientedFlatCoordinates()), (c = []);
          const e = t.getEndss();
          u = 0;
          for (let t = 0, i = e.length; t < i; ++t) {
            const i = [];
            (u = this.drawCustomCoordinates_(a, u, e[t], s, i)), c.push(i);
          }
          this.instructions.push([Tc, o, c, t, i, Jn]),
            this.hitDetectionInstructions.push([Tc, o, c, t, n || i, Jn]);
          break;
        case "Polygon":
        case "MultiLineString":
          (h = []),
            (a =
              "Polygon" == r
                ? t.getOrientedFlatCoordinates()
                : t.getFlatCoordinates()),
            (u = this.drawCustomCoordinates_(a, 0, t.getEnds(), s, h)),
            this.instructions.push([Tc, o, h, t, i, $n]),
            this.hitDetectionInstructions.push([Tc, o, h, t, n || i, $n]);
          break;
        case "LineString":
        case "Circle":
          (a = t.getFlatCoordinates()),
            (l = this.appendFlatLineCoordinates(a, 0, a.length, s, !1, !1)),
            this.instructions.push([Tc, o, l, t, i, Qn]),
            this.hitDetectionInstructions.push([Tc, o, l, t, n || i, Qn]);
          break;
        case "MultiPoint":
          (a = t.getFlatCoordinates()),
            (l = this.appendFlatPointCoordinates(a, s)),
            l > o &&
              (this.instructions.push([Tc, o, l, t, i, Qn]),
              this.hitDetectionInstructions.push([Tc, o, l, t, n || i, Qn]));
          break;
        case "Point":
          (a = t.getFlatCoordinates()),
            this.coordinates.push(a[0], a[1]),
            (l = this.coordinates.length),
            this.instructions.push([Tc, o, l, t, i]),
            this.hitDetectionInstructions.push([Tc, o, l, t, n || i]);
      }
      this.endGeometry(e);
    }
    beginGeometry(t, e) {
      (this.beginGeometryInstruction1_ = [wc, e, 0, t]),
        this.instructions.push(this.beginGeometryInstruction1_),
        (this.beginGeometryInstruction2_ = [wc, e, 0, t]),
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    finish() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates,
      };
    }
    reverseHitDetectionInstructions() {
      const t = this.hitDetectionInstructions;
      let e;
      t.reverse();
      const i = t.length;
      let n,
        r,
        s = -1;
      for (e = 0; e < i; ++e)
        (n = t[e]),
          (r = n[0]),
          r == Fc
            ? (s = e)
            : r == wc &&
              ((n[2] = e), l(this.hitDetectionInstructions, s, e), (s = -1));
    }
    setFillStrokeStyle(t, e) {
      const i = this.state;
      if (t) {
        const e = t.getColor();
        i.fillStyle = Vl(e || yo);
      } else i.fillStyle = void 0;
      if (e) {
        const t = e.getColor();
        i.strokeStyle = Vl(t || wo);
        const n = e.getLineCap();
        i.lineCap = void 0 !== n ? n : xo;
        const r = e.getLineDash();
        i.lineDash = r ? r.slice() : vo;
        const s = e.getLineDashOffset();
        i.lineDashOffset = s || 0;
        const o = e.getLineJoin();
        i.lineJoin = void 0 !== o ? o : So;
        const a = e.getWidth();
        i.lineWidth = void 0 !== a ? a : 1;
        const l = e.getMiterLimit();
        (i.miterLimit = void 0 !== l ? l : Co),
          i.lineWidth > this.maxLineWidth &&
            ((this.maxLineWidth = i.lineWidth),
            (this.bufferedMaxExtent_ = null));
      } else
        (i.strokeStyle = void 0),
          (i.lineCap = void 0),
          (i.lineDash = null),
          (i.lineDashOffset = void 0),
          (i.lineJoin = void 0),
          (i.lineWidth = void 0),
          (i.miterLimit = void 0);
    }
    createFill(t) {
      const e = t.fillStyle,
        i = [Mc, e];
      return "string" != typeof e && i.push(!0), i;
    }
    applyStroke(t) {
      this.instructions.push(this.createStroke(t));
    }
    createStroke(t) {
      return [
        Oc,
        t.strokeStyle,
        t.lineWidth * this.pixelRatio,
        t.lineCap,
        t.lineJoin,
        t.miterLimit,
        this.applyPixelRatio(t.lineDash),
        t.lineDashOffset * this.pixelRatio,
      ];
    }
    updateFillStyle(t, e) {
      const i = t.fillStyle;
      ("string" == typeof i && t.currentFillStyle == i) ||
        (void 0 !== i && this.instructions.push(e.call(this, t)),
        (t.currentFillStyle = i));
    }
    updateStrokeStyle(t, e) {
      const i = t.strokeStyle,
        n = t.lineCap,
        r = t.lineDash,
        s = t.lineDashOffset,
        o = t.lineJoin,
        a = t.lineWidth,
        l = t.miterLimit;
      (t.currentStrokeStyle != i ||
        t.currentLineCap != n ||
        (r != t.currentLineDash && !c(t.currentLineDash, r)) ||
        t.currentLineDashOffset != s ||
        t.currentLineJoin != o ||
        t.currentLineWidth != a ||
        t.currentMiterLimit != l) &&
        (void 0 !== i && e.call(this, t),
        (t.currentStrokeStyle = i),
        (t.currentLineCap = n),
        (t.currentLineDash = r),
        (t.currentLineDashOffset = s),
        (t.currentLineJoin = o),
        (t.currentLineWidth = a),
        (t.currentMiterLimit = l));
    }
    endGeometry(t) {
      (this.beginGeometryInstruction1_[2] = this.instructions.length),
        (this.beginGeometryInstruction1_ = null),
        (this.beginGeometryInstruction2_[2] =
          this.hitDetectionInstructions.length),
        (this.beginGeometryInstruction2_ = null);
      const e = [Fc, t];
      this.instructions.push(e), this.hitDetectionInstructions.push(e);
    }
    getBufferedMaxExtent() {
      if (
        !this.bufferedMaxExtent_ &&
        ((this.bufferedMaxExtent_ = Jt(this.maxExtent)), this.maxLineWidth > 0)
      ) {
        const t = (this.resolution * (this.maxLineWidth + 1)) / 2;
        $t(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_);
      }
      return this.bufferedMaxExtent_;
    }
  };
  var zc = class extends jc {
    constructor(t, e, i, n) {
      super(t, e, i, n),
        (this.hitDetectionImage_ = null),
        (this.image_ = null),
        (this.imagePixelRatio_ = void 0),
        (this.anchorX_ = void 0),
        (this.anchorY_ = void 0),
        (this.height_ = void 0),
        (this.opacity_ = void 0),
        (this.originX_ = void 0),
        (this.originY_ = void 0),
        (this.rotateWithView_ = void 0),
        (this.rotation_ = void 0),
        (this.scale_ = void 0),
        (this.width_ = void 0),
        (this.declutterMode_ = void 0),
        (this.declutterImageWithText_ = void 0);
    }
    drawPoint(t, e) {
      if (!this.image_) return;
      this.beginGeometry(t, e);
      const i = t.getFlatCoordinates(),
        n = t.getStride(),
        r = this.coordinates.length,
        s = this.appendFlatPointCoordinates(i, n);
      this.instructions.push([
        bc,
        r,
        s,
        this.image_,
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
          (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_,
      ]),
        this.hitDetectionInstructions.push([
          bc,
          r,
          s,
          this.hitDetectionImage_,
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_,
        ]),
        this.endGeometry(e);
    }
    drawMultiPoint(t, e) {
      if (!this.image_) return;
      this.beginGeometry(t, e);
      const i = t.getFlatCoordinates(),
        n = t.getStride(),
        r = this.coordinates.length,
        s = this.appendFlatPointCoordinates(i, n);
      this.instructions.push([
        bc,
        r,
        s,
        this.image_,
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
          (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_,
      ]),
        this.hitDetectionInstructions.push([
          bc,
          r,
          s,
          this.hitDetectionImage_,
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_,
        ]),
        this.endGeometry(e);
    }
    finish() {
      return (
        this.reverseHitDetectionInstructions(),
        (this.anchorX_ = void 0),
        (this.anchorY_ = void 0),
        (this.hitDetectionImage_ = null),
        (this.image_ = null),
        (this.imagePixelRatio_ = void 0),
        (this.height_ = void 0),
        (this.scale_ = void 0),
        (this.opacity_ = void 0),
        (this.originX_ = void 0),
        (this.originY_ = void 0),
        (this.rotateWithView_ = void 0),
        (this.rotation_ = void 0),
        (this.width_ = void 0),
        super.finish()
      );
    }
    setImageStyle(t, e) {
      const i = t.getAnchor(),
        n = t.getSize(),
        r = t.getOrigin();
      (this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio)),
        (this.anchorX_ = i[0]),
        (this.anchorY_ = i[1]),
        (this.hitDetectionImage_ = t.getHitDetectionImage()),
        (this.image_ = t.getImage(this.pixelRatio)),
        (this.height_ = n[1]),
        (this.opacity_ = t.getOpacity()),
        (this.originX_ = r[0]),
        (this.originY_ = r[1]),
        (this.rotateWithView_ = t.getRotateWithView()),
        (this.rotation_ = t.getRotation()),
        (this.scale_ = t.getScaleArray()),
        (this.width_ = n[0]),
        (this.declutterMode_ = t.getDeclutterMode()),
        (this.declutterImageWithText_ = e);
    }
  };
  var Uc = class extends jc {
    constructor(t, e, i, n) {
      super(t, e, i, n);
    }
    drawFlatCoordinates_(t, e, i, n) {
      const r = this.coordinates.length,
        s = this.appendFlatLineCoordinates(t, e, i, n, !1, !1),
        o = [Lc, r, s];
      return (
        this.instructions.push(o), this.hitDetectionInstructions.push(o), i
      );
    }
    drawLineString(t, e) {
      const i = this.state,
        n = i.strokeStyle,
        r = i.lineWidth;
      if (void 0 === n || void 0 === r) return;
      this.updateStrokeStyle(i, this.applyStroke),
        this.beginGeometry(t, e),
        this.hitDetectionInstructions.push(
          [
            Oc,
            i.strokeStyle,
            i.lineWidth,
            i.lineCap,
            i.lineJoin,
            i.miterLimit,
            vo,
            0,
          ],
          Dc
        );
      const s = t.getFlatCoordinates(),
        o = t.getStride();
      this.drawFlatCoordinates_(s, 0, s.length, o),
        this.hitDetectionInstructions.push(Nc),
        this.endGeometry(e);
    }
    drawMultiLineString(t, e) {
      const i = this.state,
        n = i.strokeStyle,
        r = i.lineWidth;
      if (void 0 === n || void 0 === r) return;
      this.updateStrokeStyle(i, this.applyStroke),
        this.beginGeometry(t, e),
        this.hitDetectionInstructions.push(
          [
            Oc,
            i.strokeStyle,
            i.lineWidth,
            i.lineCap,
            i.lineJoin,
            i.miterLimit,
            vo,
            0,
          ],
          Dc
        );
      const s = t.getEnds(),
        o = t.getFlatCoordinates(),
        a = t.getStride();
      let l = 0;
      for (let t = 0, e = s.length; t < e; ++t)
        l = this.drawFlatCoordinates_(o, l, s[t], a);
      this.hitDetectionInstructions.push(Nc), this.endGeometry(e);
    }
    finish() {
      const t = this.state;
      return (
        null != t.lastStroke &&
          t.lastStroke != this.coordinates.length &&
          this.instructions.push(Nc),
        this.reverseHitDetectionInstructions(),
        (this.state = null),
        super.finish()
      );
    }
    applyStroke(t) {
      null != t.lastStroke &&
        t.lastStroke != this.coordinates.length &&
        (this.instructions.push(Nc), (t.lastStroke = this.coordinates.length)),
        (t.lastStroke = 0),
        super.applyStroke(t),
        this.instructions.push(Dc);
    }
  };
  var qc = class extends jc {
    constructor(t, e, i, n) {
      super(t, e, i, n);
    }
    drawFlatCoordinatess_(t, e, i, n) {
      const r = this.state,
        s = void 0 !== r.fillStyle,
        o = void 0 !== r.strokeStyle,
        a = i.length;
      this.instructions.push(Dc), this.hitDetectionInstructions.push(Dc);
      for (let r = 0; r < a; ++r) {
        const s = i[r],
          a = this.coordinates.length,
          l = this.appendFlatLineCoordinates(t, e, s, n, !0, !o),
          h = [Lc, a, l];
        this.instructions.push(h),
          this.hitDetectionInstructions.push(h),
          o &&
            (this.instructions.push(Gc),
            this.hitDetectionInstructions.push(Gc)),
          (e = s);
      }
      return (
        s &&
          (this.instructions.push(Ac), this.hitDetectionInstructions.push(Ac)),
        o &&
          (this.instructions.push(Nc), this.hitDetectionInstructions.push(Nc)),
        e
      );
    }
    drawCircle(t, e) {
      const i = this.state,
        n = i.fillStyle,
        r = i.strokeStyle;
      if (void 0 === n && void 0 === r) return;
      this.setFillStrokeStyles_(),
        this.beginGeometry(t, e),
        void 0 !== i.fillStyle && this.hitDetectionInstructions.push([Mc, yo]),
        void 0 !== i.strokeStyle &&
          this.hitDetectionInstructions.push([
            Oc,
            i.strokeStyle,
            i.lineWidth,
            i.lineCap,
            i.lineJoin,
            i.miterLimit,
            vo,
            0,
          ]);
      const s = t.getFlatCoordinates(),
        o = t.getStride(),
        a = this.coordinates.length;
      this.appendFlatLineCoordinates(s, 0, s.length, o, !1, !1);
      const l = [Ec, a];
      this.instructions.push(Dc, l),
        this.hitDetectionInstructions.push(Dc, l),
        void 0 !== i.fillStyle &&
          (this.instructions.push(Ac), this.hitDetectionInstructions.push(Ac)),
        void 0 !== i.strokeStyle &&
          (this.instructions.push(Nc), this.hitDetectionInstructions.push(Nc)),
        this.endGeometry(e);
    }
    drawPolygon(t, e) {
      const i = this.state,
        n = i.fillStyle,
        r = i.strokeStyle;
      if (void 0 === n && void 0 === r) return;
      this.setFillStrokeStyles_(),
        this.beginGeometry(t, e),
        void 0 !== i.fillStyle && this.hitDetectionInstructions.push([Mc, yo]),
        void 0 !== i.strokeStyle &&
          this.hitDetectionInstructions.push([
            Oc,
            i.strokeStyle,
            i.lineWidth,
            i.lineCap,
            i.lineJoin,
            i.miterLimit,
            vo,
            0,
          ]);
      const s = t.getEnds(),
        o = t.getOrientedFlatCoordinates(),
        a = t.getStride();
      this.drawFlatCoordinatess_(o, 0, s, a), this.endGeometry(e);
    }
    drawMultiPolygon(t, e) {
      const i = this.state,
        n = i.fillStyle,
        r = i.strokeStyle;
      if (void 0 === n && void 0 === r) return;
      this.setFillStrokeStyles_(),
        this.beginGeometry(t, e),
        void 0 !== i.fillStyle && this.hitDetectionInstructions.push([Mc, yo]),
        void 0 !== i.strokeStyle &&
          this.hitDetectionInstructions.push([
            Oc,
            i.strokeStyle,
            i.lineWidth,
            i.lineCap,
            i.lineJoin,
            i.miterLimit,
            vo,
            0,
          ]);
      const s = t.getEndss(),
        o = t.getOrientedFlatCoordinates(),
        a = t.getStride();
      let l = 0;
      for (let t = 0, e = s.length; t < e; ++t)
        l = this.drawFlatCoordinatess_(o, l, s[t], a);
      this.endGeometry(e);
    }
    finish() {
      this.reverseHitDetectionInstructions(), (this.state = null);
      const t = this.tolerance;
      if (0 !== t) {
        const e = this.coordinates;
        for (let i = 0, n = e.length; i < n; ++i) e[i] = Zn(e[i], t);
      }
      return super.finish();
    }
    setFillStrokeStyles_() {
      const t = this.state;
      void 0 !== t.fillStyle && this.updateFillStyle(t, this.createFill),
        void 0 !== t.strokeStyle && this.updateStrokeStyle(t, this.applyStroke);
    }
  };
  function Vc(t, e, i, n, r) {
    const s = [];
    let o = i,
      a = 0,
      l = e.slice(i, 2);
    for (; a < t && o + r < n; ) {
      const [i, n] = l.slice(-2),
        h = e[o + r],
        c = e[o + r + 1],
        u = Math.sqrt((h - i) * (h - i) + (c - n) * (c - n));
      if (((a += u), a >= t)) {
        const e = (t - a + u) / u,
          d = yi(i, h, e),
          g = yi(n, c, e);
        l.push(d, g), s.push(l), (l = [d, g]), a == t && (o += r), (a = 0);
      } else if (a < t) l.push(e[o + r], e[o + r + 1]), (o += r);
      else {
        const t = u - a,
          e = yi(i, h, t / u),
          d = yi(n, c, t / u);
        l.push(e, d), s.push(l), (l = [e, d]), (a = 0), (o += r);
      }
    }
    return a > 0 && s.push(l), s;
  }
  function Xc(t, e, i, n, r) {
    let s,
      o,
      a,
      l,
      h,
      c,
      u,
      d,
      g,
      f,
      p = i,
      m = i,
      _ = 0,
      y = 0,
      x = i;
    for (o = i; o < n; o += r) {
      const i = e[o],
        n = e[o + 1];
      void 0 !== h &&
        ((g = i - h),
        (f = n - c),
        (l = Math.sqrt(g * g + f * f)),
        void 0 !== u &&
          ((y += a),
          (s = Math.acos((u * g + d * f) / (a * l))),
          s > t &&
            (y > _ && ((_ = y), (p = x), (m = o)), (y = 0), (x = o - r))),
        (a = l),
        (u = g),
        (d = f)),
        (h = i),
        (c = n);
    }
    return (y += l), y > _ ? [x, o] : [p, m];
  }
  const Zc = {
    left: 0,
    center: 0.5,
    right: 1,
    top: 0,
    middle: 0.5,
    hanging: 0.2,
    alphabetic: 0.8,
    ideographic: 0.8,
    bottom: 1,
  };
  var Kc = class extends jc {
    constructor(t, e, i, n) {
      super(t, e, i, n),
        (this.labels_ = null),
        (this.text_ = ""),
        (this.textOffsetX_ = 0),
        (this.textOffsetY_ = 0),
        (this.textRotateWithView_ = void 0),
        (this.textRotation_ = 0),
        (this.textFillState_ = null),
        (this.fillStates = {}),
        (this.fillStates[yo] = { fillStyle: yo }),
        (this.textStrokeState_ = null),
        (this.strokeStates = {}),
        (this.textState_ = {}),
        (this.textStates = {}),
        (this.textKey_ = ""),
        (this.fillKey_ = ""),
        (this.strokeKey_ = ""),
        (this.declutterImageWithText_ = void 0);
    }
    finish() {
      const t = super.finish();
      return (
        (t.textStates = this.textStates),
        (t.fillStates = this.fillStates),
        (t.strokeStates = this.strokeStates),
        t
      );
    }
    drawText(t, e) {
      const i = this.textFillState_,
        n = this.textStrokeState_,
        r = this.textState_;
      if ("" === this.text_ || !r || (!i && !n)) return;
      const s = this.coordinates;
      let o = s.length;
      const a = t.getType();
      let l = null,
        h = t.getStride();
      if (
        "line" !== r.placement ||
        ("LineString" != a &&
          "MultiLineString" != a &&
          "Polygon" != a &&
          "MultiPolygon" != a)
      ) {
        let i = r.overflow ? null : [];
        switch (a) {
          case "Point":
          case "MultiPoint":
            l = t.getFlatCoordinates();
            break;
          case "LineString":
            l = t.getFlatMidpoint();
            break;
          case "Circle":
            l = t.getCenter();
            break;
          case "MultiLineString":
            (l = t.getFlatMidpoints()), (h = 2);
            break;
          case "Polygon":
            (l = t.getFlatInteriorPoint()),
              r.overflow || i.push(l[2] / this.resolution),
              (h = 3);
            break;
          case "MultiPolygon":
            const e = t.getFlatInteriorPoints();
            l = [];
            for (let t = 0, n = e.length; t < n; t += 3)
              r.overflow || i.push(e[t + 2] / this.resolution),
                l.push(e[t], e[t + 1]);
            if (0 === l.length) return;
            h = 2;
        }
        const n = this.appendFlatPointCoordinates(l, h);
        if (n === o) return;
        if (i && (n - o) / 2 != l.length / h) {
          let t = o / 2;
          i = i.filter((e, i) => {
            const n =
              s[2 * (t + i)] === l[i * h] &&
              s[2 * (t + i) + 1] === l[i * h + 1];
            return n || --t, n;
          });
        }
        this.saveTextStates_(),
          (r.backgroundFill || r.backgroundStroke) &&
            (this.setFillStrokeStyle(r.backgroundFill, r.backgroundStroke),
            r.backgroundFill &&
              this.updateFillStyle(this.state, this.createFill),
            r.backgroundStroke &&
              (this.updateStrokeStyle(this.state, this.applyStroke),
              this.hitDetectionInstructions.push(
                this.createStroke(this.state)
              ))),
          this.beginGeometry(t, e);
        let c = r.padding;
        if (c != Ro && (r.scale[0] < 0 || r.scale[1] < 0)) {
          let t = r.padding[0],
            e = r.padding[1],
            i = r.padding[2],
            n = r.padding[3];
          r.scale[0] < 0 && ((e = -e), (n = -n)),
            r.scale[1] < 0 && ((t = -t), (i = -i)),
            (c = [t, e, i, n]);
        }
        const u = this.pixelRatio;
        this.instructions.push([
          bc,
          o,
          n,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [1, 1],
          NaN,
          void 0,
          this.declutterImageWithText_,
          c == Ro
            ? Ro
            : c.map(function (t) {
                return t * u;
              }),
          !!r.backgroundFill,
          !!r.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          i,
        ]);
        const d = 1 / u,
          g = this.state.fillStyle;
        r.backgroundFill &&
          ((this.state.fillStyle = yo),
          this.hitDetectionInstructions.push(this.createFill(this.state))),
          this.hitDetectionInstructions.push([
            bc,
            o,
            n,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [d, d],
            NaN,
            void 0,
            this.declutterImageWithText_,
            c,
            !!r.backgroundFill,
            !!r.backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_ ? yo : this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            i,
          ]),
          r.backgroundFill &&
            ((this.state.fillStyle = g),
            this.hitDetectionInstructions.push(this.createFill(this.state))),
          this.endGeometry(e);
      } else {
        if (!Ie(this.getBufferedMaxExtent(), t.getExtent())) return;
        let i;
        if (((l = t.getFlatCoordinates()), "LineString" == a)) i = [l.length];
        else if ("MultiLineString" == a) i = t.getEnds();
        else if ("Polygon" == a) i = t.getEnds().slice(0, 1);
        else if ("MultiPolygon" == a) {
          const e = t.getEndss();
          i = [];
          for (let t = 0, n = e.length; t < n; ++t) i.push(e[t][0]);
        }
        this.beginGeometry(t, e);
        const n = r.repeat,
          c = n ? void 0 : r.textAlign;
        let u = 0;
        for (let t = 0, e = i.length; t < e; ++t) {
          let e;
          e = n ? Vc(n * this.resolution, l, u, i[t], h) : [l.slice(u, i[t])];
          for (let n = 0, a = e.length; n < a; ++n) {
            const a = e[n];
            let l = 0,
              d = a.length;
            if (null == c) {
              const t = Xc(r.maxAngle, a, 0, a.length, 2);
              (l = t[0]), (d = t[1]);
            }
            for (let t = l; t < d; t += h) s.push(a[t], a[t + 1]);
            const g = s.length;
            (u = i[t]), this.drawChars_(o, g), (o = g);
          }
        }
        this.endGeometry(e);
      }
    }
    saveTextStates_() {
      const t = this.textStrokeState_,
        e = this.textState_,
        i = this.textFillState_,
        n = this.strokeKey_;
      t &&
        (n in this.strokeStates ||
          (this.strokeStates[n] = {
            strokeStyle: t.strokeStyle,
            lineCap: t.lineCap,
            lineDashOffset: t.lineDashOffset,
            lineWidth: t.lineWidth,
            lineJoin: t.lineJoin,
            miterLimit: t.miterLimit,
            lineDash: t.lineDash,
          }));
      const r = this.textKey_;
      r in this.textStates ||
        (this.textStates[r] = {
          font: e.font,
          textAlign: e.textAlign || Wo,
          justify: e.justify,
          textBaseline: e.textBaseline || Eo,
          scale: e.scale,
        });
      const s = this.fillKey_;
      i &&
        (s in this.fillStates ||
          (this.fillStates[s] = { fillStyle: i.fillStyle }));
    }
    drawChars_(t, e) {
      const i = this.textStrokeState_,
        n = this.textState_,
        r = this.strokeKey_,
        s = this.textKey_,
        o = this.fillKey_;
      this.saveTextStates_();
      const a = this.pixelRatio,
        l = Zc[n.textBaseline],
        h = this.textOffsetY_ * a,
        c = this.text_,
        u = i ? (i.lineWidth * Math.abs(n.scale[0])) / 2 : 0;
      this.instructions.push([
        Pc,
        t,
        e,
        l,
        n.overflow,
        o,
        n.maxAngle,
        a,
        h,
        r,
        u * a,
        c,
        s,
        1,
      ]),
        this.hitDetectionInstructions.push([
          Pc,
          t,
          e,
          l,
          n.overflow,
          o ? yo : o,
          n.maxAngle,
          a,
          h,
          r,
          u * a,
          c,
          s,
          1 / a,
        ]);
    }
    setTextStyle(t, e) {
      let i, n, r;
      if (t) {
        const e = t.getFill();
        e
          ? ((n = this.textFillState_),
            n || ((n = {}), (this.textFillState_ = n)),
            (n.fillStyle = Vl(e.getColor() || yo)))
          : ((n = null), (this.textFillState_ = n));
        const s = t.getStroke();
        if (s) {
          (r = this.textStrokeState_),
            r || ((r = {}), (this.textStrokeState_ = r));
          const t = s.getLineDash(),
            e = s.getLineDashOffset(),
            i = s.getWidth(),
            n = s.getMiterLimit();
          (r.lineCap = s.getLineCap() || xo),
            (r.lineDash = t ? t.slice() : vo),
            (r.lineDashOffset = void 0 === e ? 0 : e),
            (r.lineJoin = s.getLineJoin() || So),
            (r.lineWidth = void 0 === i ? 1 : i),
            (r.miterLimit = void 0 === n ? Co : n),
            (r.strokeStyle = Vl(s.getColor() || wo));
        } else (r = null), (this.textStrokeState_ = r);
        i = this.textState_;
        const o = t.getFont() || _o;
        Io(o);
        const a = t.getScaleArray();
        (i.overflow = t.getOverflow()),
          (i.font = o),
          (i.maxAngle = t.getMaxAngle()),
          (i.placement = t.getPlacement()),
          (i.textAlign = t.getTextAlign()),
          (i.repeat = t.getRepeat()),
          (i.justify = t.getJustify()),
          (i.textBaseline = t.getTextBaseline() || Eo),
          (i.backgroundFill = t.getBackgroundFill()),
          (i.backgroundStroke = t.getBackgroundStroke()),
          (i.padding = t.getPadding() || Ro),
          (i.scale = void 0 === a ? [1, 1] : a);
        const l = t.getOffsetX(),
          h = t.getOffsetY(),
          c = t.getRotateWithView(),
          u = t.getRotation();
        (this.text_ = t.getText() || ""),
          (this.textOffsetX_ = void 0 === l ? 0 : l),
          (this.textOffsetY_ = void 0 === h ? 0 : h),
          (this.textRotateWithView_ = void 0 !== c && c),
          (this.textRotation_ = void 0 === u ? 0 : u),
          (this.strokeKey_ = r
            ? ("string" == typeof r.strokeStyle
                ? r.strokeStyle
                : j(r.strokeStyle)) +
              r.lineCap +
              r.lineDashOffset +
              "|" +
              r.lineWidth +
              r.lineJoin +
              r.miterLimit +
              "[" +
              r.lineDash.join() +
              "]"
            : ""),
          (this.textKey_ =
            i.font +
            i.scale +
            (i.textAlign || "?") +
            (i.repeat || "?") +
            (i.justify || "?") +
            (i.textBaseline || "?")),
          (this.fillKey_ = n
            ? "string" == typeof n.fillStyle
              ? n.fillStyle
              : "|" + j(n.fillStyle)
            : "");
      } else this.text_ = "";
      this.declutterImageWithText_ = e;
    }
  };
  const Hc = {
    Circle: qc,
    Default: jc,
    Image: zc,
    LineString: Uc,
    Polygon: qc,
    Text: Kc,
  };
  var Yc = class {
    constructor(t, e, i, n) {
      (this.tolerance_ = t),
        (this.maxExtent_ = e),
        (this.pixelRatio_ = n),
        (this.resolution_ = i),
        (this.buildersByZIndex_ = {});
    }
    finish() {
      const t = {};
      for (const e in this.buildersByZIndex_) {
        t[e] = t[e] || {};
        const i = this.buildersByZIndex_[e];
        for (const n in i) {
          const r = i[n].finish();
          t[e][n] = r;
        }
      }
      return t;
    }
    getBuilder(t, e) {
      const i = void 0 !== t ? t.toString() : "0";
      let n = this.buildersByZIndex_[i];
      void 0 === n && ((n = {}), (this.buildersByZIndex_[i] = n));
      let r = n[e];
      if (void 0 === r) {
        (r = new (0, Hc[e])(
          this.tolerance_,
          this.maxExtent_,
          this.resolution_,
          this.pixelRatio_
        )),
          (n[e] = r);
      }
      return r;
    }
  };
  var Qc = class extends D {
    constructor(t) {
      super(),
        (this.ready = !0),
        (this.boundHandleImageChange_ = this.handleImageChange_.bind(this)),
        (this.layer_ = t),
        (this.declutterExecutorGroup = null);
    }
    getFeatures(t) {
      return G();
    }
    getData(t) {
      return null;
    }
    prepareFrame(t) {
      return G();
    }
    renderFrame(t, e) {
      return G();
    }
    loadedTileCallback(t, e, i) {
      t[e] || (t[e] = {}), (t[e][i.tileCoord.toString()] = i);
    }
    createLoadedTileFinder(t, e, i) {
      return (n, r) => {
        const s = this.loadedTileCallback.bind(this, i, n);
        return t.forEachLoadedTile(e, n, r, s);
      };
    }
    forEachFeatureAtCoordinate(t, e, i, n, r) {}
    getLayer() {
      return this.layer_;
    }
    handleFontsChanged() {}
    handleImageChange_(t) {
      const e = t.target;
      (e.getState() !== Zr && e.getState() !== Kr) ||
        this.renderIfReadyAndVisible();
    }
    loadImage(t) {
      let e = t.getState();
      return (
        e != Zr &&
          e != Kr &&
          t.addEventListener(v, this.boundHandleImageChange_),
        e == Vr && (t.load(), (e = t.getState())),
        e == Zr
      );
    }
    renderIfReadyAndVisible() {
      const t = this.getLayer();
      t && t.getVisible() && "ready" === t.getSourceState() && t.changed();
    }
    disposeInternal() {
      delete this.layer_, super.disposeInternal();
    }
  };
  const $c = [];
  let Jc = null;
  var tu = class extends Qc {
    constructor(t) {
      super(t),
        (this.container = null),
        this.renderedResolution,
        (this.tempTransform = [1, 0, 0, 1, 0, 0]),
        (this.pixelTransform = [1, 0, 0, 1, 0, 0]),
        (this.inversePixelTransform = [1, 0, 0, 1, 0, 0]),
        (this.context = null),
        (this.containerReused = !1),
        (this.pixelContext_ = null),
        (this.frameState = null);
    }
    getImageData(t, e, i) {
      let n;
      Jc || (Jc = mt(1, 1, void 0, { willReadFrequently: !0 })),
        Jc.clearRect(0, 0, 1, 1);
      try {
        Jc.drawImage(t, e, i, 1, 1, 0, 0, 1, 1),
          (n = Jc.getImageData(0, 0, 1, 1).data);
      } catch (t) {
        return (Jc = null), null;
      }
      return n;
    }
    getBackground(t) {
      let e = this.getLayer().getBackground();
      return (
        "function" == typeof e && (e = e(t.viewState.resolution)), e || void 0
      );
    }
    useContainer(t, e, i) {
      const n = this.getLayer().getClassName();
      let r, s;
      if (
        t &&
        t.className === n &&
        (!i ||
          (t &&
            t.style.backgroundColor &&
            c(hs(t.style.backgroundColor), hs(i))))
      ) {
        const e = t.firstElementChild;
        e instanceof HTMLCanvasElement && (s = e.getContext("2d"));
      }
      if (
        (s && s.canvas.style.transform === e
          ? ((this.container = t),
            (this.context = s),
            (this.containerReused = !0))
          : this.containerReused
          ? ((this.container = null),
            (this.context = null),
            (this.containerReused = !1))
          : this.container && (this.container.style.backgroundColor = null),
        !this.container)
      ) {
        (r = document.createElement("div")), (r.className = n);
        let t = r.style;
        (t.position = "absolute"),
          (t.width = "100%"),
          (t.height = "100%"),
          (s = mt());
        const e = s.canvas;
        r.appendChild(e),
          (t = e.style),
          (t.position = "absolute"),
          (t.left = "0"),
          (t.transformOrigin = "top left"),
          (this.container = r),
          (this.context = s);
      }
      this.containerReused ||
        !i ||
        this.container.style.backgroundColor ||
        (this.container.style.backgroundColor = i);
    }
    clipUnrotated(t, e, i) {
      const n = Pe(i),
        r = be(i),
        s = Se(i),
        o = ve(i);
      Bt(e.coordinateToPixelTransform, n),
        Bt(e.coordinateToPixelTransform, r),
        Bt(e.coordinateToPixelTransform, s),
        Bt(e.coordinateToPixelTransform, o);
      const a = this.inversePixelTransform;
      Bt(a, n),
        Bt(a, r),
        Bt(a, s),
        Bt(a, o),
        t.save(),
        t.beginPath(),
        t.moveTo(Math.round(n[0]), Math.round(n[1])),
        t.lineTo(Math.round(r[0]), Math.round(r[1])),
        t.lineTo(Math.round(s[0]), Math.round(s[1])),
        t.lineTo(Math.round(o[0]), Math.round(o[1])),
        t.clip();
    }
    dispatchRenderEvent_(t, e, i) {
      const n = this.getLayer();
      if (n.hasListener(t)) {
        const r = new oo(t, this.inversePixelTransform, i, e);
        n.dispatchEvent(r);
      }
    }
    preRender(t, e) {
      (this.frameState = e), this.dispatchRenderEvent_(Ps, t, e);
    }
    postRender(t, e) {
      this.dispatchRenderEvent_(bs, t, e);
    }
    getRenderTransform(t, e, i, n, r, s, o) {
      const a = r / 2,
        l = s / 2,
        h = n / e,
        c = -h,
        u = -t[0] + o,
        d = -t[1];
      return Vt(this.tempTransform, a, l, h, c, -i, u, d);
    }
    disposeInternal() {
      delete this.frameState, super.disposeInternal();
    }
  };
  function eu(t, e, i, n, r, s, o, a, l, h, c, u) {
    let d = t[e],
      g = t[e + 1],
      f = 0,
      p = 0,
      m = 0,
      _ = 0;
    function y() {
      (f = d),
        (p = g),
        (d = t[(e += n)]),
        (g = t[e + 1]),
        (_ += m),
        (m = Math.sqrt((d - f) * (d - f) + (g - p) * (g - p)));
    }
    do {
      y();
    } while (e < i - n && _ + m < s);
    let x = 0 === m ? 0 : (s - _) / m;
    const v = yi(f, d, x),
      S = yi(p, g, x),
      C = e - n,
      w = _,
      W = s + a * l(h, r, c);
    for (; e < i - n && _ + m < W; ) y();
    x = 0 === m ? 0 : (W - _) / m;
    const E = yi(f, d, x),
      R = yi(p, g, x);
    let T;
    if (u) {
      const t = [v, S, E, R];
      En(t, 0, 4, 2, u, t, t), (T = t[0] > t[2]);
    } else T = v > E;
    const P = Math.PI,
      b = [],
      F = C + n === e;
    let I;
    if (((m = 0), (_ = w), (d = t[(e = C)]), (g = t[e + 1]), F)) {
      y(), (I = Math.atan2(g - p, d - f)), T && (I += I > 0 ? -P : P);
      const t = (E + v) / 2,
        e = (R + S) / 2;
      return (b[0] = [t, e, (W - s) / 2, I, r]), b;
    }
    for (let t = 0, u = (r = r.replace(/\n/g, " ")).length; t < u; ) {
      y();
      let v = Math.atan2(g - p, d - f);
      if ((T && (v += v > 0 ? -P : P), void 0 !== I)) {
        let t = v - I;
        if (((t += t > P ? -2 * P : t < -P ? 2 * P : 0), Math.abs(t) > o))
          return null;
      }
      I = v;
      const S = t;
      let C = 0;
      for (; t < u; ++t) {
        const o = a * l(h, r[T ? u - t - 1 : t], c);
        if (e + n < i && _ + m < s + C + o / 2) break;
        C += o;
      }
      if (t === S) continue;
      const w = T ? r.substring(u - S, u - t) : r.substring(S, t);
      x = 0 === m ? 0 : (s + C / 2 - _) / m;
      const W = yi(f, d, x),
        E = yi(p, g, x);
      b.push([W, E, C / 2, v, w]), (s += C);
    }
    return b;
  }
  const iu = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
    nu = [],
    ru = [],
    su = [],
    ou = [];
  function au(t) {
    return t[3].declutterBox;
  }
  const lu = new RegExp(
    "[" +
      String.fromCharCode(1425) +
      "-" +
      String.fromCharCode(2303) +
      String.fromCharCode(64285) +
      "-" +
      String.fromCharCode(65023) +
      String.fromCharCode(65136) +
      "-" +
      String.fromCharCode(65276) +
      String.fromCharCode(67584) +
      "-" +
      String.fromCharCode(69631) +
      String.fromCharCode(124928) +
      "-" +
      String.fromCharCode(126975) +
      "]"
  );
  function hu(t, e) {
    return (
      "start" === e
        ? (e = lu.test(t) ? "right" : "left")
        : "end" === e && (e = lu.test(t) ? "left" : "right"),
      Zc[e]
    );
  }
  function cu(t, e, i) {
    return i > 0 && t.push("\n", ""), t.push(e, ""), t;
  }
  var uu = class {
    constructor(t, e, i, n) {
      (this.overlaps = i),
        (this.pixelRatio = e),
        (this.resolution = t),
        this.alignFill_,
        (this.instructions = n.instructions),
        (this.coordinates = n.coordinates),
        (this.coordinateCache_ = {}),
        (this.renderedTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.hitDetectionInstructions = n.hitDetectionInstructions),
        (this.pixelCoordinates_ = null),
        (this.viewRotation_ = 0),
        (this.fillStates = n.fillStates || {}),
        (this.strokeStates = n.strokeStates || {}),
        (this.textStates = n.textStates || {}),
        (this.widths_ = {}),
        (this.labels_ = {});
    }
    createLabel(t, e, i, n) {
      const r = t + e + i + n;
      if (this.labels_[r]) return this.labels_[r];
      const s = n ? this.strokeStates[n] : null,
        o = i ? this.fillStates[i] : null,
        a = this.textStates[e],
        l = this.pixelRatio,
        h = [a.scale[0] * l, a.scale[1] * l],
        c = Array.isArray(t),
        u = a.justify
          ? Zc[a.justify]
          : hu(Array.isArray(t) ? t[0] : t, a.textAlign || Wo),
        d = n && s.lineWidth ? s.lineWidth : 0,
        g = c ? t : t.split("\n").reduce(cu, []),
        {
          width: f,
          height: p,
          widths: m,
          heights: _,
          lineWidths: y,
        } = Ao(a, g),
        x = f + d,
        v = [],
        S = (x + 2) * h[0],
        C = (p + d) * h[1],
        w = {
          width: S < 0 ? Math.floor(S) : Math.ceil(S),
          height: C < 0 ? Math.floor(C) : Math.ceil(C),
          contextInstructions: v,
        };
      (1 == h[0] && 1 == h[1]) || v.push("scale", h),
        n &&
          (v.push("strokeStyle", s.strokeStyle),
          v.push("lineWidth", d),
          v.push("lineCap", s.lineCap),
          v.push("lineJoin", s.lineJoin),
          v.push("miterLimit", s.miterLimit),
          v.push("setLineDash", [s.lineDash]),
          v.push("lineDashOffset", s.lineDashOffset)),
        i && v.push("fillStyle", o.fillStyle),
        v.push("textBaseline", "middle"),
        v.push("textAlign", "center");
      const W = 0.5 - u;
      let E = u * x + W * d;
      const R = [],
        T = [];
      let P,
        b = 0,
        F = 0,
        I = 0,
        L = 0;
      for (let t = 0, e = g.length; t < e; t += 2) {
        const e = g[t];
        if ("\n" === e) {
          (F += b), (b = 0), (E = u * x + W * d), ++L;
          continue;
        }
        const r = g[t + 1] || a.font;
        r !== P && (n && R.push("font", r), i && T.push("font", r), (P = r)),
          (b = Math.max(b, _[I]));
        const s = [e, E + W * m[I] + u * (m[I] - y[L]), 0.5 * (d + b) + F];
        (E += m[I]),
          n && R.push("strokeText", s),
          i && T.push("fillText", s),
          ++I;
      }
      return (
        Array.prototype.push.apply(v, R),
        Array.prototype.push.apply(v, T),
        (this.labels_[r] = w),
        w
      );
    }
    replayTextBackground_(t, e, i, n, r, s, o) {
      t.beginPath(),
        t.moveTo.apply(t, e),
        t.lineTo.apply(t, i),
        t.lineTo.apply(t, n),
        t.lineTo.apply(t, r),
        t.lineTo.apply(t, e),
        s && ((this.alignFill_ = s[2]), this.fill_(t)),
        o && (this.setStrokeStyle_(t, o), t.stroke());
    }
    calculateImageOrLabelDimensions_(
      t,
      e,
      i,
      n,
      r,
      s,
      o,
      a,
      l,
      h,
      c,
      u,
      d,
      g,
      f,
      p
    ) {
      let m = i - (o *= u[0]),
        _ = n - (a *= u[1]);
      const y = r + l > t ? t - l : r,
        x = s + h > e ? e - h : s,
        v = g[3] + y * u[0] + g[1],
        S = g[0] + x * u[1] + g[2],
        C = m - g[3],
        w = _ - g[0];
      let W;
      return (
        (f || 0 !== c) &&
          ((nu[0] = C),
          (ou[0] = C),
          (nu[1] = w),
          (ru[1] = w),
          (ru[0] = C + v),
          (su[0] = ru[0]),
          (su[1] = w + S),
          (ou[1] = su[1])),
        0 !== c
          ? ((W = Vt([1, 0, 0, 1, 0, 0], i, n, 1, 1, c, -i, -n)),
            Bt(W, nu),
            Bt(W, ru),
            Bt(W, su),
            Bt(W, ou),
            oe(
              Math.min(nu[0], ru[0], su[0], ou[0]),
              Math.min(nu[1], ru[1], su[1], ou[1]),
              Math.max(nu[0], ru[0], su[0], ou[0]),
              Math.max(nu[1], ru[1], su[1], ou[1]),
              iu
            ))
          : oe(
              Math.min(C, C + v),
              Math.min(w, w + S),
              Math.max(C, C + v),
              Math.max(w, w + S),
              iu
            ),
        d && ((m = Math.round(m)), (_ = Math.round(_))),
        {
          drawImageX: m,
          drawImageY: _,
          drawImageW: y,
          drawImageH: x,
          originX: l,
          originY: h,
          declutterBox: {
            minX: iu[0],
            minY: iu[1],
            maxX: iu[2],
            maxY: iu[3],
            value: p,
          },
          canvasTransform: W,
          scale: u,
        }
      );
    }
    replayImageOrLabel_(t, e, i, n, r, s, o) {
      const a = !(!s && !o),
        l = n.declutterBox,
        h = t.canvas,
        c = o ? (o[2] * n.scale[0]) / 2 : 0;
      return (
        l.minX - c <= h.width / e &&
          l.maxX + c >= 0 &&
          l.minY - c <= h.height / e &&
          l.maxY + c >= 0 &&
          (a && this.replayTextBackground_(t, nu, ru, su, ou, s, o),
          No(
            t,
            n.canvasTransform,
            r,
            i,
            n.originX,
            n.originY,
            n.drawImageW,
            n.drawImageH,
            n.drawImageX,
            n.drawImageY,
            n.scale
          )),
        !0
      );
    }
    fill_(t) {
      if (this.alignFill_) {
        const e = Bt(this.renderedTransform_, [0, 0]),
          i = 512 * this.pixelRatio;
        t.save(), t.translate(e[0] % i, e[1] % i), t.rotate(this.viewRotation_);
      }
      t.fill(), this.alignFill_ && t.restore();
    }
    setStrokeStyle_(t, e) {
      (t.strokeStyle = e[1]),
        (t.lineWidth = e[2]),
        (t.lineCap = e[3]),
        (t.lineJoin = e[4]),
        (t.miterLimit = e[5]),
        (t.lineDashOffset = e[7]),
        t.setLineDash(e[6]);
    }
    drawLabelWithPointPlacement_(t, e, i, n) {
      const r = this.textStates[e],
        s = this.createLabel(t, e, n, i),
        o = this.strokeStates[i],
        a = this.pixelRatio,
        l = hu(Array.isArray(t) ? t[0] : t, r.textAlign || Wo),
        h = Zc[r.textBaseline || Eo],
        c = o && o.lineWidth ? o.lineWidth : 0;
      return {
        label: s,
        anchorX: l * (s.width / a - 2 * r.scale[0]) + 2 * (0.5 - l) * c,
        anchorY: (h * s.height) / a + 2 * (0.5 - h) * c,
      };
    }
    execute_(t, e, i, n, r, s, o, a) {
      let l;
      this.pixelCoordinates_ && c(i, this.renderedTransform_)
        ? (l = this.pixelCoordinates_)
        : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []),
          (l = Wn(
            this.coordinates,
            0,
            this.coordinates.length,
            2,
            i,
            this.pixelCoordinates_
          )),
          Gt(this.renderedTransform_, i));
      let h = 0;
      const u = n.length;
      let d,
        g,
        f,
        p,
        m,
        _,
        y,
        x,
        v,
        S,
        C,
        w,
        W = 0,
        E = 0,
        R = 0,
        T = null,
        P = null;
      const b = this.coordinateCache_,
        F = this.viewRotation_,
        I = Math.round(1e12 * Math.atan2(-i[1], i[0])) / 1e12,
        L = {
          context: t,
          pixelRatio: this.pixelRatio,
          resolution: this.resolution,
          rotation: F,
        },
        M = this.instructions != n || this.overlaps ? 0 : 200;
      let O, k, A, N;
      for (; h < u; ) {
        const i = n[h];
        switch (i[0]) {
          case wc:
            (O = i[1]),
              (N = i[3]),
              O.getGeometry()
                ? void 0 === o || Ie(o, N.getExtent())
                  ? ++h
                  : (h = i[2] + 1)
                : (h = i[2]);
            break;
          case Wc:
            E > M && (this.fill_(t), (E = 0)),
              R > M && (t.stroke(), (R = 0)),
              E || R || (t.beginPath(), (p = NaN), (m = NaN)),
              ++h;
            break;
          case Ec:
            W = i[1];
            const n = l[W],
              c = l[W + 1],
              u = l[W + 2] - n,
              D = l[W + 3] - c,
              G = Math.sqrt(u * u + D * D);
            t.moveTo(n + G, c), t.arc(n, c, G, 0, 2 * Math.PI, !0), ++h;
            break;
          case Rc:
            t.closePath(), ++h;
            break;
          case Tc:
            (W = i[1]), (d = i[2]);
            const B = i[3],
              j = i[4],
              z = 6 == i.length ? i[5] : void 0;
            (L.geometry = B), (L.feature = O), h in b || (b[h] = []);
            const U = b[h];
            z
              ? z(l, W, d, 2, U)
              : ((U[0] = l[W]), (U[1] = l[W + 1]), (U.length = 2)),
              j(U, L),
              ++h;
            break;
          case bc:
            (W = i[1]), (d = i[2]), (x = i[3]), (g = i[4]), (f = i[5]);
            let q = i[6];
            const V = i[7],
              X = i[8],
              Z = i[9],
              K = i[10];
            let H = i[11];
            const Y = i[12];
            let Q = i[13];
            const $ = i[14],
              J = i[15];
            if (!x && i.length >= 20) {
              (v = i[19]), (S = i[20]), (C = i[21]), (w = i[22]);
              const t = this.drawLabelWithPointPlacement_(v, S, C, w);
              (x = t.label), (i[3] = x);
              const e = i[23];
              (g = (t.anchorX - e) * this.pixelRatio), (i[4] = g);
              const n = i[24];
              (f = (t.anchorY - n) * this.pixelRatio),
                (i[5] = f),
                (q = x.height),
                (i[6] = q),
                (Q = x.width),
                (i[13] = Q);
            }
            let tt, et, it, nt;
            i.length > 25 && (tt = i[25]),
              i.length > 17
                ? ((et = i[16]), (it = i[17]), (nt = i[18]))
                : ((et = Ro), (it = !1), (nt = !1)),
              K && I ? (H += F) : K || I || (H -= F);
            let rt = 0;
            for (; W < d; W += 2) {
              if (tt && tt[rt++] < Q / this.pixelRatio) continue;
              const i = this.calculateImageOrLabelDimensions_(
                  x.width,
                  x.height,
                  l[W],
                  l[W + 1],
                  Q,
                  q,
                  g,
                  f,
                  X,
                  Z,
                  H,
                  Y,
                  r,
                  et,
                  it || nt,
                  O
                ),
                n = [t, e, x, i, V, it ? T : null, nt ? P : null];
              if (a) {
                if ("none" === $) continue;
                if ("obstacle" === $) {
                  a.insert(i.declutterBox);
                  continue;
                }
                {
                  let t, e;
                  if (J) {
                    const i = d - W;
                    if (!J[i]) {
                      J[i] = n;
                      continue;
                    }
                    if (((t = J[i]), delete J[i], (e = au(t)), a.collides(e)))
                      continue;
                  }
                  if (a.collides(i.declutterBox)) continue;
                  t && (a.insert(e), this.replayImageOrLabel_.apply(this, t)),
                    a.insert(i.declutterBox);
                }
              }
              this.replayImageOrLabel_.apply(this, n);
            }
            ++h;
            break;
          case Pc:
            const st = i[1],
              ot = i[2],
              at = i[3],
              lt = i[4];
            w = i[5];
            const ht = i[6],
              ct = i[7],
              ut = i[8];
            C = i[9];
            const dt = i[10];
            (v = i[11]), (S = i[12]);
            const gt = [i[13], i[13]],
              ft = this.textStates[S],
              pt = ft.font,
              mt = [ft.scale[0] * ct, ft.scale[1] * ct];
            let _t;
            pt in this.widths_
              ? (_t = this.widths_[pt])
              : ((_t = {}), (this.widths_[pt] = _t));
            const yt = Dl(l, st, ot, 2),
              xt = Math.abs(mt[0]) * ko(pt, v, _t);
            if (lt || xt <= yt) {
              const i = eu(
                l,
                st,
                ot,
                2,
                v,
                (yt - xt) * hu(v, this.textStates[S].textAlign),
                ht,
                Math.abs(mt[0]),
                ko,
                pt,
                _t,
                I ? 0 : this.viewRotation_
              );
              t: if (i) {
                const n = [];
                let r, s, o, l, h;
                if (C)
                  for (r = 0, s = i.length; r < s; ++r) {
                    (h = i[r]),
                      (o = h[4]),
                      (l = this.createLabel(o, S, "", C)),
                      (g = h[2] + (mt[0] < 0 ? -dt : dt)),
                      (f =
                        at * l.height +
                        (2 * (0.5 - at) * dt * mt[1]) / mt[0] -
                        ut);
                    const s = this.calculateImageOrLabelDimensions_(
                      l.width,
                      l.height,
                      h[0],
                      h[1],
                      l.width,
                      l.height,
                      g,
                      f,
                      0,
                      0,
                      h[3],
                      gt,
                      !1,
                      Ro,
                      !1,
                      O
                    );
                    if (a && a.collides(s.declutterBox)) break t;
                    n.push([t, e, l, s, 1, null, null]);
                  }
                if (w)
                  for (r = 0, s = i.length; r < s; ++r) {
                    (h = i[r]),
                      (o = h[4]),
                      (l = this.createLabel(o, S, w, "")),
                      (g = h[2]),
                      (f = at * l.height - ut);
                    const s = this.calculateImageOrLabelDimensions_(
                      l.width,
                      l.height,
                      h[0],
                      h[1],
                      l.width,
                      l.height,
                      g,
                      f,
                      0,
                      0,
                      h[3],
                      gt,
                      !1,
                      Ro,
                      !1,
                      O
                    );
                    if (a && a.collides(s.declutterBox)) break t;
                    n.push([t, e, l, s, 1, null, null]);
                  }
                a && a.load(n.map(au));
                for (let t = 0, e = n.length; t < e; ++t)
                  this.replayImageOrLabel_.apply(this, n[t]);
              }
            }
            ++h;
            break;
          case Fc:
            if (void 0 !== s) {
              O = i[1];
              const t = s(O, N);
              if (t) return t;
            }
            ++h;
            break;
          case Ic:
            M ? E++ : this.fill_(t), ++h;
            break;
          case Lc:
            for (
              W = i[1],
                d = i[2],
                k = l[W],
                A = l[W + 1],
                _ = (k + 0.5) | 0,
                y = (A + 0.5) | 0,
                (_ === p && y === m) || (t.moveTo(k, A), (p = _), (m = y)),
                W += 2;
              W < d;
              W += 2
            )
              (k = l[W]),
                (A = l[W + 1]),
                (_ = (k + 0.5) | 0),
                (y = (A + 0.5) | 0),
                (W != d - 2 && _ === p && y === m) ||
                  (t.lineTo(k, A), (p = _), (m = y));
            ++h;
            break;
          case Mc:
            (T = i),
              (this.alignFill_ = i[2]),
              E && (this.fill_(t), (E = 0), R && (t.stroke(), (R = 0))),
              (t.fillStyle = i[1]),
              ++h;
            break;
          case Oc:
            (P = i),
              R && (t.stroke(), (R = 0)),
              this.setStrokeStyle_(t, i),
              ++h;
            break;
          case kc:
            M ? R++ : t.stroke(), ++h;
            break;
          default:
            ++h;
        }
      }
      E && this.fill_(t), R && t.stroke();
    }
    execute(t, e, i, n, r, s) {
      (this.viewRotation_ = n),
        this.execute_(t, e, i, this.instructions, r, void 0, void 0, s);
    }
    executeHitDetection(t, e, i, n, r) {
      return (
        (this.viewRotation_ = i),
        this.execute_(t, 1, e, this.hitDetectionInstructions, !0, n, r)
      );
    }
  };
  const du = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
  const gu = {};
  function fu(t) {
    if (void 0 !== gu[t]) return gu[t];
    const e = 2 * t + 1,
      i = t * t,
      n = new Array(i + 1);
    for (let r = 0; r <= t; ++r)
      for (let s = 0; s <= t; ++s) {
        const o = r * r + s * s;
        if (o > i) break;
        let a = n[o];
        a || ((a = []), (n[o] = a)),
          a.push(4 * ((t + r) * e + (t + s)) + 3),
          r > 0 && a.push(4 * ((t - r) * e + (t + s)) + 3),
          s > 0 &&
            (a.push(4 * ((t + r) * e + (t - s)) + 3),
            r > 0 && a.push(4 * ((t - r) * e + (t - s)) + 3));
      }
    const r = [];
    for (let t = 0, e = n.length; t < e; ++t) n[t] && r.push(...n[t]);
    return (gu[t] = r), r;
  }
  var pu = class {
    constructor(t, e, i, n, r, s) {
      (this.maxExtent_ = t),
        (this.overlaps_ = n),
        (this.pixelRatio_ = i),
        (this.resolution_ = e),
        (this.renderBuffer_ = s),
        (this.executorsByZIndex_ = {}),
        (this.hitDetectionContext_ = null),
        (this.hitDetectionTransform_ = [1, 0, 0, 1, 0, 0]),
        this.createExecutors_(r);
    }
    clip(t, e) {
      const i = this.getClipCoords(e);
      t.beginPath(),
        t.moveTo(i[0], i[1]),
        t.lineTo(i[2], i[3]),
        t.lineTo(i[4], i[5]),
        t.lineTo(i[6], i[7]),
        t.clip();
    }
    createExecutors_(t) {
      for (const e in t) {
        let i = this.executorsByZIndex_[e];
        void 0 === i && ((i = {}), (this.executorsByZIndex_[e] = i));
        const n = t[e];
        for (const t in n) {
          const e = n[t];
          i[t] = new uu(this.resolution_, this.pixelRatio_, this.overlaps_, e);
        }
      }
    }
    hasExecutors(t) {
      for (const e in this.executorsByZIndex_) {
        const i = this.executorsByZIndex_[e];
        for (let e = 0, n = t.length; e < n; ++e) if (t[e] in i) return !0;
      }
      return !1;
    }
    forEachFeatureAtCoordinate(t, e, i, n, r, o) {
      const a = 2 * (n = Math.round(n)) + 1,
        l = Vt(
          this.hitDetectionTransform_,
          n + 0.5,
          n + 0.5,
          1 / e,
          -1 / e,
          -i,
          -t[0],
          -t[1]
        ),
        h = !this.hitDetectionContext_;
      h &&
        (this.hitDetectionContext_ = mt(a, a, void 0, {
          willReadFrequently: !0,
        }));
      const c = this.hitDetectionContext_;
      let u;
      c.canvas.width !== a || c.canvas.height !== a
        ? ((c.canvas.width = a), (c.canvas.height = a))
        : h || c.clearRect(0, 0, a, a),
        void 0 !== this.renderBuffer_ &&
          ((u = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
          ge(u, t),
          $t(u, e * (this.renderBuffer_ + n), u));
      const d = fu(n);
      let g;
      function f(t, e) {
        const i = c.getImageData(0, 0, a, a).data;
        for (let s = 0, l = d.length; s < l; s++)
          if (i[d[s]] > 0) {
            if (!o || ("Image" !== g && "Text" !== g) || o.includes(t)) {
              const i = (d[s] - 3) / 4,
                o = n - (i % a),
                l = n - ((i / a) | 0),
                h = r(t, e, o * o + l * l);
              if (h) return h;
            }
            c.clearRect(0, 0, a, a);
            break;
          }
      }
      const p = Object.keys(this.executorsByZIndex_).map(Number);
      let m, _, y, x, v;
      for (p.sort(s), m = p.length - 1; m >= 0; --m) {
        const t = p[m].toString();
        for (y = this.executorsByZIndex_[t], _ = du.length - 1; _ >= 0; --_)
          if (
            ((g = du[_]),
            (x = y[g]),
            void 0 !== x && ((v = x.executeHitDetection(c, l, i, f, u)), v))
          )
            return v;
      }
    }
    getClipCoords(t) {
      const e = this.maxExtent_;
      if (!e) return null;
      const i = e[0],
        n = e[1],
        r = e[2],
        s = e[3],
        o = [i, n, i, s, r, s, r, n];
      return Wn(o, 0, 8, 2, t, o), o;
    }
    isEmpty() {
      return y(this.executorsByZIndex_);
    }
    execute(t, e, i, n, r, o, a) {
      const l = Object.keys(this.executorsByZIndex_).map(Number);
      let h, c, u, d, g, f;
      for (
        l.sort(s),
          this.maxExtent_ && (t.save(), this.clip(t, i)),
          o = o || du,
          a && l.reverse(),
          h = 0,
          c = l.length;
        h < c;
        ++h
      ) {
        const s = l[h].toString();
        for (g = this.executorsByZIndex_[s], u = 0, d = o.length; u < d; ++u) {
          (f = g[o[u]]), void 0 !== f && f.execute(t, e, i, n, r, a);
        }
      }
      this.maxExtent_ && t.restore();
    }
  };
  var mu = class extends Bc {
    constructor(t, e, i, n, r, s, o) {
      super(),
        (this.context_ = t),
        (this.pixelRatio_ = e),
        (this.extent_ = i),
        (this.transform_ = n),
        (this.transformRotation_ = n ? xi(Math.atan2(n[1], n[0]), 10) : 0),
        (this.viewRotation_ = r),
        (this.squaredTolerance_ = s),
        (this.userTransform_ = o),
        (this.contextFillState_ = null),
        (this.contextStrokeState_ = null),
        (this.contextTextState_ = null),
        (this.fillState_ = null),
        (this.strokeState_ = null),
        (this.image_ = null),
        (this.imageAnchorX_ = 0),
        (this.imageAnchorY_ = 0),
        (this.imageHeight_ = 0),
        (this.imageOpacity_ = 0),
        (this.imageOriginX_ = 0),
        (this.imageOriginY_ = 0),
        (this.imageRotateWithView_ = !1),
        (this.imageRotation_ = 0),
        (this.imageScale_ = [0, 0]),
        (this.imageWidth_ = 0),
        (this.text_ = ""),
        (this.textOffsetX_ = 0),
        (this.textOffsetY_ = 0),
        (this.textRotateWithView_ = !1),
        (this.textRotation_ = 0),
        (this.textScale_ = [0, 0]),
        (this.textFillState_ = null),
        (this.textStrokeState_ = null),
        (this.textState_ = null),
        (this.pixelCoordinates_ = []),
        (this.tmpLocalTransform_ = [1, 0, 0, 1, 0, 0]);
    }
    drawImages_(t, e, i, n) {
      if (!this.image_) return;
      const r = Wn(t, e, i, n, this.transform_, this.pixelCoordinates_),
        s = this.context_,
        o = this.tmpLocalTransform_,
        a = s.globalAlpha;
      1 != this.imageOpacity_ && (s.globalAlpha = a * this.imageOpacity_);
      let l = this.imageRotation_;
      0 === this.transformRotation_ && (l -= this.viewRotation_),
        this.imageRotateWithView_ && (l += this.viewRotation_);
      for (let t = 0, e = r.length; t < e; t += 2) {
        const e = r[t] - this.imageAnchorX_,
          i = r[t + 1] - this.imageAnchorY_;
        if (0 !== l || 1 != this.imageScale_[0] || 1 != this.imageScale_[1]) {
          const t = e + this.imageAnchorX_,
            n = i + this.imageAnchorY_;
          Vt(o, t, n, 1, 1, l, -t, -n),
            s.save(),
            s.transform.apply(s, o),
            s.translate(t, n),
            s.scale(this.imageScale_[0], this.imageScale_[1]),
            s.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              -this.imageAnchorX_,
              -this.imageAnchorY_,
              this.imageWidth_,
              this.imageHeight_
            ),
            s.restore();
        } else
          s.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            e,
            i,
            this.imageWidth_,
            this.imageHeight_
          );
      }
      1 != this.imageOpacity_ && (s.globalAlpha = a);
    }
    drawText_(t, e, i, n) {
      if (!this.textState_ || "" === this.text_) return;
      this.textFillState_ && this.setContextFillState_(this.textFillState_),
        this.textStrokeState_ &&
          this.setContextStrokeState_(this.textStrokeState_),
        this.setContextTextState_(this.textState_);
      const r = Wn(t, e, i, n, this.transform_, this.pixelCoordinates_),
        s = this.context_;
      let o = this.textRotation_;
      for (
        0 === this.transformRotation_ && (o -= this.viewRotation_),
          this.textRotateWithView_ && (o += this.viewRotation_);
        e < i;
        e += n
      ) {
        const t = r[e] + this.textOffsetX_,
          i = r[e + 1] + this.textOffsetY_;
        0 !== o || 1 != this.textScale_[0] || 1 != this.textScale_[1]
          ? (s.save(),
            s.translate(t - this.textOffsetX_, i - this.textOffsetY_),
            s.rotate(o),
            s.translate(this.textOffsetX_, this.textOffsetY_),
            s.scale(this.textScale_[0], this.textScale_[1]),
            this.textStrokeState_ && s.strokeText(this.text_, 0, 0),
            this.textFillState_ && s.fillText(this.text_, 0, 0),
            s.restore())
          : (this.textStrokeState_ && s.strokeText(this.text_, t, i),
            this.textFillState_ && s.fillText(this.text_, t, i));
      }
    }
    moveToLineTo_(t, e, i, n, r) {
      const s = this.context_,
        o = Wn(t, e, i, n, this.transform_, this.pixelCoordinates_);
      s.moveTo(o[0], o[1]);
      let a = o.length;
      r && (a -= 2);
      for (let t = 2; t < a; t += 2) s.lineTo(o[t], o[t + 1]);
      return r && s.closePath(), i;
    }
    drawRings_(t, e, i, n) {
      for (let r = 0, s = i.length; r < s; ++r)
        e = this.moveToLineTo_(t, e, i[r], n, !0);
      return e;
    }
    drawCircle(t) {
      if (
        (this.squaredTolerance_ &&
          (t = t.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          )),
        Ie(this.extent_, t.getExtent()))
      ) {
        if (this.fillState_ || this.strokeState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_),
            this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = In(t, this.transform_, this.pixelCoordinates_),
            i = e[2] - e[0],
            n = e[3] - e[1],
            r = Math.sqrt(i * i + n * n),
            s = this.context_;
          s.beginPath(),
            s.arc(e[0], e[1], r, 0, 2 * Math.PI),
            this.fillState_ && s.fill(),
            this.strokeState_ && s.stroke();
        }
        "" !== this.text_ && this.drawText_(t.getCenter(), 0, 2, 2);
      }
    }
    setStyle(t) {
      this.setFillStrokeStyle(t.getFill(), t.getStroke()),
        this.setImageStyle(t.getImage()),
        this.setTextStyle(t.getText());
    }
    setTransform(t) {
      this.transform_ = t;
    }
    drawGeometry(t) {
      switch (t.getType()) {
        case "Point":
          this.drawPoint(t);
          break;
        case "LineString":
          this.drawLineString(t);
          break;
        case "Polygon":
          this.drawPolygon(t);
          break;
        case "MultiPoint":
          this.drawMultiPoint(t);
          break;
        case "MultiLineString":
          this.drawMultiLineString(t);
          break;
        case "MultiPolygon":
          this.drawMultiPolygon(t);
          break;
        case "GeometryCollection":
          this.drawGeometryCollection(t);
          break;
        case "Circle":
          this.drawCircle(t);
      }
    }
    drawFeature(t, e) {
      const i = e.getGeometryFunction()(t);
      i && (this.setStyle(e), this.drawGeometry(i));
    }
    drawGeometryCollection(t) {
      const e = t.getGeometriesArray();
      for (let t = 0, i = e.length; t < i; ++t) this.drawGeometry(e[t]);
    }
    drawPoint(t) {
      this.squaredTolerance_ &&
        (t = t.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        ));
      const e = t.getFlatCoordinates(),
        i = t.getStride();
      this.image_ && this.drawImages_(e, 0, e.length, i),
        "" !== this.text_ && this.drawText_(e, 0, e.length, i);
    }
    drawMultiPoint(t) {
      this.squaredTolerance_ &&
        (t = t.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        ));
      const e = t.getFlatCoordinates(),
        i = t.getStride();
      this.image_ && this.drawImages_(e, 0, e.length, i),
        "" !== this.text_ && this.drawText_(e, 0, e.length, i);
    }
    drawLineString(t) {
      if (
        (this.squaredTolerance_ &&
          (t = t.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          )),
        Ie(this.extent_, t.getExtent()))
      ) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const e = this.context_,
            i = t.getFlatCoordinates();
          e.beginPath(),
            this.moveToLineTo_(i, 0, i.length, t.getStride(), !1),
            e.stroke();
        }
        if ("" !== this.text_) {
          const e = t.getFlatMidpoint();
          this.drawText_(e, 0, 2, 2);
        }
      }
    }
    drawMultiLineString(t) {
      this.squaredTolerance_ &&
        (t = t.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        ));
      const e = t.getExtent();
      if (Ie(this.extent_, e)) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const e = this.context_,
            i = t.getFlatCoordinates();
          let n = 0;
          const r = t.getEnds(),
            s = t.getStride();
          e.beginPath();
          for (let t = 0, e = r.length; t < e; ++t)
            n = this.moveToLineTo_(i, n, r[t], s, !1);
          e.stroke();
        }
        if ("" !== this.text_) {
          const e = t.getFlatMidpoints();
          this.drawText_(e, 0, e.length, 2);
        }
      }
    }
    drawPolygon(t) {
      if (
        (this.squaredTolerance_ &&
          (t = t.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          )),
        Ie(this.extent_, t.getExtent()))
      ) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_),
            this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = this.context_;
          e.beginPath(),
            this.drawRings_(
              t.getOrientedFlatCoordinates(),
              0,
              t.getEnds(),
              t.getStride()
            ),
            this.fillState_ && e.fill(),
            this.strokeState_ && e.stroke();
        }
        if ("" !== this.text_) {
          const e = t.getFlatInteriorPoint();
          this.drawText_(e, 0, 2, 2);
        }
      }
    }
    drawMultiPolygon(t) {
      if (
        (this.squaredTolerance_ &&
          (t = t.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          )),
        Ie(this.extent_, t.getExtent()))
      ) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_),
            this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const e = this.context_,
            i = t.getOrientedFlatCoordinates();
          let n = 0;
          const r = t.getEndss(),
            s = t.getStride();
          e.beginPath();
          for (let t = 0, e = r.length; t < e; ++t) {
            const e = r[t];
            n = this.drawRings_(i, n, e, s);
          }
          this.fillState_ && e.fill(), this.strokeState_ && e.stroke();
        }
        if ("" !== this.text_) {
          const e = t.getFlatInteriorPoints();
          this.drawText_(e, 0, e.length, 2);
        }
      }
    }
    setContextFillState_(t) {
      const e = this.context_,
        i = this.contextFillState_;
      i
        ? i.fillStyle != t.fillStyle &&
          ((i.fillStyle = t.fillStyle), (e.fillStyle = t.fillStyle))
        : ((e.fillStyle = t.fillStyle),
          (this.contextFillState_ = { fillStyle: t.fillStyle }));
    }
    setContextStrokeState_(t) {
      const e = this.context_,
        i = this.contextStrokeState_;
      i
        ? (i.lineCap != t.lineCap &&
            ((i.lineCap = t.lineCap), (e.lineCap = t.lineCap)),
          c(i.lineDash, t.lineDash) || e.setLineDash((i.lineDash = t.lineDash)),
          i.lineDashOffset != t.lineDashOffset &&
            ((i.lineDashOffset = t.lineDashOffset),
            (e.lineDashOffset = t.lineDashOffset)),
          i.lineJoin != t.lineJoin &&
            ((i.lineJoin = t.lineJoin), (e.lineJoin = t.lineJoin)),
          i.lineWidth != t.lineWidth &&
            ((i.lineWidth = t.lineWidth), (e.lineWidth = t.lineWidth)),
          i.miterLimit != t.miterLimit &&
            ((i.miterLimit = t.miterLimit), (e.miterLimit = t.miterLimit)),
          i.strokeStyle != t.strokeStyle &&
            ((i.strokeStyle = t.strokeStyle), (e.strokeStyle = t.strokeStyle)))
        : ((e.lineCap = t.lineCap),
          e.setLineDash(t.lineDash),
          (e.lineDashOffset = t.lineDashOffset),
          (e.lineJoin = t.lineJoin),
          (e.lineWidth = t.lineWidth),
          (e.miterLimit = t.miterLimit),
          (e.strokeStyle = t.strokeStyle),
          (this.contextStrokeState_ = {
            lineCap: t.lineCap,
            lineDash: t.lineDash,
            lineDashOffset: t.lineDashOffset,
            lineJoin: t.lineJoin,
            lineWidth: t.lineWidth,
            miterLimit: t.miterLimit,
            strokeStyle: t.strokeStyle,
          }));
    }
    setContextTextState_(t) {
      const e = this.context_,
        i = this.contextTextState_,
        n = t.textAlign ? t.textAlign : Wo;
      i
        ? (i.font != t.font && ((i.font = t.font), (e.font = t.font)),
          i.textAlign != n && ((i.textAlign = n), (e.textAlign = n)),
          i.textBaseline != t.textBaseline &&
            ((i.textBaseline = t.textBaseline),
            (e.textBaseline = t.textBaseline)))
        : ((e.font = t.font),
          (e.textAlign = n),
          (e.textBaseline = t.textBaseline),
          (this.contextTextState_ = {
            font: t.font,
            textAlign: n,
            textBaseline: t.textBaseline,
          }));
    }
    setFillStrokeStyle(t, e) {
      if (t) {
        const e = t.getColor();
        this.fillState_ = { fillStyle: Vl(e || yo) };
      } else this.fillState_ = null;
      if (e) {
        const t = e.getColor(),
          i = e.getLineCap(),
          n = e.getLineDash(),
          r = e.getLineDashOffset(),
          s = e.getLineJoin(),
          o = e.getWidth(),
          a = e.getMiterLimit(),
          l = n || vo;
        this.strokeState_ = {
          lineCap: void 0 !== i ? i : xo,
          lineDash:
            1 === this.pixelRatio_ ? l : l.map((t) => t * this.pixelRatio_),
          lineDashOffset: (r || 0) * this.pixelRatio_,
          lineJoin: void 0 !== s ? s : So,
          lineWidth: (void 0 !== o ? o : 1) * this.pixelRatio_,
          miterLimit: void 0 !== a ? a : Co,
          strokeStyle: Vl(t || wo),
        };
      } else this.strokeState_ = null;
    }
    setImageStyle(t) {
      let e;
      if (!t || !(e = t.getSize())) return void (this.image_ = null);
      const i = t.getPixelRatio(this.pixelRatio_),
        n = t.getAnchor(),
        r = t.getOrigin();
      (this.image_ = t.getImage(this.pixelRatio_)),
        (this.imageAnchorX_ = n[0] * i),
        (this.imageAnchorY_ = n[1] * i),
        (this.imageHeight_ = e[1] * i),
        (this.imageOpacity_ = t.getOpacity()),
        (this.imageOriginX_ = r[0]),
        (this.imageOriginY_ = r[1]),
        (this.imageRotateWithView_ = t.getRotateWithView()),
        (this.imageRotation_ = t.getRotation());
      const s = t.getScaleArray();
      (this.imageScale_ = [
        (s[0] * this.pixelRatio_) / i,
        (s[1] * this.pixelRatio_) / i,
      ]),
        (this.imageWidth_ = e[0] * i);
    }
    setTextStyle(t) {
      if (t) {
        const e = t.getFill();
        if (e) {
          const t = e.getColor();
          this.textFillState_ = { fillStyle: Vl(t || yo) };
        } else this.textFillState_ = null;
        const i = t.getStroke();
        if (i) {
          const t = i.getColor(),
            e = i.getLineCap(),
            n = i.getLineDash(),
            r = i.getLineDashOffset(),
            s = i.getLineJoin(),
            o = i.getWidth(),
            a = i.getMiterLimit();
          this.textStrokeState_ = {
            lineCap: void 0 !== e ? e : xo,
            lineDash: n || vo,
            lineDashOffset: r || 0,
            lineJoin: void 0 !== s ? s : So,
            lineWidth: void 0 !== o ? o : 1,
            miterLimit: void 0 !== a ? a : Co,
            strokeStyle: Vl(t || wo),
          };
        } else this.textStrokeState_ = null;
        const n = t.getFont(),
          r = t.getOffsetX(),
          s = t.getOffsetY(),
          o = t.getRotateWithView(),
          a = t.getRotation(),
          l = t.getScaleArray(),
          h = t.getText(),
          c = t.getTextAlign(),
          u = t.getTextBaseline();
        (this.textState_ = {
          font: void 0 !== n ? n : _o,
          textAlign: void 0 !== c ? c : Wo,
          textBaseline: void 0 !== u ? u : Eo,
        }),
          (this.text_ =
            void 0 !== h
              ? Array.isArray(h)
                ? h.reduce((t, e, i) => t + (i % 2 ? " " : e), "")
                : h
              : ""),
          (this.textOffsetX_ = void 0 !== r ? this.pixelRatio_ * r : 0),
          (this.textOffsetY_ = void 0 !== s ? this.pixelRatio_ * s : 0),
          (this.textRotateWithView_ = void 0 !== o && o),
          (this.textRotation_ = void 0 !== a ? a : 0),
          (this.textScale_ = [
            this.pixelRatio_ * l[0],
            this.pixelRatio_ * l[1],
          ]);
      } else this.text_ = "";
    }
  };
  const _u = 0.5;
  function yu(t, e, i, n, r, o, a) {
    const l = mt(t[0] * _u, t[1] * _u);
    l.imageSmoothingEnabled = !1;
    const h = l.canvas,
      c = new mu(l, _u, r, null, a),
      u = i.length,
      d = Math.floor(16777215 / u),
      g = {};
    for (let t = 1; t <= u; ++t) {
      const e = i[t - 1],
        s = e.getStyleFunction() || n;
      if (!s) continue;
      let a = s(e, o);
      if (!a) continue;
      Array.isArray(a) || (a = [a]);
      const l = (t * d).toString(16).padStart(7, "#00000");
      for (let t = 0, i = a.length; t < i; ++t) {
        const i = a[t],
          n = i.getGeometryFunction()(e);
        if (!n || !Ie(r, n.getExtent())) continue;
        const s = i.clone(),
          o = s.getFill();
        o && o.setColor(l);
        const h = s.getStroke();
        h && (h.setColor(l), h.setLineDash(null)), s.setText(void 0);
        const c = i.getImage();
        if (c) {
          const t = c.getImageSize();
          if (!t) continue;
          const e = mt(t[0], t[1], void 0, { alpha: !1 }),
            i = e.canvas;
          (e.fillStyle = l),
            e.fillRect(0, 0, i.width, i.height),
            s.setImage(
              new bh({
                img: i,
                anchor: c.getAnchor(),
                anchorXUnits: "pixels",
                anchorYUnits: "pixels",
                offset: c.getOrigin(),
                opacity: 1,
                size: c.getSize(),
                scale: c.getScale(),
                rotation: c.getRotation(),
                rotateWithView: c.getRotateWithView(),
              })
            );
        }
        const u = s.getZIndex() || 0;
        let d = g[u];
        d ||
          ((d = {}),
          (g[u] = d),
          (d.Polygon = []),
          (d.Circle = []),
          (d.LineString = []),
          (d.Point = []));
        const f = n.getType();
        if ("GeometryCollection" === f) {
          const t = n.getGeometriesArrayRecursive();
          for (let e = 0, i = t.length; e < i; ++e) {
            const i = t[e];
            d[i.getType().replace("Multi", "")].push(i, s);
          }
        } else d[f.replace("Multi", "")].push(n, s);
      }
    }
    const f = Object.keys(g).map(Number).sort(s);
    for (let t = 0, i = f.length; t < i; ++t) {
      const i = g[f[t]];
      for (const t in i) {
        const n = i[t];
        for (let t = 0, i = n.length; t < i; t += 2) {
          c.setStyle(n[t + 1]);
          for (let i = 0, r = e.length; i < r; ++i)
            c.setTransform(e[i]), c.drawGeometry(n[t]);
        }
      }
    }
    return l.getImageData(0, 0, h.width, h.height);
  }
  function xu(t, e, i) {
    const n = [];
    if (i) {
      const r = Math.floor(Math.round(t[0]) * _u),
        s = Math.floor(Math.round(t[1]) * _u),
        o = 4 * (ui(r, 0, i.width - 1) + ui(s, 0, i.height - 1) * i.width),
        a = i.data[o],
        l = i.data[o + 1],
        h = i.data[o + 2] + 256 * (l + 256 * a),
        c = Math.floor(16777215 / e.length);
      h && h % c == 0 && n.push(e[h / c - 1]);
    }
    return n;
  }
  const vu = 0.5,
    Su = {
      Point: function (t, e, i, n, r) {
        const s = i.getImage(),
          o = i.getText();
        let a;
        if (s) {
          if (s.getImageState() != Zr) return;
          let l = t;
          if (r) {
            const h = s.getDeclutterMode();
            if ("none" !== h)
              if (((l = r), "obstacle" === h)) {
                const r = t.getBuilder(i.getZIndex(), "Image");
                r.setImageStyle(s, a), r.drawPoint(e, n);
              } else o && o.getText() && (a = {});
          }
          const h = l.getBuilder(i.getZIndex(), "Image");
          h.setImageStyle(s, a), h.drawPoint(e, n);
        }
        if (o && o.getText()) {
          let s = t;
          r && (s = r);
          const l = s.getBuilder(i.getZIndex(), "Text");
          l.setTextStyle(o, a), l.drawText(e, n);
        }
      },
      LineString: function (t, e, i, n, r) {
        const s = i.getStroke();
        if (s) {
          const r = t.getBuilder(i.getZIndex(), "LineString");
          r.setFillStrokeStyle(null, s), r.drawLineString(e, n);
        }
        const o = i.getText();
        if (o && o.getText()) {
          const s = (r || t).getBuilder(i.getZIndex(), "Text");
          s.setTextStyle(o), s.drawText(e, n);
        }
      },
      Polygon: function (t, e, i, n, r) {
        const s = i.getFill(),
          o = i.getStroke();
        if (s || o) {
          const r = t.getBuilder(i.getZIndex(), "Polygon");
          r.setFillStrokeStyle(s, o), r.drawPolygon(e, n);
        }
        const a = i.getText();
        if (a && a.getText()) {
          const s = (r || t).getBuilder(i.getZIndex(), "Text");
          s.setTextStyle(a), s.drawText(e, n);
        }
      },
      MultiPoint: function (t, e, i, n, r) {
        const s = i.getImage(),
          o = i.getText();
        let a;
        if (s) {
          if (s.getImageState() != Zr) return;
          let l = t;
          if (r) {
            const h = s.getDeclutterMode();
            if ("none" !== h)
              if (((l = r), "obstacle" === h)) {
                const r = t.getBuilder(i.getZIndex(), "Image");
                r.setImageStyle(s, a), r.drawMultiPoint(e, n);
              } else o && o.getText() && (a = {});
          }
          const h = l.getBuilder(i.getZIndex(), "Image");
          h.setImageStyle(s, a), h.drawMultiPoint(e, n);
        }
        if (o && o.getText()) {
          let s = t;
          r && (s = r);
          const l = s.getBuilder(i.getZIndex(), "Text");
          l.setTextStyle(o, a), l.drawText(e, n);
        }
      },
      MultiLineString: function (t, e, i, n, r) {
        const s = i.getStroke();
        if (s) {
          const r = t.getBuilder(i.getZIndex(), "LineString");
          r.setFillStrokeStyle(null, s), r.drawMultiLineString(e, n);
        }
        const o = i.getText();
        if (o && o.getText()) {
          const s = (r || t).getBuilder(i.getZIndex(), "Text");
          s.setTextStyle(o), s.drawText(e, n);
        }
      },
      MultiPolygon: function (t, e, i, n, r) {
        const s = i.getFill(),
          o = i.getStroke();
        if (o || s) {
          const r = t.getBuilder(i.getZIndex(), "Polygon");
          r.setFillStrokeStyle(s, o), r.drawMultiPolygon(e, n);
        }
        const a = i.getText();
        if (a && a.getText()) {
          const s = (r || t).getBuilder(i.getZIndex(), "Text");
          s.setTextStyle(a), s.drawText(e, n);
        }
      },
      GeometryCollection: function (t, e, i, n, r) {
        const s = e.getGeometriesArray();
        let o, a;
        for (o = 0, a = s.length; o < a; ++o) {
          (0, Su[s[o].getType()])(t, s[o], i, n, r);
        }
      },
      Circle: function (t, e, i, n, r) {
        const s = i.getFill(),
          o = i.getStroke();
        if (s || o) {
          const r = t.getBuilder(i.getZIndex(), "Circle");
          r.setFillStrokeStyle(s, o), r.drawCircle(e, n);
        }
        const a = i.getText();
        if (a && a.getText()) {
          const s = (r || t).getBuilder(i.getZIndex(), "Text");
          s.setTextStyle(a), s.drawText(e, n);
        }
      },
    };
  function Cu(t, e) {
    return parseInt(j(t), 10) - parseInt(j(e), 10);
  }
  function wu(t, e) {
    const i = Wu(t, e);
    return i * i;
  }
  function Wu(t, e) {
    return (vu * t) / e;
  }
  function Eu(t, e, i, n, r, s, o) {
    let a = !1;
    const l = i.getImage();
    if (l) {
      const t = l.getImageState();
      t == Zr || t == Kr
        ? l.unlistenImageChange(r)
        : (t == Vr && l.load(), l.listenImageChange(r), (a = !0));
    }
    return (
      (function (t, e, i, n, r, s) {
        const o = i.getGeometryFunction()(e);
        if (!o) return;
        const a = o.simplifyTransformed(n, r),
          l = i.getRenderer();
        if (l) Ru(t, a, i, e);
        else {
          (0, Su[a.getType()])(t, a, i, e, s);
        }
      })(t, e, i, n, s, o),
      a
    );
  }
  function Ru(t, e, i, n) {
    if ("GeometryCollection" == e.getType()) {
      const r = e.getGeometries();
      for (let e = 0, s = r.length; e < s; ++e) Ru(t, r[e], i, n);
      return;
    }
    t.getBuilder(i.getZIndex(), "Default").drawCustom(
      e,
      n,
      i.getRenderer(),
      i.getHitDetectionRenderer()
    );
  }
  var Tu = class extends tu {
    constructor(t) {
      super(t),
        (this.boundHandleStyleImageChange_ =
          this.handleStyleImageChange_.bind(this)),
        this.animatingOrInteracting_,
        (this.hitDetectionImageData_ = null),
        (this.renderedFeatures_ = null),
        (this.renderedRevision_ = -1),
        (this.renderedResolution_ = NaN),
        (this.renderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        (this.wrappedRenderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        this.renderedRotation_,
        (this.renderedCenter_ = null),
        (this.renderedProjection_ = null),
        (this.renderedRenderOrder_ = null),
        (this.replayGroup_ = null),
        (this.replayGroupChanged = !0),
        (this.declutterExecutorGroup = null),
        (this.clipping = !0),
        (this.compositionContext_ = null),
        (this.opacity_ = 1);
    }
    renderWorlds(t, e, i) {
      const n = e.extent,
        r = e.viewState,
        s = r.center,
        o = r.resolution,
        a = r.projection,
        l = r.rotation,
        h = a.getExtent(),
        c = this.getLayer().getSource(),
        u = e.pixelRatio,
        d = e.viewHints,
        g = !(d[Ms] || d[Os]),
        f = this.compositionContext_,
        p = Math.round(e.size[0] * u),
        m = Math.round(e.size[1] * u),
        _ = c.getWrapX() && a.canWrapX(),
        y = _ ? Fe(h) : null,
        x = _ ? Math.ceil((n[2] - h[2]) / y) + 1 : 1;
      let v = _ ? Math.floor((n[0] - h[0]) / y) : 0;
      do {
        const e = this.getRenderTransform(s, o, l, u, p, m, v * y);
        t.execute(f, 1, e, l, g, void 0, i);
      } while (++v < x);
    }
    setupCompositionContext_() {
      if (1 !== this.opacity_) {
        const t = mt(this.context.canvas.width, this.context.canvas.height, $c);
        this.compositionContext_ = t;
      } else this.compositionContext_ = this.context;
    }
    releaseCompositionContext_() {
      if (1 !== this.opacity_) {
        const t = this.context.globalAlpha;
        (this.context.globalAlpha = this.opacity_),
          this.context.drawImage(this.compositionContext_.canvas, 0, 0),
          (this.context.globalAlpha = t),
          _t(this.compositionContext_),
          $c.push(this.compositionContext_.canvas),
          (this.compositionContext_ = null);
      }
    }
    renderDeclutter(t) {
      this.declutterExecutorGroup &&
        (this.setupCompositionContext_(),
        this.renderWorlds(this.declutterExecutorGroup, t, t.declutterTree),
        this.releaseCompositionContext_());
    }
    renderFrame(t, e) {
      const i = t.pixelRatio,
        n = t.layerStatesArray[t.layerIndex];
      Ut(this.pixelTransform, 1 / i, 1 / i),
        Xt(this.inversePixelTransform, this.pixelTransform);
      const r = Ht(this.pixelTransform);
      this.useContainer(e, r, this.getBackground(t));
      const s = this.context,
        o = s.canvas,
        a = this.replayGroup_,
        l = this.declutterExecutorGroup;
      let h = (a && !a.isEmpty()) || (l && !l.isEmpty());
      if (!h) {
        if (
          !(this.getLayer().hasListener(Ps) || this.getLayer().hasListener(bs))
        )
          return null;
      }
      const c = Math.round(t.size[0] * i),
        u = Math.round(t.size[1] * i);
      o.width != c || o.height != u
        ? ((o.width = c),
          (o.height = u),
          o.style.transform !== r && (o.style.transform = r))
        : this.containerReused || s.clearRect(0, 0, c, u),
        this.preRender(s, t);
      const d = t.viewState,
        g = d.projection;
      (this.opacity_ = n.opacity), this.setupCompositionContext_();
      let f = !1;
      if (h && n.extent && this.clipping) {
        const e = xn(n.extent, g);
        (h = Ie(e, t.extent)),
          (f = h && !ie(e, t.extent)),
          f && this.clipUnrotated(this.compositionContext_, t, e);
      }
      return (
        h && this.renderWorlds(a, t),
        f && this.compositionContext_.restore(),
        this.releaseCompositionContext_(),
        this.postRender(s, t),
        this.renderedRotation_ !== d.rotation &&
          ((this.renderedRotation_ = d.rotation),
          (this.hitDetectionImageData_ = null)),
        this.container
      );
    }
    getFeatures(t) {
      return new Promise((e) => {
        if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const t = [this.context.canvas.width, this.context.canvas.height];
          Bt(this.pixelTransform, t);
          const e = this.renderedCenter_,
            i = this.renderedResolution_,
            n = this.renderedRotation_,
            r = this.renderedProjection_,
            s = this.wrappedRenderedExtent_,
            o = this.getLayer(),
            a = [],
            l = t[0] * _u,
            h = t[1] * _u;
          a.push(this.getRenderTransform(e, i, n, _u, l, h, 0).slice());
          const c = o.getSource(),
            u = r.getExtent();
          if (c.getWrapX() && r.canWrapX() && !ie(u, s)) {
            let t = s[0];
            const r = Fe(u);
            let o,
              c = 0;
            for (; t < u[0]; )
              --c,
                (o = r * c),
                a.push(this.getRenderTransform(e, i, n, _u, l, h, o).slice()),
                (t += r);
            for (c = 0, t = s[2]; t > u[2]; )
              ++c,
                (o = r * c),
                a.push(this.getRenderTransform(e, i, n, _u, l, h, o).slice()),
                (t -= r);
          }
          this.hitDetectionImageData_ = yu(
            t,
            a,
            this.renderedFeatures_,
            o.getStyleFunction(),
            s,
            i,
            n
          );
        }
        e(xu(t, this.renderedFeatures_, this.hitDetectionImageData_));
      });
    }
    forEachFeatureAtCoordinate(t, e, i, n, r) {
      if (!this.replayGroup_) return;
      const s = e.viewState.resolution,
        o = e.viewState.rotation,
        a = this.getLayer(),
        l = {},
        h = function (t, e, i) {
          const s = j(t),
            o = l[s];
          if (o) {
            if (!0 !== o && i < o.distanceSq) {
              if (0 === i)
                return (l[s] = !0), r.splice(r.lastIndexOf(o), 1), n(t, a, e);
              (o.geometry = e), (o.distanceSq = i);
            }
          } else {
            if (0 === i) return (l[s] = !0), n(t, a, e);
            r.push(
              (l[s] = {
                feature: t,
                layer: a,
                geometry: e,
                distanceSq: i,
                callback: n,
              })
            );
          }
        };
      let c;
      const u = [this.replayGroup_];
      return (
        this.declutterExecutorGroup && u.push(this.declutterExecutorGroup),
        u.some(
          (n) =>
            (c = n.forEachFeatureAtCoordinate(
              t,
              s,
              o,
              i,
              h,
              n === this.declutterExecutorGroup && e.declutterTree
                ? e.declutterTree.all().map((t) => t.value)
                : null
            ))
        ),
        c
      );
    }
    handleFontsChanged() {
      const t = this.getLayer();
      t.getVisible() && this.replayGroup_ && t.changed();
    }
    handleStyleImageChange_(t) {
      this.renderIfReadyAndVisible();
    }
    prepareFrame(t) {
      const e = this.getLayer(),
        i = e.getSource();
      if (!i) return !1;
      const n = t.viewHints[Ms],
        r = t.viewHints[Os],
        s = e.getUpdateWhileAnimating(),
        o = e.getUpdateWhileInteracting();
      if ((this.ready && !s && n) || (!o && r))
        return (this.animatingOrInteracting_ = !0), !0;
      this.animatingOrInteracting_ = !1;
      const a = t.extent,
        l = t.viewState,
        h = l.projection,
        u = l.resolution,
        d = t.pixelRatio,
        g = e.getRevision(),
        f = e.getRenderBuffer();
      let p = e.getRenderOrder();
      void 0 === p && (p = Cu);
      const m = l.center.slice(),
        _ = $t(a, f * u),
        y = _.slice(),
        x = [_.slice()],
        v = h.getExtent();
      if (i.getWrapX() && h.canWrapX() && !ie(v, t.extent)) {
        const t = Fe(v),
          e = Math.max(Fe(_) / 2, t);
        (_[0] = v[0] - e), (_[2] = v[2] + e), Ni(m, h);
        const i = Ne(x[0], h);
        i[0] < v[0] && i[2] < v[2]
          ? x.push([i[0] + t, i[1], i[2] + t, i[3]])
          : i[0] > v[0] &&
            i[2] > v[2] &&
            x.push([i[0] - t, i[1], i[2] - t, i[3]]);
      }
      if (
        this.ready &&
        this.renderedResolution_ == u &&
        this.renderedRevision_ == g &&
        this.renderedRenderOrder_ == p &&
        ie(this.wrappedRenderedExtent_, _)
      )
        return (
          c(this.renderedExtent_, y) ||
            ((this.hitDetectionImageData_ = null), (this.renderedExtent_ = y)),
          (this.renderedCenter_ = m),
          (this.replayGroupChanged = !1),
          !0
        );
      this.replayGroup_ = null;
      const S = new Yc(Wu(u, d), _, u, d);
      let C;
      this.getLayer().getDeclutter() && (C = new Yc(Wu(u, d), _, u, d));
      const w = pn();
      let W;
      if (w) {
        for (let t = 0, e = x.length; t < e; ++t) {
          const e = yn(x[t], h);
          i.loadFeatures(e, vn(u, h), w);
        }
        W = hn(w, h);
      } else
        for (let t = 0, e = x.length; t < e; ++t) i.loadFeatures(x[t], u, h);
      const E = wu(u, d);
      let R = !0;
      const T = (t) => {
          let i;
          const n = t.getStyleFunction() || e.getStyleFunction();
          if ((n && (i = n(t, u)), i)) {
            const e = this.renderFeature(t, E, i, S, W, C);
            R = R && !e;
          }
        },
        P = yn(_, h),
        b = i.getFeaturesInExtent(P);
      p && b.sort(p);
      for (let t = 0, e = b.length; t < e; ++t) T(b[t]);
      (this.renderedFeatures_ = b), (this.ready = R);
      const F = S.finish(),
        I = new pu(_, u, d, i.getOverlaps(), F, e.getRenderBuffer());
      return (
        C &&
          (this.declutterExecutorGroup = new pu(
            _,
            u,
            d,
            i.getOverlaps(),
            C.finish(),
            e.getRenderBuffer()
          )),
        (this.renderedResolution_ = u),
        (this.renderedRevision_ = g),
        (this.renderedRenderOrder_ = p),
        (this.renderedExtent_ = y),
        (this.wrappedRenderedExtent_ = _),
        (this.renderedCenter_ = m),
        (this.renderedProjection_ = h),
        (this.replayGroup_ = I),
        (this.hitDetectionImageData_ = null),
        (this.replayGroupChanged = !0),
        !0
      );
    }
    renderFeature(t, e, i, n, r, s) {
      if (!i) return !1;
      let o = !1;
      if (Array.isArray(i))
        for (let a = 0, l = i.length; a < l; ++a)
          o = Eu(n, t, i[a], e, this.boundHandleStyleImageChange_, r, s) || o;
      else o = Eu(n, t, i, e, this.boundHandleStyleImageChange_, r, s);
      return o;
    }
  };
  var Pu = class extends Cc {
    constructor(t) {
      super(t);
    }
    createRenderer() {
      return new Tu(this);
    }
  };
  var bu = class {
    constructor(t) {
      (this.rbush_ = new hh(t)), (this.items_ = {});
    }
    insert(t, e) {
      const i = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3], value: e };
      this.rbush_.insert(i), (this.items_[j(e)] = i);
    }
    load(t, e) {
      const i = new Array(e.length);
      for (let n = 0, r = e.length; n < r; n++) {
        const r = t[n],
          s = e[n],
          o = { minX: r[0], minY: r[1], maxX: r[2], maxY: r[3], value: s };
        (i[n] = o), (this.items_[j(s)] = o);
      }
      this.rbush_.load(i);
    }
    remove(t) {
      const e = j(t),
        i = this.items_[e];
      return delete this.items_[e], null !== this.rbush_.remove(i);
    }
    update(t, e) {
      const i = this.items_[j(e)];
      ce([i.minX, i.minY, i.maxX, i.maxY], t) ||
        (this.remove(e), this.insert(t, e));
    }
    getAll() {
      return this.rbush_.all().map(function (t) {
        return t.value;
      });
    }
    getInExtent(t) {
      const e = { minX: t[0], minY: t[1], maxX: t[2], maxY: t[3] };
      return this.rbush_.search(e).map(function (t) {
        return t.value;
      });
    }
    forEach(t) {
      return this.forEach_(this.getAll(), t);
    }
    forEachInExtent(t, e) {
      return this.forEach_(this.getInExtent(t), e);
    }
    forEach_(t, e) {
      let i;
      for (let n = 0, r = t.length; n < r; n++)
        if (((i = e(t[n])), i)) return i;
      return i;
    }
    isEmpty() {
      return y(this.items_);
    }
    clear() {
      this.rbush_.clear(), (this.items_ = {});
    }
    getExtent(t) {
      const e = this.rbush_.toJSON();
      return oe(e.minX, e.minY, e.maxX, e.maxY, t);
    }
    concat(t) {
      this.rbush_.load(t.rbush_.all());
      for (const e in t.items_) this.items_[e] = t.items_[e];
    }
  };
  function Fu(t) {
    return t
      ? Array.isArray(t)
        ? function (e) {
            return t;
          }
        : "function" == typeof t
        ? t
        : function (e) {
            return [t];
          }
      : null;
  }
  var Iu = class extends U {
      constructor(t) {
        super(),
          (this.projection = tn(t.projection)),
          (this.attributions_ = Fu(t.attributions)),
          (this.attributionsCollapsible_ =
            void 0 === t.attributionsCollapsible || t.attributionsCollapsible),
          (this.loading = !1),
          (this.state_ = void 0 !== t.state ? t.state : "ready"),
          (this.wrapX_ = void 0 !== t.wrapX && t.wrapX),
          (this.interpolate_ = !!t.interpolate),
          (this.viewResolver = null),
          (this.viewRejector = null);
        const e = this;
        this.viewPromise_ = new Promise(function (t, i) {
          (e.viewResolver = t), (e.viewRejector = i);
        });
      }
      getAttributions() {
        return this.attributions_;
      }
      getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      getProjection() {
        return this.projection;
      }
      getResolutions(t) {
        return null;
      }
      getView() {
        return this.viewPromise_;
      }
      getState() {
        return this.state_;
      }
      getWrapX() {
        return this.wrapX_;
      }
      getInterpolate() {
        return this.interpolate_;
      }
      refresh() {
        this.changed();
      }
      setAttributions(t) {
        (this.attributions_ = Fu(t)), this.changed();
      }
      setState(t) {
        (this.state_ = t), this.changed();
      }
    },
    Lu = "addfeature",
    Mu = "changefeature",
    Ou = "clear",
    ku = "removefeature",
    Au = "featuresloadstart",
    Nu = "featuresloadend",
    Du = "featuresloaderror";
  function Gu(t, e) {
    return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
  }
  let Bu = !1;
  function ju(t, e, i, n, r, s, o) {
    const a = new XMLHttpRequest();
    a.open("GET", "function" == typeof t ? t(i, n, r) : t, !0),
      "arraybuffer" == e.getType() && (a.responseType = "arraybuffer"),
      (a.withCredentials = Bu),
      (a.onload = function (t) {
        if (!a.status || (a.status >= 200 && a.status < 300)) {
          const t = e.getType();
          let n;
          "json" == t || "text" == t
            ? (n = a.responseText)
            : "xml" == t
            ? ((n = a.responseXML),
              n ||
                (n = new DOMParser().parseFromString(
                  a.responseText,
                  "application/xml"
                )))
            : "arraybuffer" == t && (n = a.response),
            n
              ? s(
                  e.readFeatures(n, { extent: i, featureProjection: r }),
                  e.readProjection(n)
                )
              : o();
        } else o();
      }),
      (a.onerror = o),
      a.send();
  }
  function zu(t, e) {
    return function (i, n, r, s, o) {
      const a = this;
      ju(
        t,
        e,
        i,
        n,
        r,
        function (t, e) {
          a.addFeatures(t), void 0 !== s && s(t);
        },
        o || f
      );
    };
  }
  class Uu extends e {
    constructor(t, e, i) {
      super(t), (this.feature = e), (this.features = i);
    }
  }
  var qu = class extends Iu {
    constructor(t) {
      super({
        attributions: (t = t || {}).attributions,
        interpolate: !0,
        projection: void 0,
        state: "ready",
        wrapX: void 0 === t.wrapX || t.wrapX,
      }),
        this.on,
        this.once,
        this.un,
        (this.loader_ = f),
        (this.format_ = t.format),
        (this.overlaps_ = void 0 === t.overlaps || t.overlaps),
        (this.url_ = t.url),
        void 0 !== t.loader
          ? (this.loader_ = t.loader)
          : void 0 !== this.url_ &&
            (Ft(this.format_, "`format` must be set when `url` is set"),
            (this.loader_ = zu(this.url_, this.format_))),
        (this.strategy_ = void 0 !== t.strategy ? t.strategy : Gu);
      const e = void 0 === t.useSpatialIndex || t.useSpatialIndex;
      let i, n;
      (this.featuresRtree_ = e ? new bu() : null),
        (this.loadedExtentsRtree_ = new bu()),
        (this.loadingExtentsCount_ = 0),
        (this.nullGeometryFeatures_ = {}),
        (this.idIndex_ = {}),
        (this.uidIndex_ = {}),
        (this.featureChangeKeys_ = {}),
        (this.featuresCollection_ = null),
        Array.isArray(t.features)
          ? (n = t.features)
          : t.features && ((i = t.features), (n = i.getArray())),
        e || void 0 !== i || (i = new K(n)),
        void 0 !== n && this.addFeaturesInternal(n),
        void 0 !== i && this.bindFeaturesCollection_(i);
    }
    addFeature(t) {
      this.addFeatureInternal(t), this.changed();
    }
    addFeatureInternal(t) {
      const e = j(t);
      if (!this.addToIndex_(e, t))
        return void (
          this.featuresCollection_ && this.featuresCollection_.remove(t)
        );
      this.setupChangeEvents_(e, t);
      const i = t.getGeometry();
      if (i) {
        const e = i.getExtent();
        this.featuresRtree_ && this.featuresRtree_.insert(e, t);
      } else this.nullGeometryFeatures_[e] = t;
      this.dispatchEvent(new Uu(Lu, t));
    }
    setupChangeEvents_(t, e) {
      this.featureChangeKeys_[t] = [
        M(e, v, this.handleFeatureChange_, this),
        M(e, i, this.handleFeatureChange_, this),
      ];
    }
    addToIndex_(t, e) {
      let i = !0;
      const n = e.getId();
      return (
        void 0 !== n &&
          (n.toString() in this.idIndex_
            ? (i = !1)
            : (this.idIndex_[n.toString()] = e)),
        i &&
          (Ft(
            !(t in this.uidIndex_),
            "The passed `feature` was already added to the source"
          ),
          (this.uidIndex_[t] = e)),
        i
      );
    }
    addFeatures(t) {
      this.addFeaturesInternal(t), this.changed();
    }
    addFeaturesInternal(t) {
      const e = [],
        i = [],
        n = [];
      for (let e = 0, n = t.length; e < n; e++) {
        const n = t[e],
          r = j(n);
        this.addToIndex_(r, n) && i.push(n);
      }
      for (let t = 0, r = i.length; t < r; t++) {
        const r = i[t],
          s = j(r);
        this.setupChangeEvents_(s, r);
        const o = r.getGeometry();
        if (o) {
          const t = o.getExtent();
          e.push(t), n.push(r);
        } else this.nullGeometryFeatures_[s] = r;
      }
      if (
        (this.featuresRtree_ && this.featuresRtree_.load(e, n),
        this.hasListener(Lu))
      )
        for (let t = 0, e = i.length; t < e; t++)
          this.dispatchEvent(new Uu(Lu, i[t]));
    }
    bindFeaturesCollection_(t) {
      let e = !1;
      this.addEventListener(Lu, function (i) {
        e || ((e = !0), t.push(i.feature), (e = !1));
      }),
        this.addEventListener(ku, function (i) {
          e || ((e = !0), t.remove(i.feature), (e = !1));
        }),
        t.addEventListener(q, (t) => {
          e || ((e = !0), this.addFeature(t.element), (e = !1));
        }),
        t.addEventListener(V, (t) => {
          e || ((e = !0), this.removeFeature(t.element), (e = !1));
        }),
        (this.featuresCollection_ = t);
    }
    clear(t) {
      if (t) {
        for (const t in this.featureChangeKeys_) {
          this.featureChangeKeys_[t].forEach(k);
        }
        this.featuresCollection_ ||
          ((this.featureChangeKeys_ = {}),
          (this.idIndex_ = {}),
          (this.uidIndex_ = {}));
      } else if (this.featuresRtree_) {
        const t = (t) => {
          this.removeFeatureInternal(t);
        };
        this.featuresRtree_.forEach(t);
        for (const t in this.nullGeometryFeatures_)
          this.removeFeatureInternal(this.nullGeometryFeatures_[t]);
      }
      this.featuresCollection_ && this.featuresCollection_.clear(),
        this.featuresRtree_ && this.featuresRtree_.clear(),
        (this.nullGeometryFeatures_ = {});
      const e = new Uu(Ou);
      this.dispatchEvent(e), this.changed();
    }
    forEachFeature(t) {
      if (this.featuresRtree_) return this.featuresRtree_.forEach(t);
      this.featuresCollection_ && this.featuresCollection_.forEach(t);
    }
    forEachFeatureAtCoordinateDirect(t, e) {
      const i = [t[0], t[1], t[0], t[1]];
      return this.forEachFeatureInExtent(i, function (i) {
        if (i.getGeometry().intersectsCoordinate(t)) return e(i);
      });
    }
    forEachFeatureInExtent(t, e) {
      if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(t, e);
      this.featuresCollection_ && this.featuresCollection_.forEach(e);
    }
    forEachFeatureIntersectingExtent(t, e) {
      return this.forEachFeatureInExtent(t, function (i) {
        if (i.getGeometry().intersectsExtent(t)) {
          const t = e(i);
          if (t) return t;
        }
      });
    }
    getFeaturesCollection() {
      return this.featuresCollection_;
    }
    getFeatures() {
      let t;
      return (
        this.featuresCollection_
          ? (t = this.featuresCollection_.getArray().slice(0))
          : this.featuresRtree_ &&
            ((t = this.featuresRtree_.getAll()),
            y(this.nullGeometryFeatures_) ||
              h(t, Object.values(this.nullGeometryFeatures_))),
        t
      );
    }
    getFeaturesAtCoordinate(t) {
      const e = [];
      return (
        this.forEachFeatureAtCoordinateDirect(t, function (t) {
          e.push(t);
        }),
        e
      );
    }
    getFeaturesInExtent(t, e) {
      if (this.featuresRtree_) {
        if (!(e && e.canWrapX() && this.getWrapX()))
          return this.featuresRtree_.getInExtent(t);
        const i = De(t, e);
        return [].concat(...i.map((t) => this.featuresRtree_.getInExtent(t)));
      }
      return this.featuresCollection_
        ? this.featuresCollection_.getArray().slice(0)
        : [];
    }
    getClosestFeatureToCoordinate(t, e) {
      const i = t[0],
        n = t[1];
      let r = null;
      const s = [NaN, NaN];
      let o = 1 / 0;
      const a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
      return (
        (e = e || d),
        this.featuresRtree_.forEachInExtent(a, function (t) {
          if (e(t)) {
            const e = t.getGeometry(),
              l = o;
            if (((o = e.closestPointXY(i, n, s, o)), o < l)) {
              r = t;
              const e = Math.sqrt(o);
              (a[0] = i - e), (a[1] = n - e), (a[2] = i + e), (a[3] = n + e);
            }
          }
        }),
        r
      );
    }
    getExtent(t) {
      return this.featuresRtree_.getExtent(t);
    }
    getFeatureById(t) {
      const e = this.idIndex_[t.toString()];
      return void 0 !== e ? e : null;
    }
    getFeatureByUid(t) {
      const e = this.uidIndex_[t];
      return void 0 !== e ? e : null;
    }
    getFormat() {
      return this.format_;
    }
    getOverlaps() {
      return this.overlaps_;
    }
    getUrl() {
      return this.url_;
    }
    handleFeatureChange_(t) {
      const e = t.target,
        i = j(e),
        n = e.getGeometry();
      if (n) {
        const t = n.getExtent();
        i in this.nullGeometryFeatures_
          ? (delete this.nullGeometryFeatures_[i],
            this.featuresRtree_ && this.featuresRtree_.insert(t, e))
          : this.featuresRtree_ && this.featuresRtree_.update(t, e);
      } else
        i in this.nullGeometryFeatures_ ||
          (this.featuresRtree_ && this.featuresRtree_.remove(e),
          (this.nullGeometryFeatures_[i] = e));
      const r = e.getId();
      if (void 0 !== r) {
        const t = r.toString();
        this.idIndex_[t] !== e &&
          (this.removeFromIdIndex_(e), (this.idIndex_[t] = e));
      } else this.removeFromIdIndex_(e), (this.uidIndex_[i] = e);
      this.changed(), this.dispatchEvent(new Uu(Mu, e));
    }
    hasFeature(t) {
      const e = t.getId();
      return void 0 !== e ? e in this.idIndex_ : j(t) in this.uidIndex_;
    }
    isEmpty() {
      return this.featuresRtree_
        ? this.featuresRtree_.isEmpty() && y(this.nullGeometryFeatures_)
        : !this.featuresCollection_ ||
            0 === this.featuresCollection_.getLength();
    }
    loadFeatures(t, e, i) {
      const n = this.loadedExtentsRtree_,
        r = this.strategy_(t, e, i);
      for (let t = 0, s = r.length; t < s; ++t) {
        const s = r[t];
        n.forEachInExtent(s, function (t) {
          return ie(t.extent, s);
        }) ||
          (++this.loadingExtentsCount_,
          this.dispatchEvent(new Uu(Au)),
          this.loader_.call(
            this,
            s,
            e,
            i,
            (t) => {
              --this.loadingExtentsCount_,
                this.dispatchEvent(new Uu(Nu, void 0, t));
            },
            () => {
              --this.loadingExtentsCount_, this.dispatchEvent(new Uu(Du));
            }
          ),
          n.insert(s, { extent: s.slice() }));
      }
      this.loading =
        !(this.loader_.length < 4) && this.loadingExtentsCount_ > 0;
    }
    refresh() {
      this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
    }
    removeLoadedExtent(t) {
      const e = this.loadedExtentsRtree_;
      let i;
      e.forEachInExtent(t, function (e) {
        if (ce(e.extent, t)) return (i = e), !0;
      }),
        i && e.remove(i);
    }
    removeFeature(t) {
      if (!t) return;
      const e = j(t);
      e in this.nullGeometryFeatures_
        ? delete this.nullGeometryFeatures_[e]
        : this.featuresRtree_ && this.featuresRtree_.remove(t);
      this.removeFeatureInternal(t) && this.changed();
    }
    removeFeatureInternal(t) {
      const e = j(t),
        i = this.featureChangeKeys_[e];
      if (!i) return;
      i.forEach(k), delete this.featureChangeKeys_[e];
      const n = t.getId();
      return (
        void 0 !== n && delete this.idIndex_[n.toString()],
        delete this.uidIndex_[e],
        this.dispatchEvent(new Uu(ku, t)),
        t
      );
    }
    removeFromIdIndex_(t) {
      let e = !1;
      for (const i in this.idIndex_)
        if (this.idIndex_[i] === t) {
          delete this.idIndex_[i], (e = !0);
          break;
        }
      return e;
    }
    setLoader(t) {
      this.loader_ = t;
    }
    setUrl(t) {
      Ft(this.format_, "`format` must be set when `url` is set"),
        (this.url_ = t),
        this.setLoader(zu(t, this.format_));
    }
  };
  function Vu(t) {
    if (!(t.context instanceof CanvasRenderingContext2D))
      throw new Error("Only works for render events from Canvas 2D layers");
    const e = t.inversePixelTransform[0],
      i = t.inversePixelTransform[1],
      n = Math.sqrt(e * e + i * i),
      r = t.frameState,
      s = Nt(t.inversePixelTransform.slice(), r.coordinateToPixelTransform),
      o = wu(r.viewState.resolution, n);
    let a;
    const l = pn();
    return (
      l && (a = hn(l, r.viewState.projection)),
      new mu(t.context, n, r.extent, s, r.viewState.rotation, o, a)
    );
  }
  function Xu(t, e, i) {
    const n = [];
    let r = t(0),
      s = t(1),
      o = e(r),
      a = e(s);
    const l = [s, r],
      h = [a, o],
      c = [1, 0],
      u = {};
    let d,
      g,
      f,
      p,
      m,
      _,
      y = 1e5;
    for (; --y > 0 && c.length > 0; )
      (f = c.pop()),
        (r = l.pop()),
        (o = h.pop()),
        (_ = f.toString()),
        _ in u || (n.push(o[0], o[1]), (u[_] = !0)),
        (p = c.pop()),
        (s = l.pop()),
        (a = h.pop()),
        (m = (f + p) / 2),
        (d = t(m)),
        (g = e(d)),
        di(g[0], g[1], o[0], o[1], a[0], a[1]) < i
          ? (n.push(a[0], a[1]), (_ = p.toString()), (u[_] = !0))
          : (c.push(p, m, m, f), h.push(a, g, g, o), l.push(s, d, d, r));
    return n;
  }
  function Zu(t, e, i, n, r) {
    return Xu(
      function (n) {
        return [t, e + (i - e) * n];
      },
      cn(tn("EPSG:4326"), n),
      r
    );
  }
  function Ku(t, e, i, n, r) {
    return Xu(
      function (n) {
        return [e + (i - e) * n, t];
      },
      cn(tn("EPSG:4326"), n),
      r
    );
  }
  const Hu = new zl({ color: "rgba(0,0,0,0.2)" }),
    Yu = [
      90,
      45,
      30,
      20,
      10,
      5,
      2,
      1,
      0.5,
      20 / 60,
      10 / 60,
      5 / 60,
      2 / 60,
      1 / 60,
      30 / 3600,
      20 / 3600,
      10 / 3600,
      5 / 3600,
      2 / 3600,
      1 / 3600,
    ];
  var Qu = class extends Pu {
    constructor(t) {
      t = t || {};
      const e = Object.assign(
        {
          updateWhileAnimating: !0,
          updateWhileInteracting: !0,
          renderBuffer: 0,
        },
        t
      );
      delete e.maxLines,
        delete e.strokeStyle,
        delete e.targetSize,
        delete e.showLabels,
        delete e.lonLabelFormatter,
        delete e.latLabelFormatter,
        delete e.lonLabelPosition,
        delete e.latLabelPosition,
        delete e.lonLabelStyle,
        delete e.latLabelStyle,
        delete e.intervals,
        super(e),
        (this.projection_ = null),
        (this.maxLat_ = 1 / 0),
        (this.maxLon_ = 1 / 0),
        (this.minLat_ = -1 / 0),
        (this.minLon_ = -1 / 0),
        (this.maxX_ = 1 / 0),
        (this.maxY_ = 1 / 0),
        (this.minX_ = -1 / 0),
        (this.minY_ = -1 / 0),
        (this.targetSize_ = void 0 !== t.targetSize ? t.targetSize : 100),
        (this.maxLines_ = void 0 !== t.maxLines ? t.maxLines : 100),
        (this.meridians_ = []),
        (this.parallels_ = []),
        (this.strokeStyle_ = void 0 !== t.strokeStyle ? t.strokeStyle : Hu),
        (this.fromLonLatTransform_ = void 0),
        (this.toLonLatTransform_ = void 0),
        (this.projectionCenterLonLat_ = null),
        (this.bottomLeft_ = null),
        (this.bottomRight_ = null),
        (this.topLeft_ = null),
        (this.topRight_ = null),
        (this.meridiansLabels_ = null),
        (this.parallelsLabels_ = null),
        t.showLabels &&
          ((this.lonLabelFormatter_ =
            null == t.lonLabelFormatter
              ? Pi.bind(this, "EW")
              : t.lonLabelFormatter),
          (this.latLabelFormatter_ =
            null == t.latLabelFormatter
              ? Pi.bind(this, "NS")
              : t.latLabelFormatter),
          (this.lonLabelPosition_ =
            null == t.lonLabelPosition ? 0 : t.lonLabelPosition),
          (this.latLabelPosition_ =
            null == t.latLabelPosition ? 1 : t.latLabelPosition),
          (this.lonLabelStyleBase_ = new ih({
            text:
              void 0 !== t.lonLabelStyle
                ? t.lonLabelStyle.clone()
                : new rh({
                    font: "12px Calibri,sans-serif",
                    textBaseline: "bottom",
                    fill: new Ol({ color: "rgba(0,0,0,1)" }),
                    stroke: new zl({ color: "rgba(255,255,255,1)", width: 3 }),
                  }),
          })),
          (this.lonLabelStyle_ = (t) => {
            const e = t.get("graticule_label");
            return (
              this.lonLabelStyleBase_.getText().setText(e),
              this.lonLabelStyleBase_
            );
          }),
          (this.latLabelStyleBase_ = new ih({
            text:
              void 0 !== t.latLabelStyle
                ? t.latLabelStyle.clone()
                : new rh({
                    font: "12px Calibri,sans-serif",
                    textAlign: "right",
                    fill: new Ol({ color: "rgba(0,0,0,1)" }),
                    stroke: new zl({ color: "rgba(255,255,255,1)", width: 3 }),
                  }),
          })),
          (this.latLabelStyle_ = (t) => {
            const e = t.get("graticule_label");
            return (
              this.latLabelStyleBase_.getText().setText(e),
              this.latLabelStyleBase_
            );
          }),
          (this.meridiansLabels_ = []),
          (this.parallelsLabels_ = []),
          this.addEventListener(bs, this.drawLabels_.bind(this))),
        (this.intervals_ = void 0 !== t.intervals ? t.intervals : Yu),
        this.setSource(
          new qu({
            loader: this.loaderFunction.bind(this),
            strategy: this.strategyFunction.bind(this),
            features: new K(),
            overlaps: !1,
            useSpatialIndex: !1,
            wrapX: t.wrapX,
          })
        ),
        (this.featurePool_ = []),
        (this.lineStyle_ = new ih({ stroke: this.strokeStyle_ })),
        (this.loadedExtent_ = null),
        (this.renderedExtent_ = null),
        (this.renderedResolution_ = null),
        this.setRenderOrder(null);
    }
    strategyFunction(t, e) {
      let i = t.slice();
      return (
        this.projection_ &&
          this.getSource().getWrapX() &&
          Ne(i, this.projection_),
        this.loadedExtent_ &&
          (ue(this.loadedExtent_, i, e)
            ? (i = this.loadedExtent_.slice())
            : this.getSource().removeLoadedExtent(this.loadedExtent_)),
        [i]
      );
    }
    loaderFunction(t, e, i) {
      this.loadedExtent_ = t;
      const n = this.getSource(),
        r = Te(this.getExtent() || [-1 / 0, -1 / 0, 1 / 0, 1 / 0], t);
      if (
        this.renderedExtent_ &&
        ce(this.renderedExtent_, r) &&
        this.renderedResolution_ === e
      )
        return;
      if (((this.renderedExtent_ = r), (this.renderedResolution_ = e), Le(r)))
        return;
      const s = Ce(r),
        o = (e * e) / 4;
      (!this.projection_ || !ln(this.projection_, i)) &&
        this.updateProjectionInfo_(i),
        this.createGraticule_(r, s, e, o);
      let a,
        l = this.meridians_.length + this.parallels_.length;
      for (
        this.meridiansLabels_ && (l += this.meridians_.length),
          this.parallelsLabels_ && (l += this.parallels_.length);
        l > this.featurePool_.length;

      )
        (a = new Mt()), this.featurePool_.push(a);
      const h = n.getFeaturesCollection();
      h.clear();
      let c,
        u,
        d = 0;
      for (c = 0, u = this.meridians_.length; c < u; ++c)
        (a = this.featurePool_[d++]),
          a.setGeometry(this.meridians_[c]),
          a.setStyle(this.lineStyle_),
          h.push(a);
      for (c = 0, u = this.parallels_.length; c < u; ++c)
        (a = this.featurePool_[d++]),
          a.setGeometry(this.parallels_[c]),
          a.setStyle(this.lineStyle_),
          h.push(a);
    }
    addMeridian_(t, e, i, n, r, s) {
      const o = this.getMeridian_(t, e, i, n, s);
      if (Ie(o.getExtent(), r)) {
        if (this.meridiansLabels_) {
          const e = this.lonLabelFormatter_(t);
          s in this.meridiansLabels_
            ? (this.meridiansLabels_[s].text = e)
            : (this.meridiansLabels_[s] = { geom: new or([]), text: e });
        }
        this.meridians_[s++] = o;
      }
      return s;
    }
    addParallel_(t, e, i, n, r, s) {
      const o = this.getParallel_(t, e, i, n, s);
      if (Ie(o.getExtent(), r)) {
        if (this.parallelsLabels_) {
          const e = this.latLabelFormatter_(t);
          s in this.parallelsLabels_
            ? (this.parallelsLabels_[s].text = e)
            : (this.parallelsLabels_[s] = { geom: new or([]), text: e });
        }
        this.parallels_[s++] = o;
      }
      return s;
    }
    drawLabels_(t) {
      const e = t.frameState.viewState.rotation,
        i = t.frameState.viewState.resolution,
        n = t.frameState.size,
        r = t.frameState.extent,
        s = Ce(r);
      let o = r;
      if (e) {
        const t = n[0] * i,
          e = n[1] * i;
        o = [s[0] - t / 2, s[1] - e / 2, s[0] + t / 2, s[1] + e / 2];
      }
      let a = 0,
        l = 0,
        h = this.latLabelPosition_ < 0.5;
      const c = this.projection_.getExtent(),
        u = Fe(c);
      if (
        this.getSource().getWrapX() &&
        this.projection_.canWrapX() &&
        !ie(c, r)
      ) {
        (a = Math.floor((r[0] - c[0]) / u)), (l = Math.ceil((r[2] - c[2]) / u));
        h = h !== Math.abs(e) > Math.PI / 2;
      }
      const d = Vu(t);
      for (let t = a; t <= l; ++t) {
        let i,
          n,
          c,
          g,
          f = this.meridians_.length + this.parallels_.length;
        if (this.meridiansLabels_)
          for (n = 0, c = this.meridiansLabels_.length; n < c; ++n) {
            const a = this.meridians_[n];
            if (e || 0 !== t) {
              const i = a.clone();
              i.translate(t * u, 0),
                i.rotate(-e, s),
                (g = this.getMeridianPoint_(i, o, n)),
                g.rotate(e, s);
            } else g = this.getMeridianPoint_(a, r, n);
            (i = this.featurePool_[f++]),
              i.setGeometry(g),
              i.set("graticule_label", this.meridiansLabels_[n].text),
              d.drawFeature(i, this.lonLabelStyle_(i));
          }
        if (this.parallelsLabels_ && ((t === a && h) || (t === l && !h)))
          for (n = 0, c = this.parallels_.length; n < c; ++n) {
            const a = this.parallels_[n];
            if (e || 0 !== t) {
              const i = a.clone();
              i.translate(t * u, 0),
                i.rotate(-e, s),
                (g = this.getParallelPoint_(i, o, n)),
                g.rotate(e, s);
            } else g = this.getParallelPoint_(a, r, n);
            (i = this.featurePool_[f++]),
              i.setGeometry(g),
              i.set("graticule_label", this.parallelsLabels_[n].text),
              d.drawFeature(i, this.latLabelStyle_(i));
          }
      }
    }
    createGraticule_(t, e, i, n) {
      const r = this.getInterval_(i);
      if (-1 == r)
        return (
          (this.meridians_.length = 0),
          (this.parallels_.length = 0),
          this.meridiansLabels_ && (this.meridiansLabels_.length = 0),
          void (this.parallelsLabels_ && (this.parallelsLabels_.length = 0))
        );
      let s = !1;
      const o = this.projection_.getExtent(),
        a = Fe(o);
      this.getSource().getWrapX() &&
        this.projection_.canWrapX() &&
        !ie(o, t) &&
        (Fe(t) >= a ? ((t[0] = o[0]), (t[2] = o[2])) : (s = !0));
      const l = [
          ui(e[0], this.minX_, this.maxX_),
          ui(e[1], this.minY_, this.maxY_),
        ],
        h = this.toLonLatTransform_(l);
      isNaN(h[1]) &&
        (h[1] =
          Math.abs(this.maxLat_) >= Math.abs(this.minLat_)
            ? this.maxLat_
            : this.minLat_);
      let c = ui(h[0], this.minLon_, this.maxLon_),
        u = ui(h[1], this.minLat_, this.maxLat_);
      const d = this.maxLines_;
      let g,
        f,
        p,
        m,
        _ = t;
      s ||
        (_ = [
          ui(t[0], this.minX_, this.maxX_),
          ui(t[1], this.minY_, this.maxY_),
          ui(t[2], this.minX_, this.maxX_),
          ui(t[3], this.minY_, this.maxY_),
        ]);
      const y = Ae(_, this.toLonLatTransform_, void 0, 8);
      let x = y[3],
        v = y[2],
        S = y[1],
        C = y[0];
      if (
        (s ||
          (ee(_, this.bottomLeft_) && ((C = this.minLon_), (S = this.minLat_)),
          ee(_, this.bottomRight_) && ((v = this.maxLon_), (S = this.minLat_)),
          ee(_, this.topLeft_) && ((C = this.minLon_), (x = this.maxLat_)),
          ee(_, this.topRight_) && ((v = this.maxLon_), (x = this.maxLat_)),
          (x = ui(x, u, this.maxLat_)),
          (v = ui(v, c, this.maxLon_)),
          (S = ui(S, this.minLat_, u)),
          (C = ui(C, this.minLon_, c))),
        (c = Math.floor(c / r) * r),
        (m = ui(c, this.minLon_, this.maxLon_)),
        (f = this.addMeridian_(m, S, x, n, t, 0)),
        (g = 0),
        s)
      )
        for (; (m -= r) >= C && g++ < d; )
          f = this.addMeridian_(m, S, x, n, t, f);
      else
        for (; m != this.minLon_ && g++ < d; )
          (m = Math.max(m - r, this.minLon_)),
            (f = this.addMeridian_(m, S, x, n, t, f));
      if (((m = ui(c, this.minLon_, this.maxLon_)), (g = 0), s))
        for (; (m += r) <= v && g++ < d; )
          f = this.addMeridian_(m, S, x, n, t, f);
      else
        for (; m != this.maxLon_ && g++ < d; )
          (m = Math.min(m + r, this.maxLon_)),
            (f = this.addMeridian_(m, S, x, n, t, f));
      for (
        this.meridians_.length = f,
          this.meridiansLabels_ && (this.meridiansLabels_.length = f),
          u = Math.floor(u / r) * r,
          p = ui(u, this.minLat_, this.maxLat_),
          f = this.addParallel_(p, C, v, n, t, 0),
          g = 0;
        p != this.minLat_ && g++ < d;

      )
        (p = Math.max(p - r, this.minLat_)),
          (f = this.addParallel_(p, C, v, n, t, f));
      for (
        p = ui(u, this.minLat_, this.maxLat_), g = 0;
        p != this.maxLat_ && g++ < d;

      )
        (p = Math.min(p + r, this.maxLat_)),
          (f = this.addParallel_(p, C, v, n, t, f));
      (this.parallels_.length = f),
        this.parallelsLabels_ && (this.parallelsLabels_.length = f);
    }
    getInterval_(t) {
      const e = this.projectionCenterLonLat_[0],
        i = this.projectionCenterLonLat_[1];
      let n = -1;
      const r = Math.pow(this.targetSize_ * t, 2),
        s = [],
        o = [];
      for (let t = 0, a = this.intervals_.length; t < a; ++t) {
        const a = ui(this.intervals_[t] / 2, 0, 90),
          l = ui(i, -90 + a, 90 - a);
        (s[0] = e - a),
          (s[1] = l - a),
          (o[0] = e + a),
          (o[1] = l + a),
          this.fromLonLatTransform_(s, s),
          this.fromLonLatTransform_(o, o);
        if (Math.pow(o[0] - s[0], 2) + Math.pow(o[1] - s[1], 2) <= r) break;
        n = this.intervals_[t];
      }
      return n;
    }
    getMeridian_(t, e, i, n, r) {
      const s = Zu(t, e, i, this.projection_, n);
      let o = this.meridians_[r];
      return (
        o
          ? (o.setFlatCoordinates("XY", s), o.changed())
          : ((o = new Bl(s, "XY")), (this.meridians_[r] = o)),
        o
      );
    }
    getMeridianPoint_(t, e, i) {
      const n = t.getFlatCoordinates();
      let r = 1,
        s = n.length - 1;
      n[r] > n[s] && ((r = s), (s = 1));
      const o = Math.max(e[1], n[r]),
        a = Math.min(e[3], n[s]),
        l = ui(e[1] + Math.abs(e[1] - e[3]) * this.lonLabelPosition_, o, a),
        h = [
          n[r - 1] + ((n[s - 1] - n[r - 1]) * (l - n[r])) / (n[s] - n[r]),
          l,
        ],
        c = this.meridiansLabels_[i].geom;
      return c.setCoordinates(h), c;
    }
    getMeridians() {
      return this.meridians_;
    }
    getParallel_(t, e, i, n, r) {
      const s = Ku(t, e, i, this.projection_, n);
      let o = this.parallels_[r];
      return (
        o
          ? (o.setFlatCoordinates("XY", s), o.changed())
          : (o = new Bl(s, "XY")),
        o
      );
    }
    getParallelPoint_(t, e, i) {
      const n = t.getFlatCoordinates();
      let r = 0,
        s = n.length - 2;
      n[r] > n[s] && ((r = s), (s = 0));
      const o = Math.max(e[0], n[r]),
        a = Math.min(e[2], n[s]),
        l = ui(e[0] + Math.abs(e[0] - e[2]) * this.latLabelPosition_, o, a),
        h = [
          l,
          n[r + 1] + ((n[s + 1] - n[r + 1]) * (l - n[r])) / (n[s] - n[r]),
        ],
        c = this.parallelsLabels_[i].geom;
      return c.setCoordinates(h), c;
    }
    getParallels() {
      return this.parallels_;
    }
    updateProjectionInfo_(t) {
      const e = tn("EPSG:4326"),
        i = t.getWorldExtent();
      (this.maxLat_ = i[3]),
        (this.maxLon_ = i[2]),
        (this.minLat_ = i[1]),
        (this.minLon_ = i[0]);
      const n = cn(t, e);
      if (this.minLon_ < this.maxLon_) this.toLonLatTransform_ = n;
      else {
        const t = this.minLon_ + this.maxLon_ / 2;
        (this.maxLon_ += 360),
          (this.toLonLatTransform_ = function (e, i, r) {
            const s = n(e, i, (r = r || 2));
            for (let e = 0, i = s.length; e < i; e += r)
              s[e] < t && (s[e] += 360);
            return s;
          });
      }
      this.fromLonLatTransform_ = cn(e, t);
      const r = Ae(
        [this.minLon_, this.minLat_, this.maxLon_, this.maxLat_],
        this.fromLonLatTransform_,
        void 0,
        8
      );
      (this.minX_ = r[0]),
        (this.maxX_ = r[2]),
        (this.minY_ = r[1]),
        (this.maxY_ = r[3]),
        (this.bottomLeft_ = this.fromLonLatTransform_([
          this.minLon_,
          this.minLat_,
        ])),
        (this.bottomRight_ = this.fromLonLatTransform_([
          this.maxLon_,
          this.minLat_,
        ])),
        (this.topLeft_ = this.fromLonLatTransform_([
          this.minLon_,
          this.maxLat_,
        ])),
        (this.topRight_ = this.fromLonLatTransform_([
          this.maxLon_,
          this.maxLat_,
        ])),
        (this.projectionCenterLonLat_ = this.toLonLatTransform_(
          Ce(t.getExtent())
        )),
        isNaN(this.projectionCenterLonLat_[1]) &&
          (this.projectionCenterLonLat_[1] =
            Math.abs(this.maxLat_) >= Math.abs(this.minLat_)
              ? this.maxLat_
              : this.minLat_),
        (this.projection_ = t);
    }
  };
  const $u = 34962,
    Ju = 34963,
    td = 35044,
    ed = 35048,
    id = 5126,
    nd = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
  function rd(t, e) {
    e = Object.assign({ preserveDrawingBuffer: !0, antialias: !lt }, e);
    const i = nd.length;
    for (let n = 0; n < i; ++n)
      try {
        const i = t.getContext(nd[n], e);
        if (i) return i;
      } catch (t) {}
    return null;
  }
  let sd;
  const od = td;
  function ad(t) {
    switch (t) {
      case $u:
        return Float32Array;
      case Ju:
        return Uint32Array;
      default:
        return Float32Array;
    }
  }
  var ld = class {
      constructor(t, e) {
        (this.array = null),
          (this.type = t),
          Ft(
            t === $u || t === Ju,
            "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"
          ),
          (this.usage = void 0 !== e ? e : od);
      }
      ofSize(t) {
        return (this.array = new (ad(this.type))(t)), this;
      }
      fromArray(t) {
        return (this.array = ad(this.type).from(t)), this;
      }
      fromArrayBuffer(t) {
        return (this.array = new (ad(this.type))(t)), this;
      }
      getType() {
        return this.type;
      }
      getArray() {
        return this.array;
      }
      getUsage() {
        return this.usage;
      }
      getSize() {
        return this.array ? this.array.length : 0;
      }
    },
    hd = "webglcontextlost",
    cd = "webglcontextrestored";
  var ud = class {
    constructor(t) {
      this.gl_ = t.webGlContext;
      const e = this.gl_;
      (this.scaleRatio_ = t.scaleRatio || 1),
        (this.renderTargetTexture_ = e.createTexture()),
        (this.renderTargetTextureSize_ = null),
        (this.frameBuffer_ = e.createFramebuffer()),
        (this.depthBuffer_ = e.createRenderbuffer());
      const i = e.createShader(e.VERTEX_SHADER);
      e.shaderSource(
        i,
        t.vertexShader ||
          "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n"
      ),
        e.compileShader(i);
      const n = e.createShader(e.FRAGMENT_SHADER);
      e.shaderSource(
        n,
        t.fragmentShader ||
          "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n"
      ),
        e.compileShader(n),
        (this.renderTargetProgram_ = e.createProgram()),
        e.attachShader(this.renderTargetProgram_, i),
        e.attachShader(this.renderTargetProgram_, n),
        e.linkProgram(this.renderTargetProgram_),
        (this.renderTargetVerticesBuffer_ = e.createBuffer());
      e.bindBuffer(e.ARRAY_BUFFER, this.renderTargetVerticesBuffer_),
        e.bufferData(
          e.ARRAY_BUFFER,
          new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1]),
          e.STATIC_DRAW
        ),
        (this.renderTargetAttribLocation_ = e.getAttribLocation(
          this.renderTargetProgram_,
          "a_position"
        )),
        (this.renderTargetUniformLocation_ = e.getUniformLocation(
          this.renderTargetProgram_,
          "u_screenSize"
        )),
        (this.renderTargetOpacityLocation_ = e.getUniformLocation(
          this.renderTargetProgram_,
          "u_opacity"
        )),
        (this.renderTargetTextureLocation_ = e.getUniformLocation(
          this.renderTargetProgram_,
          "u_image"
        )),
        (this.uniforms_ = []),
        t.uniforms &&
          Object.keys(t.uniforms).forEach((i) => {
            this.uniforms_.push({
              value: t.uniforms[i],
              location: e.getUniformLocation(this.renderTargetProgram_, i),
            });
          });
    }
    getGL() {
      return this.gl_;
    }
    init(t) {
      const e = this.getGL(),
        i = [
          e.drawingBufferWidth * this.scaleRatio_,
          e.drawingBufferHeight * this.scaleRatio_,
        ];
      if (
        (e.bindFramebuffer(e.FRAMEBUFFER, this.getFrameBuffer()),
        e.bindRenderbuffer(e.RENDERBUFFER, this.getDepthBuffer()),
        e.viewport(0, 0, i[0], i[1]),
        !this.renderTargetTextureSize_ ||
          this.renderTargetTextureSize_[0] !== i[0] ||
          this.renderTargetTextureSize_[1] !== i[1])
      ) {
        this.renderTargetTextureSize_ = i;
        const t = 0,
          n = e.RGBA,
          r = 0,
          s = e.RGBA,
          o = e.UNSIGNED_BYTE,
          a = null;
        e.bindTexture(e.TEXTURE_2D, this.renderTargetTexture_),
          e.texImage2D(e.TEXTURE_2D, t, n, i[0], i[1], r, s, o, a),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
          e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
          e.framebufferTexture2D(
            e.FRAMEBUFFER,
            e.COLOR_ATTACHMENT0,
            e.TEXTURE_2D,
            this.renderTargetTexture_,
            0
          ),
          e.renderbufferStorage(
            e.RENDERBUFFER,
            e.DEPTH_COMPONENT16,
            i[0],
            i[1]
          ),
          e.framebufferRenderbuffer(
            e.FRAMEBUFFER,
            e.DEPTH_ATTACHMENT,
            e.RENDERBUFFER,
            this.depthBuffer_
          );
      }
    }
    apply(t, e, i, n) {
      const r = this.getGL(),
        s = t.size;
      if (
        (r.bindFramebuffer(r.FRAMEBUFFER, e ? e.getFrameBuffer() : null),
        r.activeTexture(r.TEXTURE0),
        r.bindTexture(r.TEXTURE_2D, this.renderTargetTexture_),
        !e)
      ) {
        const e = j(r.canvas);
        if (!t.renderTargets[e]) {
          const i = r.getContextAttributes();
          i &&
            i.preserveDrawingBuffer &&
            (r.clearColor(0, 0, 0, 0),
            r.clearDepth(1),
            r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT)),
            (t.renderTargets[e] = !0);
        }
      }
      r.disable(r.DEPTH_TEST),
        r.enable(r.BLEND),
        r.blendFunc(r.ONE, r.ONE_MINUS_SRC_ALPHA),
        r.viewport(0, 0, r.drawingBufferWidth, r.drawingBufferHeight),
        r.bindBuffer(r.ARRAY_BUFFER, this.renderTargetVerticesBuffer_),
        r.useProgram(this.renderTargetProgram_),
        r.enableVertexAttribArray(this.renderTargetAttribLocation_),
        r.vertexAttribPointer(
          this.renderTargetAttribLocation_,
          2,
          r.FLOAT,
          !1,
          0,
          0
        ),
        r.uniform2f(this.renderTargetUniformLocation_, s[0], s[1]),
        r.uniform1i(this.renderTargetTextureLocation_, 0);
      const o = t.layerStatesArray[t.layerIndex].opacity;
      r.uniform1f(this.renderTargetOpacityLocation_, o),
        this.applyUniforms(t),
        i && i(r, t),
        r.drawArrays(r.TRIANGLES, 0, 6),
        n && n(r, t);
    }
    getFrameBuffer() {
      return this.frameBuffer_;
    }
    getDepthBuffer() {
      return this.depthBuffer_;
    }
    applyUniforms(t) {
      const e = this.getGL();
      let i,
        n = 1;
      this.uniforms_.forEach(function (r) {
        if (
          ((i = "function" == typeof r.value ? r.value(t) : r.value),
          i instanceof HTMLCanvasElement || i instanceof ImageData)
        )
          r.texture || (r.texture = e.createTexture()),
            e.activeTexture(e[`TEXTURE${n}`]),
            e.bindTexture(e.TEXTURE_2D, r.texture),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            i instanceof ImageData
              ? e.texImage2D(
                  e.TEXTURE_2D,
                  0,
                  e.RGBA,
                  e.RGBA,
                  i.width,
                  i.height,
                  0,
                  e.UNSIGNED_BYTE,
                  new Uint8Array(i.data)
                )
              : e.texImage2D(
                  e.TEXTURE_2D,
                  0,
                  e.RGBA,
                  e.RGBA,
                  e.UNSIGNED_BYTE,
                  i
                ),
            e.uniform1i(r.location, n++);
        else if (Array.isArray(i))
          switch (i.length) {
            case 2:
              return void e.uniform2f(r.location, i[0], i[1]);
            case 3:
              return void e.uniform3f(r.location, i[0], i[1], i[2]);
            case 4:
              return void e.uniform4f(r.location, i[0], i[1], i[2], i[3]);
            default:
              return;
          }
        else "number" == typeof i && e.uniform1f(r.location, i);
      });
    }
  };
  function dd() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function gd(t, e) {
    return (
      (t[0] = e[0]),
      (t[1] = e[1]),
      (t[4] = e[2]),
      (t[5] = e[3]),
      (t[12] = e[4]),
      (t[13] = e[5]),
      t
    );
  }
  const fd = {
      PROJECTION_MATRIX: "u_projectionMatrix",
      SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix",
      TIME: "u_time",
      ZOOM: "u_zoom",
      RESOLUTION: "u_resolution",
      ROTATION: "u_rotation",
      VIEWPORT_SIZE_PX: "u_viewportSizePx",
      PIXEL_RATIO: "u_pixelRatio",
      HIT_DETECTION: "u_hitDetection",
    },
    pd = {
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123,
      UNSIGNED_INT: 5125,
      FLOAT: id,
    },
    md = {};
  function _d(t) {
    return "shared/" + t;
  }
  let yd = 0;
  function xd(t) {
    let e = 0;
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      e += n.size * vd(n.type);
    }
    return e;
  }
  function vd(t) {
    switch (t) {
      case pd.UNSIGNED_BYTE:
        return Uint8Array.BYTES_PER_ELEMENT;
      case pd.UNSIGNED_SHORT:
        return Uint16Array.BYTES_PER_ELEMENT;
      case pd.UNSIGNED_INT:
        return Uint32Array.BYTES_PER_ELEMENT;
      case pd.FLOAT:
      default:
        return Float32Array.BYTES_PER_ELEMENT;
    }
  }
  var Sd = class extends n {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.boundHandleWebGLContextLost_ =
          this.handleWebGLContextLost.bind(this)),
        (this.boundHandleWebGLContextRestored_ =
          this.handleWebGLContextRestored.bind(this)),
        (this.canvasCacheKey_ = t.canvasCacheKey
          ? _d(t.canvasCacheKey)
          : (function () {
              const t = "unique/" + yd;
              return (yd += 1), t;
            })()),
        (this.gl_ = (function (t) {
          let e = md[t];
          if (!e) {
            const i = document.createElement("canvas");
            (i.width = 1),
              (i.height = 1),
              (i.style.position = "absolute"),
              (i.style.left = "0"),
              (e = { users: 0, context: rd(i) }),
              (md[t] = e);
          }
          return (e.users += 1), e.context;
        })(this.canvasCacheKey_)),
        (this.bufferCache_ = {}),
        (this.extensionCache_ = {}),
        (this.currentProgram_ = null),
        (this.needsToBeRecreated_ = !1);
      const e = this.gl_.canvas;
      e.addEventListener(hd, this.boundHandleWebGLContextLost_),
        e.addEventListener(cd, this.boundHandleWebGLContextRestored_),
        (this.offsetRotateMatrix_ = [1, 0, 0, 1, 0, 0]),
        (this.offsetScaleMatrix_ = [1, 0, 0, 1, 0, 0]),
        (this.tmpMat4_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        (this.uniformLocationsByProgram_ = {}),
        (this.attribLocationsByProgram_ = {}),
        (this.uniforms_ = []),
        t.uniforms && this.setUniforms(t.uniforms),
        (this.postProcessPasses_ = t.postProcesses
          ? t.postProcesses.map(
              (t) =>
                new ud({
                  webGlContext: this.gl_,
                  scaleRatio: t.scaleRatio,
                  vertexShader: t.vertexShader,
                  fragmentShader: t.fragmentShader,
                  uniforms: t.uniforms,
                })
            )
          : [new ud({ webGlContext: this.gl_ })]),
        (this.shaderCompileErrors_ = null),
        (this.startTime_ = Date.now());
    }
    setUniforms(t) {
      (this.uniforms_ = []), this.addUniforms(t);
    }
    addUniforms(t) {
      for (const e in t) this.uniforms_.push({ name: e, value: t[e] });
    }
    canvasCacheKeyMatches(t) {
      return this.canvasCacheKey_ === _d(t);
    }
    getExtension(t) {
      if (t in this.extensionCache_) return this.extensionCache_[t];
      const e = this.gl_.getExtension(t);
      return (this.extensionCache_[t] = e), e;
    }
    bindBuffer(t) {
      const e = this.gl_,
        i = j(t);
      let n = this.bufferCache_[i];
      if (!n) {
        (n = { buffer: t, webGlBuffer: e.createBuffer() }),
          (this.bufferCache_[i] = n);
      }
      e.bindBuffer(t.getType(), n.webGlBuffer);
    }
    flushBufferData(t) {
      const e = this.gl_;
      this.bindBuffer(t), e.bufferData(t.getType(), t.getArray(), t.getUsage());
    }
    deleteBuffer(t) {
      const e = this.gl_,
        i = j(t),
        n = this.bufferCache_[i];
      n && !e.isContextLost() && e.deleteBuffer(n.webGlBuffer),
        delete this.bufferCache_[i];
    }
    disposeInternal() {
      const t = this.gl_.canvas;
      t.removeEventListener(hd, this.boundHandleWebGLContextLost_),
        t.removeEventListener(cd, this.boundHandleWebGLContextRestored_),
        (function (t) {
          const e = md[t];
          if (!e) return;
          if (((e.users -= 1), e.users > 0)) return;
          const i = e.context,
            n = i.getExtension("WEBGL_lose_context");
          n && n.loseContext();
          const r = i.canvas;
          (r.width = 1), (r.height = 1), delete md[t];
        })(this.canvasCacheKey_),
        delete this.gl_;
    }
    prepareDraw(t, e, i) {
      const n = this.gl_,
        r = this.getCanvas(),
        s = t.size,
        o = t.pixelRatio;
      (r.width === s[0] * o && r.height === s[1] * o) ||
        ((r.width = s[0] * o),
        (r.height = s[1] * o),
        (r.style.width = s[0] + "px"),
        (r.style.height = s[1] + "px"));
      for (let e = this.postProcessPasses_.length - 1; e >= 0; e--)
        this.postProcessPasses_[e].init(t);
      n.bindTexture(n.TEXTURE_2D, null),
        n.clearColor(0, 0, 0, 0),
        n.depthRange(0, 1),
        n.clearDepth(1),
        n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT),
        n.enable(n.BLEND),
        n.blendFunc(n.ONE, e ? n.ZERO : n.ONE_MINUS_SRC_ALPHA),
        i
          ? (n.enable(n.DEPTH_TEST), n.depthFunc(n.LEQUAL))
          : n.disable(n.DEPTH_TEST);
    }
    bindTexture(t, e, i) {
      const n = this.gl_;
      n.activeTexture(n.TEXTURE0 + e),
        n.bindTexture(n.TEXTURE_2D, t),
        n.uniform1i(this.getUniformLocation(i), e);
    }
    prepareDrawToRenderTarget(t, e, i, n) {
      const r = this.gl_,
        s = e.getSize();
      r.bindFramebuffer(r.FRAMEBUFFER, e.getFramebuffer()),
        r.bindRenderbuffer(r.RENDERBUFFER, e.getDepthbuffer()),
        r.viewport(0, 0, s[0], s[1]),
        r.bindTexture(r.TEXTURE_2D, e.getTexture()),
        r.clearColor(0, 0, 0, 0),
        r.depthRange(0, 1),
        r.clearDepth(1),
        r.clear(r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT),
        r.enable(r.BLEND),
        r.blendFunc(r.ONE, i ? r.ZERO : r.ONE_MINUS_SRC_ALPHA),
        n
          ? (r.enable(r.DEPTH_TEST), r.depthFunc(r.LEQUAL))
          : r.disable(r.DEPTH_TEST);
    }
    drawElements(t, e) {
      const i = this.gl_;
      this.getExtension("OES_element_index_uint");
      const n = i.UNSIGNED_INT,
        r = e - t,
        s = 4 * t;
      i.drawElements(i.TRIANGLES, r, n, s);
    }
    finalizeDraw(t, e, i) {
      for (let n = 0, r = this.postProcessPasses_.length; n < r; n++)
        n === r - 1
          ? this.postProcessPasses_[n].apply(t, null, e, i)
          : this.postProcessPasses_[n].apply(t, this.postProcessPasses_[n + 1]);
    }
    getCanvas() {
      return this.gl_.canvas;
    }
    getGL() {
      return this.gl_;
    }
    applyFrameState(t) {
      const e = t.size,
        i = t.viewState.rotation,
        n = t.pixelRatio;
      this.setUniformFloatValue(
        fd.TIME,
        0.001 * (Date.now() - this.startTime_)
      ),
        this.setUniformFloatValue(fd.ZOOM, t.viewState.zoom),
        this.setUniformFloatValue(fd.RESOLUTION, t.viewState.resolution),
        this.setUniformFloatValue(fd.PIXEL_RATIO, n),
        this.setUniformFloatVec2(fd.VIEWPORT_SIZE_PX, [e[0], e[1]]),
        this.setUniformFloatValue(fd.ROTATION, i);
    }
    applyHitDetectionUniform(t) {
      const e = this.getUniformLocation(fd.HIT_DETECTION);
      this.getGL().uniform1i(e, t ? 1 : 0),
        t && this.setUniformFloatValue(fd.PIXEL_RATIO, 0.5);
    }
    applyUniforms(t) {
      const e = this.gl_;
      let i,
        n = 0;
      this.uniforms_.forEach((r) => {
        if (
          ((i = "function" == typeof r.value ? r.value(t) : r.value),
          i instanceof HTMLCanvasElement ||
            i instanceof HTMLImageElement ||
            i instanceof ImageData)
        ) {
          r.texture ||
            ((r.prevValue = void 0), (r.texture = e.createTexture())),
            this.bindTexture(r.texture, n, r.name),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
          (!(i instanceof HTMLImageElement) || i.complete) &&
            r.prevValue !== i &&
            ((r.prevValue = i),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, i)),
            n++;
        } else if (Array.isArray(i) && 6 === i.length)
          this.setUniformMatrixValue(r.name, gd(this.tmpMat4_, i));
        else if (Array.isArray(i) && i.length <= 4)
          switch (i.length) {
            case 2:
              return void e.uniform2f(
                this.getUniformLocation(r.name),
                i[0],
                i[1]
              );
            case 3:
              return void e.uniform3f(
                this.getUniformLocation(r.name),
                i[0],
                i[1],
                i[2]
              );
            case 4:
              return void e.uniform4f(
                this.getUniformLocation(r.name),
                i[0],
                i[1],
                i[2],
                i[3]
              );
            default:
              return;
          }
        else
          "number" == typeof i &&
            e.uniform1f(this.getUniformLocation(r.name), i);
      });
    }
    useProgram(t, e) {
      this.gl_.useProgram(t),
        (this.currentProgram_ = t),
        this.applyFrameState(e),
        this.applyUniforms(e);
    }
    compileShader(t, e) {
      const i = this.gl_,
        n = i.createShader(e);
      return i.shaderSource(n, t), i.compileShader(n), n;
    }
    getProgram(t, e) {
      const i = this.gl_,
        n = this.compileShader(t, i.FRAGMENT_SHADER),
        r = this.compileShader(e, i.VERTEX_SHADER),
        s = i.createProgram();
      if (
        (i.attachShader(s, n),
        i.attachShader(s, r),
        i.linkProgram(s),
        !i.getShaderParameter(n, i.COMPILE_STATUS))
      ) {
        const t = `Fragment shader compilation failed: ${i.getShaderInfoLog(
          n
        )}`;
        throw new Error(t);
      }
      if ((i.deleteShader(n), !i.getShaderParameter(r, i.COMPILE_STATUS))) {
        const t = `Vertex shader compilation failed: ${i.getShaderInfoLog(r)}`;
        throw new Error(t);
      }
      if ((i.deleteShader(r), !i.getProgramParameter(s, i.LINK_STATUS))) {
        const t = `GL program linking failed: ${i.getProgramInfoLog(s)}`;
        throw new Error(t);
      }
      return s;
    }
    getUniformLocation(t) {
      const e = j(this.currentProgram_);
      return (
        void 0 === this.uniformLocationsByProgram_[e] &&
          (this.uniformLocationsByProgram_[e] = {}),
        void 0 === this.uniformLocationsByProgram_[e][t] &&
          (this.uniformLocationsByProgram_[e][t] = this.gl_.getUniformLocation(
            this.currentProgram_,
            t
          )),
        this.uniformLocationsByProgram_[e][t]
      );
    }
    getAttributeLocation(t) {
      const e = j(this.currentProgram_);
      return (
        void 0 === this.attribLocationsByProgram_[e] &&
          (this.attribLocationsByProgram_[e] = {}),
        void 0 === this.attribLocationsByProgram_[e][t] &&
          (this.attribLocationsByProgram_[e][t] = this.gl_.getAttribLocation(
            this.currentProgram_,
            t
          )),
        this.attribLocationsByProgram_[e][t]
      );
    }
    makeProjectionTransform(t, e) {
      const i = t.size,
        n = t.viewState.rotation,
        r = t.viewState.resolution,
        s = t.viewState.center;
      return Vt(e, 0, 0, 2 / (r * i[0]), 2 / (r * i[1]), -n, -s[0], -s[1]), e;
    }
    setUniformFloatValue(t, e) {
      this.gl_.uniform1f(this.getUniformLocation(t), e);
    }
    setUniformFloatVec2(t, e) {
      this.gl_.uniform2fv(this.getUniformLocation(t), e);
    }
    setUniformFloatVec4(t, e) {
      this.gl_.uniform4fv(this.getUniformLocation(t), e);
    }
    setUniformMatrixValue(t, e) {
      this.gl_.uniformMatrix4fv(this.getUniformLocation(t), !1, e);
    }
    enableAttributeArray_(t, e, i, n, r) {
      const s = this.getAttributeLocation(t);
      s < 0 ||
        (this.gl_.enableVertexAttribArray(s),
        this.gl_.vertexAttribPointer(s, e, i, !1, n, r));
    }
    enableAttributes(t) {
      const e = xd(t);
      let i = 0;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        this.enableAttributeArray_(r.name, r.size, r.type || id, e, i),
          (i += r.size * vd(r.type));
      }
    }
    handleWebGLContextLost(t) {
      _(this.bufferCache_), (this.currentProgram_ = null), t.preventDefault();
    }
    handleWebGLContextRestored() {
      this.needsToBeRecreated_ = !0;
    }
    needsToBeRecreated() {
      return this.needsToBeRecreated_;
    }
    createTexture(t, e, i) {
      const n = this.gl_;
      i = i || n.createTexture();
      const r = n.RGBA,
        s = n.RGBA,
        o = n.UNSIGNED_BYTE;
      return (
        n.bindTexture(n.TEXTURE_2D, i),
        e
          ? n.texImage2D(n.TEXTURE_2D, 0, r, s, o, e)
          : n.texImage2D(n.TEXTURE_2D, 0, r, t[0], t[1], 0, s, o, null),
        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR),
        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
        i
      );
    }
  };
  class Cd extends Qc {
    constructor(t, e) {
      super(t),
        (e = e || {}),
        (this.inversePixelTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.pixelContext_ = null),
        (this.postProcesses_ = e.postProcesses),
        (this.uniforms_ = e.uniforms),
        this.helper,
        t.addChangeListener(Rs, this.removeHelper.bind(this)),
        (this.dispatchPreComposeEvent =
          this.dispatchPreComposeEvent.bind(this)),
        (this.dispatchPostComposeEvent =
          this.dispatchPostComposeEvent.bind(this));
    }
    dispatchPreComposeEvent(t, e) {
      const i = this.getLayer();
      if (i.hasListener(Fs)) {
        const n = new oo(Fs, void 0, e, t);
        i.dispatchEvent(n);
      }
    }
    dispatchPostComposeEvent(t, e) {
      const i = this.getLayer();
      if (i.hasListener(Is)) {
        const n = new oo(Is, void 0, e, t);
        i.dispatchEvent(n);
      }
    }
    reset(t) {
      (this.uniforms_ = t.uniforms),
        this.helper && this.helper.setUniforms(this.uniforms_);
    }
    removeHelper() {
      this.helper && (this.helper.dispose(), delete this.helper);
    }
    prepareFrame(t) {
      if (this.getLayer().getRenderSource()) {
        let e,
          i = !0,
          n = -1;
        for (let r = 0, s = t.layerStatesArray.length; r < s; r++) {
          const s = t.layerStatesArray[r].layer,
            o = s.getRenderer();
          if (!(o instanceof Cd)) {
            i = !0;
            continue;
          }
          const a = s.getClassName();
          if (((i || a !== e) && ((n += 1), (i = !1)), (e = a), o === this))
            break;
        }
        const r = "map/" + t.mapId + "/group/" + n;
        (this.helper &&
          this.helper.canvasCacheKeyMatches(r) &&
          !this.helper.needsToBeRecreated()) ||
          (this.removeHelper(),
          (this.helper = new Sd({
            postProcesses: this.postProcesses_,
            uniforms: this.uniforms_,
            canvasCacheKey: r,
          })),
          e && (this.helper.getCanvas().className = e),
          this.afterHelperCreated());
      }
      return this.prepareFrameInternal(t);
    }
    afterHelperCreated() {}
    prepareFrameInternal(t) {
      return !0;
    }
    disposeInternal() {
      this.removeHelper(), super.disposeInternal();
    }
    dispatchRenderEvent_(t, e, i) {
      const n = this.getLayer();
      if (n.hasListener(t)) {
        Vt(
          this.inversePixelTransform_,
          0,
          0,
          i.pixelRatio,
          -i.pixelRatio,
          0,
          0,
          -i.size[1]
        );
        const r = new oo(t, this.inversePixelTransform_, i, e);
        n.dispatchEvent(r);
      }
    }
    preRender(t, e) {
      this.dispatchRenderEvent_(Ps, t, e);
    }
    postRender(t, e) {
      this.dispatchRenderEvent_(bs, t, e);
    }
  }
  var wd = Cd;
  const Wd = new Uint8Array(4);
  var Ed = class {
    constructor(t, e) {
      this.helper_ = t;
      const i = t.getGL();
      (this.texture_ = i.createTexture()),
        (this.framebuffer_ = i.createFramebuffer()),
        (this.depthbuffer_ = i.createRenderbuffer()),
        (this.size_ = e || [1, 1]),
        (this.data_ = new Uint8Array(0)),
        (this.dataCacheDirty_ = !0),
        this.updateSize_();
    }
    setSize(t) {
      c(t, this.size_) ||
        ((this.size_[0] = t[0]), (this.size_[1] = t[1]), this.updateSize_());
    }
    getSize() {
      return this.size_;
    }
    clearCachedData() {
      this.dataCacheDirty_ = !0;
    }
    readAll() {
      if (this.dataCacheDirty_) {
        const t = this.size_,
          e = this.helper_.getGL();
        e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_),
          e.readPixels(0, 0, t[0], t[1], e.RGBA, e.UNSIGNED_BYTE, this.data_),
          (this.dataCacheDirty_ = !1);
      }
      return this.data_;
    }
    readPixel(t, e) {
      if (t < 0 || e < 0 || t > this.size_[0] || e >= this.size_[1])
        return (Wd[0] = 0), (Wd[1] = 0), (Wd[2] = 0), (Wd[3] = 0), Wd;
      this.readAll();
      const i =
        Math.floor(t) + (this.size_[1] - Math.floor(e) - 1) * this.size_[0];
      return (
        (Wd[0] = this.data_[4 * i]),
        (Wd[1] = this.data_[4 * i + 1]),
        (Wd[2] = this.data_[4 * i + 2]),
        (Wd[3] = this.data_[4 * i + 3]),
        Wd
      );
    }
    getTexture() {
      return this.texture_;
    }
    getFramebuffer() {
      return this.framebuffer_;
    }
    getDepthbuffer() {
      return this.depthbuffer_;
    }
    updateSize_() {
      const t = this.size_,
        e = this.helper_.getGL();
      (this.texture_ = this.helper_.createTexture(t, null, this.texture_)),
        e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer_),
        e.viewport(0, 0, t[0], t[1]),
        e.framebufferTexture2D(
          e.FRAMEBUFFER,
          e.COLOR_ATTACHMENT0,
          e.TEXTURE_2D,
          this.texture_,
          0
        ),
        e.bindRenderbuffer(e.RENDERBUFFER, this.depthbuffer_),
        e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_COMPONENT16, t[0], t[1]),
        e.framebufferRenderbuffer(
          e.FRAMEBUFFER,
          e.DEPTH_ATTACHMENT,
          e.RENDERBUFFER,
          this.depthbuffer_
        ),
        (this.data_ = new Uint8Array(t[0] * t[1] * 4));
    }
  };
  const Rd = "GENERATE_POLYGON_BUFFERS",
    Td = "GENERATE_POINT_BUFFERS",
    Pd = "GENERATE_LINE_STRING_BUFFERS";
  function bd(t) {
    return t &&
      t.__esModule &&
      Object.prototype.hasOwnProperty.call(t, "default")
      ? t.default
      : t;
  }
  var Fd = { exports: {} };
  function Id(t, e, i) {
    i = i || 2;
    var n,
      r,
      s,
      o,
      a,
      l,
      h,
      c = e && e.length,
      u = c ? e[0] * i : t.length,
      d = Ld(t, 0, u, i, !0),
      g = [];
    if (!d || d.next === d.prev) return g;
    if (
      (c &&
        (d = (function (t, e, i, n) {
          var r,
            s,
            o,
            a = [];
          for (r = 0, s = e.length; r < s; r++)
            (o = Ld(
              t,
              e[r] * n,
              r < s - 1 ? e[r + 1] * n : t.length,
              n,
              !1
            )) === o.next && (o.steiner = !0),
              a.push(Ud(o));
          for (a.sort(Gd), r = 0; r < a.length; r++) i = Bd(a[r], i);
          return i;
        })(t, e, d, i)),
      t.length > 80 * i)
    ) {
      (n = s = t[0]), (r = o = t[1]);
      for (var f = i; f < u; f += i)
        (a = t[f]) < n && (n = a),
          (l = t[f + 1]) < r && (r = l),
          a > s && (s = a),
          l > o && (o = l);
      h = 0 !== (h = Math.max(s - n, o - r)) ? 32767 / h : 0;
    }
    return Od(d, g, i, n, r, h, 0), g;
  }
  function Ld(t, e, i, n, r) {
    var s, o;
    if (r === ig(t, e, i, n) > 0)
      for (s = e; s < i; s += n) o = Jd(s, t[s], t[s + 1], o);
    else for (s = i - n; s >= e; s -= n) o = Jd(s, t[s], t[s + 1], o);
    return o && Zd(o, o.next) && (tg(o), (o = o.next)), o;
  }
  function Md(t, e) {
    if (!t) return t;
    e || (e = t);
    var i,
      n = t;
    do {
      if (
        ((i = !1), n.steiner || (!Zd(n, n.next) && 0 !== Xd(n.prev, n, n.next)))
      )
        n = n.next;
      else {
        if ((tg(n), (n = e = n.prev) === n.next)) break;
        i = !0;
      }
    } while (i || n !== e);
    return e;
  }
  function Od(t, e, i, n, r, s, o) {
    if (t) {
      !o &&
        s &&
        (function (t, e, i, n) {
          var r = t;
          do {
            0 === r.z && (r.z = zd(r.x, r.y, e, i, n)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== t);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (t) {
              var e,
                i,
                n,
                r,
                s,
                o,
                a,
                l,
                h = 1;
              do {
                for (i = t, t = null, s = null, o = 0; i; ) {
                  for (
                    o++, n = i, a = 0, e = 0;
                    e < h && (a++, (n = n.nextZ));
                    e++
                  );
                  for (l = h; a > 0 || (l > 0 && n); )
                    0 !== a && (0 === l || !n || i.z <= n.z)
                      ? ((r = i), (i = i.nextZ), a--)
                      : ((r = n), (n = n.nextZ), l--),
                      s ? (s.nextZ = r) : (t = r),
                      (r.prevZ = s),
                      (s = r);
                  i = n;
                }
                (s.nextZ = null), (h *= 2);
              } while (o > 1);
            })(r);
        })(t, n, r, s);
      for (var a, l, h = t; t.prev !== t.next; )
        if (((a = t.prev), (l = t.next), s ? Ad(t, n, r, s) : kd(t)))
          e.push((a.i / i) | 0),
            e.push((t.i / i) | 0),
            e.push((l.i / i) | 0),
            tg(t),
            (t = l.next),
            (h = l.next);
        else if ((t = l) === h) {
          o
            ? 1 === o
              ? Od((t = Nd(Md(t), e, i)), e, i, n, r, s, 2)
              : 2 === o && Dd(t, e, i, n, r, s)
            : Od(Md(t), e, i, n, r, s, 1);
          break;
        }
    }
  }
  function kd(t) {
    var e = t.prev,
      i = t,
      n = t.next;
    if (Xd(e, i, n) >= 0) return !1;
    for (
      var r = e.x,
        s = i.x,
        o = n.x,
        a = e.y,
        l = i.y,
        h = n.y,
        c = r < s ? (r < o ? r : o) : s < o ? s : o,
        u = a < l ? (a < h ? a : h) : l < h ? l : h,
        d = r > s ? (r > o ? r : o) : s > o ? s : o,
        g = a > l ? (a > h ? a : h) : l > h ? l : h,
        f = n.next;
      f !== e;

    ) {
      if (
        f.x >= c &&
        f.x <= d &&
        f.y >= u &&
        f.y <= g &&
        qd(r, a, s, l, o, h, f.x, f.y) &&
        Xd(f.prev, f, f.next) >= 0
      )
        return !1;
      f = f.next;
    }
    return !0;
  }
  function Ad(t, e, i, n) {
    var r = t.prev,
      s = t,
      o = t.next;
    if (Xd(r, s, o) >= 0) return !1;
    for (
      var a = r.x,
        l = s.x,
        h = o.x,
        c = r.y,
        u = s.y,
        d = o.y,
        g = a < l ? (a < h ? a : h) : l < h ? l : h,
        f = c < u ? (c < d ? c : d) : u < d ? u : d,
        p = a > l ? (a > h ? a : h) : l > h ? l : h,
        m = c > u ? (c > d ? c : d) : u > d ? u : d,
        _ = zd(g, f, e, i, n),
        y = zd(p, m, e, i, n),
        x = t.prevZ,
        v = t.nextZ;
      x && x.z >= _ && v && v.z <= y;

    ) {
      if (
        x.x >= g &&
        x.x <= p &&
        x.y >= f &&
        x.y <= m &&
        x !== r &&
        x !== o &&
        qd(a, c, l, u, h, d, x.x, x.y) &&
        Xd(x.prev, x, x.next) >= 0
      )
        return !1;
      if (
        ((x = x.prevZ),
        v.x >= g &&
          v.x <= p &&
          v.y >= f &&
          v.y <= m &&
          v !== r &&
          v !== o &&
          qd(a, c, l, u, h, d, v.x, v.y) &&
          Xd(v.prev, v, v.next) >= 0)
      )
        return !1;
      v = v.nextZ;
    }
    for (; x && x.z >= _; ) {
      if (
        x.x >= g &&
        x.x <= p &&
        x.y >= f &&
        x.y <= m &&
        x !== r &&
        x !== o &&
        qd(a, c, l, u, h, d, x.x, x.y) &&
        Xd(x.prev, x, x.next) >= 0
      )
        return !1;
      x = x.prevZ;
    }
    for (; v && v.z <= y; ) {
      if (
        v.x >= g &&
        v.x <= p &&
        v.y >= f &&
        v.y <= m &&
        v !== r &&
        v !== o &&
        qd(a, c, l, u, h, d, v.x, v.y) &&
        Xd(v.prev, v, v.next) >= 0
      )
        return !1;
      v = v.nextZ;
    }
    return !0;
  }
  function Nd(t, e, i) {
    var n = t;
    do {
      var r = n.prev,
        s = n.next.next;
      !Zd(r, s) &&
        Kd(r, n, n.next, s) &&
        Qd(r, s) &&
        Qd(s, r) &&
        (e.push((r.i / i) | 0),
        e.push((n.i / i) | 0),
        e.push((s.i / i) | 0),
        tg(n),
        tg(n.next),
        (n = t = s)),
        (n = n.next);
    } while (n !== t);
    return Md(n);
  }
  function Dd(t, e, i, n, r, s) {
    var o = t;
    do {
      for (var a = o.next.next; a !== o.prev; ) {
        if (o.i !== a.i && Vd(o, a)) {
          var l = $d(o, a);
          return (
            (o = Md(o, o.next)),
            (l = Md(l, l.next)),
            Od(o, e, i, n, r, s, 0),
            void Od(l, e, i, n, r, s, 0)
          );
        }
        a = a.next;
      }
      o = o.next;
    } while (o !== t);
  }
  function Gd(t, e) {
    return t.x - e.x;
  }
  function Bd(t, e) {
    var i = (function (t, e) {
      var i,
        n = e,
        r = t.x,
        s = t.y,
        o = -1 / 0;
      do {
        if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
          var a = n.x + ((s - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
          if (
            a <= r &&
            a > o &&
            ((o = a), (i = n.x < n.next.x ? n : n.next), a === r)
          )
            return i;
        }
        n = n.next;
      } while (n !== e);
      if (!i) return null;
      var l,
        h = i,
        c = i.x,
        u = i.y,
        d = 1 / 0;
      n = i;
      do {
        r >= n.x &&
          n.x >= c &&
          r !== n.x &&
          qd(s < u ? r : o, s, c, u, s < u ? o : r, s, n.x, n.y) &&
          ((l = Math.abs(s - n.y) / (r - n.x)),
          Qd(n, t) &&
            (l < d || (l === d && (n.x > i.x || (n.x === i.x && jd(i, n))))) &&
            ((i = n), (d = l))),
          (n = n.next);
      } while (n !== h);
      return i;
    })(t, e);
    if (!i) return e;
    var n = $d(i, t);
    return Md(n, n.next), Md(i, i.next);
  }
  function jd(t, e) {
    return Xd(t.prev, t, e.prev) < 0 && Xd(e.next, t, t.next) < 0;
  }
  function zd(t, e, i, n, r) {
    return (
      (t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = ((t - i) * r) | 0) | (t << 8))) |
              (t << 4))) |
            (t << 2))) |
          (t << 1))) |
      ((e =
        1431655765 &
        ((e =
          858993459 &
          ((e =
            252645135 &
            ((e = 16711935 & ((e = ((e - n) * r) | 0) | (e << 8))) |
              (e << 4))) |
            (e << 2))) |
          (e << 1))) <<
        1)
    );
  }
  function Ud(t) {
    var e = t,
      i = t;
    do {
      (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
    } while (e !== t);
    return i;
  }
  function qd(t, e, i, n, r, s, o, a) {
    return (
      (r - o) * (e - a) >= (t - o) * (s - a) &&
      (t - o) * (n - a) >= (i - o) * (e - a) &&
      (i - o) * (s - a) >= (r - o) * (n - a)
    );
  }
  function Vd(t, e) {
    return (
      t.next.i !== e.i &&
      t.prev.i !== e.i &&
      !(function (t, e) {
        var i = t;
        do {
          if (
            i.i !== t.i &&
            i.next.i !== t.i &&
            i.i !== e.i &&
            i.next.i !== e.i &&
            Kd(i, i.next, t, e)
          )
            return !0;
          i = i.next;
        } while (i !== t);
        return !1;
      })(t, e) &&
      ((Qd(t, e) &&
        Qd(e, t) &&
        (function (t, e) {
          var i = t,
            n = !1,
            r = (t.x + e.x) / 2,
            s = (t.y + e.y) / 2;
          do {
            i.y > s != i.next.y > s &&
              i.next.y !== i.y &&
              r < ((i.next.x - i.x) * (s - i.y)) / (i.next.y - i.y) + i.x &&
              (n = !n),
              (i = i.next);
          } while (i !== t);
          return n;
        })(t, e) &&
        (Xd(t.prev, t, e.prev) || Xd(t, e.prev, e))) ||
        (Zd(t, e) && Xd(t.prev, t, t.next) > 0 && Xd(e.prev, e, e.next) > 0))
    );
  }
  function Xd(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function Zd(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function Kd(t, e, i, n) {
    var r = Yd(Xd(t, e, i)),
      s = Yd(Xd(t, e, n)),
      o = Yd(Xd(i, n, t)),
      a = Yd(Xd(i, n, e));
    return (
      (r !== s && o !== a) ||
      !(0 !== r || !Hd(t, i, e)) ||
      !(0 !== s || !Hd(t, n, e)) ||
      !(0 !== o || !Hd(i, t, n)) ||
      !(0 !== a || !Hd(i, e, n))
    );
  }
  function Hd(t, e, i) {
    return (
      e.x <= Math.max(t.x, i.x) &&
      e.x >= Math.min(t.x, i.x) &&
      e.y <= Math.max(t.y, i.y) &&
      e.y >= Math.min(t.y, i.y)
    );
  }
  function Yd(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }
  function Qd(t, e) {
    return Xd(t.prev, t, t.next) < 0
      ? Xd(t, e, t.next) >= 0 && Xd(t, t.prev, e) >= 0
      : Xd(t, e, t.prev) < 0 || Xd(t, t.next, e) < 0;
  }
  function $d(t, e) {
    var i = new eg(t.i, t.x, t.y),
      n = new eg(e.i, e.x, e.y),
      r = t.next,
      s = e.prev;
    return (
      (t.next = e),
      (e.prev = t),
      (i.next = r),
      (r.prev = i),
      (n.next = i),
      (i.prev = n),
      (s.next = n),
      (n.prev = s),
      n
    );
  }
  function Jd(t, e, i, n) {
    var r = new eg(t, e, i);
    return (
      n
        ? ((r.next = n.next), (r.prev = n), (n.next.prev = r), (n.next = r))
        : ((r.prev = r), (r.next = r)),
      r
    );
  }
  function tg(t) {
    (t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function eg(t, e, i) {
    (this.i = t),
      (this.x = e),
      (this.y = i),
      (this.prev = null),
      (this.next = null),
      (this.z = 0),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  function ig(t, e, i, n) {
    for (var r = 0, s = e, o = i - n; s < i; s += n)
      (r += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s);
    return r;
  }
  (Fd.exports = Id),
    (Fd.exports.default = Id),
    (Id.deviation = function (t, e, i, n) {
      var r = e && e.length,
        s = r ? e[0] * i : t.length,
        o = Math.abs(ig(t, 0, s, i));
      if (r)
        for (var a = 0, l = e.length; a < l; a++) {
          var h = e[a] * i,
            c = a < l - 1 ? e[a + 1] * i : t.length;
          o -= Math.abs(ig(t, h, c, i));
        }
      var u = 0;
      for (a = 0; a < n.length; a += 3) {
        var d = n[a] * i,
          g = n[a + 1] * i,
          f = n[a + 2] * i;
        u += Math.abs(
          (t[d] - t[f]) * (t[g + 1] - t[d + 1]) -
            (t[d] - t[g]) * (t[f + 1] - t[d + 1])
        );
      }
      return 0 === o && 0 === u ? 0 : Math.abs((u - o) / o);
    }),
    (Id.flatten = function (t) {
      for (
        var e = t[0][0].length,
          i = { vertices: [], holes: [], dimensions: e },
          n = 0,
          r = 0;
        r < t.length;
        r++
      ) {
        for (var s = 0; s < t[r].length; s++)
          for (var o = 0; o < e; o++) i.vertices.push(t[r][s][o]);
        r > 0 && ((n += t[r - 1].length), i.holes.push(n));
      }
      return i;
    });
  var ng = bd(Fd.exports);
  const rg = [],
    sg = { vertexPosition: 0, indexPosition: 0 };
  function og(t, e, i, n, r) {
    (t[e + 0] = i), (t[e + 1] = n), (t[e + 2] = r);
  }
  function ag(t, e) {
    const i = 256,
      n = 255;
    return (
      ((e = e || [])[0] = Math.floor(t / i / i / i) / n),
      (e[1] = (Math.floor(t / i / i) % i) / n),
      (e[2] = (Math.floor(t / i) % i) / n),
      (e[3] = (t % i) / n),
      e
    );
  }
  function lg(t) {
    let e = 0;
    const i = 256,
      n = 255;
    return (
      (e += Math.round(t[0] * i * i * i * n)),
      (e += Math.round(t[1] * i * i * n)),
      (e += Math.round(t[2] * i * n)),
      (e += Math.round(t[3] * n)),
      e
    );
  }
  function hg() {
    const t =
      'const e="GENERATE_POLYGON_BUFFERS",t="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS";function r(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function x(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new Error(t)}(0!==n,"Transformation matrix cannot be inverted");const x=t[0],i=t[1],u=t[2],o=t[3],f=t[4],s=t[5];return e[0]=o/n,e[1]=-i/n,e[2]=-u/n,e[3]=x/n,e[4]=(u*s-o*f)/n,e[5]=-(x*s-i*f)/n,e}function i(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}new Array(6);var u={exports:{}};function o(e,t,n){n=n||2;var r,x,i,u,o,s,l,v=t&&t.length,c=v?t[0]*n:e.length,h=f(e,0,c,n,!0),g=[];if(!h||h.next===h.prev)return g;if(v&&(h=function(e,t,n,r){var x,i,u,o=[];for(x=0,i=t.length;x<i;x++)(u=f(e,t[x]*r,x<i-1?t[x+1]*r:e.length,r,!1))===u.next&&(u.steiner=!0),o.push(d(u));for(o.sort(p),x=0;x<o.length;x++)n=y(o[x],n);return n}(e,t,h,n)),e.length>80*n){r=i=e[0],x=u=e[1];for(var b=n;b<c;b+=n)(o=e[b])<r&&(r=o),(s=e[b+1])<x&&(x=s),o>i&&(i=o),s>u&&(u=s);l=0!==(l=Math.max(i-r,u-x))?32767/l:0}return a(h,g,n,r,x,l,0),g}function f(e,t,n,r,x){var i,u;if(x===O(e,t,n,r)>0)for(i=t;i<n;i+=r)u=P(i,e[i],e[i+1],u);else for(i=n-r;i>=t;i-=r)u=P(i,e[i],e[i+1],u);return u&&m(u,u.next)&&(B(u),u=u.next),u}function s(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!m(r,r.next)&&0!==M(r.prev,r,r.next))r=r.next;else{if(B(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function a(e,t,n,r,x,i,u){if(e){!u&&i&&function(e,t,n,r){var x=e;do{0===x.z&&(x.z=b(x.x,x.y,t,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==e);x.prevZ.nextZ=null,x.prevZ=null,function(e){var t,n,r,x,i,u,o,f,s=1;do{for(n=e,e=null,i=null,u=0;n;){for(u++,r=n,o=0,t=0;t<s&&(o++,r=r.nextZ);t++);for(f=s;o>0||f>0&&r;)0!==o&&(0===f||!r||n.z<=r.z)?(x=n,n=n.nextZ,o--):(x=r,r=r.nextZ,f--),i?i.nextZ=x:e=x,x.prevZ=i,i=x;n=r}i.nextZ=null,s*=2}while(u>1)}(x)}(e,r,x,i);for(var o,f,p=e;e.prev!==e.next;)if(o=e.prev,f=e.next,i?v(e,r,x,i):l(e))t.push(o.i/n|0),t.push(e.i/n|0),t.push(f.i/n|0),B(e),e=f.next,p=f.next;else if((e=f)===p){u?1===u?a(e=c(s(e),t,n),t,n,r,x,i,2):2===u&&h(e,t,n,r,x,i):a(s(e),t,n,r,x,i,1);break}}}function l(e){var t=e.prev,n=e,r=e.next;if(M(t,n,r)>=0)return!1;for(var x=t.x,i=n.x,u=r.x,o=t.y,f=n.y,s=r.y,a=x<i?x<u?x:u:i<u?i:u,l=o<f?o<s?o:s:f<s?f:s,v=x>i?x>u?x:u:i>u?i:u,c=o>f?o>s?o:s:f>s?f:s,h=r.next;h!==t;){if(h.x>=a&&h.x<=v&&h.y>=l&&h.y<=c&&Z(x,o,i,f,u,s,h.x,h.y)&&M(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function v(e,t,n,r){var x=e.prev,i=e,u=e.next;if(M(x,i,u)>=0)return!1;for(var o=x.x,f=i.x,s=u.x,a=x.y,l=i.y,v=u.y,c=o<f?o<s?o:s:f<s?f:s,h=a<l?a<v?a:v:l<v?l:v,p=o>f?o>s?o:s:f>s?f:s,y=a>l?a>v?a:v:l>v?l:v,g=b(c,h,t,n,r),d=b(p,y,t,n,r),w=e.prevZ,m=e.nextZ;w&&w.z>=g&&m&&m.z<=d;){if(w.x>=c&&w.x<=p&&w.y>=h&&w.y<=y&&w!==x&&w!==u&&Z(o,a,f,l,s,v,w.x,w.y)&&M(w.prev,w,w.next)>=0)return!1;if(w=w.prevZ,m.x>=c&&m.x<=p&&m.y>=h&&m.y<=y&&m!==x&&m!==u&&Z(o,a,f,l,s,v,m.x,m.y)&&M(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;w&&w.z>=g;){if(w.x>=c&&w.x<=p&&w.y>=h&&w.y<=y&&w!==x&&w!==u&&Z(o,a,f,l,s,v,w.x,w.y)&&M(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;m&&m.z<=d;){if(m.x>=c&&m.x<=p&&m.y>=h&&m.y<=y&&m!==x&&m!==u&&Z(o,a,f,l,s,v,m.x,m.y)&&M(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function c(e,t,n){var r=e;do{var x=r.prev,i=r.next.next;!m(x,i)&&A(x,r,r.next,i)&&F(x,i)&&F(i,x)&&(t.push(x.i/n|0),t.push(r.i/n|0),t.push(i.i/n|0),B(r),B(r.next),r=e=i),r=r.next}while(r!==e);return s(r)}function h(e,t,n,r,x,i){var u=e;do{for(var o=u.next.next;o!==u.prev;){if(u.i!==o.i&&w(u,o)){var f=I(u,o);return u=s(u,u.next),f=s(f,f.next),a(u,t,n,r,x,i,0),void a(f,t,n,r,x,i,0)}o=o.next}u=u.next}while(u!==e)}function p(e,t){return e.x-t.x}function y(e,t){var n=function(e,t){var n,r=t,x=e.x,i=e.y,u=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var o=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(o<=x&&o>u&&(u=o,n=r.x<r.next.x?r:r.next,o===x))return n}r=r.next}while(r!==t);if(!n)return null;var f,s=n,a=n.x,l=n.y,v=1/0;r=n;do{x>=r.x&&r.x>=a&&x!==r.x&&Z(i<l?x:u,i,a,l,i<l?u:x,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(x-r.x),F(r,e)&&(f<v||f===v&&(r.x>n.x||r.x===n.x&&g(n,r)))&&(n=r,v=f)),r=r.next}while(r!==s);return n}(e,t);if(!n)return t;var r=I(n,e);return s(r,r.next),s(n,n.next)}function g(e,t){return M(e.prev,e,t.prev)<0&&M(t.next,e,e.next)<0}function b(e,t,n,r,x){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function d(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function Z(e,t,n,r,x,i,u,o){return(x-u)*(t-o)>=(e-u)*(i-o)&&(e-u)*(r-o)>=(n-u)*(t-o)&&(n-u)*(i-o)>=(x-u)*(r-o)}function w(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&A(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(F(e,t)&&F(t,e)&&function(e,t){var n=e,r=!1,x=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&x<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(M(e.prev,e,t.prev)||M(e,t.prev,t))||m(e,t)&&M(e.prev,e,e.next)>0&&M(t.prev,t,t.next)>0)}function M(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function m(e,t){return e.x===t.x&&e.y===t.y}function A(e,t,n,r){var x=z(M(e,t,n)),i=z(M(e,t,r)),u=z(M(n,r,e)),o=z(M(n,r,t));return x!==i&&u!==o||(!(0!==x||!E(e,n,t))||(!(0!==i||!E(e,r,t))||(!(0!==u||!E(n,e,r))||!(0!==o||!E(n,t,r)))))}function E(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function z(e){return e>0?1:e<0?-1:0}function F(e,t){return M(e.prev,e,e.next)<0?M(e,t,e.next)>=0&&M(e,e.prev,t)>=0:M(e,t,e.prev)<0||M(e,e.next,t)<0}function I(e,t){var n=new _(e.i,e.x,e.y),r=new _(t.i,t.x,t.y),x=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=x,x.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function P(e,t,n,r){var x=new _(e,t,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function B(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function _(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function O(e,t,n,r){for(var x=0,i=t,u=n-r;i<n;i+=r)x+=(e[u]-e[i])*(e[i+1]+e[u+1]),u=i;return x}u.exports=o,u.exports.default=o,o.deviation=function(e,t,n,r){var x=t&&t.length,i=x?t[0]*n:e.length,u=Math.abs(O(e,0,i,n));if(x)for(var o=0,f=t.length;o<f;o++){var s=t[o]*n,a=o<f-1?t[o+1]*n:e.length;u-=Math.abs(O(e,s,a,n))}var l=0;for(o=0;o<r.length;o+=3){var v=r[o]*n,c=r[o+1]*n,h=r[o+2]*n;l+=Math.abs((e[v]-e[h])*(e[c+1]-e[v+1])-(e[v]-e[c])*(e[h+1]-e[v+1]))}return 0===u&&0===l?0:Math.abs((l-u)/u)},o.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,x=0;x<e.length;x++){for(var i=0;i<e[x].length;i++)for(var u=0;u<t;u++)n.vertices.push(e[x][i][u]);x>0&&(r+=e[x-1].length,n.holes.push(r))}return n};var N=i(u.exports);const R=[],S={vertexPosition:0,indexPosition:0};function T(e,t,n,r,x){e[t+0]=n,e[t+1]=r,e[t+2]=x}function U(e,t,n,r,x,i){const u=3+x,o=e[t+0],f=e[t+1],s=R;s.length=x;for(let n=0;n<s.length;n++)s[n]=e[t+2+n];let a=i?i.vertexPosition:0,l=i?i.indexPosition:0;const v=a/u;return T(n,a,o,f,0),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,1),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,2),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,3),s.length&&n.set(s,a+3),a+=u,r[l++]=v,r[l++]=v+1,r[l++]=v+3,r[l++]=v+1,r[l++]=v+2,r[l++]=v+3,S.vertexPosition=a,S.indexPosition=l,S}function k(e,t,n,x,i,u,o,f,s,a){const l=8+f.length,v=u.length/l,c=[e[t+0],e[t+1]],h=[e[n],e[n+1]],p=r(s,[...c]),y=r(s,[...h]);function g(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),x=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-x[1],x[0]],u=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),o=[(n[0]-e[0])/u,(n[1]-e[1])/u],f=0===r||0===u?0:Math.acos((s=o[0]*x[0]+o[1]*x[1],a=-1,l=1,Math.min(Math.max(s,a),l)));var s,a,l;return o[0]*i[0]+o[1]*i[1]>0?f:2*Math.PI-f}let b=-1,d=-1;const Z=null!==i;if(null!==x){b=g(p,y,r(s,[...[e[x],e[x+1]]]))}if(Z){d=g(y,p,r(s,[...[e[i],e[i+1]]]))}return u.push(c[0],c[1],h[0],h[1],b,d,a,0),u.push(...f),u.push(c[0],c[1],h[0],h[1],b,d,a,1),u.push(...f),u.push(c[0],c[1],h[0],h[1],b,d,a,2),u.push(...f),u.push(c[0],c[1],h[0],h[1],b,d,a,3),u.push(...f),o.push(v,v+1,v+2,v+1,v+3,v+2),a+Math.sqrt((y[0]-p[0])*(y[0]-p[0])+(y[1]-p[1])*(y[1]-p[1]))}function G(e,t,n,r,x){const i=2+x;let u=t;const o=e.slice(u,u+x);u+=x;const f=e[u++];let s=0;const a=new Array(f-1);for(let t=0;t<f;t++)s+=e[u++],t<f-1&&(a[t]=s);const l=e.slice(u,u+2*s),v=N(l,a,2);for(let e=0;e<v.length;e++)r.push(v[e]+n.length/i);for(let e=0;e<l.length;e+=2)n.push(l[e],l[e+1],...o);return u+2*s}const j=self;j.onmessage=r=>{const i=r.data;switch(i.type){case t:{const e=3,t=2,n=i.customAttributesSize,r=t+n,x=new Float32Array(i.renderInstructions),u=x.length/r,o=4*u*(n+e),f=new Uint32Array(6*u),s=new Float32Array(o);let a;for(let e=0;e<x.length;e+=r)a=U(x,e,s,f,n,a);const l=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},i);j.postMessage(l,[s.buffer,f.buffer,x.buffer]);break}case n:{const e=[],t=[],n=i.customAttributesSize,r=2,u=new Float32Array(i.renderInstructions);let o=0;const f=[1,0,0,1,0,0];let s,a;for(x(f,i.renderInstructionsTransform);o<u.length;){a=Array.from(u.slice(o,o+n)),o+=n,s=u[o++];const x=o,i=o+(s-1)*r,l=u[x]===u[i]&&u[x+1]===u[i+1];let v=0;for(let n=0;n<s-1;n++){let c=null;n>0?c=o+(n-1)*r:l&&(c=i-r);let h=null;n<s-2?h=o+(n+2)*r:l&&(h=x+r),v=k(u,o+n*r,o+(n+1)*r,c,h,e,t,a,f,v)}o+=s*r}const l=Uint32Array.from(t),v=Float32Array.from(e),c=Object.assign({vertexBuffer:v.buffer,indexBuffer:l.buffer,renderInstructions:u.buffer},i);j.postMessage(c,[v.buffer,l.buffer,u.buffer]);break}case e:{const e=[],t=[],n=i.customAttributesSize,r=new Float32Array(i.renderInstructions);let x=0;for(;x<r.length;)x=G(r,x,e,t,n);const u=Uint32Array.from(t),o=Float32Array.from(e),f=Object.assign({vertexBuffer:o.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},i);j.postMessage(f,[o.buffer,u.buffer,r.buffer]);break}}};';
    return new Worker(
      "undefined" == typeof Blob
        ? "data:application/javascript;base64," +
          Buffer.from(t, "binary").toString("base64")
        : URL.createObjectURL(new Blob([t], { type: "application/javascript" }))
    );
  }
  var cg = class extends wd {
    constructor(t, e) {
      const i = e.uniforms || {},
        n = [1, 0, 0, 1, 0, 0];
      (i[fd.PROJECTION_MATRIX] = n),
        super(t, { uniforms: i, postProcesses: e.postProcesses }),
        (this.sourceRevision_ = -1),
        (this.verticesBuffer_ = new ld($u, ed)),
        (this.indicesBuffer_ = new ld(Ju, ed)),
        (this.vertexShader_ = e.vertexShader),
        (this.fragmentShader_ = e.fragmentShader),
        this.program_,
        (this.hitDetectionEnabled_ = e.hitDetectionEnabled ?? !0);
      const r = e.attributes
        ? e.attributes.map(function (t) {
            return { name: "a_" + t.name, size: 1, type: pd.FLOAT };
          })
        : [];
      (this.attributes = [
        { name: "a_position", size: 2, type: pd.FLOAT },
        { name: "a_index", size: 1, type: pd.FLOAT },
      ]),
        this.hitDetectionEnabled_ &&
          (this.attributes.push({
            name: "a_hitColor",
            size: 4,
            type: pd.FLOAT,
          }),
          this.attributes.push({
            name: "a_featureUid",
            size: 1,
            type: pd.FLOAT,
          })),
        this.attributes.push(...r),
        (this.customAttributes = e.attributes ? e.attributes : []),
        (this.previousExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        (this.currentTransform_ = n),
        (this.renderTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.invertRenderTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.renderInstructions_ = new Float32Array(0)),
        this.hitRenderTarget_,
        (this.lastSentId = 0),
        (this.worker_ = hg()),
        this.worker_.addEventListener("message", (t) => {
          const e = t.data;
          if (e.type === Td) {
            const i = e.projectionTransform;
            this.verticesBuffer_.fromArrayBuffer(e.vertexBuffer),
              this.helper.flushBufferData(this.verticesBuffer_),
              this.indicesBuffer_.fromArrayBuffer(e.indexBuffer),
              this.helper.flushBufferData(this.indicesBuffer_),
              (this.renderTransform_ = i),
              Xt(this.invertRenderTransform_, this.renderTransform_),
              (this.renderInstructions_ = new Float32Array(
                t.data.renderInstructions
              )),
              e.id === this.lastSentId && (this.ready = !0),
              this.getLayer().changed();
          }
        }),
        (this.featureCache_ = {}),
        (this.featureCount_ = 0);
      const s = this.getLayer().getSource();
      (this.sourceListenKeys_ = [
        M(s, Lu, this.handleSourceFeatureAdded_, this),
        M(s, Mu, this.handleSourceFeatureChanged_, this),
        M(s, ku, this.handleSourceFeatureDelete_, this),
        M(s, Ou, this.handleSourceFeatureClear_, this),
      ]),
        s.forEachFeature((t) => {
          (this.featureCache_[j(t)] = {
            feature: t,
            properties: t.getProperties(),
            geometry: t.getGeometry(),
          }),
            this.featureCount_++;
        });
    }
    afterHelperCreated() {
      (this.program_ = this.helper.getProgram(
        this.fragmentShader_,
        this.vertexShader_
      )),
        this.hitDetectionEnabled_ &&
          (this.hitRenderTarget_ = new Ed(this.helper));
    }
    handleSourceFeatureAdded_(t) {
      const e = t.feature;
      (this.featureCache_[j(e)] = {
        feature: e,
        properties: e.getProperties(),
        geometry: e.getGeometry(),
      }),
        this.featureCount_++;
    }
    handleSourceFeatureChanged_(t) {
      const e = t.feature;
      this.featureCache_[j(e)] = {
        feature: e,
        properties: e.getProperties(),
        geometry: e.getGeometry(),
      };
    }
    handleSourceFeatureDelete_(t) {
      const e = t.feature;
      delete this.featureCache_[j(e)], this.featureCount_--;
    }
    handleSourceFeatureClear_() {
      (this.featureCache_ = {}), (this.featureCount_ = 0);
    }
    renderFrame(t) {
      const e = this.helper.getGL();
      this.preRender(e, t);
      const [i, n, r] = this.getWorldParameters_(t);
      this.renderWorlds(t, !1, i, n, r),
        this.helper.finalizeDraw(
          t,
          this.dispatchPreComposeEvent,
          this.dispatchPostComposeEvent
        );
      const s = this.helper.getCanvas();
      return (
        this.hitDetectionEnabled_ &&
          (this.renderWorlds(t, !0, i, n, r),
          this.hitRenderTarget_.clearCachedData()),
        this.postRender(e, t),
        s
      );
    }
    getWorldParameters_(t) {
      const e = t.viewState.projection,
        i = this.getLayer().getSource().getWrapX() && e.canWrapX(),
        n = e.getExtent(),
        r = t.extent,
        s = i ? Fe(n) : null,
        o = i ? Math.ceil((r[2] - n[2]) / s) + 1 : 1;
      return [i ? Math.floor((r[0] - n[0]) / s) : 0, o, s];
    }
    prepareFrameInternal(t) {
      const e = this.getLayer(),
        i = e.getSource(),
        n = t.viewState,
        r = !t.viewHints[Ms] && !t.viewHints[Os],
        s = !ce(this.previousExtent_, t.extent),
        o = this.sourceRevision_ < i.getRevision();
      if ((o && (this.sourceRevision_ = i.getRevision()), r && (s || o))) {
        const r = n.projection,
          s = n.resolution,
          o = e instanceof Cc ? e.getRenderBuffer() : 0,
          a = $t(t.extent, o * s);
        i.loadFeatures(a, s, r),
          this.rebuildBuffers_(t),
          (this.previousExtent_ = t.extent.slice());
      }
      return (
        this.helper.useProgram(this.program_, t),
        this.helper.prepareDraw(t),
        this.helper.bindBuffer(this.verticesBuffer_),
        this.helper.bindBuffer(this.indicesBuffer_),
        this.helper.enableAttributes(this.attributes),
        !0
      );
    }
    rebuildBuffers_(t) {
      const e = [1, 0, 0, 1, 0, 0];
      this.helper.makeProjectionTransform(t, e);
      const i =
          (this.hitDetectionEnabled_ ? 7 : 2) + this.customAttributes.length,
        n = i * this.featureCount_;
      let r, s;
      (this.renderInstructions_ && this.renderInstructions_.length === n) ||
        (this.renderInstructions_ = new Float32Array(n));
      const o = [],
        a = [];
      let l = -1;
      for (const t in this.featureCache_)
        if (
          ((r = this.featureCache_[t]),
          (s = r.geometry),
          s && "Point" === s.getType())
        ) {
          if (
            ((o[0] = s.getFlatCoordinates()[0]),
            (o[1] = s.getFlatCoordinates()[1]),
            Bt(e, o),
            (this.renderInstructions_[++l] = o[0]),
            (this.renderInstructions_[++l] = o[1]),
            this.hitDetectionEnabled_)
          ) {
            const e = ag(l + 5, a);
            (this.renderInstructions_[++l] = e[0]),
              (this.renderInstructions_[++l] = e[1]),
              (this.renderInstructions_[++l] = e[2]),
              (this.renderInstructions_[++l] = e[3]),
              (this.renderInstructions_[++l] = Number(t));
          }
          for (let t = 0; t < this.customAttributes.length; t++) {
            const e = this.customAttributes[t].callback(
              r.feature,
              r.properties
            );
            this.renderInstructions_[++l] = e;
          }
        }
      const h = {
        id: ++this.lastSentId,
        type: Td,
        renderInstructions: this.renderInstructions_.buffer,
        customAttributesSize: i - 2,
      };
      (h.projectionTransform = e),
        (this.ready = !1),
        this.worker_.postMessage(h, [this.renderInstructions_.buffer]),
        (this.renderInstructions_ = null);
    }
    forEachFeatureAtCoordinate(t, e, i, n, r) {
      if (
        (Ft(
          this.hitDetectionEnabled_,
          "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`"
        ),
        !this.renderInstructions_ || !this.hitDetectionEnabled_)
      )
        return;
      const s = Bt(e.coordinateToPixelTransform, t.slice()),
        o = this.hitRenderTarget_.readPixel(s[0] / 2, s[1] / 2),
        a = lg([o[0] / 255, o[1] / 255, o[2] / 255, o[3] / 255]),
        l = this.renderInstructions_[a],
        h = Math.floor(l).toString(),
        c = this.getLayer().getSource().getFeatureByUid(h);
      return c ? n(c, this.getLayer(), null) : void 0;
    }
    renderWorlds(t, e, i, n, r) {
      let s = i;
      this.helper.useProgram(this.program_, t),
        e &&
          (this.hitRenderTarget_.setSize([
            Math.floor(t.size[0] / 2),
            Math.floor(t.size[1] / 2),
          ]),
          this.helper.prepareDrawToRenderTarget(t, this.hitRenderTarget_, !0)),
        this.helper.bindBuffer(this.verticesBuffer_),
        this.helper.bindBuffer(this.indicesBuffer_),
        this.helper.enableAttributes(this.attributes);
      do {
        this.helper.makeProjectionTransform(t, this.currentTransform_),
          qt(this.currentTransform_, s * r, 0),
          Nt(this.currentTransform_, this.invertRenderTransform_),
          this.helper.applyUniforms(t),
          this.helper.applyHitDetectionUniform(e);
        const i = this.indicesBuffer_.getSize();
        this.helper.drawElements(0, i);
      } while (++s < n);
    }
    disposeInternal() {
      this.worker_.terminate(),
        (this.layer_ = null),
        this.sourceListenKeys_.forEach(function (t) {
          k(t);
        }),
        (this.sourceListenKeys_ = null),
        super.disposeInternal();
    }
  };
  var ug = class {
    constructor(t, e) {
      (this.name = t), (this.data = e), (this.texture_ = null);
    }
    getTexture(t) {
      if (!this.texture_) {
        const e = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, e),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST),
          t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST),
          t.texImage2D(
            t.TEXTURE_2D,
            0,
            t.RGBA,
            this.data.length / 4,
            1,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            this.data
          ),
          (this.texture_ = e);
      }
      return this.texture_;
    }
  };
  const dg = 0.5;
  var gg = class {
    constructor(t, e, i, n, r, s) {
      (this.sourceProj_ = t), (this.targetProj_ = e);
      let o = {};
      const a = cn(this.targetProj_, this.sourceProj_);
      (this.transformInv_ = function (t) {
        const e = t[0] + "/" + t[1];
        return o[e] || (o[e] = a(t)), o[e];
      }),
        (this.maxSourceExtent_ = n),
        (this.errorThresholdSquared_ = r * r),
        (this.triangles_ = []),
        (this.wrapsXInSource_ = !1),
        (this.canWrapXInSource_ =
          this.sourceProj_.canWrapX() &&
          !!n &&
          !!this.sourceProj_.getExtent() &&
          Fe(n) >= Fe(this.sourceProj_.getExtent())),
        (this.sourceWorldWidth_ = this.sourceProj_.getExtent()
          ? Fe(this.sourceProj_.getExtent())
          : null),
        (this.targetWorldWidth_ = this.targetProj_.getExtent()
          ? Fe(this.targetProj_.getExtent())
          : null);
      const l = Pe(i),
        h = be(i),
        c = Se(i),
        u = ve(i),
        d = this.transformInv_(l),
        g = this.transformInv_(h),
        f = this.transformInv_(c),
        p = this.transformInv_(u),
        m =
          10 +
          (s
            ? Math.max(0, Math.ceil(Math.log2(xe(i) / (s * s * 256 * 256))))
            : 0);
      if ((this.addQuad_(l, h, c, u, d, g, f, p, m), this.wrapsXInSource_)) {
        let t = 1 / 0;
        this.triangles_.forEach(function (e, i, n) {
          t = Math.min(t, e.source[0][0], e.source[1][0], e.source[2][0]);
        }),
          this.triangles_.forEach((e) => {
            if (
              Math.max(e.source[0][0], e.source[1][0], e.source[2][0]) - t >
              this.sourceWorldWidth_ / 2
            ) {
              const i = [
                [e.source[0][0], e.source[0][1]],
                [e.source[1][0], e.source[1][1]],
                [e.source[2][0], e.source[2][1]],
              ];
              i[0][0] - t > this.sourceWorldWidth_ / 2 &&
                (i[0][0] -= this.sourceWorldWidth_),
                i[1][0] - t > this.sourceWorldWidth_ / 2 &&
                  (i[1][0] -= this.sourceWorldWidth_),
                i[2][0] - t > this.sourceWorldWidth_ / 2 &&
                  (i[2][0] -= this.sourceWorldWidth_);
              const n = Math.min(i[0][0], i[1][0], i[2][0]);
              Math.max(i[0][0], i[1][0], i[2][0]) - n <
                this.sourceWorldWidth_ / 2 && (e.source = i);
            }
          });
      }
      o = {};
    }
    addTriangle_(t, e, i, n, r, s) {
      this.triangles_.push({ source: [n, r, s], target: [t, e, i] });
    }
    addQuad_(t, e, i, n, r, s, o, a, l) {
      const h = Qt([r, s, o, a]),
        c = this.sourceWorldWidth_ ? Fe(h) / this.sourceWorldWidth_ : null,
        u = this.sourceWorldWidth_,
        d = this.sourceProj_.canWrapX() && c > 0.5 && c < 1;
      let g = !1;
      if (l > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          g = Fe(Qt([t, e, i, n])) / this.targetWorldWidth_ > 0.25 || g;
        }
        !d && this.sourceProj_.isGlobal() && c && (g = c > 0.25 || g);
      }
      if (
        !g &&
        this.maxSourceExtent_ &&
        isFinite(h[0]) &&
        isFinite(h[1]) &&
        isFinite(h[2]) &&
        isFinite(h[3]) &&
        !Ie(h, this.maxSourceExtent_)
      )
        return;
      let f = 0;
      if (
        !(
          g ||
          (isFinite(r[0]) &&
            isFinite(r[1]) &&
            isFinite(s[0]) &&
            isFinite(s[1]) &&
            isFinite(o[0]) &&
            isFinite(o[1]) &&
            isFinite(a[0]) &&
            isFinite(a[1]))
        )
      )
        if (l > 0) g = !0;
        else if (
          ((f =
            (isFinite(r[0]) && isFinite(r[1]) ? 0 : 8) +
            (isFinite(s[0]) && isFinite(s[1]) ? 0 : 4) +
            (isFinite(o[0]) && isFinite(o[1]) ? 0 : 2) +
            (isFinite(a[0]) && isFinite(a[1]) ? 0 : 1)),
          1 != f && 2 != f && 4 != f && 8 != f)
        )
          return;
      if (l > 0) {
        if (!g) {
          const e = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2],
            n = this.transformInv_(e);
          let s;
          if (d) {
            s = (_i(r[0], u) + _i(o[0], u)) / 2 - _i(n[0], u);
          } else s = (r[0] + o[0]) / 2 - n[0];
          const a = (r[1] + o[1]) / 2 - n[1];
          g = s * s + a * a > this.errorThresholdSquared_;
        }
        if (g) {
          if (Math.abs(t[0] - i[0]) <= Math.abs(t[1] - i[1])) {
            const h = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2],
              c = this.transformInv_(h),
              u = [(n[0] + t[0]) / 2, (n[1] + t[1]) / 2],
              d = this.transformInv_(u);
            this.addQuad_(t, e, h, u, r, s, c, d, l - 1),
              this.addQuad_(u, h, i, n, d, c, o, a, l - 1);
          } else {
            const h = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2],
              c = this.transformInv_(h),
              u = [(i[0] + n[0]) / 2, (i[1] + n[1]) / 2],
              d = this.transformInv_(u);
            this.addQuad_(t, h, u, n, r, c, d, a, l - 1),
              this.addQuad_(h, e, i, u, c, s, o, d, l - 1);
          }
          return;
        }
      }
      if (d) {
        if (!this.canWrapXInSource_) return;
        this.wrapsXInSource_ = !0;
      }
      0 == (11 & f) && this.addTriangle_(t, i, n, r, o, a),
        0 == (14 & f) && this.addTriangle_(t, i, e, r, o, s),
        f &&
          (0 == (13 & f) && this.addTriangle_(e, n, t, s, a, r),
          0 == (7 & f) && this.addTriangle_(e, n, i, s, a, o));
    }
    calculateSourceExtent() {
      const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      return (
        this.triangles_.forEach(function (e, i, n) {
          const r = e.source;
          ge(t, r[0]), ge(t, r[1]), ge(t, r[2]);
        }),
        t
      );
    }
    getTriangles() {
      return this.triangles_;
    }
  };
  let fg;
  const pg = [];
  function mg(t, e, i, n, r) {
    t.beginPath(),
      t.moveTo(0, 0),
      t.lineTo(e, i),
      t.lineTo(n, r),
      t.closePath(),
      t.save(),
      t.clip(),
      t.fillRect(0, 0, Math.max(e, n) + 1, Math.max(i, r)),
      t.restore();
  }
  function _g(t, e) {
    return Math.abs(t[4 * e] - 210) > 2 || Math.abs(t[4 * e + 3] - 191.25) > 2;
  }
  function yg(t, e, i, n) {
    const r = un(i, e, t);
    let s = en(e, n, i);
    const o = e.getMetersPerUnit();
    void 0 !== o && (s *= o);
    const a = t.getMetersPerUnit();
    void 0 !== a && (s /= a);
    const l = t.getExtent();
    if (!l || ee(l, r)) {
      const e = en(t, s, r) / s;
      isFinite(e) && e > 0 && (s /= e);
    }
    return s;
  }
  function xg(t, e, i, n) {
    const r = Ce(i);
    let s = yg(t, e, r, n);
    return (
      (!isFinite(s) || s <= 0) &&
        ye(i, function (i) {
          return (s = yg(t, e, i, n)), isFinite(s) && s > 0;
        }),
      s
    );
  }
  function vg(t, e, i, n, r, s, o, a, l, h, c, u) {
    const d = mt(Math.round(i * t), Math.round(i * e), pg);
    if ((u || (d.imageSmoothingEnabled = !1), 0 === l.length)) return d.canvas;
    function g(t) {
      return Math.round(t * i) / i;
    }
    d.scale(i, i), (d.globalCompositeOperation = "lighter");
    const f = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    l.forEach(function (t, e, i) {
      de(f, t.extent);
    });
    const p = Fe(f),
      m = Re(f),
      _ = mt(Math.round((i * p) / n), Math.round((i * m) / n), pg);
    u || (_.imageSmoothingEnabled = !1);
    const y = i / n;
    l.forEach(function (t, e, i) {
      const n = t.extent[0] - f[0],
        r = -(t.extent[3] - f[3]),
        s = Fe(t.extent),
        o = Re(t.extent);
      t.image.width > 0 &&
        t.image.height > 0 &&
        _.drawImage(
          t.image,
          h,
          h,
          t.image.width - 2 * h,
          t.image.height - 2 * h,
          n * y,
          r * y,
          s * y,
          o * y
        );
    });
    const x = Pe(o);
    return (
      a.getTriangles().forEach(function (t, e, r) {
        const o = t.source,
          a = t.target;
        let l = o[0][0],
          h = o[0][1],
          c = o[1][0],
          p = o[1][1],
          m = o[2][0],
          y = o[2][1];
        const v = g((a[0][0] - x[0]) / s),
          S = g(-(a[0][1] - x[1]) / s),
          C = g((a[1][0] - x[0]) / s),
          w = g(-(a[1][1] - x[1]) / s),
          W = g((a[2][0] - x[0]) / s),
          E = g(-(a[2][1] - x[1]) / s),
          R = l,
          T = h;
        (l = 0), (h = 0), (c -= R), (p -= T), (m -= R), (y -= T);
        const P = fi([
          [c, p, 0, 0, C - v],
          [m, y, 0, 0, W - v],
          [0, 0, c, p, w - S],
          [0, 0, m, y, E - S],
        ]);
        if (P) {
          if (
            (d.save(),
            d.beginPath(),
            (function () {
              if (void 0 === fg) {
                const t = mt(6, 6, pg);
                (t.globalCompositeOperation = "lighter"),
                  (t.fillStyle = "rgba(210, 0, 0, 0.75)"),
                  mg(t, 4, 5, 4, 0),
                  mg(t, 4, 5, 0, 5);
                const e = t.getImageData(0, 0, 3, 3).data;
                (fg = _g(e, 0) || _g(e, 4) || _g(e, 8)),
                  _t(t),
                  pg.push(t.canvas);
              }
              return fg;
            })() || !u)
          ) {
            d.moveTo(C, w);
            const t = 4,
              e = v - C,
              i = S - w;
            for (let n = 0; n < t; n++)
              d.lineTo(C + g(((n + 1) * e) / t), w + g((n * i) / (t - 1))),
                n != t - 1 &&
                  d.lineTo(
                    C + g(((n + 1) * e) / t),
                    w + g(((n + 1) * i) / (t - 1))
                  );
            d.lineTo(W, E);
          } else d.moveTo(C, w), d.lineTo(v, S), d.lineTo(W, E);
          d.clip(),
            d.transform(P[0], P[2], P[1], P[3], v, S),
            d.translate(f[0] - R, f[3] - T),
            d.scale(n / i, -n / i),
            d.drawImage(_.canvas, 0, 0),
            d.restore();
        }
      }),
      _t(_),
      pg.push(_.canvas),
      c &&
        (d.save(),
        (d.globalCompositeOperation = "source-over"),
        (d.strokeStyle = "black"),
        (d.lineWidth = 1),
        a.getTriangles().forEach(function (t, e, i) {
          const n = t.target,
            r = (n[0][0] - x[0]) / s,
            o = -(n[0][1] - x[1]) / s,
            a = (n[1][0] - x[0]) / s,
            l = -(n[1][1] - x[1]) / s,
            h = (n[2][0] - x[0]) / s,
            c = -(n[2][1] - x[1]) / s;
          d.beginPath(),
            d.moveTo(a, l),
            d.lineTo(r, o),
            d.lineTo(h, c),
            d.closePath(),
            d.stroke();
        }),
        d.restore()),
      d.canvas
    );
  }
  var Sg = class extends bt {
    constructor(t) {
      super({
        tileCoord: t.tileCoord,
        loader: () => Promise.resolve(new Uint8Array(4)),
        interpolate: t.interpolate,
        transition: t.transition,
      }),
        (this.pixelRatio_ = t.pixelRatio),
        (this.gutter_ = t.gutter),
        (this.reprojData_ = null),
        (this.reprojError_ = null),
        (this.reprojSize_ = void 0),
        (this.sourceTileGrid_ = t.sourceTileGrid),
        (this.targetTileGrid_ = t.targetTileGrid),
        (this.wrappedTileCoord_ = t.wrappedTileCoord || t.tileCoord),
        (this.sourceTiles_ = []),
        (this.sourcesListenerKeys_ = null),
        (this.sourceZ_ = 0);
      const e = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_),
        i = this.targetTileGrid_.getExtent();
      let n = this.sourceTileGrid_.getExtent();
      const r = i ? Te(e, i) : e;
      if (0 === xe(r)) return void (this.state = J);
      const s = t.sourceProj,
        o = s.getExtent();
      o && (n = n ? Te(n, o) : o);
      const a = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]),
        l = t.targetProj,
        h = xg(s, l, r, a);
      if (!isFinite(h) || h <= 0) return void (this.state = J);
      const c = void 0 !== t.errorThreshold ? t.errorThreshold : dg;
      if (
        ((this.triangulation_ = new gg(s, l, r, n, h * c, a)),
        0 === this.triangulation_.getTriangles().length)
      )
        return void (this.state = J);
      this.sourceZ_ = this.sourceTileGrid_.getZForResolution(h);
      let u = this.triangulation_.calculateSourceExtent();
      if (
        (n &&
          (s.canWrapX()
            ? ((u[1] = ui(u[1], n[1], n[3])), (u[3] = ui(u[3], n[1], n[3])))
            : (u = Te(u, n))),
        xe(u))
      ) {
        const e = this.sourceTileGrid_.getTileRangeForExtentAndZ(
            u,
            this.sourceZ_
          ),
          i = t.getTileFunction;
        for (let t = e.minX; t <= e.maxX; t++)
          for (let n = e.minY; n <= e.maxY; n++) {
            const e = i(this.sourceZ_, t, n, this.pixelRatio_);
            e && this.sourceTiles_.push(e);
          }
        0 === this.sourceTiles_.length && (this.state = J);
      } else this.state = J;
    }
    getSize() {
      return this.reprojSize_;
    }
    getData() {
      return this.reprojData_;
    }
    getError() {
      return this.reprojError_;
    }
    reproject_() {
      const t = [];
      if (
        (this.sourceTiles_.forEach((e) => {
          if (!e || e.getState() !== Q) return;
          const i = e.getSize(),
            n = this.gutter_;
          let r;
          const s = Et(e.getData());
          r = s || Tt(Wt(e.getData()));
          const o = [i[0] + 2 * n, i[1] + 2 * n],
            a = r instanceof Float32Array,
            l = o[0] * o[1],
            h = a ? Float32Array : Uint8Array,
            c = new h(r.buffer),
            u = h.BYTES_PER_ELEMENT,
            d = (u * c.length) / l,
            g = c.byteLength / o[1],
            f = Math.floor(g / u / o[0]),
            p = l * f;
          let m = c;
          if (c.length !== p) {
            m = new h(p);
            let t = 0,
              e = 0;
            const i = o[0] * f;
            for (let n = 0; n < o[1]; ++n) {
              for (let n = 0; n < i; ++n) m[t++] = c[e + n];
              e += g / u;
            }
          }
          t.push({
            extent: this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),
            data: new Uint8Array(m.buffer),
            dataType: h,
            bytesPerPixel: d,
            pixelSize: o,
          });
        }),
        (this.sourceTiles_.length = 0),
        0 === t.length)
      )
        this.state = $;
      else {
        const e = this.wrappedTileCoord_[0],
          i = this.targetTileGrid_.getTileSize(e),
          n = "number" == typeof i ? i : i[0],
          r = "number" == typeof i ? i : i[1],
          s = this.targetTileGrid_.getResolution(e),
          o = this.sourceTileGrid_.getResolution(this.sourceZ_),
          a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        let l, h;
        const c = t[0].bytesPerPixel;
        for (let e = Math.ceil(c / 3) - 1; e >= 0; --e) {
          const i = [];
          for (let n = 0, r = t.length; n < r; ++n) {
            const r = t[n],
              s = r.data,
              o = r.pixelSize,
              a = o[0],
              l = o[1],
              h = mt(a, l, pg),
              u = h.createImageData(a, l),
              d = u.data;
            let g = 3 * e;
            for (let t = 0, e = d.length; t < e; t += 4)
              (d[t] = s[g]),
                (d[t + 1] = s[g + 1]),
                (d[t + 2] = s[g + 2]),
                (d[t + 3] = 255),
                (g += c);
            h.putImageData(u, 0, 0),
              i.push({ extent: r.extent, image: h.canvas });
          }
          const u = vg(
            n,
            r,
            this.pixelRatio_,
            o,
            this.sourceTileGrid_.getExtent(),
            s,
            a,
            this.triangulation_,
            i,
            this.gutter_,
            !1,
            !1
          );
          for (let t = 0, e = i.length; t < e; ++t) {
            const e = i[t].image.getContext("2d");
            _t(e), pg.push(e.canvas);
          }
          const d = u.getContext("2d"),
            g = d.getImageData(0, 0, u.width, u.height);
          _t(d),
            pg.push(u),
            l ||
              ((h = new Uint8Array(c * g.width * g.height)),
              (l = new t[0].dataType(h.buffer)));
          const f = g.data;
          let p = 3 * e;
          for (let t = 0, e = f.length; t < e; t += 4)
            255 === f[t + 3]
              ? ((h[p] = f[t]), (h[p + 1] = f[t + 1]), (h[p + 2] = f[t + 2]))
              : ((h[p] = 0), (h[p + 1] = 0), (h[p + 2] = 0)),
              (p += c);
        }
        (this.reprojData_ = l),
          (this.reprojSize_ = [
            Math.round(n * this.pixelRatio_),
            Math.round(r * this.pixelRatio_),
          ]),
          (this.state = Q);
      }
      this.changed();
    }
    load() {
      if (this.state !== H && this.state !== $) return;
      (this.state = Y), this.changed();
      let t = 0;
      (this.sourcesListenerKeys_ = []),
        this.sourceTiles_.forEach((e) => {
          const i = e.getState();
          if (i !== H && i !== Y) return;
          t++;
          const n = M(
            e,
            v,
            function () {
              const i = e.getState();
              (i != Q && i != $ && i != J) ||
                (k(n),
                t--,
                0 === t && (this.unlistenSources_(), this.reproject_()));
            },
            this
          );
          this.sourcesListenerKeys_.push(n);
        }),
        0 === t
          ? setTimeout(this.reproject_.bind(this), 0)
          : this.sourceTiles_.forEach(function (t) {
              t.getState() == H && t.load();
            });
    }
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(k), (this.sourcesListenerKeys_ = null);
    }
  };
  var Cg = class extends rt {
    constructor(t, e, i, n, r, s, o, a, l, h, c, u) {
      super(r, H, { interpolate: !!u }),
        (this.renderEdges_ = void 0 !== c && c),
        (this.pixelRatio_ = o),
        (this.gutter_ = a),
        (this.canvas_ = null),
        (this.sourceTileGrid_ = e),
        (this.targetTileGrid_ = n),
        (this.wrappedTileCoord_ = s || r),
        (this.sourceTiles_ = []),
        (this.sourcesListenerKeys_ = null),
        (this.sourceZ_ = 0);
      const d = n.getTileCoordExtent(this.wrappedTileCoord_),
        g = this.targetTileGrid_.getExtent();
      let f = this.sourceTileGrid_.getExtent();
      const p = g ? Te(d, g) : d;
      if (0 === xe(p)) return void (this.state = J);
      const m = t.getExtent();
      m && (f = f ? Te(f, m) : m);
      const _ = n.getResolution(this.wrappedTileCoord_[0]),
        y = xg(t, i, p, _);
      if (!isFinite(y) || y <= 0) return void (this.state = J);
      const x = void 0 !== h ? h : dg;
      if (
        ((this.triangulation_ = new gg(t, i, p, f, y * x, _)),
        0 === this.triangulation_.getTriangles().length)
      )
        return void (this.state = J);
      this.sourceZ_ = e.getZForResolution(y);
      let v = this.triangulation_.calculateSourceExtent();
      if (
        (f &&
          (t.canWrapX()
            ? ((v[1] = ui(v[1], f[1], f[3])), (v[3] = ui(v[3], f[1], f[3])))
            : (v = Te(v, f))),
        xe(v))
      ) {
        const t = e.getTileRangeForExtentAndZ(v, this.sourceZ_);
        for (let e = t.minX; e <= t.maxX; e++)
          for (let i = t.minY; i <= t.maxY; i++) {
            const t = l(this.sourceZ_, e, i, o);
            t && this.sourceTiles_.push(t);
          }
        0 === this.sourceTiles_.length && (this.state = J);
      } else this.state = J;
    }
    getImage() {
      return this.canvas_;
    }
    reproject_() {
      const t = [];
      if (
        (this.sourceTiles_.forEach((e) => {
          e &&
            e.getState() == Q &&
            t.push({
              extent: this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),
              image: e.getImage(),
            });
        }),
        (this.sourceTiles_.length = 0),
        0 === t.length)
      )
        this.state = $;
      else {
        const e = this.wrappedTileCoord_[0],
          i = this.targetTileGrid_.getTileSize(e),
          n = "number" == typeof i ? i : i[0],
          r = "number" == typeof i ? i : i[1],
          s = this.targetTileGrid_.getResolution(e),
          o = this.sourceTileGrid_.getResolution(this.sourceZ_),
          a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        (this.canvas_ = vg(
          n,
          r,
          this.pixelRatio_,
          o,
          this.sourceTileGrid_.getExtent(),
          s,
          a,
          this.triangulation_,
          t,
          this.gutter_,
          this.renderEdges_,
          this.interpolate
        )),
          (this.state = Q);
      }
      this.changed();
    }
    load() {
      if (this.state == H) {
        (this.state = Y), this.changed();
        let t = 0;
        (this.sourcesListenerKeys_ = []),
          this.sourceTiles_.forEach((e) => {
            const i = e.getState();
            if (i == H || i == Y) {
              t++;
              const i = M(
                e,
                v,
                function (n) {
                  const r = e.getState();
                  (r != Q && r != $ && r != J) ||
                    (k(i),
                    t--,
                    0 === t && (this.unlistenSources_(), this.reproject_()));
                },
                this
              );
              this.sourcesListenerKeys_.push(i);
            }
          }),
          0 === t
            ? setTimeout(this.reproject_.bind(this), 0)
            : this.sourceTiles_.forEach(function (t, e, i) {
                t.getState() == H && t.load();
              });
      }
    }
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(k), (this.sourcesListenerKeys_ = null);
    }
    release() {
      this.canvas_ &&
        (_t(this.canvas_.getContext("2d")),
        pg.push(this.canvas_),
        (this.canvas_ = null)),
        super.release();
    }
  };
  var wg = class extends x {
    constructor(t) {
      super(),
        this.tile,
        (this.handleTileChange_ = this.handleTileChange_.bind(this)),
        (this.gutter_ = t.gutter || 0),
        (this.helper_ = t.helper),
        (this.loaded = !1),
        (this.ready = !1);
    }
    setTile(t) {
      if (t !== this.tile)
        if (
          (this.tile &&
            this.tile.removeEventListener(v, this.handleTileChange_),
          (this.tile = t),
          (this.loaded = t.getState() === Q),
          this.loaded)
        )
          this.uploadTile();
        else {
          if (t instanceof is) {
            const e = t.getImage();
            e instanceof Image &&
              !e.crossOrigin &&
              (e.crossOrigin = "anonymous");
          }
          t.addEventListener(v, this.handleTileChange_);
        }
    }
    uploadTile() {
      G();
    }
    setReady() {
      (this.ready = !0), this.dispatchEvent(v);
    }
    handleTileChange_() {
      this.tile.getState() === Q && ((this.loaded = !0), this.uploadTile());
    }
    disposeInternal() {
      this.tile.removeEventListener(v, this.handleTileChange_);
    }
  };
  function Wg(t, e, i) {
    const n = i ? t.LINEAR : t.NEAREST;
    t.bindTexture(t.TEXTURE_2D, e),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n);
  }
  function Eg(t, e, i, n, r, s) {
    const o = t.getGL();
    let a, l;
    if (i instanceof Float32Array) {
      (a = o.FLOAT), t.getExtension("OES_texture_float");
      l = null !== t.getExtension("OES_texture_float_linear");
    } else (a = o.UNSIGNED_BYTE), (l = !0);
    Wg(o, e, s && l);
    const h = i.byteLength / n[1];
    let c,
      u = 1;
    switch (
      (h % 8 == 0 ? (u = 8) : h % 4 == 0 ? (u = 4) : h % 2 == 0 && (u = 2), r)
    ) {
      case 1:
        c = o.LUMINANCE;
        break;
      case 2:
        c = o.LUMINANCE_ALPHA;
        break;
      case 3:
        c = o.RGB;
        break;
      case 4:
        c = o.RGBA;
        break;
      default:
        throw new Error(`Unsupported number of bands: ${r}`);
    }
    const d = o.getParameter(o.UNPACK_ALIGNMENT);
    o.pixelStorei(o.UNPACK_ALIGNMENT, u),
      o.texImage2D(o.TEXTURE_2D, 0, c, n[0], n[1], 0, c, a, i),
      o.pixelStorei(o.UNPACK_ALIGNMENT, d);
  }
  let Rg = null;
  var Tg = class extends wg {
    constructor(t) {
      super(t),
        (this.textures = []),
        (this.renderSize_ = sl(t.grid.getTileSize(t.tile.tileCoord[0]))),
        (this.bandCount = NaN);
      const e = new ld($u, td);
      e.fromArray([0, 1, 1, 1, 1, 0, 0, 0]),
        this.helper_.flushBufferData(e),
        (this.coords = e),
        this.setTile(t.tile);
    }
    uploadTile() {
      const t = this.helper_,
        e = t.getGL(),
        i = this.tile;
      let n;
      (this.textures.length = 0),
        (n = i instanceof is || i instanceof Cg ? i.getImage() : i.getData());
      const r = Wt(n);
      if (r) {
        const t = e.createTexture();
        return (
          this.textures.push(t),
          (this.bandCount = 4),
          (function (t, e, i, n) {
            Wg(t, e, n),
              t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, i);
          })(e, t, r, i.interpolate),
          void this.setReady()
        );
      }
      n = Et(n);
      const s = i.getSize(),
        o = [s[0] + 2 * this.gutter_, s[1] + 2 * this.gutter_],
        a = n instanceof Float32Array,
        l = o[0] * o[1],
        h = a ? Float32Array : Uint8Array,
        c = h.BYTES_PER_ELEMENT,
        u = n.byteLength / o[1];
      this.bandCount = Math.floor(u / c / o[0]);
      const d = Math.ceil(this.bandCount / 4);
      if (1 === d) {
        const r = e.createTexture();
        return (
          this.textures.push(r),
          Eg(t, r, n, o, this.bandCount, i.interpolate),
          void this.setReady()
        );
      }
      const g = new Array(d);
      for (let t = 0; t < d; ++t) {
        const i = e.createTexture();
        this.textures.push(i);
        const n = t < d - 1 ? 4 : ((this.bandCount - 1) % 4) + 1;
        g[t] = new h(l * n);
      }
      let f = 0,
        p = 0;
      const m = o[0] * this.bandCount;
      for (let t = 0; t < o[1]; ++t) {
        for (let t = 0; t < m; ++t) {
          const e = n[p + t],
            i = Math.floor(f / this.bandCount),
            r = t % this.bandCount,
            s = g[Math.floor(r / 4)];
          (s[i * (s.length / l) + (r % 4)] = e), ++f;
        }
        p += u / c;
      }
      for (let e = 0; e < d; ++e) {
        const n = this.textures[e],
          r = g[e];
        Eg(t, n, r, o, r.length / l, i.interpolate);
      }
      this.setReady();
    }
    disposeInternal() {
      const t = this.helper_.getGL();
      this.helper_.deleteBuffer(this.coords);
      for (let e = 0; e < this.textures.length; ++e)
        t.deleteTexture(this.textures[e]);
      this.tile.removeEventListener(v, this.handleTileChange_);
    }
    getImagePixelData_(t, e, i) {
      const n = this.gutter_,
        r = this.renderSize_[0],
        s = this.renderSize_[1];
      Rg || (Rg = mt(1, 1, void 0, { willReadFrequently: !0 })),
        Rg.clearRect(0, 0, 1, 1);
      const o = t.width - 2 * n,
        a = t.height - 2 * n,
        l = n + Math.floor(o * (e / r)),
        h = n + Math.floor(a * (i / s));
      let c;
      try {
        Rg.drawImage(t, l, h, 1, 1, 0, 0, 1, 1),
          (c = Rg.getImageData(0, 0, 1, 1).data);
      } catch (t) {
        return (Rg = null), null;
      }
      return c;
    }
    getArrayPixelData_(t, e, i, n) {
      const r = this.gutter_,
        s = this.renderSize_[0],
        o = this.renderSize_[1],
        a = e[0],
        l = e[1],
        h = a + 2 * r,
        c = l + 2 * r,
        u = r + Math.floor(a * (i / s)),
        d = r + Math.floor(l * (n / o));
      if (t instanceof DataView) {
        const e = t.byteLength / (h * c),
          i = e * (d * h + u),
          n = t.buffer.slice(i, i + e);
        return new DataView(n);
      }
      const g = this.bandCount * (d * h + u);
      return t.slice(g, g + this.bandCount);
    }
    getPixelData(t, e) {
      if (!this.loaded) return null;
      if (this.tile instanceof bt) {
        const i = this.tile.getData(),
          n = Et(i);
        if (n) {
          const i = this.tile.getSize();
          return this.getArrayPixelData_(n, i, t, e);
        }
        return this.getImagePixelData_(Wt(i), t, e);
      }
      return this.getImagePixelData_(this.tile.getImage(), t, e);
    }
  };
  var Pg = class {
    constructor(t) {
      (this.highWaterMark = void 0 !== t ? t : 2048),
        (this.count_ = 0),
        (this.entries_ = {}),
        (this.oldest_ = null),
        (this.newest_ = null);
    }
    canExpireCache() {
      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }
    expireCache(t) {
      for (; this.canExpireCache(); ) this.pop();
    }
    clear() {
      (this.count_ = 0),
        (this.entries_ = {}),
        (this.oldest_ = null),
        (this.newest_ = null);
    }
    containsKey(t) {
      return this.entries_.hasOwnProperty(t);
    }
    forEach(t) {
      let e = this.oldest_;
      for (; e; ) t(e.value_, e.key_, this), (e = e.newer);
    }
    get(t, e) {
      const i = this.entries_[t];
      return (
        Ft(
          void 0 !== i,
          "Tried to get a value for a key that does not exist in the cache"
        ),
        i === this.newest_ ||
          (i === this.oldest_
            ? ((this.oldest_ = this.oldest_.newer), (this.oldest_.older = null))
            : ((i.newer.older = i.older), (i.older.newer = i.newer)),
          (i.newer = null),
          (i.older = this.newest_),
          (this.newest_.newer = i),
          (this.newest_ = i)),
        i.value_
      );
    }
    remove(t) {
      const e = this.entries_[t];
      return (
        Ft(
          void 0 !== e,
          "Tried to get a value for a key that does not exist in the cache"
        ),
        e === this.newest_
          ? ((this.newest_ = e.older),
            this.newest_ && (this.newest_.newer = null))
          : e === this.oldest_
          ? ((this.oldest_ = e.newer),
            this.oldest_ && (this.oldest_.older = null))
          : ((e.newer.older = e.older), (e.older.newer = e.newer)),
        delete this.entries_[t],
        --this.count_,
        e.value_
      );
    }
    getCount() {
      return this.count_;
    }
    getKeys() {
      const t = new Array(this.count_);
      let e,
        i = 0;
      for (e = this.newest_; e; e = e.older) t[i++] = e.key_;
      return t;
    }
    getValues() {
      const t = new Array(this.count_);
      let e,
        i = 0;
      for (e = this.newest_; e; e = e.older) t[i++] = e.value_;
      return t;
    }
    peekLast() {
      return this.oldest_.value_;
    }
    peekLastKey() {
      return this.oldest_.key_;
    }
    peekFirstKey() {
      return this.newest_.key_;
    }
    peek(t) {
      if (this.containsKey(t)) return this.entries_[t].value_;
    }
    pop() {
      const t = this.oldest_;
      return (
        delete this.entries_[t.key_],
        t.newer && (t.newer.older = null),
        (this.oldest_ = t.newer),
        this.oldest_ || (this.newest_ = null),
        --this.count_,
        t.value_
      );
    }
    replace(t, e) {
      this.get(t), (this.entries_[t].value_ = e);
    }
    set(t, e) {
      Ft(
        !(t in this.entries_),
        "Tried to set a value for a key that is used already"
      );
      const i = { key_: t, newer: null, older: this.newest_, value_: e };
      this.newest_ ? (this.newest_.newer = i) : (this.oldest_ = i),
        (this.newest_ = i),
        (this.entries_[t] = i),
        ++this.count_;
    }
    setSize(t) {
      this.highWaterMark = t;
    }
  };
  class bg {
    constructor(t, e, i, n) {
      (this.minX = t), (this.maxX = e), (this.minY = i), (this.maxY = n);
    }
    contains(t) {
      return this.containsXY(t[1], t[2]);
    }
    containsTileRange(t) {
      return (
        this.minX <= t.minX &&
        t.maxX <= this.maxX &&
        this.minY <= t.minY &&
        t.maxY <= this.maxY
      );
    }
    containsXY(t, e) {
      return (
        this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY
      );
    }
    equals(t) {
      return (
        this.minX == t.minX &&
        this.minY == t.minY &&
        this.maxX == t.maxX &&
        this.maxY == t.maxY
      );
    }
    extend(t) {
      t.minX < this.minX && (this.minX = t.minX),
        t.maxX > this.maxX && (this.maxX = t.maxX),
        t.minY < this.minY && (this.minY = t.minY),
        t.maxY > this.maxY && (this.maxY = t.maxY);
    }
    getHeight() {
      return this.maxY - this.minY + 1;
    }
    getSize() {
      return [this.getWidth(), this.getHeight()];
    }
    getWidth() {
      return this.maxX - this.minX + 1;
    }
    intersects(t) {
      return (
        this.minX <= t.maxX &&
        this.maxX >= t.minX &&
        this.minY <= t.maxY &&
        this.maxY >= t.minY
      );
    }
  }
  function Fg(t, e, i, n, r) {
    return void 0 !== r
      ? ((r.minX = t), (r.maxX = e), (r.minY = i), (r.maxY = n), r)
      : new bg(t, e, i, n);
  }
  var Ig = bg;
  function Lg(t, e, i, n) {
    return void 0 !== n ? ((n[0] = t), (n[1] = e), (n[2] = i), n) : [t, e, i];
  }
  function Mg(t, e, i) {
    return t + "/" + e + "/" + i;
  }
  function Og(t) {
    return Mg(t[0], t[1], t[2]);
  }
  function kg(t) {
    const [e, i, n] = t
      .substring(t.lastIndexOf("/") + 1, t.length)
      .split(",")
      .map(Number);
    return Mg(e, i, n);
  }
  function Ag(t) {
    return t.split("/").map(Number);
  }
  function Ng(t) {
    return (t[1] << t[0]) + t[2];
  }
  function Dg(t, e) {
    const i = t[0],
      n = t[1],
      r = t[2];
    if (e.getMinZoom() > i || i > e.getMaxZoom()) return !1;
    const s = e.getFullTileRange(i);
    return !s || s.containsXY(n, r);
  }
  const Gg = {
      TILE_TRANSFORM: "u_tileTransform",
      TRANSITION_ALPHA: "u_transitionAlpha",
      DEPTH: "u_depth",
      RENDER_EXTENT: "u_renderExtent",
      RESOLUTION: "u_resolution",
      ZOOM: "u_zoom",
      GLOBAL_ALPHA: "u_globalAlpha",
      PROJECTION_MATRIX: "u_projectionMatrix",
      SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix",
    },
    Bg = {};
  function jg() {
    return { tileIds: new Set(), representationsByZ: {} };
  }
  function zg(t, e) {
    return t.tileIds.has(j(e));
  }
  function Ug(t, e, i) {
    const n = t.representationsByZ;
    i in n || (n[i] = new Set()), n[i].add(e), t.tileIds.add(j(e.tile));
  }
  function qg(t, e) {
    const i = t.layerStatesArray[t.layerIndex];
    i.extent && (e = Te(e, xn(i.extent, t.viewState.projection)));
    const n = i.layer.getRenderSource();
    if (!n.getWrapX()) {
      const i = n.getTileGridForProjection(t.viewState.projection).getExtent();
      i && (e = Te(e, i));
    }
    return e;
  }
  function Vg(t, e) {
    return `${t.getKey()},${Og(e)}`;
  }
  var Xg = class extends wd {
    constructor(t, e) {
      super(t, { uniforms: e.uniforms, postProcesses: e.postProcesses }),
        (this.renderComplete = !1),
        (this.tileTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.tempMat4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        (this.tempTileRange_ = new Ig(0, 0, 0, 0)),
        (this.tempTileCoord_ = Lg(0, 0, 0)),
        (this.tempSize_ = [0, 0]);
      const i = void 0 !== e.cacheSize ? e.cacheSize : 512;
      (this.tileRepresentationCache = new Pg(i)),
        (this.frameState = null),
        (this.projection_ = void 0);
    }
    reset(t) {
      super.reset({ uniforms: t.uniforms });
    }
    isDrawableTile_(t) {
      const e = this.getLayer(),
        i = t.getState(),
        n = e.getUseInterimTilesOnError();
      return i == Q || i == J || (i == $ && !n);
    }
    prepareFrameInternal(t) {
      this.projection_
        ? t.viewState.projection !== this.projection_ &&
          (this.clearCache(), (this.projection_ = t.viewState.projection))
        : (this.projection_ = t.viewState.projection);
      const e = this.getLayer().getRenderSource();
      return !!e && !Le(qg(t, t.extent)) && "ready" === e.getState();
    }
    createTileRepresentation(t) {
      return G();
    }
    enqueueTiles(t, e, i, n, r) {
      const s = t.viewState,
        o = this.getLayer(),
        a = o.getRenderSource(),
        l = a.getTileGridForProjection(s.projection),
        h = a.getGutterForProjection(s.projection),
        c = j(a);
      c in t.wantedTiles || (t.wantedTiles[c] = {});
      const u = t.wantedTiles[c],
        d = this.tileRepresentationCache,
        g = o.getMapInternal(),
        f = Math.max(
          i - r,
          l.getMinZoom(),
          l.getZForResolution(
            Math.min(
              o.getMaxResolution(),
              g
                ? g.getView().getResolutionForZoom(Math.max(o.getMinZoom(), 0))
                : l.getResolution(0)
            ),
            a.zDirection
          )
        );
      for (let r = i; r >= f; --r) {
        const i = l.getTileRangeForExtentAndZ(e, r, this.tempTileRange_),
          o = l.getResolution(r);
        for (let e = i.minX; e <= i.maxX; ++e)
          for (let g = i.minY; g <= i.maxY; ++g) {
            const i = Lg(r, e, g, this.tempTileCoord_),
              f = Vg(a, i);
            let p, m;
            if (
              (d.containsKey(f) && ((p = d.get(f)), (m = p.tile)),
              (p && p.tile.key === a.getKey()) ||
                (m = a.getTile(r, e, g, t.pixelRatio, s.projection)),
              zg(n, m))
            )
              continue;
            if (p)
              if (this.isDrawableTile_(m)) p.setTile(m);
              else {
                const t = m.getInterimTile();
                p.setTile(t);
              }
            else
              (p = this.createTileRepresentation({
                tile: m,
                grid: l,
                helper: this.helper,
                gutter: h,
              })),
                d.set(f, p);
            Ug(n, p, r);
            const _ = m.getKey();
            (u[_] = !0),
              m.getState() === H &&
                (t.tileQueue.isKeyQueued(_) ||
                  t.tileQueue.enqueue([m, c, l.getTileCoordCenter(i), o]));
          }
      }
    }
    beforeTilesRender(t, e) {
      this.helper.prepareDraw(this.frameState, !e, !0);
    }
    renderTile(t, e, i, n, r, s, o, a, l, h, c) {}
    drawTile_(t, e, i, n, r, s, o) {
      if (!e.loaded) return;
      const a = e.tile.tileCoord,
        l = Og(a),
        h = l in s ? s[l] : 1,
        c = o.getResolution(i),
        u = sl(o.getTileSize(i), this.tempSize_),
        d = o.getOrigin(i),
        g = o.getTileCoordExtent(a),
        f = h < 1 ? -1 : 1 / (i + 2);
      h < 1 && (t.animate = !0);
      const p = t.viewState,
        m = p.center[0],
        _ = p.center[1],
        y = u[0] + 2 * n,
        x = u[1] + 2 * n,
        v = y / x,
        S = (m - d[0]) / (u[0] * c),
        C = (d[1] - _) / (u[1] * c),
        w = p.resolution / c,
        W = a[1],
        E = a[2];
      At(this.tileTransform_),
        zt(
          this.tileTransform_,
          2 / ((t.size[0] * w) / y),
          -2 / ((t.size[1] * w) / y)
        ),
        jt(this.tileTransform_, p.rotation),
        zt(this.tileTransform_, 1, 1 / v),
        qt(
          this.tileTransform_,
          (u[0] * (W - S) - n) / y,
          (u[1] * (E - C) - n) / x
        ),
        this.renderTile(e, this.tileTransform_, t, r, c, u, d, g, f, n, h);
    }
    renderFrame(t) {
      (this.frameState = t), (this.renderComplete = !0);
      const e = this.helper.getGL();
      this.preRender(e, t);
      const i = t.viewState,
        n = this.getLayer(),
        r = n.getRenderSource(),
        s = r.getTileGridForProjection(i.projection),
        a = r.getGutterForProjection(i.projection),
        l = qg(t, t.extent),
        h = s.getZForResolution(i.resolution, r.zDirection),
        c = jg(),
        u = n.getPreload();
      if (t.nextExtent) {
        const e = s.getZForResolution(i.nextResolution, r.zDirection),
          n = qg(t, t.nextExtent);
        this.enqueueTiles(t, n, e, c, u);
      }
      this.enqueueTiles(t, l, h, c, 0),
        u > 0 &&
          setTimeout(() => {
            this.enqueueTiles(t, l, h - 1, c, u - 1);
          }, 0);
      const d = {},
        g = j(this),
        f = t.time;
      let p = !1;
      for (const t of c.representationsByZ[h]) {
        const e = t.tile;
        if ((e instanceof Cg || e instanceof Sg) && e.getState() === J)
          continue;
        const i = e.tileCoord;
        if (t.loaded) {
          const t = e.getAlpha(g, f);
          if (1 === t) {
            e.endTransition(g);
            continue;
          }
          p = !0;
          d[Og(i)] = t;
        }
        this.renderComplete = !1;
        if (this.findAltTiles_(s, i, h + 1, c)) continue;
        const n = s.getMinZoom();
        for (let t = h - 1; t >= n; --t) {
          if (this.findAltTiles_(s, i, t, c)) break;
        }
      }
      this.beforeTilesRender(t, p);
      const m = c.representationsByZ,
        _ = Object.keys(m).map(Number).sort(o);
      for (let e = 0, i = _.length; e < i; ++e) {
        const i = _[e];
        for (const e of m[i]) {
          Og(e.tile.tileCoord) in d || this.drawTile_(t, e, i, a, l, d, s);
        }
      }
      for (const e of m[h]) {
        Og(e.tile.tileCoord) in d && this.drawTile_(t, e, h, a, l, d, s);
      }
      this.helper.finalizeDraw(
        t,
        this.dispatchPreComposeEvent,
        this.dispatchPostComposeEvent
      );
      const y = this.helper.getCanvas(),
        x = this.tileRepresentationCache;
      for (; x.canExpireCache(); ) {
        x.pop().dispose();
      }
      return (
        t.postRenderFunctions.push(function (t, e) {
          r.updateCacheSize(0.1, e.viewState.projection),
            r.expireCache(e.viewState.projection, Bg);
        }),
        this.postRender(e, t),
        y
      );
    }
    findAltTiles_(t, e, i, n) {
      const r = t.getTileRangeForTileCoordAndZ(e, i, this.tempTileRange_);
      if (!r) return !1;
      let s = !0;
      const o = this.tileRepresentationCache,
        a = this.getLayer().getRenderSource();
      for (let t = r.minX; t <= r.maxX; ++t)
        for (let e = r.minY; e <= r.maxY; ++e) {
          const r = Vg(a, [i, t, e]);
          let l = !1;
          if (o.containsKey(r)) {
            const t = o.get(r);
            t.loaded && !zg(n, t.tile) && (Ug(n, t, i), (l = !0));
          }
          l || (s = !1);
        }
      return s;
    }
    clearCache() {
      const t = this.tileRepresentationCache;
      t.forEach((t) => t.dispose()), t.clear();
    }
    removeHelper() {
      this.helper && this.clearCache(), super.removeHelper();
    }
    disposeInternal() {
      super.disposeInternal(), delete this.frameState;
    }
  };
  const Zg = {
      ...Gg,
      TILE_TEXTURE_ARRAY: "u_tileTextures",
      TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
      TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
      TEXTURE_RESOLUTION: "u_textureResolution",
      TEXTURE_ORIGIN_X: "u_textureOriginX",
      TEXTURE_ORIGIN_Y: "u_textureOriginY",
    },
    Kg = { TEXTURE_COORD: "a_textureCoord" },
    Hg = [{ name: Kg.TEXTURE_COORD, size: 2, type: pd.FLOAT }];
  var Yg = class extends Xg {
    constructor(t, e) {
      super(t, e),
        this.program_,
        (this.vertexShader_ = e.vertexShader),
        (this.fragmentShader_ = e.fragmentShader),
        (this.indices_ = new ld(Ju, td)),
        this.indices_.fromArray([0, 1, 3, 1, 2, 3]),
        (this.paletteTextures_ = e.paletteTextures || []);
    }
    reset(t) {
      super.reset(t),
        (this.vertexShader_ = t.vertexShader),
        (this.fragmentShader_ = t.fragmentShader),
        this.helper &&
          (this.program_ = this.helper.getProgram(
            this.fragmentShader_,
            this.vertexShader_
          ));
    }
    afterHelperCreated() {
      (this.program_ = this.helper.getProgram(
        this.fragmentShader_,
        this.vertexShader_
      )),
        this.helper.flushBufferData(this.indices_);
    }
    createTileRepresentation(t) {
      return new Tg(t);
    }
    beforeTilesRender(t, e) {
      super.beforeTilesRender(t, e), this.helper.useProgram(this.program_, t);
    }
    renderTile(t, e, i, n, r, s, o, a, l, h, c) {
      const u = this.helper.getGL();
      this.helper.bindBuffer(t.coords),
        this.helper.bindBuffer(this.indices_),
        this.helper.enableAttributes(Hg);
      let d = 0;
      for (; d < t.textures.length; ) {
        const e = `${Zg.TILE_TEXTURE_ARRAY}[${d}]`;
        this.helper.bindTexture(t.textures[d], d, e), ++d;
      }
      for (let t = 0; t < this.paletteTextures_.length; ++t) {
        const e = this.paletteTextures_[t],
          i = e.getTexture(u);
        this.helper.bindTexture(i, d, e.name), ++d;
      }
      const g = i.viewState,
        f = s[0] + 2 * h,
        p = s[1] + 2 * h,
        m = t.tile.tileCoord,
        _ = m[1],
        y = m[2];
      this.helper.setUniformMatrixValue(
        Zg.TILE_TRANSFORM,
        gd(this.tempMat4, e)
      ),
        this.helper.setUniformFloatValue(Zg.TRANSITION_ALPHA, c),
        this.helper.setUniformFloatValue(Zg.DEPTH, l);
      let x = n;
      h > 0 && ((x = a), Te(x, n, x)),
        this.helper.setUniformFloatVec4(Zg.RENDER_EXTENT, x),
        this.helper.setUniformFloatValue(Zg.RESOLUTION, g.resolution),
        this.helper.setUniformFloatValue(Zg.ZOOM, g.zoom),
        this.helper.setUniformFloatValue(Zg.TEXTURE_PIXEL_WIDTH, f),
        this.helper.setUniformFloatValue(Zg.TEXTURE_PIXEL_HEIGHT, p),
        this.helper.setUniformFloatValue(Zg.TEXTURE_RESOLUTION, r),
        this.helper.setUniformFloatValue(
          Zg.TEXTURE_ORIGIN_X,
          o[0] + _ * s[0] * r - h * r
        ),
        this.helper.setUniformFloatValue(
          Zg.TEXTURE_ORIGIN_Y,
          o[1] - y * s[1] * r + h * r
        ),
        this.helper.drawElements(0, this.indices_.getSize());
    }
    getData(t) {
      if (!this.helper.getGL()) return null;
      const e = this.frameState;
      if (!e) return null;
      const i = this.getLayer(),
        n = Bt(e.pixelToCoordinateTransform, t.slice()),
        r = e.viewState,
        s = i.getExtent();
      if (s && !ee(xn(s, r.projection), n)) return null;
      const o = i.getSources(Qt([n]), r.resolution);
      let a, l, h;
      for (a = o.length - 1; a >= 0; --a)
        if (((l = o[a]), "ready" === l.getState())) {
          if (((h = l.getTileGridForProjection(r.projection)), l.getWrapX()))
            break;
          const t = h.getExtent();
          if (!t || ee(t, n)) break;
        }
      if (a < 0) return null;
      const c = this.tileRepresentationCache;
      for (
        let t = h.getZForResolution(r.resolution);
        t >= h.getMinZoom();
        --t
      ) {
        const e = h.getTileCoordForCoordAndZ(n, t),
          i = Vg(l, e);
        if (!c.containsKey(i)) continue;
        const r = c.get(i),
          s = r.tile;
        if ((s instanceof Cg || s instanceof Sg) && s.getState() === J)
          return null;
        if (!r.loaded) continue;
        const o = h.getOrigin(t),
          a = sl(h.getTileSize(t)),
          u = h.getResolution(t),
          d = (n[0] - o[0]) / u - e[1] * a[0],
          g = (o[1] - n[1]) / u - e[2] * a[1];
        return r.getPixelData(d, g);
      }
      return null;
    }
    disposeInternal() {
      const t = this.helper;
      if (t) {
        t.getGL().deleteProgram(this.program_),
          delete this.program_,
          t.deleteBuffer(this.indices_);
      }
      super.disposeInternal(), delete this.indices_;
    }
  };
  const Qg = {
    NUMBER: 1,
    STRING: 2,
    COLOR: 4,
    BOOLEAN: 8,
    NUMBER_ARRAY: 16,
    ANY: 31,
    NONE: 0,
  };
  const $g = {};
  function Jg(t) {
    if ("number" == typeof t) return Qg.NUMBER;
    if ("boolean" == typeof t) return Qg.BOOLEAN;
    if ("string" == typeof t) return ds(t) ? Qg.COLOR | Qg.STRING : Qg.STRING;
    if (!Array.isArray(t))
      throw new Error(`Unhandled value type: ${JSON.stringify(t)}`);
    const e = t;
    if (
      e.every(function (t) {
        return "number" == typeof t;
      })
    )
      return 3 === e.length || 4 === e.length
        ? Qg.COLOR | Qg.NUMBER_ARRAY
        : Qg.NUMBER_ARRAY;
    if ("string" != typeof e[0])
      throw new Error(
        `Expected an expression operator but received: ${JSON.stringify(e)}`
      );
    const i = $g[e[0]];
    if (void 0 === i)
      throw new Error(`Unrecognized expression operator: ${JSON.stringify(e)}`);
    return i.getReturnType(e.slice(1));
  }
  function tf(t) {
    return Math.log2(t) % 1 == 0;
  }
  function ef(t) {
    const e = [];
    return (
      (t & Qg.NUMBER) > 0 && e.push("number"),
      (t & Qg.COLOR) > 0 && e.push("color"),
      (t & Qg.BOOLEAN) > 0 && e.push("boolean"),
      (t & Qg.NUMBER_ARRAY) > 0 && e.push("number[]"),
      (t & Qg.STRING) > 0 && e.push("string"),
      e.length > 0 ? e.join(", ") : "(no type)"
    );
  }
  function nf(t) {
    const e = t.toString();
    return e.includes(".") ? e : e + ".0";
  }
  function rf(t) {
    if (t.length < 2 || t.length > 4)
      throw new Error(
        "`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."
      );
    return `vec${t.length}(${t.map(nf).join(", ")})`;
  }
  function sf(t) {
    const e = hs(t),
      i = e.length > 3 ? e[3] : 1;
    return rf([(e[0] / 255) * i, (e[1] / 255) * i, (e[2] / 255) * i, i]);
  }
  const of = {};
  let af = 0;
  function lf(t) {
    return t in of || (of[t] = af++), of[t];
  }
  function hf(t) {
    return nf(lf(t));
  }
  function cf(t, e, i) {
    const n = void 0 !== i ? i : Qg.NUMBER;
    if (Array.isArray(e) && "string" == typeof e[0]) {
      const i = $g[e[0]];
      if (void 0 === i)
        throw new Error(
          `Unrecognized expression operator: ${JSON.stringify(e)}`
        );
      return i.toGlsl(t, e.slice(1), n);
    }
    const r = Jg(e) & n;
    if ((xf(e, r, ""), (r & Qg.NUMBER) > 0)) return nf(e);
    if ((r & Qg.BOOLEAN) > 0) return e.toString();
    if ((r & Qg.STRING) > 0) return hf(e.toString());
    if ((r & Qg.COLOR) > 0) return sf(e);
    if ((r & Qg.NUMBER_ARRAY) > 0) return rf(e);
    throw new Error(`Unexpected expression ${e} (expected type ${ef(n)})`);
  }
  function uf(t) {
    if (0 == (Jg(t) & Qg.NUMBER))
      throw new Error(
        `A numeric value was expected, got ${JSON.stringify(t)} instead`
      );
  }
  function df(t) {
    for (let e = 0; e < t.length; e++) uf(t[e]);
  }
  function gf(t) {
    if (0 == (Jg(t) & Qg.STRING))
      throw new Error(
        `A string value was expected, got ${JSON.stringify(t)} instead`
      );
  }
  function ff(t) {
    if (0 == (Jg(t) & Qg.BOOLEAN))
      throw new Error(
        `A boolean value was expected, got ${JSON.stringify(t)} instead`
      );
  }
  function pf(t, e) {
    if (t.length !== e)
      throw new Error(
        `Exactly ${e} arguments were expected, got ${t.length} instead`
      );
  }
  function mf(t, e) {
    if (t.length < e)
      throw new Error(
        `At least ${e} arguments were expected, got ${t.length} instead`
      );
  }
  function _f(t, e) {
    if (t.length > e)
      throw new Error(
        `At most ${e} arguments were expected, got ${t.length} instead`
      );
  }
  function yf(t) {
    if (t.length % 2 != 0)
      throw new Error(
        `An even amount of arguments was expected, got ${JSON.stringify(
          t
        )} instead`
      );
  }
  function xf(t, e, i) {
    if (e === Qg.NONE)
      throw new Error(
        `No matching type was found for the following expression ${i}: ${JSON.stringify(
          t
        )}`
      );
  }
  function vf(t, e, i) {
    if ((xf(t, e, i), !tf(e)))
      throw new Error(
        `Expected to have a unique type for the following expression ${i}: ${JSON.stringify(
          t
        )}\nGot the following types instead: ${ef(e)}`
      );
  }
  function Sf(t, e, i, n) {
    if ((e & i) === Qg.NONE)
      throw new Error(
        `Expected the ${n} type of the following expression: ${JSON.stringify(
          t
        )} to be of the following types: ${ef(
          i
        )}\nGot these types instead: ${ef(e)}`
      );
  }
  function Cf(t) {
    return "u_var_" + t;
  }
  ($g.get = {
    getReturnType: function (t) {
      if (2 === t.length) {
        return (function (t) {
          switch (t) {
            case "string":
              return Qg.STRING;
            case "color":
              return Qg.COLOR;
            case "number":
              return Qg.NUMBER;
            case "boolean":
              return Qg.BOOLEAN;
            case "number[]":
              return Qg.NUMBER_ARRAY;
            default:
              throw new Error(`Unrecognized type hint: ${t}`);
          }
        })(t[1]);
      }
      return Qg.ANY;
    },
    toGlsl: function (t, e, i) {
      mf(e, 1), _f(e, 2), gf(e[0]);
      const n = i & $g.get.getReturnType(e);
      vf(["get", ...e], n, "");
      const r = e[0].toString(),
        s = t.attributes.find((t) => t.name === r);
      if (s) {
        if (n !== s.type)
          throw new Error(
            `The following attribute was used in different places with incompatible types: ${r}\nTypes were: ${ef(
              s.type
            )} and ${ef(n)}`
          );
      } else t.attributes.push({ name: r, type: n });
      return (t.inFragmentShader ? "v_" : "a_") + r;
    },
  }),
    ($g.var = {
      getReturnType: function () {
        return Qg.ANY;
      },
      toGlsl: function (t, e, i) {
        pf(e, 1), gf(e[0]);
        const n = e[0].toString();
        if (!t.style.variables || void 0 === t.style.variables[n])
          throw new Error(
            `The following variable is missing from the style: ${n}`
          );
        const r = i & Jg(t.style.variables[n]);
        vf(["var", ...e], r, "");
        const s = t.variables.find((t) => t.name === n);
        if (s) {
          if (r !== s.type)
            throw new Error(
              `The following variable was used in different places with incompatible types: ${n}\nTypes were: ${ef(
                s.type
              )} and ${ef(r)}`
            );
        } else t.variables.push({ name: n, type: r });
        return Cf(n);
      },
    });
  const wf = "u_paletteTextures";
  $g.palette = {
    getReturnType: function () {
      return Qg.COLOR;
    },
    toGlsl: function (t, e) {
      pf(e, 2), uf(e[0]);
      const i = cf(t, e[0]),
        n = e[1];
      if (!Array.isArray(n))
        throw new Error("The second argument of palette must be an array");
      const r = n.length,
        s = new Uint8Array(4 * r);
      for (let t = 0; t < r; t++) {
        const e = n[t];
        let i;
        if ("string" == typeof e) i = ls(e);
        else {
          if (!Array.isArray(e))
            throw new Error(
              "The second argument of palette must be an array of strings or colors"
            );
          const t = e.length;
          if (4 === t) i = e;
          else {
            if (3 !== t)
              throw new Error(
                `Expected palette color to have 3 or 4 values, got ${t}`
              );
            i = [e[0], e[1], e[2], 1];
          }
        }
        const r = 4 * t;
        (s[r] = i[0]),
          (s[r + 1] = i[1]),
          (s[r + 2] = i[2]),
          (s[r + 3] = 255 * i[3]);
      }
      t.paletteTextures || (t.paletteTextures = []);
      const o = `${wf}[${t.paletteTextures.length}]`,
        a = new ug(o, s);
      return (
        t.paletteTextures.push(a),
        `texture2D(${o}, vec2((${i} + 0.5) / ${r}.0, 0.5))`
      );
    },
  };
  const Wf = "getBandValue";
  function Ef(t) {
    return {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (e, i) {
        pf(i, 2);
        let n = Qg.ANY;
        for (let t = 0; t < i.length; t++) n &= Jg(i[t]);
        if (n === Qg.NONE)
          throw new Error(
            `All arguments should be of compatible type, got ${JSON.stringify(
              i
            )} instead`
          );
        return (n &= ~Qg.COLOR), `(${cf(e, i[0], n)} ${t} ${cf(e, i[1], n)})`;
      },
    };
  }
  function Rf(t) {
    return {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (e, i) {
        mf(i, 2);
        for (let t = 0; t < i.length; t++) ff(i[t]);
        let n = i.map((t) => cf(e, t, Qg.BOOLEAN)).join(` ${t} `);
        return (n = `(${n})`), n;
      },
    };
  }
  function Tf() {
    return {
      "fill-color": "rgba(255,255,255,0.4)",
      "stroke-color": "#3399CC",
      "stroke-width": 1.25,
      "circle-radius": 5,
      "circle-fill-color": "rgba(255,255,255,0.4)",
      "circle-stroke-width": 1.25,
      "circle-stroke-color": "#3399CC",
    };
  }
  ($g.band = {
    getReturnType: function () {
      return Qg.NUMBER;
    },
    toGlsl: function (t, e) {
      mf(e, 1), _f(e, 3);
      const i = e[0];
      if (!(Wf in t.functions)) {
        let e = "";
        const i = t.bandCount || 1;
        for (let t = 0; t < i; t++) {
          const n = Math.floor(t / 4);
          let r = t % 4;
          t === i - 1 && 1 === r && (r = 3);
          e += `\n          if (band == ${
            t + 1
          }.0) {\n            return texture2D(${`${Zg.TILE_TEXTURE_ARRAY}[${n}]`}, v_textureCoord + vec2(dx, dy))[${r}];\n          }\n        `;
        }
        t.functions[
          Wf
        ] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Zg.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Zg.TEXTURE_PIXEL_HEIGHT};\n          ${e}\n        }\n      `;
      }
      const n = cf(t, i),
        r = cf(t, e[1] || 0),
        s = cf(t, e[2] || 0);
      return `${Wf}(${n}, ${r}, ${s})`;
    },
  }),
    ($g.time = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 0), "u_time";
      },
    }),
    ($g.zoom = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 0), "u_zoom";
      },
    }),
    ($g.resolution = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 0), "u_resolution";
      },
    }),
    ($g["geometry-type"] = {
      getReturnType: function () {
        return Qg.STRING;
      },
      toGlsl: function (t, e) {
        pf(e, 0);
        const i = "geometryType",
          n = (t) => {
            const e = t.getType();
            switch (e) {
              case "Point":
              case "LineString":
              case "Polygon":
                return e;
              case "MultiPoint":
              case "MultiLineString":
              case "MultiPolygon":
                return e.substring(5);
              case "Circle":
                return "Polygon";
              case "GeometryCollection":
                return n(t.getGeometries()[0]);
            }
          };
        t.attributes.find((t) => t.name === i) ||
          t.attributes.push({
            name: i,
            type: Qg.STRING,
            callback: (t) => n(t.getGeometry()),
          });
        return (t.inFragmentShader ? "v_" : "a_") + i;
      },
    }),
    ($g["*"] = {
      getReturnType: function (t) {
        let e = Qg.NUMBER | Qg.COLOR;
        for (let i = 0; i < t.length; i++) e &= Jg(t[i]);
        return e;
      },
      toGlsl: function (t, e, i) {
        mf(e, 2);
        let n = i;
        for (let t = 0; t < e.length; t++) n &= Jg(e[t]);
        return (
          Sf(e, n, Qg.NUMBER | Qg.COLOR, "output"),
          `(${e.map((e) => cf(t, e, n)).join(" * ")})`
        );
      },
    }),
    ($g["/"] = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `(${cf(t, e[0])} / ${cf(t, e[1])})`;
      },
    }),
    ($g["+"] = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return mf(e, 2), df(e), `(${e.map((e) => cf(t, e)).join(" + ")})`;
      },
    }),
    ($g["-"] = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `(${cf(t, e[0])} - ${cf(t, e[1])})`;
      },
    }),
    ($g.clamp = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        pf(e, 3), df(e);
        const i = cf(t, e[1]),
          n = cf(t, e[2]);
        return `clamp(${cf(t, e[0])}, ${i}, ${n})`;
      },
    }),
    ($g["%"] = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `mod(${cf(t, e[0])}, ${cf(t, e[1])})`;
      },
    }),
    ($g["^"] = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `pow(${cf(t, e[0])}, ${cf(t, e[1])})`;
      },
    }),
    ($g.abs = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), df(e), `abs(${cf(t, e[0])})`;
      },
    }),
    ($g.floor = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), df(e), `floor(${cf(t, e[0])})`;
      },
    }),
    ($g.round = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), df(e), `floor(${cf(t, e[0])} + 0.5)`;
      },
    }),
    ($g.ceil = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), df(e), `ceil(${cf(t, e[0])})`;
      },
    }),
    ($g.sin = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), df(e), `sin(${cf(t, e[0])})`;
      },
    }),
    ($g.cos = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), df(e), `cos(${cf(t, e[0])})`;
      },
    }),
    ($g.atan = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return (
          mf(e, 1),
          _f(e, 2),
          df(e),
          2 === e.length
            ? `atan(${cf(t, e[0])}, ${cf(t, e[1])})`
            : `atan(${cf(t, e[0])})`
        );
      },
    }),
    ($g.sqrt = {
      getReturnType: function () {
        return Qg.NUMBER;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), df(e), `sqrt(${cf(t, e[0])})`;
      },
    }),
    ($g[">"] = {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `(${cf(t, e[0])} > ${cf(t, e[1])})`;
      },
    }),
    ($g[">="] = {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `(${cf(t, e[0])} >= ${cf(t, e[1])})`;
      },
    }),
    ($g["<"] = {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `(${cf(t, e[0])} < ${cf(t, e[1])})`;
      },
    }),
    ($g["<="] = {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (t, e) {
        return pf(e, 2), df(e), `(${cf(t, e[0])} <= ${cf(t, e[1])})`;
      },
    }),
    ($g["=="] = Ef("==")),
    ($g["!="] = Ef("!=")),
    ($g["!"] = {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (t, e) {
        return pf(e, 1), ff(e[0]), `(!${cf(t, e[0], Qg.BOOLEAN)})`;
      },
    }),
    ($g.all = Rf("&&")),
    ($g.any = Rf("||")),
    ($g.between = {
      getReturnType: function () {
        return Qg.BOOLEAN;
      },
      toGlsl: function (t, e) {
        pf(e, 3), df(e);
        const i = cf(t, e[1]),
          n = cf(t, e[2]),
          r = cf(t, e[0]);
        return `(${r} >= ${i} && ${r} <= ${n})`;
      },
    }),
    ($g.array = {
      getReturnType: function () {
        return Qg.NUMBER_ARRAY;
      },
      toGlsl: function (t, e) {
        mf(e, 2), _f(e, 4), df(e);
        const i = e.map(function (e) {
          return cf(t, e);
        });
        return `vec${e.length}(${i.join(", ")})`;
      },
    }),
    ($g.color = {
      getReturnType: function () {
        return Qg.COLOR;
      },
      toGlsl: function (t, e) {
        mf(e, 3), _f(e, 4), df(e);
        const i = e.slice(0, 3).map((e) => `${cf(t, e)} / 255.0`);
        if (3 === e.length) return `vec4(${i.join(", ")}, 1.0)`;
        return `(${cf(t, e[3])} * vec4(${i.join(", ")}, 1.0))`;
      },
    }),
    ($g.interpolate = {
      getReturnType: function (t) {
        let e = Qg.COLOR | Qg.NUMBER;
        for (let i = 3; i < t.length; i += 2) e &= Jg(t[i]);
        return e;
      },
      toGlsl: function (t, e, i) {
        yf(e), mf(e, 6);
        const n = e[0];
        let r;
        switch (n[0]) {
          case "linear":
            r = 1;
            break;
          case "exponential":
            r = n[1];
            break;
          default:
            r = null;
        }
        if (!r)
          throw new Error(
            `Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(
              n
            )}`
          );
        const s = Qg.NUMBER,
          o = $g.interpolate.getReturnType(e) & i;
        vf(["interpolate", ...e], o, "output");
        const a = cf(t, e[1], s),
          l = nf(r);
        let h = "";
        for (let i = 2; i < e.length - 2; i += 2) {
          const n = cf(t, e[i], s),
            c = h || cf(t, e[i + 1], o),
            u = cf(t, e[i + 2], s);
          let d;
          (d =
            1 === r
              ? `(${a} - ${n}) / (${u} - ${n})`
              : `(pow(${l}, (${a} - ${n})) - 1.0) / (pow(${l}, (${u} - ${n})) - 1.0)`),
            (h = `mix(${c}, ${cf(t, e[i + 3], o)}, clamp(${d}, 0.0, 1.0))`);
        }
        return h;
      },
    }),
    ($g.match = {
      getReturnType: function (t) {
        let e = Qg.ANY;
        for (let i = 2; i < t.length; i += 2) e &= Jg(t[i]);
        return (e &= Jg(t[t.length - 1])), e;
      },
      toGlsl: function (t, e, i) {
        yf(e), mf(e, 4);
        let n = Jg(e[0]);
        for (let t = 1; t < e.length - 1; t += 2) n &= Jg(e[t]);
        Sf(["match", ...e], n, Qg.STRING | Qg.NUMBER | Qg.BOOLEAN, "input"),
          (n = (Qg.STRING | Qg.NUMBER | Qg.BOOLEAN) & n);
        const r = $g.match.getReturnType(e) & i;
        vf(["match", ...e], r, "output");
        const s = cf(t, e[0], n),
          o = cf(t, e[e.length - 1], r);
        let a = null;
        for (let i = e.length - 3; i >= 1; i -= 2) {
          a = `(${s} == ${cf(t, e[i], n)} ? ${cf(t, e[i + 1], r)} : ${a || o})`;
        }
        return a;
      },
    }),
    ($g.case = {
      getReturnType: function (t) {
        let e = Qg.ANY;
        for (let i = 1; i < t.length; i += 2) e &= Jg(t[i]);
        return (e &= Jg(t[t.length - 1])), e;
      },
      toGlsl: function (t, e, i) {
        !(function (t) {
          if (t.length % 2 == 0)
            throw new Error(
              `An odd amount of arguments was expected, got ${JSON.stringify(
                t
              )} instead`
            );
        })(e),
          mf(e, 3);
        const n = $g.case.getReturnType(e) & i;
        vf(["case", ...e], n, "output");
        for (let t = 0; t < e.length - 1; t += 2) ff(e[t]);
        const r = cf(t, e[e.length - 1], n);
        let s = null;
        for (let i = e.length - 3; i >= 0; i -= 2) {
          s = `(${cf(t, e[i], Qg.BOOLEAN)} ? ${cf(t, e[i + 1], n)} : ${
            s || r
          })`;
        }
        return s;
      },
    }),
    ($g.in = {
      getReturnType: function (t) {
        return Qg.BOOLEAN;
      },
      toGlsl: function (t, e) {
        pf(e, 2);
        const i = e[0];
        let n = e[1];
        if (!Array.isArray(n))
          throw new Error(
            'The "in" operator expects an array literal as its second argument.'
          );
        if ("string" == typeof n[0]) {
          if ("literal" !== n[0])
            throw new Error(
              'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.'
            );
          if (!Array.isArray(n[1]))
            throw new Error(
              'The "in" operator was provided a literal value which was not an array as second argument.'
            );
          n = n[1];
        }
        let r = Jg(i);
        for (let t = 0; t < n.length - 1; t += 1) r &= Jg(n[t]);
        Sf(["match", ...e], r, Qg.STRING | Qg.NUMBER | Qg.BOOLEAN, "input"),
          (r = (Qg.STRING | Qg.NUMBER | Qg.BOOLEAN) & r);
        const s = (function (t, e) {
            return `operator_${t}_${Object.keys(e.functions).length}`;
          })("in", t),
          o = [];
        for (let e = 0; e < n.length; e += 1)
          o.push(`  if (inputValue == ${cf(t, n[e], r)}) { return true; }`);
        return (
          (t.functions[s] = `bool ${s}(float inputValue) {\n${o.join(
            "\n"
          )}\n  return false;\n}`),
          `${s}(${cf(t, i, r)})`
        );
      },
    });
  const Pf =
      "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_screenToWorldMatrix;\nuniform vec2 u_viewportSizePx;\nuniform float u_pixelRatio;\nuniform float u_globalAlpha;\nuniform float u_time;\nuniform float u_zoom;\nuniform float u_resolution;\nuniform float u_rotation;\nuniform vec4 u_renderExtent;\nuniform mediump int u_hitDetection;\n\nconst float PI = 3.141592653589793238;\nconst float TWO_PI = 2.0 * PI;\n",
    bf = {
      "fill-color": "rgba(255,255,255,0.4)",
      "stroke-color": "#3399CC",
      "stroke-width": 1.25,
      "circle-radius": 5,
      "circle-fill-color": "rgba(255,255,255,0.4)",
      "circle-stroke-width": 1.25,
      "circle-stroke-color": "#3399CC",
    };
  class Ff {
    constructor() {
      (this.uniforms_ = []),
        (this.attributes_ = []),
        (this.varyings_ = []),
        (this.hasSymbol_ = !1),
        (this.symbolSizeExpression_ = `vec2(${nf(bf["circle-radius"])} + ${nf(
          0.5 * bf["circle-stroke-width"]
        )})`),
        (this.symbolRotationExpression_ = "0.0"),
        (this.symbolOffsetExpression_ = "vec2(0.0)"),
        (this.symbolColorExpression_ = sf(bf["circle-fill-color"])),
        (this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)"),
        (this.discardExpression_ = "false"),
        (this.symbolRotateWithView_ = !1),
        (this.hasStroke_ = !1),
        (this.strokeWidthExpression_ = nf(bf["stroke-width"])),
        (this.strokeColorExpression_ = sf(bf["stroke-color"])),
        (this.strokeOffsetExpression_ = "0."),
        (this.strokeCapExpression_ = hf("round")),
        (this.strokeJoinExpression_ = hf("round")),
        (this.strokeMiterLimitExpression_ = "10."),
        (this.strokeDistanceFieldExpression_ = "-1000."),
        (this.hasFill_ = !1),
        (this.fillColorExpression_ = sf(bf["fill-color"])),
        (this.vertexShaderFunctions_ = []),
        (this.fragmentShaderFunctions_ = []);
    }
    addUniform(t) {
      return this.uniforms_.push(t), this;
    }
    addAttribute(t) {
      return this.attributes_.push(t), this;
    }
    addVarying(t, e, i) {
      return this.varyings_.push({ name: t, type: e, expression: i }), this;
    }
    setSymbolSizeExpression(t) {
      return (this.hasSymbol_ = !0), (this.symbolSizeExpression_ = t), this;
    }
    getSymbolSizeExpression() {
      return this.symbolSizeExpression_;
    }
    setSymbolRotationExpression(t) {
      return (this.symbolRotationExpression_ = t), this;
    }
    setSymbolOffsetExpression(t) {
      return (this.symbolOffsetExpression_ = t), this;
    }
    getSymbolOffsetExpression() {
      return this.symbolOffsetExpression_;
    }
    setSymbolColorExpression(t) {
      return (this.hasSymbol_ = !0), (this.symbolColorExpression_ = t), this;
    }
    getSymbolColorExpression() {
      return this.symbolColorExpression_;
    }
    setTextureCoordinateExpression(t) {
      return (this.texCoordExpression_ = t), this;
    }
    setFragmentDiscardExpression(t) {
      return (this.discardExpression_ = t), this;
    }
    setSymbolRotateWithView(t) {
      return (this.symbolRotateWithView_ = t), this;
    }
    setStrokeWidthExpression(t) {
      return (this.hasStroke_ = !0), (this.strokeWidthExpression_ = t), this;
    }
    setStrokeColorExpression(t) {
      return (this.hasStroke_ = !0), (this.strokeColorExpression_ = t), this;
    }
    setStrokeOffsetExpression(t) {
      return (this.strokeOffsetExpression_ = t), this;
    }
    setStrokeCapExpression(t) {
      return (this.strokeCapExpression_ = t), this;
    }
    setStrokeJoinExpression(t) {
      return (this.strokeJoinExpression_ = t), this;
    }
    setStrokeMiterLimitExpression(t) {
      return (this.strokeMiterLimitExpression_ = t), this;
    }
    setStrokeDistanceFieldExpression(t) {
      return (this.strokeDistanceFieldExpression_ = t), this;
    }
    setFillColorExpression(t) {
      return (this.hasFill_ = !0), (this.fillColorExpression_ = t), this;
    }
    addVertexShaderFunction(t) {
      this.vertexShaderFunctions_.includes(t) ||
        this.vertexShaderFunctions_.push(t);
    }
    addFragmentShaderFunction(t) {
      this.fragmentShaderFunctions_.includes(t) ||
        this.fragmentShaderFunctions_.push(t);
    }
    getSymbolVertexShader() {
      return this.hasSymbol_
        ? `${Pf}\n${this.uniforms_
            .map(function (t) {
              return "uniform " + t + ";";
            })
            .join(
              "\n"
            )}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec4 a_hitColor;\n${this.attributes_
            .map(function (t) {
              return "attribute " + t + ";";
            })
            .join(
              "\n"
            )}\nvarying vec2 v_texCoord;\nvarying vec2 v_quadCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_
            .map(function (t) {
              return "varying " + t.type + " " + t.name + ";";
            })
            .join("\n")}\n${this.vertexShaderFunctions_.join(
            "\n"
          )}\nvec2 pxToScreen(vec2 coordPx) {\n  vec2 scaled = coordPx / u_viewportSizePx / 0.5;\n  ${
            this.symbolRotateWithView_
              ? "scaled = vec2(scaled.x * cos(-u_rotation) - scaled.y * sin(-u_rotation), scaled.x * sin(-u_rotation) + scaled.y * cos(-u_rotation));"
              : ""
          }\n  return scaled;\n}\n\nvec2 screenToPx(vec2 coordScreen) {\n  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;\n}\n\nvoid main(void) {\n  v_quadSizePx = ${
            this.symbolSizeExpression_
          };\n  vec2 halfSizePx = v_quadSizePx * 0.5;\n  vec2 centerOffsetPx = ${
            this.symbolOffsetExpression_
          };\n  vec2 offsetPx = centerOffsetPx;\n  if (a_index == 0.0) {\n    offsetPx -= halfSizePx;\n  } else if (a_index == 1.0) {\n    offsetPx += halfSizePx * vec2(1., -1.);\n  } else if (a_index == 2.0) {\n    offsetPx += halfSizePx;\n  } else {\n    offsetPx += halfSizePx * vec2(-1., 1.);\n  }\n  float angle = ${
            this.symbolRotationExpression_
          };\n  float c = cos(-angle);\n  float s = sin(-angle);\n  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);\n  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  gl_Position = center + vec4(pxToScreen(offsetPx), 0., 0.);\n  vec4 texCoord = ${
            this.texCoordExpression_
          };\n  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;\n  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;\n  v_texCoord = vec2(u, v);\n  v_hitColor = a_hitColor;\n  v_angle = angle;\n  ${
            this.symbolRotateWithView_ ? "v_angle += u_rotation;" : ""
          }\n  c = cos(-v_angle);\n  s = sin(-v_angle);\n  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); \n  v_centerPx = screenToPx(center.xy) + centerOffsetPx;\n${this.varyings_
            .map(function (t) {
              return "  " + t.name + " = " + t.expression + ";";
            })
            .join("\n")}\n}`
        : null;
    }
    getSymbolFragmentShader() {
      return this.hasSymbol_
        ? `${Pf}\n${this.uniforms_
            .map(function (t) {
              return "uniform " + t + ";";
            })
            .join(
              "\n"
            )}\nvarying vec2 v_texCoord;\nvarying vec4 v_hitColor;\nvarying vec2 v_centerPx;\nvarying float v_angle;\nvarying vec2 v_quadSizePx;\n${this.varyings_
            .map(function (t) {
              return "varying " + t.type + " " + t.name + ";";
            })
            .join("\n")}\n${this.fragmentShaderFunctions_.join(
            "\n"
          )}\n\nvoid main(void) {\n  if (${
            this.discardExpression_
          }) { discard; }\n  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center\n  float c = cos(v_angle);\n  float s = sin(v_angle);\n  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);\n  gl_FragColor = ${
            this.symbolColorExpression_
          };\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.05) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`
        : null;
    }
    getStrokeVertexShader() {
      return this.hasStroke_
        ? `${Pf}\n${this.uniforms_
            .map(function (t) {
              return "uniform " + t + ";";
            })
            .join(
              "\n"
            )}\nattribute vec2 a_position;\nattribute float a_index;\nattribute vec2 a_segmentStart;\nattribute vec2 a_segmentEnd;\nattribute float a_parameters;\nattribute float a_distance;\nattribute vec2 a_joinAngles;\nattribute vec4 a_hitColor;\n${this.attributes_
            .map(function (t) {
              return "attribute " + t + ";";
            })
            .join(
              "\n"
            )}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n${this.varyings_
            .map(function (t) {
              return "varying " + t.type + " " + t.name + ";";
            })
            .join("\n")}\n${this.vertexShaderFunctions_.join(
            "\n"
          )}\nvec2 worldToPx(vec2 worldPos) {\n  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;\n}\n\nvec4 pxToScreen(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return vec4(screenPos, 0.0, 1.0);\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nvec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {\n  float halfAngle = joinAngle / 2.0;\n  float c = cos(halfAngle);\n  float s = sin(halfAngle);\n  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);\n  float length = 1.0 / s;\n  return angleBisectorNormal * length;\n}\n\nvec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {\n  // if on a cap or the join angle is too high, offset the line along the segment normal\n  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {\n    return point - normal * offsetPx;\n  }\n  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)\n  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;\n}\n\nvoid main(void) {\n  v_angleStart = a_joinAngles.x;\n  v_angleEnd = a_joinAngles.y;\n  float vertexNumber = a_parameters;\n\n  float lineWidth = ${
            this.strokeWidthExpression_
          };\n  float lineOffsetPx = ${
            this.strokeOffsetExpression_
          };\n\n  // compute segment start/end in px with offset\n  vec2 segmentStartPx = worldToPx(a_segmentStart);\n  vec2 segmentEndPx = worldToPx(a_segmentEnd);\n  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);\n  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),\n  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);\n  \n  // compute current vertex position\n  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n  vec2 joinDirection;\n  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;\n  // if angle is too high, do not make a proper join\n  if (cos(angle) > 0.985 || isCap(angle)) {\n    joinDirection = normalPx * normalDir - tangentPx * tangentDir;\n  } else {\n    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);\n  }\n  positionPx = positionPx + joinDirection * lineWidth * 0.5;\n  gl_Position = pxToScreen(positionPx);\n\n  v_segmentStart = segmentStartPx;\n  v_segmentEnd = segmentEndPx;\n  v_width = lineWidth;\n  v_hitColor = a_hitColor;\n  v_distanceOffsetPx = a_distance / u_resolution;\n${this.varyings_
            .map(function (t) {
              return "  " + t.name + " = " + t.expression + ";";
            })
            .join("\n")}\n}`
        : null;
    }
    getStrokeFragmentShader() {
      return this.hasStroke_
        ? `${Pf}\n${this.uniforms_
            .map(function (t) {
              return "uniform " + t + ";";
            })
            .join(
              "\n"
            )}\nvarying vec2 v_segmentStart;\nvarying vec2 v_segmentEnd;\nvarying float v_angleStart;\nvarying float v_angleEnd;\nvarying float v_width;\nvarying vec4 v_hitColor;\nvarying float v_distanceOffsetPx;\n${this.varyings_
            .map(function (t) {
              return "varying " + t.type + " " + t.name + ";";
            })
            .join("\n")}\n${this.fragmentShaderFunctions_.join(
            "\n"
          )}\n\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nbool isCap(float joinAngle) {\n  return joinAngle < -0.1;\n}\n\nfloat segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  vec2 tangent = normalize(end - start);\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 startToPoint = point - start;\n  return abs(dot(startToPoint, normal)) - width * 0.5;\n}\n\nfloat buttCapDistanceField(vec2 point, vec2 start, vec2 end) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  return dot(startToPoint, -tangent);\n}\n\nfloat squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return buttCapDistanceField(point, start, end) - width * 0.5;\n}\n\nfloat roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment\n  return length(point - start) - width * 0.5 - onSegment;\n}\n\nfloat roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  vec2 startToPoint = point - start;\n  vec2 tangent = normalize(end - start);\n  float c = cos(joinAngle * 0.5);\n  float s = sin(joinAngle * 0.5);\n  float direction = -sign(sin(joinAngle));\n  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);\n  float radius = width * 0.5 * s;\n  return dot(startToPoint, bisector * direction) - radius;\n}\n\nfloat miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {\n  if (cos(joinAngle) > 0.985) { // avoid risking a division by zero\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  float miterLength = 1. / sin(joinAngle * 0.5);\n  float miterLimit = ${
            this.strokeMiterLimitExpression_
          };\n  if (miterLength > miterLimit) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  }\n  return -1000.;\n}\n\nfloat capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {\n   if (capType == ${hf(
            "butt"
          )}) {\n    return buttCapDistanceField(point, start, end);\n  } else if (capType == ${hf(
            "square"
          )}) {\n    return squareCapDistanceField(point, start, end, width);\n  }\n  return roundCapDistanceField(point, start, end, width);\n}\n\nfloat joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {\n  if (joinType == ${hf(
            "bevel"
          )}) {\n    return bevelJoinField(point, start, end, width, joinAngle);\n  } else if (joinType == ${hf(
            "miter"
          )}) {\n    return miterJoinDistanceField(point, start, end, width, joinAngle);\n  }\n  return roundJoinDistanceField(point, start, end, width);\n}\n\nfloat computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {\n  if (isCap(joinAngle)) {\n    return capDistanceField(point, start, end, width, capType);\n  }\n  return joinDistanceField(point, start, end, width, joinAngle, joinType);\n}\n\nvoid main(void) {\n  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(currentPoint);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${
            this.discardExpression_
          }) { discard; }\n\n  float segmentLength = length(v_segmentEnd - v_segmentStart);\n  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;\n  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);\n  vec2 startToPoint = currentPoint - v_segmentStart;\n  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; \n  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));\n  vec4 color = ${
            this.strokeColorExpression_
          } * u_globalAlpha;\n  float capType = ${
            this.strokeCapExpression_
          };\n  float joinType = ${
            this.strokeJoinExpression_
          };\n  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);\n  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);\n  float distance = max(\n    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),\n    max(segmentStartDistance, segmentEndDistance)\n  );\n  distance = max(distance, ${
            this.strokeDistanceFieldExpression_
          });\n  gl_FragColor = color * smoothstep(0., -1., distance);\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`
        : null;
    }
    getFillVertexShader() {
      return this.hasFill_
        ? `${Pf}\n${this.uniforms_
            .map(function (t) {
              return "uniform " + t + ";";
            })
            .join(
              "\n"
            )}\nattribute vec2 a_position;\nattribute vec4 a_hitColor;\n${this.attributes_
            .map(function (t) {
              return "attribute " + t + ";";
            })
            .join("\n")}\nvarying vec4 v_hitColor;\n${this.varyings_
            .map(function (t) {
              return "varying " + t.type + " " + t.name + ";";
            })
            .join("\n")}\n${this.vertexShaderFunctions_.join(
            "\n"
          )}\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n${this.varyings_
            .map(function (t) {
              return "  " + t.name + " = " + t.expression + ";";
            })
            .join("\n")}\n}`
        : null;
    }
    getFillFragmentShader() {
      return this.hasFill_
        ? `${Pf}\n${this.uniforms_
            .map(function (t) {
              return "uniform " + t + ";";
            })
            .join("\n")}\nvarying vec4 v_hitColor;\n${this.varyings_
            .map(function (t) {
              return "varying " + t.type + " " + t.name + ";";
            })
            .join("\n")}\n${this.fragmentShaderFunctions_.join(
            "\n"
          )}\nvec2 pxToWorld(vec2 pxPos) {\n  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;\n  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;\n}\n\nvoid main(void) {\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n  vec2 v_worldPos = pxToWorld(gl_FragCoord.xy / u_pixelRatio);\n  if (\n    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (\n      v_worldPos[0] < u_renderExtent[0] ||\n      v_worldPos[1] < u_renderExtent[1] ||\n      v_worldPos[0] > u_renderExtent[2] ||\n      v_worldPos[1] > u_renderExtent[3]\n    )\n  ) {\n    discard;\n  }\n  #endif\n  if (${
            this.discardExpression_
          }) { discard; }\n  gl_FragColor = ${
            this.fillColorExpression_
          } * u_globalAlpha;\n  if (u_hitDetection > 0) {\n    if (gl_FragColor.a < 0.1) { discard; };\n    gl_FragColor = v_hitColor;\n  }\n}`
        : null;
    }
  }
  const If = "blur",
    Lf = "gradient",
    Mf = "radius",
    Of = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
  var kf = class extends Cc {
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.gradient,
        delete e.radius,
        delete e.blur,
        delete e.weight,
        super(e),
        (this.gradient_ = null),
        this.addChangeListener(Lf, this.handleGradientChanged_),
        this.setGradient(t.gradient ? t.gradient : Of),
        this.setBlur(void 0 !== t.blur ? t.blur : 15),
        this.setRadius(void 0 !== t.radius ? t.radius : 8);
      const i = t.weight ? t.weight : "weight";
      (this.weightFunction_ =
        "string" == typeof i
          ? function (t) {
              return t.get(i);
            }
          : i),
        this.setRenderOrder(null);
    }
    getBlur() {
      return this.get(If);
    }
    getGradient() {
      return this.get(Lf);
    }
    getRadius() {
      return this.get(Mf);
    }
    handleGradientChanged_() {
      this.gradient_ = (function (t) {
        const e = 1,
          i = 256,
          n = mt(e, i),
          r = n.createLinearGradient(0, 0, e, i),
          s = 1 / (t.length - 1);
        for (let e = 0, i = t.length; e < i; ++e) r.addColorStop(e * s, t[e]);
        return (n.fillStyle = r), n.fillRect(0, 0, e, i), n.canvas;
      })(this.getGradient());
    }
    setBlur(t) {
      this.set(If, t);
    }
    setGradient(t) {
      this.set(Lf, t);
    }
    setRadius(t) {
      this.set(Mf, t);
    }
    createRenderer() {
      const t = new Ff()
        .addAttribute("float a_weight")
        .addVarying("v_weight", "float", "a_weight")
        .addUniform("float u_size")
        .addUniform("float u_blurSlope")
        .setSymbolSizeExpression("vec2(u_size)")
        .setSymbolColorExpression(
          "vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_weight)"
        );
      return new cg(this, {
        className: this.getClassName(),
        attributes: [
          {
            name: "weight",
            callback: (t) => {
              const e = this.weightFunction_(t);
              return void 0 !== e ? ui(e, 0, 1) : 1;
            },
          },
        ],
        uniforms: {
          u_size: () => 2 * (this.get(Mf) + this.get(If)),
          u_blurSlope: () => this.get(Mf) / Math.max(1, this.get(If)),
        },
        hitDetectionEnabled: !0,
        vertexShader: t.getSymbolVertexShader(),
        fragmentShader: t.getSymbolFragmentShader(),
        postProcesses: [
          {
            fragmentShader:
              "\n            precision mediump float;\n\n            uniform sampler2D u_image;\n            uniform sampler2D u_gradientTexture;\n            uniform float u_opacity;\n\n            varying vec2 v_texCoord;\n\n            void main() {\n              vec4 color = texture2D(u_image, v_texCoord);\n              gl_FragColor.a = color.a * u_opacity;\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\n              gl_FragColor.rgb *= gl_FragColor.a;\n            }",
            uniforms: {
              u_gradientTexture: () => this.gradient_,
              u_opacity: () => this.getOpacity(),
            },
          },
        ],
      });
    }
    renderDeclutter() {}
  };
  var Af = class extends no {
    constructor(t) {
      super((t = t || {}));
    }
  };
  var Nf = class extends tu {
    constructor(t) {
      super(t), (this.image_ = null);
    }
    getImage() {
      return this.image_ ? this.image_.getImage() : null;
    }
    prepareFrame(t) {
      const e = t.layerStatesArray[t.layerIndex],
        i = t.pixelRatio,
        n = t.viewState,
        r = n.resolution,
        s = this.getLayer().getSource(),
        o = t.viewHints;
      let a = t.extent;
      if (
        (void 0 !== e.extent && (a = Te(a, xn(e.extent, n.projection))),
        !o[Ms] && !o[Os] && !Le(a))
      )
        if (s) {
          const t = n.projection,
            e = s.getImage(a, r, i, t);
          e &&
            (this.loadImage(e)
              ? (this.image_ = e)
              : e.getState() === Hr && (this.image_ = null));
        } else this.image_ = null;
      return !!this.image_;
    }
    getData(t) {
      const e = this.frameState;
      if (!e) return null;
      const i = this.getLayer(),
        n = Bt(e.pixelToCoordinateTransform, t.slice()),
        r = i.getExtent();
      if (r && !ee(r, n)) return null;
      const s = this.image_.getExtent(),
        o = this.image_.getImage(),
        a = Fe(s),
        l = Math.floor(o.width * ((n[0] - s[0]) / a));
      if (l < 0 || l >= o.width) return null;
      const h = Re(s),
        c = Math.floor(o.height * ((s[3] - n[1]) / h));
      return c < 0 || c >= o.height ? null : this.getImageData(o, l, c);
    }
    renderFrame(t, e) {
      const i = this.image_,
        n = i.getExtent(),
        r = i.getResolution(),
        [s, o] = Array.isArray(r) ? r : [r, r],
        a = i.getPixelRatio(),
        l = t.layerStatesArray[t.layerIndex],
        h = t.pixelRatio,
        c = t.viewState,
        u = c.center,
        d = c.resolution,
        g = (h * s) / (d * a),
        f = (h * o) / (d * a),
        p = t.extent,
        m = c.resolution,
        _ = c.rotation,
        y = Math.round((Fe(p) / m) * h),
        x = Math.round((Re(p) / m) * h);
      Vt(
        this.pixelTransform,
        t.size[0] / 2,
        t.size[1] / 2,
        1 / h,
        1 / h,
        _,
        -y / 2,
        -x / 2
      ),
        Xt(this.inversePixelTransform, this.pixelTransform);
      const v = Ht(this.pixelTransform);
      this.useContainer(e, v, this.getBackground(t));
      const S = this.context,
        C = S.canvas;
      C.width != y || C.height != x
        ? ((C.width = y), (C.height = x))
        : this.containerReused || S.clearRect(0, 0, y, x);
      let w = !1,
        W = !0;
      if (l.extent) {
        const e = xn(l.extent, c.projection);
        (W = Ie(e, t.extent)),
          (w = W && !ie(e, t.extent)),
          w && this.clipUnrotated(S, t, e);
      }
      const E = i.getImage(),
        R = Vt(
          this.tempTransform,
          y / 2,
          x / 2,
          g,
          f,
          0,
          (a * (n[0] - u[0])) / s,
          (a * (u[1] - n[3])) / o
        );
      this.renderedResolution = (o * h) / a;
      const T = E.width * R[0],
        P = E.height * R[3];
      if (
        (this.getLayer().getSource().getInterpolate() ||
          (S.imageSmoothingEnabled = !1),
        this.preRender(S, t),
        W && T >= 0.5 && P >= 0.5)
      ) {
        const t = R[4],
          e = R[5],
          i = l.opacity;
        let n;
        1 !== i && ((n = S.globalAlpha), (S.globalAlpha = i)),
          S.drawImage(E, 0, 0, +E.width, +E.height, t, e, T, P),
          1 !== i && (S.globalAlpha = n);
      }
      return (
        this.postRender(S, t),
        w && S.restore(),
        (S.imageSmoothingEnabled = !0),
        v !== C.style.transform && (C.style.transform = v),
        this.container
      );
    }
  };
  var Df = class extends Af {
      constructor(t) {
        super(t);
      }
      createRenderer() {
        return new Nf(this);
      }
      getData(t) {
        return super.getData(t);
      }
    },
    Gf = "preload",
    Bf = "useInterimTilesOnError";
  var jf = class extends no {
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.preload,
        delete e.useInterimTilesOnError,
        super(e),
        this.on,
        this.once,
        this.un,
        this.setPreload(void 0 !== t.preload ? t.preload : 0),
        this.setUseInterimTilesOnError(
          void 0 === t.useInterimTilesOnError || t.useInterimTilesOnError
        );
    }
    getPreload() {
      return this.get(Gf);
    }
    setPreload(t) {
      this.set(Gf, t);
    }
    getUseInterimTilesOnError() {
      return this.get(Bf);
    }
    setUseInterimTilesOnError(t) {
      this.set(Bf, t);
    }
    getData(t) {
      return super.getData(t);
    }
  };
  var zf = class extends tu {
    constructor(t) {
      super(t),
        (this.extentChanged = !0),
        (this.renderedExtent_ = null),
        this.renderedPixelRatio,
        (this.renderedProjection = null),
        this.renderedRevision,
        (this.renderedTiles = []),
        (this.newTiles_ = !1),
        (this.tmpExtent = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        (this.tmpTileRange_ = new Ig(0, 0, 0, 0));
    }
    isDrawableTile(t) {
      const e = this.getLayer(),
        i = t.getState(),
        n = e.getUseInterimTilesOnError();
      return i == Q || i == J || (i == $ && !n);
    }
    getTile(t, e, i, n) {
      const r = n.pixelRatio,
        s = n.viewState.projection,
        o = this.getLayer();
      let a = o.getSource().getTile(t, e, i, r, s);
      return (
        a.getState() == $ &&
          o.getUseInterimTilesOnError() &&
          o.getPreload() > 0 &&
          (this.newTiles_ = !0),
        this.isDrawableTile(a) || (a = a.getInterimTile()),
        a
      );
    }
    getData(t) {
      const e = this.frameState;
      if (!e) return null;
      const i = this.getLayer(),
        n = Bt(e.pixelToCoordinateTransform, t.slice()),
        r = i.getExtent();
      if (r && !ee(r, n)) return null;
      const s = e.pixelRatio,
        o = e.viewState.projection,
        a = e.viewState,
        l = i.getRenderSource(),
        h = l.getTileGridForProjection(a.projection),
        c = l.getTilePixelRatio(e.pixelRatio);
      for (
        let t = h.getZForResolution(a.resolution);
        t >= h.getMinZoom();
        --t
      ) {
        const e = h.getTileCoordForCoordAndZ(n, t),
          i = l.getTile(t, e[1], e[2], s, o);
        if (
          !(i instanceof is || i instanceof Cg) ||
          (i instanceof Cg && i.getState() === J)
        )
          return null;
        if (i.getState() !== Q) continue;
        const r = h.getOrigin(t),
          u = sl(h.getTileSize(t)),
          d = h.getResolution(t),
          g = Math.floor(c * ((n[0] - r[0]) / d - e[1] * u[0])),
          f = Math.floor(c * ((r[1] - n[1]) / d - e[2] * u[1])),
          p = Math.round(c * l.getGutterForProjection(a.projection));
        return this.getImageData(i.getImage(), g + p, f + p);
      }
      return null;
    }
    loadedTileCallback(t, e, i) {
      return !!this.isDrawableTile(i) && super.loadedTileCallback(t, e, i);
    }
    prepareFrame(t) {
      return !!this.getLayer().getSource();
    }
    renderFrame(t, e) {
      const i = t.layerStatesArray[t.layerIndex],
        n = t.viewState,
        r = n.projection,
        o = n.resolution,
        a = n.center,
        l = n.rotation,
        h = t.pixelRatio,
        c = this.getLayer(),
        u = c.getSource(),
        d = u.getRevision(),
        g = u.getTileGridForProjection(r),
        f = g.getZForResolution(o, u.zDirection),
        p = g.getResolution(f);
      let m = t.extent;
      const _ = t.viewState.resolution,
        y = u.getTilePixelRatio(h),
        x = Math.round((Fe(m) / _) * h),
        v = Math.round((Re(m) / _) * h),
        S = i.extent && xn(i.extent, r);
      S && (m = Te(m, xn(i.extent, r)));
      const C = (p * x) / 2 / y,
        w = (p * v) / 2 / y,
        W = [a[0] - C, a[1] - w, a[0] + C, a[1] + w],
        E = g.getTileRangeForExtentAndZ(m, f),
        R = {};
      R[f] = {};
      const T = this.createLoadedTileFinder(u, r, R),
        P = this.tmpExtent,
        b = this.tmpTileRange_;
      this.newTiles_ = !1;
      const F = l ? Ee(n.center, _, l, t.size) : void 0;
      for (let e = E.minX; e <= E.maxX; ++e)
        for (let n = E.minY; n <= E.maxY; ++n) {
          if (l && !g.tileCoordIntersectsViewport([f, e, n], F)) continue;
          const r = this.getTile(f, e, n, t);
          if (this.isDrawableTile(r)) {
            const e = j(this);
            if (r.getState() == Q) {
              R[f][r.tileCoord.toString()] = r;
              let t = r.inTransition(e);
              t && 1 !== i.opacity && (r.endTransition(e), (t = !1)),
                this.newTiles_ ||
                  (!t && this.renderedTiles.includes(r)) ||
                  (this.newTiles_ = !0);
            }
            if (1 === r.getAlpha(e, t.time)) continue;
          }
          const s = g.getTileCoordChildTileRange(r.tileCoord, b, P);
          let o = !1;
          s && (o = T(f + 1, s)),
            o || g.forEachTileCoordParentTileRange(r.tileCoord, T, b, P);
        }
      const I = ((p / o) * h) / y;
      Vt(
        this.pixelTransform,
        t.size[0] / 2,
        t.size[1] / 2,
        1 / h,
        1 / h,
        l,
        -x / 2,
        -v / 2
      );
      const L = Ht(this.pixelTransform);
      this.useContainer(e, L, this.getBackground(t));
      const M = this.context,
        O = M.canvas;
      Xt(this.inversePixelTransform, this.pixelTransform),
        Vt(this.tempTransform, x / 2, v / 2, I, I, 0, -x / 2, -v / 2),
        O.width != x || O.height != v
          ? ((O.width = x), (O.height = v))
          : this.containerReused || M.clearRect(0, 0, x, v),
        S && this.clipUnrotated(M, t, S),
        u.getInterpolate() || (M.imageSmoothingEnabled = !1),
        this.preRender(M, t),
        (this.renderedTiles.length = 0);
      let k,
        A,
        N,
        D = Object.keys(R).map(Number);
      D.sort(s),
        1 !== i.opacity ||
        (this.containerReused && !u.getOpaque(t.viewState.projection))
          ? ((k = []), (A = []))
          : (D = D.reverse());
      for (let e = D.length - 1; e >= 0; --e) {
        const i = D[e],
          n = u.getTilePixelSize(i, h, r),
          s = g.getResolution(i) / p,
          o = n[0] * s * I,
          a = n[1] * s * I,
          l = g.getTileCoordForCoordAndZ(Pe(W), i),
          c = g.getTileCoordExtent(l),
          d = Bt(this.tempTransform, [
            (y * (c[0] - W[0])) / p,
            (y * (W[3] - c[3])) / p,
          ]),
          m = y * u.getGutterForProjection(r),
          _ = R[i];
        for (const e in _) {
          const n = _[e],
            r = n.tileCoord,
            s = l[1] - r[1],
            h = Math.round(d[0] - (s - 1) * o),
            c = l[2] - r[2],
            g = Math.round(d[1] - (c - 1) * a),
            p = Math.round(d[0] - s * o),
            y = Math.round(d[1] - c * a),
            x = h - p,
            v = g - y,
            S = f === i,
            C = S && 1 !== n.getAlpha(j(this), t.time);
          let w = !1;
          if (!C)
            if (k) {
              N = [p, y, p + x, y, p + x, y + v, p, y + v];
              for (let t = 0, e = k.length; t < e; ++t)
                if (f !== i && i < A[t]) {
                  const e = k[t];
                  Ie([p, y, p + x, y + v], [e[0], e[3], e[4], e[7]]) &&
                    (w || (M.save(), (w = !0)),
                    M.beginPath(),
                    M.moveTo(N[0], N[1]),
                    M.lineTo(N[2], N[3]),
                    M.lineTo(N[4], N[5]),
                    M.lineTo(N[6], N[7]),
                    M.moveTo(e[6], e[7]),
                    M.lineTo(e[4], e[5]),
                    M.lineTo(e[2], e[3]),
                    M.lineTo(e[0], e[1]),
                    M.clip());
                }
              k.push(N), A.push(i);
            } else M.clearRect(p, y, x, v);
          this.drawTileImage(n, t, p, y, x, v, m, S),
            k && !C
              ? (w && M.restore(), this.renderedTiles.unshift(n))
              : this.renderedTiles.push(n),
            this.updateUsedTiles(t.usedTiles, u, n);
        }
      }
      return (
        (this.renderedRevision = d),
        (this.renderedResolution = p),
        (this.extentChanged =
          !this.renderedExtent_ || !ce(this.renderedExtent_, W)),
        (this.renderedExtent_ = W),
        (this.renderedPixelRatio = h),
        (this.renderedProjection = r),
        this.manageTilePyramid(t, u, g, h, r, m, f, c.getPreload()),
        this.scheduleExpireCache(t, u),
        this.postRender(M, t),
        i.extent && M.restore(),
        (M.imageSmoothingEnabled = !0),
        L !== O.style.transform && (O.style.transform = L),
        this.container
      );
    }
    drawTileImage(t, e, i, n, r, s, o, a) {
      const l = this.getTileImage(t);
      if (!l) return;
      const h = j(this),
        c = e.layerStatesArray[e.layerIndex],
        u = c.opacity * (a ? t.getAlpha(h, e.time) : 1),
        d = u !== this.context.globalAlpha;
      d && (this.context.save(), (this.context.globalAlpha = u)),
        this.context.drawImage(
          l,
          o,
          o,
          l.width - 2 * o,
          l.height - 2 * o,
          i,
          n,
          r,
          s
        ),
        d && this.context.restore(),
        u !== c.opacity ? (e.animate = !0) : a && t.endTransition(h);
    }
    getImage() {
      const t = this.context;
      return t ? t.canvas : null;
    }
    getTileImage(t) {
      return t.getImage();
    }
    scheduleExpireCache(t, e) {
      if (e.canExpireCache()) {
        const i = function (t, e, i) {
          const n = j(t);
          n in i.usedTiles &&
            t.expireCache(i.viewState.projection, i.usedTiles[n]);
        }.bind(null, e);
        t.postRenderFunctions.push(i);
      }
    }
    updateUsedTiles(t, e, i) {
      const n = j(e);
      n in t || (t[n] = {}), (t[n][i.getKey()] = !0);
    }
    manageTilePyramid(t, e, i, n, r, s, o, a, l) {
      const h = j(e);
      h in t.wantedTiles || (t.wantedTiles[h] = {});
      const c = t.wantedTiles[h],
        u = t.tileQueue,
        d = i.getMinZoom(),
        g = t.viewState.rotation,
        f = g
          ? Ee(t.viewState.center, t.viewState.resolution, g, t.size)
          : void 0;
      let p,
        m,
        _,
        y,
        x,
        v,
        S = 0;
      for (v = d; v <= o; ++v)
        for (
          m = i.getTileRangeForExtentAndZ(s, v, m),
            _ = i.getResolution(v),
            y = m.minX;
          y <= m.maxX;
          ++y
        )
          for (x = m.minY; x <= m.maxY; ++x)
            (g && !i.tileCoordIntersectsViewport([v, y, x], f)) ||
              (o - v <= a
                ? (++S,
                  (p = e.getTile(v, y, x, n, r)),
                  p.getState() == H &&
                    ((c[p.getKey()] = !0),
                    u.isKeyQueued(p.getKey()) ||
                      u.enqueue([p, h, i.getTileCoordCenter(p.tileCoord), _])),
                  void 0 !== l && l(p))
                : e.useTile(v, y, x, r));
      e.updateCacheSize(S, r);
    }
  };
  var Uf = class extends jf {
    constructor(t) {
      super(t);
    }
    createRenderer() {
      return new zf(this);
    }
  };
  function qf(t) {
    return Array.isArray(t) ? Math.min(...t) : t;
  }
  var Vf = class extends Nf {
    constructor(t) {
      super(t),
        (this.vectorRenderer_ = new Tu(t)),
        (this.layerImageRatio_ = t.getImageRatio()),
        (this.coordinateToVectorPixelTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.renderedPixelToCoordinateTransform_ = null);
    }
    disposeInternal() {
      this.vectorRenderer_.dispose(), super.disposeInternal();
    }
    getFeatures(t) {
      if (!this.vectorRenderer_) return Promise.resolve([]);
      const e = Bt(
        this.coordinateToVectorPixelTransform_,
        Bt(this.renderedPixelToCoordinateTransform_, t.slice())
      );
      return this.vectorRenderer_.getFeatures(e);
    }
    handleFontsChanged() {
      this.vectorRenderer_.handleFontsChanged();
    }
    prepareFrame(t) {
      const e = t.pixelRatio,
        i = t.viewState,
        n = i.resolution,
        r = t.viewHints,
        s = this.vectorRenderer_;
      let o = t.extent;
      1 !== this.layerImageRatio_ &&
        ((o = o.slice(0)), Oe(o, this.layerImageRatio_));
      const a = Fe(o) / n,
        l = Re(o) / n;
      if (!r[Ms] && !r[Os] && !Le(o)) {
        s.useContainer(null, null);
        const r = s.context,
          h = t.layerStatesArray[t.layerIndex],
          c = Object.assign({}, h, { opacity: 1 }),
          u = Object.assign({}, t, {
            declutterTree: new hh(9),
            extent: o,
            size: [a, l],
            viewState: Object.assign({}, t.viewState, { rotation: 0 }),
            layerStatesArray: [c],
            layerIndex: 0,
          });
        let d = !0;
        const g = new es(o, n, e, r.canvas, function (t) {
          s.prepareFrame(u) &&
            s.replayGroupChanged &&
            ((s.clipping = !1),
            s.renderFrame(u, null) && (s.renderDeclutter(u), (d = !1)),
            t());
        });
        g.addEventListener(v, () => {
          if (g.getState() !== Zr) return;
          this.image_ = d ? null : g;
          const t = g.getPixelRatio(),
            n = (qf(g.getResolution()) * e) / t;
          (this.renderedResolution = n),
            (this.coordinateToVectorPixelTransform_ = Vt(
              this.coordinateToVectorPixelTransform_,
              a / 2,
              l / 2,
              1 / n,
              -1 / n,
              0,
              -i.center[0],
              -i.center[1]
            ));
        }),
          g.load();
      }
      return (
        this.image_ &&
          (this.renderedPixelToCoordinateTransform_ =
            t.pixelToCoordinateTransform.slice()),
        !!this.image_
      );
    }
    preRender() {}
    postRender() {}
    renderDeclutter() {}
    forEachFeatureAtCoordinate(t, e, i, n, r) {
      return this.vectorRenderer_
        ? this.vectorRenderer_.forEachFeatureAtCoordinate(t, e, i, n, r)
        : super.forEachFeatureAtCoordinate(t, e, i, n, r);
    }
  };
  var Xf = class extends Cc {
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.imageRatio,
        super(e),
        (this.imageRatio_ = void 0 !== t.imageRatio ? t.imageRatio : 1);
    }
    getImageRatio() {
      return this.imageRatio_;
    }
    createRenderer() {
      return new Vf(this);
    }
  };
  const Zf = {
      image: ["Polygon", "Circle", "LineString", "Image", "Text"],
      hybrid: ["Polygon", "LineString"],
      vector: [],
    },
    Kf = {
      hybrid: ["Image", "Text", "Default"],
      vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"],
    };
  var Hf = class extends zf {
    constructor(t) {
      super(t),
        (this.boundHandleStyleImageChange_ =
          this.handleStyleImageChange_.bind(this)),
        this.renderedLayerRevision_,
        (this.renderedPixelToCoordinateTransform_ = null),
        this.renderedRotation_,
        (this.tmpTransform_ = [1, 0, 0, 1, 0, 0]);
    }
    prepareTile(t, e, i) {
      let n;
      const r = t.getState();
      return (
        (r !== Q && r !== $) ||
          (this.updateExecutorGroup_(t, e, i),
          this.tileImageNeedsRender_(t) && (n = !0)),
        n
      );
    }
    getTile(t, e, i, n) {
      const r = n.pixelRatio,
        s = n.viewState,
        o = s.resolution,
        a = s.projection,
        l = this.getLayer(),
        h = l.getSource().getTile(t, e, i, r, a),
        c = n.viewHints,
        u = !(c[Ms] || c[Os]);
      (!u && h.wantedResolution) || (h.wantedResolution = o);
      return (
        this.prepareTile(h, r, a) &&
          (u || Date.now() - n.time < 8) &&
          "vector" !== l.getRenderMode() &&
          this.renderTileImage_(h, n),
        super.getTile(t, e, i, n)
      );
    }
    isDrawableTile(t) {
      const e = this.getLayer();
      return (
        super.isDrawableTile(t) &&
        ("vector" === e.getRenderMode()
          ? j(e) in t.executorGroups
          : t.hasContext(e))
      );
    }
    getTileImage(t) {
      return t.getImage(this.getLayer());
    }
    prepareFrame(t) {
      const e = this.getLayer().getRevision();
      return (
        this.renderedLayerRevision_ !== e &&
          ((this.renderedLayerRevision_ = e), (this.renderedTiles.length = 0)),
        super.prepareFrame(t)
      );
    }
    updateExecutorGroup_(t, e, i) {
      const n = this.getLayer(),
        r = n.getRevision(),
        s = n.getRenderOrder() || null,
        o = t.wantedResolution,
        a = t.getReplayState(n);
      if (
        !a.dirty &&
        a.renderedResolution === o &&
        a.renderedRevision == r &&
        a.renderedRenderOrder == s
      )
        return;
      const l = n.getSource(),
        h = n.getDeclutter(),
        c = l.getTileGrid(),
        u = l
          .getTileGridForProjection(i)
          .getTileCoordExtent(t.wrappedTileCoord),
        d = l.getSourceTiles(e, i, t),
        g = j(n);
      delete t.hitDetectionImageData[g],
        (t.executorGroups[g] = []),
        h && (t.declutterExecutorGroups[g] = []),
        (a.dirty = !1);
      for (let i = 0, r = d.length; i < r; ++i) {
        const r = d[i];
        if (r.getState() != Q) continue;
        const f = r.tileCoord,
          p = c.getTileCoordExtent(f),
          m = Te(u, p),
          _ = $t(m, n.getRenderBuffer() * o, this.tmpExtent),
          y = ce(p, m) ? null : _,
          x = new Yc(0, _, o, e),
          v = h ? new Yc(0, m, o, e) : void 0,
          S = wu(o, e),
          C = function (t) {
            let e;
            const i = t.getStyleFunction() || n.getStyleFunction();
            if ((i && (e = i(t, o)), e)) {
              const i = this.renderFeature(t, S, e, x, v);
              a.dirty = a.dirty || i;
            }
          },
          w = r.getFeatures();
        s && s !== a.renderedRenderOrder && w.sort(s);
        for (let t = 0, e = w.length; t < e; ++t) {
          const e = w[t];
          (y && !Ie(y, e.getGeometry().getExtent())) || C.call(this, e);
        }
        const W = x.finish(),
          E = "vector" !== n.getRenderMode() && h && 1 === d.length ? null : m,
          R = new pu(E, o, e, l.getOverlaps(), W, n.getRenderBuffer());
        if ((t.executorGroups[g].push(R), v)) {
          const i = new pu(
            null,
            o,
            e,
            l.getOverlaps(),
            v.finish(),
            n.getRenderBuffer()
          );
          t.declutterExecutorGroups[g].push(i);
        }
      }
      (a.renderedRevision = r),
        (a.renderedRenderOrder = s),
        (a.renderedResolution = o);
    }
    forEachFeatureAtCoordinate(t, e, i, n, r) {
      const s = e.viewState.resolution,
        o = e.viewState.rotation;
      i = null == i ? 0 : i;
      const a = this.getLayer(),
        l = a.getSource().getTileGridForProjection(e.viewState.projection),
        h = Qt([t]);
      $t(h, s * i, h);
      const c = {},
        u = function (t, e, i) {
          let s = t.getId();
          void 0 === s && (s = j(t));
          const o = c[s];
          if (o) {
            if (!0 !== o && i < o.distanceSq) {
              if (0 === i)
                return (c[s] = !0), r.splice(r.lastIndexOf(o), 1), n(t, a, e);
              (o.geometry = e), (o.distanceSq = i);
            }
          } else {
            if (0 === i) return (c[s] = !0), n(t, a, e);
            r.push(
              (c[s] = {
                feature: t,
                layer: a,
                geometry: e,
                distanceSq: i,
                callback: n,
              })
            );
          }
        },
        d = this.renderedTiles;
      let g;
      for (let n = 0, r = d.length; !g && n < r; ++n) {
        const r = d[n];
        if (!Ie(l.getTileCoordExtent(r.wrappedTileCoord), h)) continue;
        const c = j(a),
          f = [r.executorGroups[c]],
          p = r.declutterExecutorGroups[c];
        p && f.push(p),
          f.some((n) => {
            const r =
              n === p ? e.declutterTree.all().map((t) => t.value) : null;
            for (let e = 0, a = n.length; e < a; ++e) {
              const a = n[e];
              if (((g = a.forEachFeatureAtCoordinate(t, s, o, i, u, r)), g))
                return !0;
            }
          });
      }
      return g;
    }
    getFeatures(t) {
      return new Promise((e, i) => {
        const n = this.getLayer(),
          r = j(n),
          s = n.getSource(),
          o = this.renderedProjection,
          a = o.getExtent(),
          l = this.renderedResolution,
          h = s.getTileGridForProjection(o),
          c = Bt(this.renderedPixelToCoordinateTransform_, t.slice()),
          u = h.getTileCoordForCoordAndResolution(c, l);
        let d;
        for (let t = 0, e = this.renderedTiles.length; t < e; ++t)
          if (u.toString() === this.renderedTiles[t].tileCoord.toString()) {
            if (((d = this.renderedTiles[t]), d.getState() === Q)) {
              const t = h.getTileCoordExtent(d.tileCoord);
              s.getWrapX() && o.canWrapX() && !ie(a, t) && Ni(c, o);
              break;
            }
            d = void 0;
          }
        if (!d || d.loadingSourceTiles > 0) return void e([]);
        const g = Pe(h.getTileCoordExtent(d.wrappedTileCoord)),
          f = [(c[0] - g[0]) / l, (g[1] - c[1]) / l],
          p = d.getSourceTiles().reduce(function (t, e) {
            return t.concat(e.getFeatures());
          }, []);
        let m = d.hitDetectionImageData[r];
        if (!m) {
          const t = sl(h.getTileSize(h.getZForResolution(l, s.zDirection))),
            e = this.renderedRotation_;
          (m = yu(
            t,
            [
              this.getRenderTransform(
                h.getTileCoordCenter(d.wrappedTileCoord),
                l,
                0,
                _u,
                t[0] * _u,
                t[1] * _u,
                0
              ),
            ],
            p,
            n.getStyleFunction(),
            h.getTileCoordExtent(d.wrappedTileCoord),
            d.getReplayState(n).renderedResolution,
            e
          )),
            (d.hitDetectionImageData[r] = m);
        }
        e(xu(f, p, m));
      });
    }
    handleFontsChanged() {
      const t = this.getLayer();
      t.getVisible() && void 0 !== this.renderedLayerRevision_ && t.changed();
    }
    handleStyleImageChange_(t) {
      this.renderIfReadyAndVisible();
    }
    renderDeclutter(t) {
      const e = this.context,
        i = e.globalAlpha;
      e.globalAlpha = this.getLayer().getOpacity();
      const n = t.viewHints,
        r = !(n[Ms] || n[Os]),
        s = this.renderedTiles;
      for (let e = 0, i = s.length; e < i; ++e) {
        const i = s[e],
          n = i.declutterExecutorGroups[j(this.getLayer())];
        if (n)
          for (let e = n.length - 1; e >= 0; --e)
            n[e].execute(
              this.context,
              1,
              this.getTileRenderTransform(i, t),
              t.viewState.rotation,
              r,
              void 0,
              t.declutterTree
            );
      }
      e.globalAlpha = i;
    }
    getTileRenderTransform(t, e) {
      const i = e.pixelRatio,
        n = e.viewState,
        r = n.center,
        s = n.resolution,
        o = n.rotation,
        a = e.size,
        l = Math.round(a[0] * i),
        h = Math.round(a[1] * i),
        c = this.getLayer()
          .getSource()
          .getTileGridForProjection(e.viewState.projection),
        u = t.tileCoord,
        d = c.getTileCoordExtent(t.wrappedTileCoord),
        g = c.getTileCoordExtent(u, this.tmpExtent)[0] - d[0];
      return Nt(
        zt(this.inversePixelTransform.slice(), 1 / i, 1 / i),
        this.getRenderTransform(r, s, o, i, l, h, g)
      );
    }
    postRender(t, e) {
      const i = e.viewHints,
        n = !(i[Ms] || i[Os]);
      (this.renderedPixelToCoordinateTransform_ =
        e.pixelToCoordinateTransform.slice()),
        (this.renderedRotation_ = e.viewState.rotation);
      const r = this.getLayer(),
        s = r.getRenderMode(),
        o = t.globalAlpha;
      t.globalAlpha = r.getOpacity();
      const a = Kf[s],
        l = e.viewState,
        h = l.rotation,
        c = r.getSource(),
        u = c
          .getTileGridForProjection(l.projection)
          .getZForResolution(l.resolution, c.zDirection),
        d = this.renderedTiles,
        g = [],
        f = [];
      let p = !0;
      for (let i = d.length - 1; i >= 0; --i) {
        const s = d[i];
        p = p && !s.getReplayState(r).dirty;
        const o = s.executorGroups[j(r)].filter((t) => t.hasExecutors(a));
        if (0 === o.length) continue;
        const l = this.getTileRenderTransform(s, e),
          c = s.tileCoord[0];
        let m = !1;
        const _ = o[0].getClipCoords(l);
        if (_) {
          for (let e = 0, i = g.length; e < i; ++e)
            if (u !== c && c < f[e]) {
              const i = g[e];
              Ie([_[0], _[3], _[4], _[7]], [i[0], i[3], i[4], i[7]]) &&
                (m || (t.save(), (m = !0)),
                t.beginPath(),
                t.moveTo(_[0], _[1]),
                t.lineTo(_[2], _[3]),
                t.lineTo(_[4], _[5]),
                t.lineTo(_[6], _[7]),
                t.moveTo(i[6], i[7]),
                t.lineTo(i[4], i[5]),
                t.lineTo(i[2], i[3]),
                t.lineTo(i[0], i[1]),
                t.clip());
            }
          g.push(_), f.push(c);
        }
        for (let e = 0, i = o.length; e < i; ++e) {
          o[e].execute(t, 1, l, h, n, a);
        }
        m && t.restore();
      }
      (t.globalAlpha = o), (this.ready = p), super.postRender(t, e);
    }
    renderFeature(t, e, i, n, r) {
      if (!i) return !1;
      let s = !1;
      if (Array.isArray(i))
        for (let o = 0, a = i.length; o < a; ++o)
          s =
            Eu(n, t, i[o], e, this.boundHandleStyleImageChange_, void 0, r) ||
            s;
      else s = Eu(n, t, i, e, this.boundHandleStyleImageChange_, void 0, r);
      return s;
    }
    tileImageNeedsRender_(t) {
      const e = this.getLayer();
      if ("vector" === e.getRenderMode()) return !1;
      const i = t.getReplayState(e),
        n = e.getRevision(),
        r = t.wantedResolution;
      return i.renderedTileResolution !== r || i.renderedTileRevision !== n;
    }
    renderTileImage_(t, e) {
      const i = this.getLayer(),
        n = t.getReplayState(i),
        r = i.getRevision(),
        s = t.executorGroups[j(i)];
      n.renderedTileRevision = r;
      const o = t.wrappedTileCoord,
        a = o[0],
        l = i.getSource();
      let h = e.pixelRatio;
      const c = e.viewState.projection,
        u = l.getTileGridForProjection(c),
        d = u.getResolution(t.tileCoord[0]),
        g = (e.pixelRatio / t.wantedResolution) * d,
        f = u.getResolution(a),
        p = t.getContext(i);
      h = Math.round(Math.max(h, g / h));
      const m = l.getTilePixelSize(a, h, c);
      (p.canvas.width = m[0]), (p.canvas.height = m[1]);
      const _ = h / g;
      if (1 !== _) {
        const t = At(this.tmpTransform_);
        zt(t, _, _), p.setTransform.apply(p, t);
      }
      const y = u.getTileCoordExtent(o, this.tmpExtent),
        x = g / f,
        v = At(this.tmpTransform_);
      zt(v, x, -x), qt(v, -y[0], -y[3]);
      for (let t = 0, e = s.length; t < e; ++t) {
        s[t].execute(p, _, v, 0, !0, Zf[i.getRenderMode()]);
      }
      n.renderedTileResolution = t.wantedResolution;
    }
  };
  var Yf = class extends Cc {
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t);
      delete e.preload,
        delete e.useInterimTilesOnError,
        super(e),
        this.on,
        this.once,
        this.un;
      const i = t.renderMode || "hybrid";
      Ft(
        "hybrid" == i || "vector" == i,
        "`renderMode` must be `'hybrid'` or `'vector'`"
      ),
        (this.renderMode_ = i),
        this.setPreload(t.preload ? t.preload : 0),
        this.setUseInterimTilesOnError(
          void 0 === t.useInterimTilesOnError || t.useInterimTilesOnError
        ),
        this.getBackground,
        this.setBackground;
    }
    createRenderer() {
      return new Hf(this);
    }
    getFeatures(t) {
      return super.getFeatures(t);
    }
    getRenderMode() {
      return this.renderMode_;
    }
    getPreload() {
      return this.get(Gf);
    }
    getUseInterimTilesOnError() {
      return this.get(Bf);
    }
    setPreload(t) {
      this.set(Gf, t);
    }
    setUseInterimTilesOnError(t) {
      this.set(Bf, t);
    }
  };
  function Qf(t) {
    const e = hs(t);
    return [256 * e[0] + e[1], 256 * e[2] + Math.round(255 * e[3])];
  }
  function $f(t) {
    return t === Qg.COLOR ? 2 : t === Qg.NUMBER_ARRAY ? 4 : 1;
  }
  function Jf(t) {
    const e = $f(t);
    return e > 1 ? `vec${e}` : "float";
  }
  function tp(t, e, i, n) {
    let r;
    if (
      (`${n}radius` in t && "icon-" !== n
        ? (r = cf(i, t[`${n}radius`], Qg.NUMBER))
        : `${n}radius1` in t &&
          "shape-" === n &&
          (r = cf(i, t[`${n}radius1`], Qg.NUMBER)),
      void 0 !== r &&
        (`${n}stroke-width` in t &&
          (r = `(${r} + ${cf(i, t[`${n}stroke-width`], Qg.NUMBER)} * 0.5)`),
        e.setSymbolSizeExpression(`vec2(${r} * 2. + 0.5)`)),
      `${n}scale` in t)
    ) {
      const r = cf(i, t[`${n}scale`], Qg.NUMBER | Qg.NUMBER_ARRAY);
      e.setSymbolSizeExpression(`${e.getSymbolSizeExpression()} * ${r}`);
    }
    `${n}displacement` in t &&
      e.setSymbolOffsetExpression(
        cf(i, t[`${n}displacement`], Qg.NUMBER_ARRAY)
      ),
      `${n}rotation` in t &&
        e.setSymbolRotationExpression(cf(i, t[`${n}rotation`], Qg.NUMBER)),
      `${n}rotate-with-view` in t &&
        e.setSymbolRotateWithView(!!t[`${n}rotate-with-view`]);
  }
  function ep(t, e, i, n, r) {
    let s = "vec4(0.)";
    if ((null !== e && (s = e), null !== i && null !== n)) {
      s = `mix(${i}, ${s}, ${`smoothstep(-${n} + 0.63, -${n} - 0.58, ${t})`})`;
    }
    let o = `${s} * ${`(1.0 - smoothstep(-0.63, 0.58, ${t}))`}`;
    return null !== r && (o = `${o} * ${r}`), o;
  }
  function ip(t) {
    const e = {
        inFragmentShader: !1,
        variables: [],
        attributes: [],
        functions: {},
        style: t,
      },
      i = {
        inFragmentShader: !0,
        variables: e.variables,
        attributes: [],
        functions: {},
        style: t,
      },
      n = new Ff(),
      r = {};
    if (
      ("icon-src" in t || "icon-img" in t
        ? (function (t, e, i, n, r) {
            r.functions.samplePremultiplied =
              "vec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {\n  vec4 color = texture2D(sampler, texCoord);\n  return vec4(color.rgb * color.a, color.a);\n}";
            let s,
              o,
              a = "vec4(1.0)";
            "icon-color" in t && (a = cf(r, t["icon-color"], Qg.COLOR)),
              "icon-opacity" in t &&
                (a = `${a} * ${cf(r, t["icon-opacity"], Qg.NUMBER)}`);
            const l = j(t);
            if (
              ("icon-src" in t
                ? ((s = new Image()),
                  (s.crossOrigin =
                    void 0 === t["icon-cross-origin"]
                      ? "anonymous"
                      : t["icon-cross-origin"]),
                  (s.src = t["icon-src"]),
                  (i[`u_texture${l}_size`] = () =>
                    s.complete ? [s.width, s.height] : [0, 0]),
                  (o = `u_texture${l}_size`),
                  e.addUniform(`vec2 u_texture${l}_size`))
                : ((s = t["icon-img"]),
                  s instanceof HTMLImageElement
                    ? s.complete && s.width && s.height
                      ? (o = rf([s.width, s.height]))
                      : ((i[`u_texture${l}_size`] = () =>
                          s.complete ? [s.width, s.height] : [0, 0]),
                        (o = `u_texture${l}_size`))
                    : (o = rf([s.width, s.height]))),
              (i[`u_texture${l}`] = s),
              e
                .addUniform(`sampler2D u_texture${l}`)
                .setSymbolColorExpression(
                  `${a} * samplePremultiplied(u_texture${l}, v_texCoord)`
                )
                .setSymbolSizeExpression(o),
              "icon-width" in t &&
                "icon-height" in t &&
                e.setSymbolSizeExpression(
                  `vec2(${cf(n, t["icon-width"], Qg.NUMBER)}, ${cf(
                    n,
                    t["icon-height"],
                    Qg.NUMBER
                  )})`
                ),
              "icon-offset" in t && "icon-size" in t)
            ) {
              let i = cf(n, t["icon-offset"], Qg.NUMBER_ARRAY);
              const r = cf(n, t["icon-size"], Qg.NUMBER_ARRAY),
                s = e.getSymbolSizeExpression();
              if ((e.setSymbolSizeExpression(r), "icon-offset-origin" in t))
                switch (t["icon-offset-origin"]) {
                  case "top-right":
                    i = `vec2(v_quadSizePx.x, 0.) + ${r} * vec2(-1., 0.) + ${i} * vec2(-1., 1.)`;
                    break;
                  case "bottom-left":
                    i = `vec2(0., v_quadSizePx.y) + ${r} * vec2(0., -1.) + ${i} * vec2(1., -1.)`;
                    break;
                  case "bottom-right":
                    i = `v_quadSizePx - ${r} - ${i}`;
                }
              e.setTextureCoordinateExpression(
                `(vec4((${i}).xyxy) + vec4(0., 0., ${r})) / (${s}).xyxy`
              );
            }
            if ((tp(t, e, n, "icon-"), "icon-anchor" in t)) {
              const i = cf(n, t["icon-anchor"], Qg.NUMBER_ARRAY);
              let r,
                s = "1.0";
              "icon-scale" in t &&
                (s = cf(n, t["icon-scale"], Qg.NUMBER | Qg.NUMBER_ARRAY)),
                (r =
                  "pixels" === t["icon-anchor-x-units"] &&
                  "pixels" === t["icon-anchor-y-units"]
                    ? `${i} * ${s}`
                    : "pixels" === t["icon-anchor-x-units"]
                    ? `${i} * vec2(vec2(${s}).x, v_quadSizePx.y)`
                    : "pixels" === t["icon-anchor-y-units"]
                    ? `${i} * vec2(v_quadSizePx.x, vec2(${s}).x)`
                    : `${i} * v_quadSizePx`);
              let o = `v_quadSizePx * vec2(0.5, -0.5) + ${r} * vec2(-1., 1.)`;
              if ("icon-anchor-origin" in t)
                switch (t["icon-anchor-origin"]) {
                  case "top-right":
                    o = `v_quadSizePx * -0.5 + ${r}`;
                    break;
                  case "bottom-left":
                    o = `v_quadSizePx * 0.5 - ${r}`;
                    break;
                  case "bottom-right":
                    o = `v_quadSizePx * vec2(-0.5, 0.5) + ${r} * vec2(1., -1.)`;
                }
              e.setSymbolOffsetExpression(
                `${e.getSymbolOffsetExpression()} + ${o}`
              );
            }
          })(t, n, r, e, i)
        : "shape-points" in t
        ? (function (t, e, i, n, r) {
            (r.functions.round =
              "float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}"),
              (r.functions.starDistanceField =
                "float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}"),
              (r.functions.regularDistanceField =
                "float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}"),
              tp(t, e, n, "shape-");
            let s = null;
            "shape-opacity" in t && (s = cf(r, t["shape-opacity"], Qg.NUMBER));
            let o = "coordsPx";
            "shape-scale" in t &&
              (o = `coordsPx / ${cf(
                r,
                t["shape-scale"],
                Qg.NUMBER | Qg.NUMBER_ARRAY
              )}`);
            let a = null;
            "shape-fill-color" in t &&
              (a = cf(r, t["shape-fill-color"], Qg.COLOR));
            let l = null;
            "shape-stroke-color" in t &&
              (l = cf(r, t["shape-stroke-color"], Qg.COLOR));
            let h = null;
            "shape-stroke-width" in t &&
              (h = cf(r, t["shape-stroke-width"], Qg.NUMBER));
            const c = cf(r, t["shape-points"], Qg.NUMBER);
            let u,
              d = "0.";
            if (
              ("shape-angle" in t && (d = cf(r, t["shape-angle"], Qg.NUMBER)),
              "shape-radius" in t)
            ) {
              let e = cf(r, t["shape-radius"], Qg.NUMBER);
              null !== h && (e = `${e} + ${h} * 0.5`),
                (u = `regularDistanceField(${o}, ${c}, ${e}, ${d})`);
            } else {
              let e = cf(r, t["shape-radius1"], Qg.NUMBER),
                i = cf(r, t["shape-radius2"], Qg.NUMBER);
              null !== h &&
                ((e = `${e} + ${h} * 0.5`), (i = `${i} + ${h} * 0.5`)),
                (u = `starDistanceField(${o}, ${c}, ${i}, ${e}, ${d})`);
            }
            const g = ep(u, a, l, h, s);
            e.setSymbolColorExpression(g);
          })(t, n, 0, e, i)
        : "circle-radius" in t &&
          (function (t, e, i, n, r) {
            (r.functions.circleDistanceField =
              "float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}"),
              tp(t, e, n, "circle-");
            let s = null;
            "circle-opacity" in t &&
              (s = cf(r, t["circle-opacity"], Qg.NUMBER));
            let o = "coordsPx";
            "circle-scale" in t &&
              (o = `coordsPx / ${cf(
                r,
                t["circle-scale"],
                Qg.NUMBER | Qg.NUMBER_ARRAY
              )}`);
            let a = null;
            "circle-fill-color" in t &&
              (a = cf(r, t["circle-fill-color"], Qg.COLOR));
            let l = null;
            "circle-stroke-color" in t &&
              (l = cf(r, t["circle-stroke-color"], Qg.COLOR));
            let h = cf(r, t["circle-radius"], Qg.NUMBER),
              c = null;
            "circle-stroke-width" in t &&
              ((c = cf(r, t["circle-stroke-width"], Qg.NUMBER)),
              (h = `(${h} + ${c} * 0.5)`));
            const u = ep(`circleDistanceField(${o}, ${h})`, a, l, c, s);
            e.setSymbolColorExpression(u);
          })(t, n, 0, e, i),
      (function (t, e, i, n, r) {
        if (
          ("stroke-color" in t &&
            e.setStrokeColorExpression(cf(r, t["stroke-color"], Qg.COLOR)),
          "stroke-width" in t &&
            e.setStrokeWidthExpression(cf(n, t["stroke-width"], Qg.NUMBER)),
          "stroke-offset" in t &&
            e.setStrokeOffsetExpression(cf(n, t["stroke-offset"], Qg.NUMBER)),
          "stroke-line-cap" in t &&
            e.setStrokeCapExpression(cf(n, t["stroke-line-cap"], Qg.STRING)),
          "stroke-line-join" in t &&
            e.setStrokeJoinExpression(cf(n, t["stroke-line-join"], Qg.STRING)),
          "stroke-miter-limit" in t &&
            e.setStrokeMiterLimitExpression(
              cf(n, t["stroke-miter-limit"], Qg.NUMBER)
            ),
          "stroke-line-dash" in t)
        ) {
          r.functions.getSingleDashDistance = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${hf(
            "square"
          )}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${hf(
            "round"
          )}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;
          let i = t["stroke-line-dash"].map((t) => cf(r, t, Qg.NUMBER));
          i.length % 2 == 1 && (i = [...i, ...i]);
          let s = "0.";
          "stroke-line-dash-offset" in t &&
            (s = cf(n, t["stroke-line-dash-offset"], Qg.NUMBER));
          let o = JSON.stringify(t["stroke-line-dash"])
            .split("")
            .reduce((t, e) => (t << 5) - t + e.charCodeAt(0), 0);
          o >>>= 0;
          const a = `dashDistanceField_${o}`,
            l = i.map((t, e) => `float dashLength${e} = ${t};`),
            h = i.map((t, e) => `dashLength${e}`).join(" + ");
          let c = "0.",
            u = `getSingleDashDistance(distance, radius, ${c}, dashLength0, totalDashLength, capType)`;
          for (let t = 2; t < i.length; t += 2)
            (c = `${c} + dashLength${t - 2} + dashLength${t - 1}`),
              (u = `min(${u}, getSingleDashDistance(distance, radius, ${c}, dashLength${t}, totalDashLength, capType))`);
          (r.functions[
            a
          ] = `float ${a}(float distance, float radius, float capType) {\n  ${l.join(
            "\n  "
          )}\n  float totalDashLength = ${h};\n  return ${u};\n}`),
            e.setStrokeDistanceFieldExpression(
              `${a}(currentLengthPx + ${s}, currentRadiusPx, capType)`
            );
        }
      })(t, n, 0, e, i),
      (function (t, e, i, n, r) {
        "fill-color" in t &&
          e.setFillColorExpression(cf(r, t["fill-color"], Qg.COLOR));
      })(t, n, 0, 0, i),
      t.filter)
    ) {
      const e = cf(i, t.filter, Qg.BOOLEAN);
      n.setFragmentDiscardExpression(`!${e}`);
    }
    i.variables.forEach(function (e) {
      const i = Cf(e.name);
      let s;
      n.addUniform(`${Jf(e.type)} ${i}`),
        (s =
          e.type === Qg.STRING
            ? () => lf(t.variables[e.name])
            : e.type === Qg.COLOR
            ? () => Qf([...hs(t.variables[e.name] || "#eee")])
            : e.type === Qg.BOOLEAN
            ? () => (t.variables[e.name] ? 1 : 0)
            : () => t.variables[e.name]),
        (r[i] = s);
    }),
      i.attributes.forEach(function (t) {
        e.attributes.find((e) => e.name === t.name) || e.attributes.push(t);
        let i = Jf(t.type),
          r = `a_${t.name}`;
        t.type === Qg.COLOR &&
          ((i = "vec4"),
          (r = `unpackColor(${r})`),
          n.addVertexShaderFunction(
            "vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}"
          )),
          n.addVarying(`v_${t.name}`, i, r);
      }),
      e.attributes.forEach(function (t) {
        n.addAttribute(`${Jf(t.type)} a_${t.name}`);
      });
    const s = e.attributes.map(function (t) {
      let e;
      return (
        (e = t.callback
          ? t.callback
          : t.type === Qg.STRING
          ? (e) => lf(e.get(t.name))
          : t.type === Qg.COLOR
          ? (e) => Qf([...hs(e.get(t.name) || "#eee")])
          : t.type === Qg.BOOLEAN
          ? (e) => (e.get(t.name) ? 1 : 0)
          : (e) => e.get(t.name)),
        { name: t.name, size: $f(t.type), callback: e }
      );
    });
    for (const t in e.functions) n.addVertexShaderFunction(e.functions[t]);
    for (const t in i.functions) n.addFragmentShaderFunction(i.functions[t]);
    return {
      builder: n,
      attributes: s.reduce(
        (t, e) => ({ ...t, [e.name]: { callback: e.callback, size: e.size } }),
        {}
      ),
      uniforms: r,
    };
  }
  var np = class extends no {
    constructor(t) {
      super(Object.assign({}, t)),
        (this.parseResult_ = ip(t.style)),
        (this.styleVariables_ = t.style.variables || {}),
        (this.hitDetectionDisabled_ = !!t.disableHitDetection);
    }
    createRenderer() {
      const t = Object.keys(this.parseResult_.attributes).map((t) => ({
        name: t,
        ...this.parseResult_.attributes[t],
      }));
      return new cg(this, {
        vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
        fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
        hitDetectionEnabled: !this.hitDetectionDisabled_,
        uniforms: this.parseResult_.uniforms,
        attributes: t,
      });
    }
    updateStyleVariables(t) {
      Object.assign(this.styleVariables_, t), this.changed();
    }
  };
  function rp(t, e) {
    const i = `\n    attribute vec2 ${Kg.TEXTURE_COORD};\n    uniform mat4 ${Zg.TILE_TRANSFORM};\n    uniform float ${Zg.TEXTURE_PIXEL_WIDTH};\n    uniform float ${Zg.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${Zg.TEXTURE_RESOLUTION};\n    uniform float ${Zg.TEXTURE_ORIGIN_X};\n    uniform float ${Zg.TEXTURE_ORIGIN_Y};\n    uniform float ${Zg.DEPTH};\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ${Kg.TEXTURE_COORD};\n      v_mapCoord = vec2(\n        ${Zg.TEXTURE_ORIGIN_X} + ${Zg.TEXTURE_RESOLUTION} * ${Zg.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],\n        ${Zg.TEXTURE_ORIGIN_Y} - ${Zg.TEXTURE_RESOLUTION} * ${Zg.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]\n      );\n      gl_Position = ${Zg.TILE_TRANSFORM} * vec4(${Kg.TEXTURE_COORD}, ${Zg.DEPTH}, 1.0);\n    }\n  `,
      n = {
        inFragmentShader: !0,
        variables: [],
        attributes: [],
        functions: {},
        bandCount: e,
        style: t,
      },
      r = [];
    if (void 0 !== t.color) {
      const e = cf(n, t.color, Qg.COLOR);
      r.push(`color = ${e};`);
    }
    if (void 0 !== t.contrast) {
      const e = cf(n, t.contrast, Qg.NUMBER);
      r.push(
        `color.rgb = clamp((${e} + 1.0) * color.rgb - (${e} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
      );
    }
    if (void 0 !== t.exposure) {
      const e = cf(n, t.exposure, Qg.NUMBER);
      r.push(
        `color.rgb = clamp((${e} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
      );
    }
    if (void 0 !== t.saturation) {
      const e = cf(n, t.saturation, Qg.NUMBER);
      r.push(
        `\n      float saturation = ${e} + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    `
      );
    }
    if (void 0 !== t.gamma) {
      const e = cf(n, t.gamma, Qg.NUMBER);
      r.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${e}));`);
    }
    if (void 0 !== t.brightness) {
      const e = cf(n, t.brightness, Qg.NUMBER);
      r.push(
        `color.rgb = clamp(color.rgb + ${e}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`
      );
    }
    const s = {},
      o = n.variables.length;
    if (o > 1 && !t.variables)
      throw new Error(`Missing variables in style (expected ${n.variables})`);
    for (let e = 0; e < o; ++e) {
      const i = n.variables[e];
      if (!(i.name in t.variables))
        throw new Error(`Missing '${i.name}' in style variables`);
      s[Cf(i.name)] = function () {
        let e = t.variables[i.name];
        return "string" == typeof e && (e = lf(e)), void 0 !== e ? e : -9999999;
      };
    }
    const a = Object.keys(s).map(function (t) {
        return `uniform float ${t};`;
      }),
      l = Math.ceil(e / 4);
    a.push(`uniform sampler2D ${Zg.TILE_TEXTURE_ARRAY}[${l}];`),
      n.paletteTextures &&
        a.push(`uniform sampler2D ${wf}[${n.paletteTextures.length}];`);
    const h = Object.keys(n.functions).map(function (t) {
      return n.functions[t];
    });
    return {
      vertexShader: i,
      fragmentShader: `\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ${
        Zg.RENDER_EXTENT
      };\n    uniform float ${Zg.TRANSITION_ALPHA};\n    uniform float ${
        Zg.TEXTURE_PIXEL_WIDTH
      };\n    uniform float ${Zg.TEXTURE_PIXEL_HEIGHT};\n    uniform float ${
        Zg.RESOLUTION
      };\n    uniform float ${Zg.ZOOM};\n\n    ${a.join("\n")}\n\n    ${h.join(
        "\n"
      )}\n\n    void main() {\n      if (\n        v_mapCoord[0] < ${
        Zg.RENDER_EXTENT
      }[0] ||\n        v_mapCoord[1] < ${
        Zg.RENDER_EXTENT
      }[1] ||\n        v_mapCoord[0] > ${
        Zg.RENDER_EXTENT
      }[2] ||\n        v_mapCoord[1] > ${
        Zg.RENDER_EXTENT
      }[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(${
        Zg.TILE_TEXTURE_ARRAY
      }[0],  v_textureCoord);\n\n      ${r.join(
        "\n"
      )}\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ${
        Zg.TRANSITION_ALPHA
      };\n    }`,
      uniforms: s,
      paletteTextures: n.paletteTextures,
    };
  }
  class sp extends jf {
    constructor(t) {
      const e = (t = t ? Object.assign({}, t) : {}).style || {};
      delete t.style;
      const i = t.cacheSize;
      delete t.cacheSize,
        super(t),
        (this.sources_ = t.sources),
        (this.renderedSource_ = null),
        (this.renderedResolution_ = NaN),
        (this.style_ = e),
        (this.cacheSize_ = i),
        (this.styleVariables_ = this.style_.variables || {}),
        this.addChangeListener(Es, this.handleSourceUpdate_);
    }
    getSources(t, e) {
      const i = this.getSource();
      return this.sources_
        ? "function" == typeof this.sources_
          ? this.sources_(t, e)
          : this.sources_
        : i
        ? [i]
        : [];
    }
    getRenderSource() {
      return this.renderedSource_ || this.getSource();
    }
    getSourceState() {
      const t = this.getRenderSource();
      return t ? t.getState() : "undefined";
    }
    handleSourceUpdate_() {
      this.hasRenderer() && this.getRenderer().clearCache(),
        this.getSource() && this.setStyle(this.style_);
    }
    getSourceBandCount_() {
      const t = Number.MAX_SAFE_INTEGER,
        e = this.getSources([-t, -t, t, t], t);
      return e && e.length && "bandCount" in e[0] ? e[0].bandCount : 4;
    }
    createRenderer() {
      const t = rp(this.style_, this.getSourceBandCount_());
      return new Yg(this, {
        vertexShader: t.vertexShader,
        fragmentShader: t.fragmentShader,
        uniforms: t.uniforms,
        cacheSize: this.cacheSize_,
        paletteTextures: t.paletteTextures,
      });
    }
    renderSources(t, e) {
      const i = this.getRenderer();
      let n;
      for (let r = 0, s = e.length; r < s; ++r)
        (this.renderedSource_ = e[r]),
          i.prepareFrame(t) && (n = i.renderFrame(t));
      return n;
    }
    render(t, e) {
      this.rendered = !0;
      const i = t.viewState,
        n = this.getSources(t.extent, i.resolution);
      let r = !0;
      for (let t = 0, e = n.length; t < e; ++t) {
        const e = n[t],
          i = e.getState();
        if ("loading" == i) {
          const t = () => {
            "ready" == e.getState() &&
              (e.removeEventListener("change", t), this.changed());
          };
          e.addEventListener("change", t);
        }
        r = r && "ready" == i;
      }
      const s = this.renderSources(t, n);
      if (this.getRenderer().renderComplete && r)
        return (this.renderedResolution_ = i.resolution), s;
      if (this.renderedResolution_ > 0.5 * i.resolution) {
        const e = this.getSources(t.extent, this.renderedResolution_).filter(
          (t) => !n.includes(t)
        );
        if (e.length > 0) return this.renderSources(t, e);
      }
      return s;
    }
    setStyle(t) {
      (this.styleVariables_ = t.variables || {}), (this.style_ = t);
      const e = rp(this.style_, this.getSourceBandCount_());
      this.getRenderer().reset({
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader,
        uniforms: e.uniforms,
      }),
        this.changed();
    }
    updateStyleVariables(t) {
      Object.assign(this.styleVariables_, t), this.changed();
    }
  }
  sp.prototype.dispose;
  var op = sp;
  var ap = class extends Pg {
      clear() {
        for (; this.getCount() > 0; ) this.pop().release();
        super.clear();
      }
      expireCache(t) {
        for (; this.canExpireCache(); ) {
          if (this.peekLast().getKey() in t) break;
          this.pop().release();
        }
      }
      pruneExceptNewestZ() {
        if (0 === this.getCount()) return;
        const t = Ag(this.peekFirstKey())[0];
        this.forEach((e) => {
          e.tileCoord[0] !== t && (this.remove(Og(e.tileCoord)), e.release());
        });
      }
    },
    lp = "tileloadstart",
    hp = "tileloadend",
    cp = "tileloaderror";
  const up = [0, 0, 0];
  var dp = class {
    constructor(t) {
      let e;
      if (
        ((this.minZoom = void 0 !== t.minZoom ? t.minZoom : 0),
        (this.resolutions_ = t.resolutions),
        Ft(
          u(
            this.resolutions_,
            function (t, e) {
              return e - t;
            },
            !0
          ),
          "`resolutions` must be sorted in descending order"
        ),
        !t.origins)
      )
        for (let t = 0, i = this.resolutions_.length - 1; t < i; ++t)
          if (e) {
            if (this.resolutions_[t] / this.resolutions_[t + 1] !== e) {
              e = void 0;
              break;
            }
          } else e = this.resolutions_[t] / this.resolutions_[t + 1];
      (this.zoomFactor_ = e),
        (this.maxZoom = this.resolutions_.length - 1),
        (this.origin_ = void 0 !== t.origin ? t.origin : null),
        (this.origins_ = null),
        void 0 !== t.origins &&
          ((this.origins_ = t.origins),
          Ft(
            this.origins_.length == this.resolutions_.length,
            "Number of `origins` and `resolutions` must be equal"
          ));
      const i = t.extent;
      void 0 === i || this.origin_ || this.origins_ || (this.origin_ = Pe(i)),
        Ft(
          (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
          "Either `origin` or `origins` must be configured, never both"
        ),
        (this.tileSizes_ = null),
        void 0 !== t.tileSizes &&
          ((this.tileSizes_ = t.tileSizes),
          Ft(
            this.tileSizes_.length == this.resolutions_.length,
            "Number of `tileSizes` and `resolutions` must be equal"
          )),
        (this.tileSize_ =
          void 0 !== t.tileSize ? t.tileSize : this.tileSizes_ ? null : Ns),
        Ft(
          (!this.tileSize_ && this.tileSizes_) ||
            (this.tileSize_ && !this.tileSizes_),
          "Either `tileSize` or `tileSizes` must be configured, never both"
        ),
        (this.extent_ = void 0 !== i ? i : null),
        (this.fullTileRanges_ = null),
        (this.tmpSize_ = [0, 0]),
        (this.tmpExtent_ = [0, 0, 0, 0]),
        void 0 !== t.sizes
          ? (this.fullTileRanges_ = t.sizes.map(function (t, e) {
              const n = new Ig(
                Math.min(0, t[0]),
                Math.max(t[0] - 1, -1),
                Math.min(0, t[1]),
                Math.max(t[1] - 1, -1)
              );
              if (i) {
                const t = this.getTileRangeForExtentAndZ(i, e);
                (n.minX = Math.max(t.minX, n.minX)),
                  (n.maxX = Math.min(t.maxX, n.maxX)),
                  (n.minY = Math.max(t.minY, n.minY)),
                  (n.maxY = Math.min(t.maxY, n.maxY));
              }
              return n;
            }, this))
          : i && this.calculateTileRanges_(i);
    }
    forEachTileCoord(t, e, i) {
      const n = this.getTileRangeForExtentAndZ(t, e);
      for (let t = n.minX, r = n.maxX; t <= r; ++t)
        for (let r = n.minY, s = n.maxY; r <= s; ++r) i([e, t, r]);
    }
    forEachTileCoordParentTileRange(t, e, i, n) {
      let r,
        s,
        o,
        a = null,
        l = t[0] - 1;
      for (
        2 === this.zoomFactor_
          ? ((s = t[1]), (o = t[2]))
          : (a = this.getTileCoordExtent(t, n));
        l >= this.minZoom;

      ) {
        if (
          (2 === this.zoomFactor_
            ? ((s = Math.floor(s / 2)),
              (o = Math.floor(o / 2)),
              (r = Fg(s, s, o, o, i)))
            : (r = this.getTileRangeForExtentAndZ(a, l, i)),
          e(l, r))
        )
          return !0;
        --l;
      }
      return !1;
    }
    getExtent() {
      return this.extent_;
    }
    getMaxZoom() {
      return this.maxZoom;
    }
    getMinZoom() {
      return this.minZoom;
    }
    getOrigin(t) {
      return this.origin_ ? this.origin_ : this.origins_[t];
    }
    getResolution(t) {
      return this.resolutions_[t];
    }
    getResolutions() {
      return this.resolutions_;
    }
    getTileCoordChildTileRange(t, e, i) {
      if (t[0] < this.maxZoom) {
        if (2 === this.zoomFactor_) {
          const i = 2 * t[1],
            n = 2 * t[2];
          return Fg(i, i + 1, n, n + 1, e);
        }
        const n = this.getTileCoordExtent(t, i || this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(n, t[0] + 1, e);
      }
      return null;
    }
    getTileRangeForTileCoordAndZ(t, e, i) {
      if (e > this.maxZoom || e < this.minZoom) return null;
      const n = t[0],
        r = t[1],
        s = t[2];
      if (e === n) return Fg(r, s, r, s, i);
      if (this.zoomFactor_) {
        const t = Math.pow(this.zoomFactor_, e - n),
          o = Math.floor(r * t),
          a = Math.floor(s * t);
        if (e < n) return Fg(o, o, a, a, i);
        return Fg(
          o,
          Math.floor(t * (r + 1)) - 1,
          a,
          Math.floor(t * (s + 1)) - 1,
          i
        );
      }
      const o = this.getTileCoordExtent(t, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(o, e, i);
    }
    getTileRangeForExtentAndZ(t, e, i) {
      this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, up);
      const n = up[1],
        r = up[2];
      this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, up);
      return Fg(n, up[1], r, up[2], i);
    }
    getTileCoordCenter(t) {
      const e = this.getOrigin(t[0]),
        i = this.getResolution(t[0]),
        n = sl(this.getTileSize(t[0]), this.tmpSize_);
      return [e[0] + (t[1] + 0.5) * n[0] * i, e[1] - (t[2] + 0.5) * n[1] * i];
    }
    getTileCoordExtent(t, e) {
      const i = this.getOrigin(t[0]),
        n = this.getResolution(t[0]),
        r = sl(this.getTileSize(t[0]), this.tmpSize_),
        s = i[0] + t[1] * r[0] * n,
        o = i[1] - (t[2] + 1) * r[1] * n;
      return oe(s, o, s + r[0] * n, o + r[1] * n, e);
    }
    getTileCoordForCoordAndResolution(t, e, i) {
      return this.getTileCoordForXYAndResolution_(t[0], t[1], e, !1, i);
    }
    getTileCoordForXYAndResolution_(t, e, i, n, r) {
      const s = this.getZForResolution(i),
        o = i / this.getResolution(s),
        a = this.getOrigin(s),
        l = sl(this.getTileSize(s), this.tmpSize_);
      let h = (o * (t - a[0])) / i / l[0],
        c = (o * (a[1] - e)) / i / l[1];
      return (
        n
          ? ((h = Ci(h, 5) - 1), (c = Ci(c, 5) - 1))
          : ((h = Si(h, 5)), (c = Si(c, 5))),
        Lg(s, h, c, r)
      );
    }
    getTileCoordForXYAndZ_(t, e, i, n, r) {
      const s = this.getOrigin(i),
        o = this.getResolution(i),
        a = sl(this.getTileSize(i), this.tmpSize_);
      let l = (t - s[0]) / o / a[0],
        h = (s[1] - e) / o / a[1];
      return (
        n
          ? ((l = Ci(l, 5) - 1), (h = Ci(h, 5) - 1))
          : ((l = Si(l, 5)), (h = Si(h, 5))),
        Lg(i, l, h, r)
      );
    }
    getTileCoordForCoordAndZ(t, e, i) {
      return this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, i);
    }
    getTileCoordResolution(t) {
      return this.resolutions_[t[0]];
    }
    getTileSize(t) {
      return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t];
    }
    getFullTileRange(t) {
      return this.fullTileRanges_
        ? this.fullTileRanges_[t]
        : this.extent_
        ? this.getTileRangeForExtentAndZ(this.extent_, t)
        : null;
    }
    getZForResolution(t, e) {
      return ui(a(this.resolutions_, t, e || 0), this.minZoom, this.maxZoom);
    }
    tileCoordIntersectsViewport(t, e) {
      return mr(e, 0, e.length, 2, this.getTileCoordExtent(t));
    }
    calculateTileRanges_(t) {
      const e = this.resolutions_.length,
        i = new Array(e);
      for (let n = this.minZoom; n < e; ++n)
        i[n] = this.getTileRangeForExtentAndZ(t, n);
      this.fullTileRanges_ = i;
    }
  };
  function gp(t) {
    let e = t.getDefaultTileGrid();
    return e || ((e = yp(t)), t.setDefaultTileGrid(e)), e;
  }
  function fp(t, e, i) {
    const n = e[0],
      r = t.getTileCoordCenter(e),
      s = xp(i);
    if (!ee(s, r)) {
      const e = Fe(s),
        i = Math.ceil((s[0] - r[0]) / e);
      return (r[0] += e * i), t.getTileCoordForCoordAndZ(r, n);
    }
    return e;
  }
  function pp(t, e, i, n) {
    n = void 0 !== n ? n : "top-left";
    const r = _p(t, e, i);
    return new dp({ extent: t, origin: we(t, n), resolutions: r, tileSize: i });
  }
  function mp(t) {
    const e = t || {},
      i = e.extent || tn("EPSG:3857").getExtent(),
      n = {
        extent: i,
        minZoom: e.minZoom,
        tileSize: e.tileSize,
        resolutions: _p(i, e.maxZoom, e.tileSize, e.maxResolution),
      };
    return new dp(n);
  }
  function _p(t, e, i, n) {
    (e = void 0 !== e ? e : As), (i = sl(void 0 !== i ? i : Ns));
    const r = Re(t),
      s = Fe(t);
    n = n > 0 ? n : Math.max(s / i[0], r / i[1]);
    const o = e + 1,
      a = new Array(o);
    for (let t = 0; t < o; ++t) a[t] = n / Math.pow(2, t);
    return a;
  }
  function yp(t, e, i, n) {
    return pp(xp(t), e, i, n);
  }
  function xp(t) {
    let e = (t = tn(t)).getExtent();
    if (!e) {
      const i = (180 * je.degrees) / t.getMetersPerUnit();
      e = oe(-i, -i, i, i);
    }
    return e;
  }
  class vp extends e {
    constructor(t, e) {
      super(t), (this.tile = e);
    }
  }
  var Sp = class extends Iu {
    constructor(t) {
      super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        projection: t.projection,
        state: t.state,
        wrapX: t.wrapX,
        interpolate: t.interpolate,
      }),
        this.on,
        this.once,
        this.un,
        (this.opaque_ = void 0 !== t.opaque && t.opaque),
        (this.tilePixelRatio_ =
          void 0 !== t.tilePixelRatio ? t.tilePixelRatio : 1),
        (this.tileGrid = void 0 !== t.tileGrid ? t.tileGrid : null);
      const e = [256, 256];
      this.tileGrid &&
        sl(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), e),
        (this.tileCache = new ap(t.cacheSize || 0)),
        (this.tmpSize = [0, 0]),
        (this.key_ = t.key || ""),
        (this.tileOptions = {
          transition: t.transition,
          interpolate: t.interpolate,
        }),
        (this.zDirection = t.zDirection ? t.zDirection : 0);
    }
    canExpireCache() {
      return this.tileCache.canExpireCache();
    }
    expireCache(t, e) {
      const i = this.getTileCacheForProjection(t);
      i && i.expireCache(e);
    }
    forEachLoadedTile(t, e, i, n) {
      const r = this.getTileCacheForProjection(t);
      if (!r) return !1;
      let s,
        o,
        a,
        l = !0;
      for (let t = i.minX; t <= i.maxX; ++t)
        for (let h = i.minY; h <= i.maxY; ++h)
          (o = Mg(e, t, h)),
            (a = !1),
            r.containsKey(o) &&
              ((s = r.get(o)),
              (a = s.getState() === Q),
              a && (a = !1 !== n(s))),
            a || (l = !1);
      return l;
    }
    getGutterForProjection(t) {
      return 0;
    }
    getKey() {
      return this.key_;
    }
    setKey(t) {
      this.key_ !== t && ((this.key_ = t), this.changed());
    }
    getOpaque(t) {
      return this.opaque_;
    }
    getResolutions(t) {
      const e = t ? this.getTileGridForProjection(t) : this.tileGrid;
      return e ? e.getResolutions() : null;
    }
    getTile(t, e, i, n, r) {
      return G();
    }
    getTileGrid() {
      return this.tileGrid;
    }
    getTileGridForProjection(t) {
      return this.tileGrid ? this.tileGrid : gp(t);
    }
    getTileCacheForProjection(t) {
      const e = this.getProjection();
      return (
        Ft(
          null === e || ln(e, t),
          "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
        ),
        this.tileCache
      );
    }
    getTilePixelRatio(t) {
      return this.tilePixelRatio_;
    }
    getTilePixelSize(t, e, i) {
      const n = this.getTileGridForProjection(i),
        r = this.getTilePixelRatio(e),
        s = sl(n.getTileSize(t), this.tmpSize);
      return 1 == r ? s : rl(s, r, this.tmpSize);
    }
    getTileCoordForTileUrlFunction(t, e) {
      e = void 0 !== e ? e : this.getProjection();
      const i = this.getTileGridForProjection(e);
      return (
        this.getWrapX() && e.isGlobal() && (t = fp(i, t, e)),
        Dg(t, i) ? t : null
      );
    }
    clear() {
      this.tileCache.clear();
    }
    refresh() {
      this.clear(), super.refresh();
    }
    updateCacheSize(t, e) {
      const i = this.getTileCacheForProjection(e);
      t > i.highWaterMark && (i.highWaterMark = t);
    }
    useTile(t, e, i, n) {}
  };
  function Cp(t, e) {
    const i = /\{z\}/g,
      n = /\{x\}/g,
      r = /\{y\}/g,
      s = /\{-y\}/g;
    return function (o, a, l) {
      if (o)
        return t
          .replace(i, o[0].toString())
          .replace(n, o[1].toString())
          .replace(r, o[2].toString())
          .replace(s, function () {
            const t = o[0],
              i = e.getFullTileRange(t);
            Ft(i, "The {-y} placeholder requires a tile grid with extent");
            return (i.getHeight() - o[2] - 1).toString();
          });
    };
  }
  function wp(t, e) {
    const i = t.length,
      n = new Array(i);
    for (let r = 0; r < i; ++r) n[r] = Cp(t[r], e);
    return Wp(n);
  }
  function Wp(t) {
    return 1 === t.length
      ? t[0]
      : function (e, i, n) {
          if (!e) return;
          const r = _i(Ng(e), t.length);
          return t[r](e, i, n);
        };
  }
  function Ep(t, e, i) {}
  function Rp(t) {
    const e = [];
    let i = /\{([a-z])-([a-z])\}/.exec(t);
    if (i) {
      const n = i[1].charCodeAt(0),
        r = i[2].charCodeAt(0);
      let s;
      for (s = n; s <= r; ++s) e.push(t.replace(i[0], String.fromCharCode(s)));
      return e;
    }
    if (((i = /\{(\d+)-(\d+)\}/.exec(t)), i)) {
      const n = parseInt(i[2], 10);
      for (let r = parseInt(i[1], 10); r <= n; r++)
        e.push(t.replace(i[0], r.toString()));
      return e;
    }
    return e.push(t), e;
  }
  class Tp extends Sp {
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        opaque: t.opaque,
        projection: t.projection,
        state: t.state,
        tileGrid: t.tileGrid,
        tilePixelRatio: t.tilePixelRatio,
        wrapX: t.wrapX,
        transition: t.transition,
        interpolate: t.interpolate,
        key: t.key,
        attributionsCollapsible: t.attributionsCollapsible,
        zDirection: t.zDirection,
      }),
        (this.generateTileUrlFunction_ =
          this.tileUrlFunction === Tp.prototype.tileUrlFunction),
        (this.tileLoadFunction = t.tileLoadFunction),
        t.tileUrlFunction && (this.tileUrlFunction = t.tileUrlFunction),
        (this.urls = null),
        t.urls ? this.setUrls(t.urls) : t.url && this.setUrl(t.url),
        (this.tileLoadingKeys_ = {});
    }
    getTileLoadFunction() {
      return this.tileLoadFunction;
    }
    getTileUrlFunction() {
      return Object.getPrototypeOf(this).tileUrlFunction ===
        this.tileUrlFunction
        ? this.tileUrlFunction.bind(this)
        : this.tileUrlFunction;
    }
    getUrls() {
      return this.urls;
    }
    handleTileChange(t) {
      const e = t.target,
        i = j(e),
        n = e.getState();
      let r;
      n == Y
        ? ((this.tileLoadingKeys_[i] = !0), (r = lp))
        : i in this.tileLoadingKeys_ &&
          (delete this.tileLoadingKeys_[i],
          (r = n == $ ? cp : n == Q ? hp : void 0)),
        null != r && this.dispatchEvent(new vp(r, e));
    }
    setTileLoadFunction(t) {
      this.tileCache.clear(), (this.tileLoadFunction = t), this.changed();
    }
    setTileUrlFunction(t, e) {
      (this.tileUrlFunction = t),
        this.tileCache.pruneExceptNewestZ(),
        void 0 !== e ? this.setKey(e) : this.changed();
    }
    setUrl(t) {
      const e = Rp(t);
      (this.urls = e), this.setUrls(e);
    }
    setUrls(t) {
      this.urls = t;
      const e = t.join("\n");
      this.generateTileUrlFunction_
        ? this.setTileUrlFunction(wp(t, this.tileGrid), e)
        : this.setKey(e);
    }
    tileUrlFunction(t, e, i) {}
    useTile(t, e, i) {
      const n = Mg(t, e, i);
      this.tileCache.containsKey(n) && this.tileCache.get(n);
    }
  }
  var Pp = Tp;
  function bp(t, e) {
    t.getImage().src = e;
  }
  var Fp = class extends Pp {
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        opaque: t.opaque,
        projection: t.projection,
        state: t.state,
        tileGrid: t.tileGrid,
        tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : bp,
        tilePixelRatio: t.tilePixelRatio,
        tileUrlFunction: t.tileUrlFunction,
        url: t.url,
        urls: t.urls,
        wrapX: t.wrapX,
        transition: t.transition,
        interpolate: void 0 === t.interpolate || t.interpolate,
        key: t.key,
        attributionsCollapsible: t.attributionsCollapsible,
        zDirection: t.zDirection,
      }),
        (this.crossOrigin = void 0 !== t.crossOrigin ? t.crossOrigin : null),
        (this.tileClass = void 0 !== t.tileClass ? t.tileClass : is),
        (this.tileCacheForProjection = {}),
        (this.tileGridForProjection = {}),
        (this.reprojectionErrorThreshold_ = t.reprojectionErrorThreshold),
        (this.renderReprojectionEdges_ = !1);
    }
    canExpireCache() {
      if (this.tileCache.canExpireCache()) return !0;
      for (const t in this.tileCacheForProjection)
        if (this.tileCacheForProjection[t].canExpireCache()) return !0;
      return !1;
    }
    expireCache(t, e) {
      const i = this.getTileCacheForProjection(t);
      this.tileCache.expireCache(this.tileCache == i ? e : {});
      for (const t in this.tileCacheForProjection) {
        const n = this.tileCacheForProjection[t];
        n.expireCache(n == i ? e : {});
      }
    }
    getGutterForProjection(t) {
      return this.getProjection() && t && !ln(this.getProjection(), t)
        ? 0
        : this.getGutter();
    }
    getGutter() {
      return 0;
    }
    getKey() {
      let t = super.getKey();
      return this.getInterpolate() || (t += ":disable-interpolation"), t;
    }
    getOpaque(t) {
      return (
        !(this.getProjection() && t && !ln(this.getProjection(), t)) &&
        super.getOpaque(t)
      );
    }
    getTileGridForProjection(t) {
      const e = this.getProjection();
      if (this.tileGrid && (!e || ln(e, t))) return this.tileGrid;
      const i = j(t);
      return (
        i in this.tileGridForProjection ||
          (this.tileGridForProjection[i] = gp(t)),
        this.tileGridForProjection[i]
      );
    }
    getTileCacheForProjection(t) {
      const e = this.getProjection();
      if (!e || ln(e, t)) return this.tileCache;
      const i = j(t);
      return (
        i in this.tileCacheForProjection ||
          (this.tileCacheForProjection[i] = new ap(
            this.tileCache.highWaterMark
          )),
        this.tileCacheForProjection[i]
      );
    }
    createTile_(t, e, i, n, r, s) {
      const o = [t, e, i],
        a = this.getTileCoordForTileUrlFunction(o, r),
        l = a ? this.tileUrlFunction(a, n, r) : void 0,
        h = new this.tileClass(
          o,
          void 0 !== l ? H : J,
          void 0 !== l ? l : "",
          this.crossOrigin,
          this.tileLoadFunction,
          this.tileOptions
        );
      return (
        (h.key = s), h.addEventListener(v, this.handleTileChange.bind(this)), h
      );
    }
    getTile(t, e, i, n, r) {
      const s = this.getProjection();
      if (!s || !r || ln(s, r)) return this.getTileInternal(t, e, i, n, s || r);
      const o = this.getTileCacheForProjection(r),
        a = [t, e, i];
      let l;
      const h = Og(a);
      o.containsKey(h) && (l = o.get(h));
      const c = this.getKey();
      if (l && l.key == c) return l;
      const u = this.getTileGridForProjection(s),
        d = this.getTileGridForProjection(r),
        g = this.getTileCoordForTileUrlFunction(a, r),
        f = new Cg(
          s,
          u,
          r,
          d,
          a,
          g,
          this.getTilePixelRatio(n),
          this.getGutter(),
          (t, e, i, n) => this.getTileInternal(t, e, i, n, s),
          this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_,
          this.getInterpolate()
        );
      return (
        (f.key = c),
        l
          ? ((f.interimTile = l), f.refreshInterimChain(), o.replace(h, f))
          : o.set(h, f),
        f
      );
    }
    getTileInternal(t, e, i, n, r) {
      let s = null;
      const o = Mg(t, e, i),
        a = this.getKey();
      if (this.tileCache.containsKey(o)) {
        if (((s = this.tileCache.get(o)), s.key != a)) {
          const l = s;
          (s = this.createTile_(t, e, i, n, r, a)),
            l.getState() == H
              ? (s.interimTile = l.interimTile)
              : (s.interimTile = l),
            s.refreshInterimChain(),
            this.tileCache.replace(o, s);
        }
      } else (s = this.createTile_(t, e, i, n, r, a)), this.tileCache.set(o, s);
      return s;
    }
    setRenderReprojectionEdges(t) {
      if (this.renderReprojectionEdges_ != t) {
        this.renderReprojectionEdges_ = t;
        for (const t in this.tileCacheForProjection)
          this.tileCacheForProjection[t].clear();
        this.changed();
      }
    }
    setTileGridForProjection(t, e) {
      const i = tn(t);
      if (i) {
        const t = j(i);
        t in this.tileGridForProjection || (this.tileGridForProjection[t] = e);
      }
    }
    clear() {
      super.clear();
      for (const t in this.tileCacheForProjection)
        this.tileCacheForProjection[t].clear();
    }
  };
  function Ip(t) {
    const e = t[0],
      i = new Array(e);
    let n,
      r,
      s = 1 << (e - 1);
    for (n = 0; n < e; ++n)
      (r = 48),
        t[1] & s && (r += 1),
        t[2] & s && (r += 2),
        (i[n] = String.fromCharCode(r)),
        (s >>= 1);
    return i.join("");
  }
  var Lp = class extends Fp {
    constructor(t) {
      const e = void 0 !== t.hidpi && t.hidpi;
      super({
        cacheSize: t.cacheSize,
        crossOrigin: "anonymous",
        interpolate: t.interpolate,
        opaque: !0,
        projection: tn("EPSG:3857"),
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        state: "loading",
        tileLoadFunction: t.tileLoadFunction,
        tilePixelRatio: e ? 2 : 1,
        wrapX: void 0 === t.wrapX || t.wrapX,
        transition: t.transition,
        zDirection: t.zDirection,
      }),
        (this.hidpi_ = e),
        (this.culture_ = void 0 !== t.culture ? t.culture : "en-us"),
        (this.maxZoom_ = void 0 !== t.maxZoom ? t.maxZoom : -1),
        (this.apiKey_ = t.key),
        (this.imagerySet_ = t.imagerySet),
        (this.placeholderTiles_ = t.placeholderTiles);
      const i =
        "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" +
        this.imagerySet_ +
        "?uriScheme=https&include=ImageryProviders&key=" +
        this.apiKey_ +
        "&c=" +
        this.culture_;
      fetch(i)
        .then((t) => t.json())
        .then((t) => this.handleImageryMetadataResponse(t));
    }
    getApiKey() {
      return this.apiKey_;
    }
    getImagerySet() {
      return this.imagerySet_;
    }
    handleImageryMetadataResponse(t) {
      if (
        200 != t.statusCode ||
        "OK" != t.statusDescription ||
        "ValidCredentials" != t.authenticationResultCode ||
        1 != t.resourceSets.length ||
        1 != t.resourceSets[0].resources.length
      )
        return void this.setState("error");
      const e = t.resourceSets[0].resources[0],
        i = -1 == this.maxZoom_ ? e.zoomMax : this.maxZoom_,
        n = xp(this.getProjection()),
        r = this.hidpi_ ? 2 : 1,
        s =
          e.imageWidth == e.imageHeight
            ? e.imageWidth / r
            : [e.imageWidth / r, e.imageHeight / r],
        o = mp({ extent: n, minZoom: e.zoomMin, maxZoom: i, tileSize: s });
      this.tileGrid = o;
      const a = this.culture_,
        l = this.hidpi_,
        h = this.placeholderTiles_;
      if (
        ((this.tileUrlFunction = Wp(
          e.imageUrlSubdomains.map(function (t) {
            const i = [0, 0, 0],
              n = e.imageUrl.replace("{subdomain}", t).replace("{culture}", a);
            return function (t, e, r) {
              if (!t) return;
              Lg(t[0], t[1], t[2], i);
              const s = new URL(n.replace("{quadkey}", Ip(i))),
                o = s.searchParams;
              return (
                l && (o.set("dpi", "d1"), o.set("device", "mobile")),
                !0 === h ? o.delete("n") : !1 === h && o.set("n", "z"),
                s.toString()
              );
            };
          })
        )),
        e.imageryProviders)
      ) {
        const t = hn(tn("EPSG:4326"), this.getProjection());
        this.setAttributions((i) => {
          const n = [],
            r = i.viewState,
            s = this.getTileGrid(),
            o = s.getZForResolution(r.resolution, this.zDirection),
            a = s.getTileCoordForCoordAndZ(r.center, o)[0];
          return (
            e.imageryProviders.map(function (e) {
              let r = !1;
              const s = e.coverageAreas;
              for (let e = 0, n = s.length; e < n; ++e) {
                const n = s[e];
                if (a >= n.zoomMin && a <= n.zoomMax) {
                  const e = n.bbox;
                  if (Ie(Ae([e[1], e[0], e[3], e[2]], t), i.extent)) {
                    r = !0;
                    break;
                  }
                }
              }
              r && n.push(e.attribution);
            }),
            n.push(
              '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>'
            ),
            n
          );
        });
      }
      this.setState("ready");
    }
  };
  var Mp = class extends Fp {
    constructor(t) {
      const e =
          void 0 !== (t = t || {}).projection ? t.projection : "EPSG:3857",
        i =
          void 0 !== t.tileGrid
            ? t.tileGrid
            : mp({
                extent: xp(e),
                maxResolution: t.maxResolution,
                maxZoom: t.maxZoom,
                minZoom: t.minZoom,
                tileSize: t.tileSize,
              });
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        interpolate: t.interpolate,
        opaque: t.opaque,
        projection: e,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        tileGrid: i,
        tileLoadFunction: t.tileLoadFunction,
        tilePixelRatio: t.tilePixelRatio,
        tileUrlFunction: t.tileUrlFunction,
        url: t.url,
        urls: t.urls,
        wrapX: void 0 === t.wrapX || t.wrapX,
        transition: t.transition,
        attributionsCollapsible: t.attributionsCollapsible,
        zDirection: t.zDirection,
      }),
        (this.gutter_ = void 0 !== t.gutter ? t.gutter : 0);
    }
    getGutter() {
      return this.gutter_;
    }
  };
  var Op = class extends Mp {
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 18,
        minZoom: t.minZoom,
        projection: t.projection,
        transition: t.transition,
        wrapX: t.wrapX,
        zDirection: t.zDirection,
      }),
        (this.account_ = t.account),
        (this.mapId_ = t.map || ""),
        (this.config_ = t.config || {}),
        (this.templateCache_ = {}),
        this.initializeMap_();
    }
    getConfig() {
      return this.config_;
    }
    updateConfig(t) {
      Object.assign(this.config_, t), this.initializeMap_();
    }
    setConfig(t) {
      (this.config_ = t || {}), this.initializeMap_();
    }
    initializeMap_() {
      const t = JSON.stringify(this.config_);
      if (this.templateCache_[t])
        return void this.applyTemplate_(this.templateCache_[t]);
      let e = "https://" + this.account_ + ".carto.com/api/v1/map";
      this.mapId_ && (e += "/named/" + this.mapId_);
      const i = new XMLHttpRequest();
      i.addEventListener("load", this.handleInitResponse_.bind(this, t)),
        i.addEventListener("error", this.handleInitError_.bind(this)),
        i.open("POST", e),
        i.setRequestHeader("Content-type", "application/json"),
        i.send(JSON.stringify(this.config_));
    }
    handleInitResponse_(t, e) {
      const i = e.target;
      if (!i.status || (i.status >= 200 && i.status < 300)) {
        let e;
        try {
          e = JSON.parse(i.responseText);
        } catch (t) {
          return void this.setState("error");
        }
        this.applyTemplate_(e),
          (this.templateCache_[t] = e),
          this.setState("ready");
      } else this.setState("error");
    }
    handleInitError_(t) {
      this.setState("error");
    }
    applyTemplate_(t) {
      const e =
        "https://" +
        t.cdn_url.https +
        "/" +
        this.account_ +
        "/api/v1/map/" +
        t.layergroupid +
        "/{z}/{x}/{y}.png";
      this.setUrl(e);
    }
  };
  var kp = class extends qu {
    constructor(t) {
      super({ attributions: t.attributions, wrapX: t.wrapX }),
        (this.resolution = void 0),
        (this.distance = void 0 !== t.distance ? t.distance : 20),
        (this.minDistance = t.minDistance || 0),
        (this.interpolationRatio = 0),
        (this.features = []),
        (this.geometryFunction =
          t.geometryFunction ||
          function (t) {
            const e = t.getGeometry();
            return (
              Ft(
                !e || "Point" === e.getType(),
                "The default `geometryFunction` can only handle `Point` or null geometries"
              ),
              e
            );
          }),
        (this.createCustomCluster_ = t.createCluster),
        (this.source = null),
        (this.boundRefresh_ = this.refresh.bind(this)),
        this.updateDistance(this.distance, this.minDistance),
        this.setSource(t.source || null);
    }
    clear(t) {
      (this.features.length = 0), super.clear(t);
    }
    getDistance() {
      return this.distance;
    }
    getSource() {
      return this.source;
    }
    loadFeatures(t, e, i) {
      this.source.loadFeatures(t, e, i),
        e !== this.resolution && ((this.resolution = e), this.refresh());
    }
    setDistance(t) {
      this.updateDistance(t, this.minDistance);
    }
    setMinDistance(t) {
      this.updateDistance(this.distance, t);
    }
    getMinDistance() {
      return this.minDistance;
    }
    setSource(t) {
      this.source && this.source.removeEventListener(v, this.boundRefresh_),
        (this.source = t),
        t && t.addEventListener(v, this.boundRefresh_),
        this.refresh();
    }
    refresh() {
      this.clear(), this.cluster(), this.addFeatures(this.features);
    }
    updateDistance(t, e) {
      const i = 0 === t ? 0 : Math.min(e, t) / t,
        n = t !== this.distance || this.interpolationRatio !== i;
      (this.distance = t),
        (this.minDistance = e),
        (this.interpolationRatio = i),
        n && this.refresh();
    }
    cluster() {
      if (void 0 === this.resolution || !this.source) return;
      const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
        e = this.distance * this.resolution,
        i = this.source.getFeatures(),
        n = {};
      for (let r = 0, s = i.length; r < s; r++) {
        const s = i[r];
        if (!(j(s) in n)) {
          const i = this.geometryFunction(s);
          if (i) {
            le(i.getCoordinates(), t), $t(t, e, t);
            const r = this.source.getFeaturesInExtent(t).filter(function (t) {
              const e = j(t);
              return !(e in n) && ((n[e] = !0), !0);
            });
            this.features.push(this.createCluster(r, t));
          }
        }
      }
    }
    createCluster(t, e) {
      const i = [0, 0];
      for (let e = t.length - 1; e >= 0; --e) {
        const n = this.geometryFunction(t[e]);
        n ? Ei(i, n.getCoordinates()) : t.splice(e, 1);
      }
      Li(i, 1 / t.length);
      const n = Ce(e),
        r = this.interpolationRatio,
        s = new or([i[0] * (1 - r) + n[0] * r, i[1] * (1 - r) + n[1] * r]);
      return this.createCustomCluster_
        ? this.createCustomCluster_(s, t)
        : new Mt({ geometry: s, features: t });
    }
  };
  var Ap = class extends Sp {
    constructor(t) {
      const e = void 0 === t.projection ? "EPSG:3857" : t.projection;
      let i = t.tileGrid;
      void 0 === i &&
        e &&
        (i = mp({
          extent: xp(e),
          maxResolution: t.maxResolution,
          maxZoom: t.maxZoom,
          minZoom: t.minZoom,
          tileSize: t.tileSize,
        })),
        super({
          cacheSize: 0.1,
          attributions: t.attributions,
          attributionsCollapsible: t.attributionsCollapsible,
          projection: e,
          tileGrid: i,
          opaque: t.opaque,
          state: t.state,
          wrapX: t.wrapX,
          transition: t.transition,
          interpolate: t.interpolate,
        }),
        (this.gutter_ = void 0 !== t.gutter ? t.gutter : 0),
        (this.tileSize_ = t.tileSize ? sl(t.tileSize) : null),
        (this.tileSizes_ = null),
        (this.tileLoadingKeys_ = {}),
        (this.loader_ = t.loader),
        (this.handleTileChange_ = this.handleTileChange_.bind(this)),
        (this.bandCount = void 0 === t.bandCount ? 4 : t.bandCount),
        (this.tileGridForProjection_ = {}),
        (this.tileCacheForProjection_ = {});
    }
    setTileSizes(t) {
      this.tileSizes_ = t;
    }
    getTileSize(t) {
      if (this.tileSizes_) return this.tileSizes_[t];
      if (this.tileSize_) return this.tileSize_;
      const e = this.getTileGrid();
      return e ? sl(e.getTileSize(t)) : [256, 256];
    }
    getGutterForProjection(t) {
      const e = this.getProjection();
      return !e || ln(e, t) ? this.gutter_ : 0;
    }
    setLoader(t) {
      this.loader_ = t;
    }
    getReprojTile_(t, e, i, n, r) {
      const s = this.getTileCacheForProjection(n),
        o = Mg(t, e, i);
      if (s.containsKey(o)) {
        const t = s.get(o);
        if (t && t.key == this.getKey()) return t;
      }
      const a = this.getTileGrid(),
        l = Math.max.apply(
          null,
          a.getResolutions().map((t, e) => {
            const i = sl(a.getTileSize(e)),
              n = this.getTileSize(e);
            return Math.max(n[0] / i[0], n[1] / i[1]);
          })
        ),
        h = this.getTileGridForProjection(r),
        c = this.getTileGridForProjection(n),
        u = [t, e, i],
        d = this.getTileCoordForTileUrlFunction(u, n),
        g = Object.assign(
          {
            sourceProj: r,
            sourceTileGrid: h,
            targetProj: n,
            targetTileGrid: c,
            tileCoord: u,
            wrappedTileCoord: d,
            pixelRatio: l,
            gutter: this.getGutterForProjection(r),
            getTileFunction: (t, e, i, n) => this.getTile(t, e, i, n, r),
          },
          this.tileOptions
        ),
        f = new Sg(g);
      return (f.key = this.getKey()), f;
    }
    getTile(t, e, i, n, r) {
      const s = this.getProjection();
      if (s && r && !ln(s, r)) return this.getReprojTile_(t, e, i, r, s);
      const o = this.getTileSize(t),
        a = Mg(t, e, i);
      if (this.tileCache.containsKey(a)) return this.tileCache.get(a);
      const l = this.loader_;
      const h = Object.assign(
          {
            tileCoord: [t, e, i],
            loader: function () {
              return m(function () {
                return l(t, e, i);
              });
            },
            size: o,
          },
          this.tileOptions
        ),
        c = new bt(h);
      return (
        (c.key = this.getKey()),
        c.addEventListener(v, this.handleTileChange_),
        this.tileCache.set(a, c),
        c
      );
    }
    handleTileChange_(t) {
      const e = t.target,
        i = j(e),
        n = e.getState();
      let r;
      n == Y
        ? ((this.tileLoadingKeys_[i] = !0), (r = lp))
        : i in this.tileLoadingKeys_ &&
          (delete this.tileLoadingKeys_[i],
          (r = n == $ ? cp : n == Q ? hp : void 0)),
        r && this.dispatchEvent(new vp(r, e));
    }
    getTileGridForProjection(t) {
      const e = this.getProjection();
      if (this.tileGrid && (!e || ln(e, t))) return this.tileGrid;
      const i = j(t);
      return (
        i in this.tileGridForProjection_ ||
          (this.tileGridForProjection_[i] = gp(t)),
        this.tileGridForProjection_[i]
      );
    }
    setTileGridForProjection(t, e) {
      const i = tn(t);
      if (i) {
        const t = j(i);
        t in this.tileGridForProjection_ ||
          (this.tileGridForProjection_[t] = e);
      }
    }
    getTileCacheForProjection(t) {
      const e = this.getProjection();
      if (!e || ln(e, t)) return this.tileCache;
      const i = j(t);
      return (
        i in this.tileCacheForProjection_ ||
          (this.tileCacheForProjection_[i] = new ap(0.1)),
        this.tileCacheForProjection_[i]
      );
    }
    expireCache(t, e) {
      const i = this.getTileCacheForProjection(t);
      this.tileCache.expireCache(this.tileCache == i ? e : {});
      for (const t in this.tileCacheForProjection_) {
        const n = this.tileCacheForProjection_[t];
        n.expireCache(n == i ? e : {});
      }
    }
    clear() {
      super.clear();
      for (const t in this.tileCacheForProjection_)
        this.tileCacheForProjection_[t].clear();
    }
  };
  function Np(t, e) {
    if (!t) return !1;
    if (!0 === t) return !0;
    if (3 !== e.getSamplesPerPixel()) return !1;
    const i = e.fileDirectory.PhotometricInterpretation,
      n = GeoTIFF.globals.photometricInterpretations;
    return i === n.CMYK || i === n.YCbCr || i === n.CIELab || i === n.ICCLab;
  }
  const Dp = "STATISTICS_MAXIMUM",
    Gp = "STATISTICS_MINIMUM";
  let Bp;
  function jp(t) {
    try {
      return t.getBoundingBox();
    } catch (e) {
      return [0, 0, t.getWidth(), t.getHeight()];
    }
  }
  function zp(t) {
    try {
      return t.getOrigin().slice(0, 2);
    } catch (e) {
      return [0, t.getHeight()];
    }
  }
  function Up(t, e) {
    try {
      return t.getResolution(e);
    } catch (i) {
      return [e.getWidth() / t.getWidth(), e.getHeight() / t.getHeight()];
    }
  }
  function qp(t) {
    const e = t.geoKeys;
    if (!e) return null;
    if (e.ProjectedCSTypeGeoKey && 32767 !== e.ProjectedCSTypeGeoKey) {
      const t = "EPSG:" + e.ProjectedCSTypeGeoKey;
      let i = tn(t);
      if (!i) {
        const n = Be(e.ProjLinearUnitsGeoKey);
        n && (i = new ze({ code: t, units: n }));
      }
      return i;
    }
    if (e.GeographicTypeGeoKey && 32767 !== e.GeographicTypeGeoKey) {
      const t = "EPSG:" + e.GeographicTypeGeoKey;
      let i = tn(t);
      if (!i) {
        const n = Be(e.GeogAngularUnitsGeoKey);
        n && (i = new ze({ code: t, units: n }));
      }
      return i;
    }
    return null;
  }
  function Vp(t) {
    return t.getImageCount().then(function (e) {
      const i = new Array(e);
      for (let n = 0; n < e; ++n) i[n] = t.getImage(n);
      return Promise.all(i);
    });
  }
  function Xp(t, e) {
    let i;
    return (
      (i = t.blob
        ? GeoTIFF.fromBlob(t.blob)
        : t.overviews
        ? GeoTIFF.fromUrls(t.url, t.overviews, e)
        : GeoTIFF.fromUrl(t.url, e)),
      i.then(Vp)
    );
  }
  function Zp(t, e, i, n, r) {
    if (Array.isArray(t)) {
      const s = t.length;
      if (!Array.isArray(e) || s != e.length) {
        const t = new Error(n);
        throw (r(t), t);
      }
      for (let o = 0; o < s; ++o) Zp(t[o], e[o], i, n, r);
    } else if (Math.abs(t - e) > i * t) throw new Error(n);
  }
  function Kp(t) {
    return t instanceof Int8Array
      ? 127
      : t instanceof Uint8Array || t instanceof Uint8ClampedArray
      ? 255
      : t instanceof Int16Array
      ? 32767
      : t instanceof Uint16Array
      ? 65535
      : t instanceof Int32Array
      ? 2147483647
      : t instanceof Uint32Array
      ? 4294967295
      : t instanceof Float32Array
      ? 34e37
      : 255;
  }
  class Hp extends Ap {
    constructor(t) {
      super({
        state: "loading",
        tileGrid: null,
        projection: t.projection || null,
        opaque: t.opaque,
        transition: t.transition,
        interpolate: !1 !== t.interpolate,
        wrapX: t.wrapX,
      }),
        (this.sourceInfo_ = t.sources);
      const e = this.sourceInfo_.length;
      (this.sourceOptions_ = t.sourceOptions),
        (this.sourceImagery_ = new Array(e)),
        (this.sourceMasks_ = new Array(e)),
        (this.resolutionFactors_ = new Array(e)),
        this.samplesPerPixel_,
        this.nodataValues_,
        this.metadata_,
        (this.normalize_ = !1 !== t.normalize),
        (this.addAlpha_ = !1),
        (this.error_ = null),
        (this.convertToRGB_ = t.convertToRGB || !1),
        this.setKey(this.sourceInfo_.map((t) => t.url).join(","));
      const i = this,
        n = new Array(e);
      for (let t = 0; t < e; ++t)
        n[t] = Xp(this.sourceInfo_[t], this.sourceOptions_);
      Promise.all(n)
        .then(function (t) {
          i.configure_(t);
        })
        .catch(function (t) {
          Zi(t), (i.error_ = t), i.setState("error");
        });
    }
    getError() {
      return this.error_;
    }
    determineProjection(t) {
      const e = t[0];
      for (let t = e.length - 1; t >= 0; --t) {
        const i = qp(e[t]);
        if (i) {
          this.projection = i;
          break;
        }
      }
    }
    configure_(t) {
      let e, i, n, r, s;
      const o = new Array(t.length),
        a = new Array(t.length),
        l = new Array(t.length);
      let h = 0;
      const c = t.length;
      for (let u = 0; u < c; ++u) {
        const c = [],
          d = [];
        t[u].forEach((t) => {
          4 == (4 & (t.fileDirectory.NewSubfileType || 0))
            ? d.push(t)
            : c.push(t);
        });
        const g = c.length;
        if (d.length > 0 && d.length !== g)
          throw new Error(
            `Expected one mask per image found ${d.length} masks and ${g} images`
          );
        let f, p;
        const m = new Array(g),
          _ = new Array(g),
          y = new Array(g);
        (a[u] = new Array(g)), (l[u] = new Array(g));
        for (let t = 0; t < g; ++t) {
          const e = c[t],
            i = e.getGDALNoData();
          (l[u][t] = e.getGDALMetadata(0)), (a[u][t] = i);
          const n = this.sourceInfo_[u].bands;
          o[u] = n ? n.length : e.getSamplesPerPixel();
          const r = g - (t + 1);
          f || (f = jp(e)), p || (p = zp(e));
          const s = Up(e, c[0]);
          y[r] = s[0];
          const h = [e.getTileWidth(), e.getTileHeight()];
          h[0] !== h[1] && h[1] < 256 && ((h[0] = 256), (h[1] = 256)),
            (m[r] = h);
          const d = s[0] / Math.abs(s[1]);
          _[r] = [h[0], h[1] / d];
        }
        if ((e ? Te(e, f, e) : (e = f), i)) {
          Zp(
            i,
            p,
            0,
            `Origin mismatch for source ${u}, got [${p}] but expected [${i}]`,
            this.viewRejector
          );
        } else i = p;
        if (s) {
          s.length - h > y.length && (h = s.length - y.length);
          const t = s[s.length - 1] / y[y.length - 1];
          this.resolutionFactors_[u] = t;
          const e = y.map((e) => e * t),
            i = `Resolution mismatch for source ${u}, got [${e}] but expected [${s}]`;
          Zp(s.slice(h, s.length), e, 0.02, i, this.viewRejector);
        } else (s = y), (this.resolutionFactors_[u] = 1);
        n
          ? Zp(
              n.slice(h, n.length),
              _,
              0.01,
              `Tile size mismatch for source ${u}`,
              this.viewRejector
            )
          : (n = _),
          r
            ? Zp(
                r.slice(h, r.length),
                m,
                0,
                `Tile size mismatch for source ${u}`,
                this.viewRejector
              )
            : (r = m),
          (this.sourceImagery_[u] = c.reverse()),
          (this.sourceMasks_[u] = d.reverse());
      }
      for (let t = 0, e = this.sourceImagery_.length; t < e; ++t) {
        const e = this.sourceImagery_[t];
        for (; e.length < s.length; ) e.unshift(void 0);
      }
      this.getProjection() || this.determineProjection(t),
        (this.samplesPerPixel_ = o),
        (this.nodataValues_ = a),
        (this.metadata_ = l);
      t: for (let t = 0; t < c; ++t) {
        if (void 0 !== this.sourceInfo_[t].nodata) {
          this.addAlpha_ = !0;
          break;
        }
        if (this.sourceMasks_[t].length) {
          this.addAlpha_ = !0;
          break;
        }
        const e = a[t],
          i = this.sourceInfo_[t].bands;
        if (i) {
          for (let t = 0; t < i.length; ++t)
            if (null !== e[i[t] - 1]) {
              this.addAlpha_ = !0;
              break t;
            }
        } else
          for (let t = 0; t < e.length; ++t)
            if (null !== e[t]) {
              this.addAlpha_ = !0;
              break t;
            }
      }
      let u = this.addAlpha_ ? 1 : 0;
      for (let t = 0; t < c; ++t) u += o[t];
      this.bandCount = u;
      const d = new dp({
        extent: e,
        minZoom: h,
        origin: i,
        resolutions: s,
        tileSizes: n,
      });
      (this.tileGrid = d),
        this.setTileSizes(r),
        this.setLoader(this.loadTile_.bind(this)),
        this.setState("ready");
      2 === s.length
        ? (s = [s[0], s[1], s[1] / 2])
        : 1 === s.length && (s = [2 * s[0], s[0], s[0] / 2]),
        this.viewResolver({
          showFullExtent: !0,
          projection: this.projection,
          resolutions: s,
          center: mn(Ce(e), this.projection),
          extent: yn(e, this.projection),
          zoom: 1,
        });
    }
    loadTile_(t, e, i) {
      const n = this.getTileSize(t),
        r = this.sourceImagery_.length,
        s = new Array(2 * r),
        o = this.nodataValues_,
        a = this.sourceInfo_,
        l = (Bp || (Bp = new GeoTIFF.Pool()), Bp);
      for (let h = 0; h < r; ++h) {
        const c = a[h],
          u = this.resolutionFactors_[h],
          d = [
            Math.round(e * (n[0] * u)),
            Math.round(i * (n[1] * u)),
            Math.round((e + 1) * (n[0] * u)),
            Math.round((i + 1) * (n[1] * u)),
          ],
          g = this.sourceImagery_[h][t];
        let f, p;
        c.bands &&
          (f = c.bands.map(function (t) {
            return t - 1;
          })),
          (p =
            "nodata" in c && null !== c.nodata
              ? c.nodata
              : f
              ? f.map(function (t) {
                  return o[h][t];
                })
              : o[h]);
        const m = {
          window: d,
          width: n[0],
          height: n[1],
          samples: f,
          fillValue: p,
          pool: l,
          interleave: !1,
        };
        Np(this.convertToRGB_, g)
          ? (s[h] = g.readRGB(m))
          : (s[h] = g.readRasters(m));
        const _ = r + h,
          y = this.sourceMasks_[h][t];
        y
          ? (s[_] = y.readRasters({
              window: d,
              width: n[0],
              height: n[1],
              samples: [0],
              pool: l,
              interleave: !1,
            }))
          : (s[_] = Promise.resolve(null));
      }
      return Promise.all(s)
        .then(this.composeTile_.bind(this, n))
        .catch(function (t) {
          throw (Zi(t), t);
        });
    }
    composeTile_(t, e) {
      const i = this.metadata_,
        n = this.sourceInfo_,
        r = this.sourceImagery_.length,
        s = this.bandCount,
        o = this.samplesPerPixel_,
        a = this.nodataValues_,
        l = this.normalize_,
        h = this.addAlpha_,
        c = t[0] * t[1],
        u = c * s;
      let d;
      d = l ? new Uint8Array(u) : new Float32Array(u);
      let g = 0;
      for (let t = 0; t < c; ++t) {
        let s = h;
        for (let c = 0; c < r; ++c) {
          const u = n[c];
          let p,
            m,
            _ = u.min,
            y = u.max;
          if (l) {
            const t = i[c][0];
            void 0 === _ &&
              (_ =
                t && Gp in t
                  ? parseFloat(t[Gp])
                  : (f = e[c][0]) instanceof Int8Array
                  ? -128
                  : f instanceof Int16Array
                  ? -32768
                  : f instanceof Int32Array
                  ? -2147483648
                  : f instanceof Float32Array
                  ? 12e-39
                  : 0),
              void 0 === y &&
                (y = t && Dp in t ? parseFloat(t[Dp]) : Kp(e[c][0])),
              (p = 255 / (y - _)),
              (m = -_ * p);
          }
          for (let i = 0; i < o[c]; ++i) {
            const n = e[c][i][t];
            let r;
            if (((r = l ? ui(p * n + m, 0, 255) : n), h)) {
              let t = u.nodata;
              if (void 0 === t) {
                let e;
                (e = u.bands ? u.bands[i] - 1 : i), (t = a[c][e]);
              }
              const e = isNaN(t);
              ((!e && n !== t) || (e && !isNaN(n))) && ((s = !1), (d[g] = r));
            } else d[g] = r;
            g++;
          }
          if (!s) {
            const i = e[r + c];
            i && !i[0][t] && (s = !0);
          }
        }
        h && (s || (d[g] = 255), g++);
      }
      var f;
      return d;
    }
  }
  Hp.prototype.getView;
  var Yp = Hp;
  let Qp = class extends is {
    constructor(t, e, i, n, r, s, o) {
      super(e, i, n, r, s, o),
        (this.zoomifyImage_ = null),
        (this.tileSize_ = t);
    }
    getImage() {
      if (this.zoomifyImage_) return this.zoomifyImage_;
      const t = super.getImage();
      if (this.state == Q) {
        const e = this.tileSize_;
        if (t.width == e[0] && t.height == e[1])
          return (this.zoomifyImage_ = t), t;
        const i = mt(e[0], e[1]);
        return i.drawImage(t, 0, 0), (this.zoomifyImage_ = i.canvas), i.canvas;
      }
      return t;
    }
  };
  var $p = class extends Fp {
    constructor(t) {
      const e = t.size,
        i =
          void 0 !== t.tierSizeCalculation ? t.tierSizeCalculation : "default",
        n = t.tilePixelRatio || 1,
        r = e[0],
        s = e[1],
        o = [],
        a = t.tileSize || Ns;
      let l = a * n;
      switch (i) {
        case "default":
          for (; r > l || s > l; )
            o.push([Math.ceil(r / l), Math.ceil(s / l)]), (l += l);
          break;
        case "truncated":
          let t = r,
            e = s;
          for (; t > l || e > l; )
            o.push([Math.ceil(t / l), Math.ceil(e / l)]), (t >>= 1), (e >>= 1);
          break;
        default:
          throw new Error("Unknown `tierSizeCalculation` configured");
      }
      o.push([1, 1]), o.reverse();
      const h = [n],
        c = [0];
      for (let t = 1, e = o.length; t < e; t++)
        h.push(n << t), c.push(o[t - 1][0] * o[t - 1][1] + c[t - 1]);
      h.reverse();
      const u = new dp({
        tileSize: a,
        extent: t.extent || [0, -s, r, 0],
        resolutions: h,
      });
      let d = t.url;
      !d ||
        d.includes("{TileGroup}") ||
        d.includes("{tileIndex}") ||
        (d += "{TileGroup}/{z}-{x}-{y}.jpg");
      const g = Rp(d);
      let f = a * n;
      const p = Wp(
          g.map(function (t) {
            return function (e, i, n) {
              if (!e) return;
              const r = e[0],
                s = e[1],
                a = e[2],
                l = s + a * o[r][0],
                h = {
                  z: r,
                  x: s,
                  y: a,
                  tileIndex: l,
                  TileGroup: "TileGroup" + (((l + c[r]) / f) | 0),
                };
              return t.replace(/\{(\w+?)\}/g, function (t, e) {
                return h[e];
              });
            };
          })
        ),
        m = Qp.bind(null, sl(a * n));
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        interpolate: t.interpolate,
        projection: t.projection,
        tilePixelRatio: n,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        tileClass: m,
        tileGrid: u,
        tileUrlFunction: p,
        transition: t.transition,
      }),
        (this.zDirection = t.zDirection);
      const _ = p(
          u.getTileCoordForCoordAndResolution(
            Ce(u.getExtent()),
            h[h.length - 1]
          ),
          1,
          null
        ),
        y = new Image();
      y.addEventListener("error", () => {
        (f = a), this.changed();
      }),
        (y.src = _);
    }
  };
  const Jp = "version1",
    tm = "version2",
    em = "version3",
    im = {};
  (im[Jp] = {
    level0: { supports: [], formats: [], qualities: ["native"] },
    level1: {
      supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
      formats: ["jpg"],
      qualities: ["native"],
    },
    level2: {
      supports: [
        "regionByPx",
        "regionByPct",
        "sizeByW",
        "sizeByH",
        "sizeByPct",
        "sizeByConfinedWh",
        "sizeByWh",
      ],
      formats: ["jpg", "png"],
      qualities: ["native", "color", "grey", "bitonal"],
    },
  }),
    (im[tm] = {
      level0: { supports: [], formats: ["jpg"], qualities: ["default"] },
      level1: {
        supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
        formats: ["jpg"],
        qualities: ["default"],
      },
      level2: {
        supports: [
          "regionByPx",
          "regionByPct",
          "sizeByW",
          "sizeByH",
          "sizeByPct",
          "sizeByConfinedWh",
          "sizeByDistortedWh",
          "sizeByWh",
        ],
        formats: ["jpg", "png"],
        qualities: ["default", "bitonal"],
      },
    }),
    (im[em] = {
      level0: { supports: [], formats: ["jpg"], qualities: ["default"] },
      level1: {
        supports: [
          "regionByPx",
          "regionSquare",
          "sizeByW",
          "sizeByH",
          "sizeByWh",
        ],
        formats: ["jpg"],
        qualities: ["default"],
      },
      level2: {
        supports: [
          "regionByPx",
          "regionSquare",
          "regionByPct",
          "sizeByW",
          "sizeByH",
          "sizeByPct",
          "sizeByConfinedWh",
          "sizeByWh",
        ],
        formats: ["jpg", "png"],
        qualities: ["default"],
      },
    }),
    (im.none = { none: { supports: [], formats: [], qualities: [] } });
  const nm =
      /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/,
    rm = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/,
    sm =
      /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
  const om = {};
  (om[Jp] = function (t) {
    let e = t.getComplianceLevelSupportedFeatures();
    return (
      void 0 === e && (e = im[Jp].level0),
      {
        url:
          void 0 === t.imageInfo["@id"]
            ? void 0
            : t.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
        supports: e.supports,
        formats: [
          ...e.formats,
          void 0 === t.imageInfo.formats ? [] : t.imageInfo.formats,
        ],
        qualities: [
          ...e.qualities,
          void 0 === t.imageInfo.qualities ? [] : t.imageInfo.qualities,
        ],
        resolutions: t.imageInfo.scale_factors,
        tileSize:
          void 0 !== t.imageInfo.tile_width
            ? void 0 !== t.imageInfo.tile_height
              ? [t.imageInfo.tile_width, t.imageInfo.tile_height]
              : [t.imageInfo.tile_width, t.imageInfo.tile_width]
            : null != t.imageInfo.tile_height
            ? [t.imageInfo.tile_height, t.imageInfo.tile_height]
            : void 0,
      }
    );
  }),
    (om[tm] = function (t) {
      const e = t.getComplianceLevelSupportedFeatures(),
        i =
          Array.isArray(t.imageInfo.profile) && t.imageInfo.profile.length > 1,
        n =
          i && t.imageInfo.profile[1].supports
            ? t.imageInfo.profile[1].supports
            : [],
        r =
          i && t.imageInfo.profile[1].formats
            ? t.imageInfo.profile[1].formats
            : [],
        s =
          i && t.imageInfo.profile[1].qualities
            ? t.imageInfo.profile[1].qualities
            : [];
      return {
        url: t.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
        sizes:
          void 0 === t.imageInfo.sizes
            ? void 0
            : t.imageInfo.sizes.map(function (t) {
                return [t.width, t.height];
              }),
        tileSize:
          void 0 === t.imageInfo.tiles
            ? void 0
            : [
                t.imageInfo.tiles.map(function (t) {
                  return t.width;
                })[0],
                t.imageInfo.tiles.map(function (t) {
                  return void 0 === t.height ? t.width : t.height;
                })[0],
              ],
        resolutions:
          void 0 === t.imageInfo.tiles
            ? void 0
            : t.imageInfo.tiles.map(function (t) {
                return t.scaleFactors;
              })[0],
        supports: [...e.supports, ...n],
        formats: [...e.formats, ...r],
        qualities: [...e.qualities, ...s],
      };
    }),
    (om[em] = function (t) {
      const e = t.getComplianceLevelSupportedFeatures(),
        i =
          void 0 === t.imageInfo.extraFormats
            ? e.formats
            : [...e.formats, ...t.imageInfo.extraFormats],
        n =
          void 0 !== t.imageInfo.preferredFormats &&
          Array.isArray(t.imageInfo.preferredFormats) &&
          t.imageInfo.preferredFormats.length > 0
            ? t.imageInfo.preferredFormats
                .filter(function (t) {
                  return ["jpg", "png", "gif"].includes(t);
                })
                .reduce(function (t, e) {
                  return void 0 === t && i.includes(e) ? e : t;
                }, void 0)
            : void 0;
      return {
        url: t.imageInfo.id,
        sizes:
          void 0 === t.imageInfo.sizes
            ? void 0
            : t.imageInfo.sizes.map(function (t) {
                return [t.width, t.height];
              }),
        tileSize:
          void 0 === t.imageInfo.tiles
            ? void 0
            : [
                t.imageInfo.tiles.map(function (t) {
                  return t.width;
                })[0],
                t.imageInfo.tiles.map(function (t) {
                  return t.height;
                })[0],
              ],
        resolutions:
          void 0 === t.imageInfo.tiles
            ? void 0
            : t.imageInfo.tiles.map(function (t) {
                return t.scaleFactors;
              })[0],
        supports:
          void 0 === t.imageInfo.extraFeatures
            ? e.supports
            : [...e.supports, ...t.imageInfo.extraFeatures],
        formats: i,
        qualities:
          void 0 === t.imageInfo.extraQualities
            ? e.qualities
            : [...e.qualities, ...t.imageInfo.extraQualities],
        preferredFormat: n,
      };
    });
  var am = class {
    constructor(t) {
      this.setImageInfo(t);
    }
    setImageInfo(t) {
      this.imageInfo = "string" == typeof t ? JSON.parse(t) : t;
    }
    getImageApiVersion() {
      if (void 0 === this.imageInfo) return;
      let t = this.imageInfo["@context"] || "ol-no-context";
      "string" == typeof t && (t = [t]);
      for (let e = 0; e < t.length; e++)
        switch (t[e]) {
          case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
          case "http://iiif.io/api/image/1/context.json":
            return Jp;
          case "http://iiif.io/api/image/2/context.json":
            return tm;
          case "http://iiif.io/api/image/3/context.json":
            return em;
          case "ol-no-context":
            if (
              this.getComplianceLevelEntryFromProfile(Jp) &&
              this.imageInfo.identifier
            )
              return Jp;
        }
      Ft(
        !1,
        "Cannot determine IIIF Image API version from provided image information JSON"
      );
    }
    getComplianceLevelEntryFromProfile(t) {
      if (void 0 !== this.imageInfo && void 0 !== this.imageInfo.profile)
        switch ((void 0 === t && (t = this.getImageApiVersion()), t)) {
          case Jp:
            if (nm.test(this.imageInfo.profile)) return this.imageInfo.profile;
            break;
          case em:
            if (sm.test(this.imageInfo.profile)) return this.imageInfo.profile;
            break;
          case tm:
            if (
              "string" == typeof this.imageInfo.profile &&
              rm.test(this.imageInfo.profile)
            )
              return this.imageInfo.profile;
            if (
              Array.isArray(this.imageInfo.profile) &&
              this.imageInfo.profile.length > 0 &&
              "string" == typeof this.imageInfo.profile[0] &&
              rm.test(this.imageInfo.profile[0])
            )
              return this.imageInfo.profile[0];
        }
    }
    getComplianceLevelFromProfile(t) {
      const e = this.getComplianceLevelEntryFromProfile(t);
      if (void 0 === e) return;
      const i = e.match(/level[0-2](?:\.json)?$/g);
      return Array.isArray(i) ? i[0].replace(".json", "") : void 0;
    }
    getComplianceLevelSupportedFeatures() {
      if (void 0 === this.imageInfo) return;
      const t = this.getImageApiVersion(),
        e = this.getComplianceLevelFromProfile(t);
      return void 0 === e ? im.none.none : im[t][e];
    }
    getTileSourceOptions(t) {
      const e = t || {},
        i = this.getImageApiVersion();
      if (void 0 === i) return;
      const n = void 0 === i ? void 0 : om[i](this);
      return void 0 !== n
        ? {
            url: n.url,
            version: i,
            size: [this.imageInfo.width, this.imageInfo.height],
            sizes: n.sizes,
            format:
              void 0 !== e.format && n.formats.includes(e.format)
                ? e.format
                : void 0 !== n.preferredFormat
                ? n.preferredFormat
                : "jpg",
            supports: n.supports,
            quality:
              e.quality && n.qualities.includes(e.quality)
                ? e.quality
                : n.qualities.includes("native")
                ? "native"
                : "default",
            resolutions: Array.isArray(n.resolutions)
              ? n.resolutions.sort(function (t, e) {
                  return e - t;
                })
              : void 0,
            tileSize: n.tileSize,
          }
        : void 0;
    }
  };
  function lm(t) {
    return t.toLocaleString("en", { maximumFractionDigits: 10 });
  }
  var hm = class extends Fp {
    constructor(t) {
      const e = t || {};
      let i = e.url || "";
      i += i.lastIndexOf("/") === i.length - 1 || "" === i ? "" : "/";
      const n = e.version || tm,
        r = e.sizes || [],
        s = e.size;
      Ft(
        null != s &&
          Array.isArray(s) &&
          2 == s.length &&
          !isNaN(s[0]) &&
          s[0] > 0 &&
          !isNaN(s[1]) &&
          s[1] > 0,
        "Missing or invalid `size`"
      );
      const o = s[0],
        a = s[1],
        l = e.tileSize,
        h = e.tilePixelRatio || 1,
        c = e.format || "jpg",
        u = e.quality || (e.version == Jp ? "native" : "default");
      let d = e.resolutions || [];
      const g = e.supports || [],
        f = e.extent || [0, -a, o, 0],
        p = null != r && Array.isArray(r) && r.length > 0,
        m =
          void 0 !== l &&
          (("number" == typeof l && Number.isInteger(l) && l > 0) ||
            (Array.isArray(l) && l.length > 0)),
        _ =
          null != g &&
          Array.isArray(g) &&
          (g.includes("regionByPx") || g.includes("regionByPct")) &&
          (g.includes("sizeByWh") ||
            g.includes("sizeByH") ||
            g.includes("sizeByW") ||
            g.includes("sizeByPct"));
      let y, x, v;
      if (
        (d.sort(function (t, e) {
          return e - t;
        }),
        m || _)
      )
        if (
          (null != l &&
            ("number" == typeof l && Number.isInteger(l) && l > 0
              ? ((y = l), (x = l))
              : Array.isArray(l) &&
                l.length > 0 &&
                ((1 == l.length || (null == l[1] && Number.isInteger(l[0]))) &&
                  ((y = l[0]), (x = l[0])),
                2 == l.length &&
                  (Number.isInteger(l[0]) && Number.isInteger(l[1])
                    ? ((y = l[0]), (x = l[1]))
                    : null == l[0] &&
                      Number.isInteger(l[1]) &&
                      ((y = l[1]), (x = l[1]))))),
          (void 0 !== y && void 0 !== x) || ((y = Ns), (x = Ns)),
          0 == d.length)
        ) {
          v = Math.max(
            Math.ceil(Math.log(o / y) / Math.LN2),
            Math.ceil(Math.log(a / x) / Math.LN2)
          );
          for (let t = v; t >= 0; t--) d.push(Math.pow(2, t));
        } else {
          const t = Math.max(...d);
          v = Math.round(Math.log(t) / Math.LN2);
        }
      else if (((y = o), (x = a), (d = []), p)) {
        r.sort(function (t, e) {
          return t[0] - e[0];
        }),
          (v = -1);
        const t = [];
        for (let e = 0; e < r.length; e++) {
          const i = o / r[e][0];
          d.length > 0 && d[d.length - 1] == i ? t.push(e) : (d.push(i), v++);
        }
        if (t.length > 0)
          for (let e = 0; e < t.length; e++) r.splice(t[e] - e, 1);
      } else d.push(1), r.push([o, a]), (v = 0);
      const S = new dp({
          tileSize: [y, x],
          extent: f,
          origin: Pe(f),
          resolutions: d,
        }),
        C = Qp.bind(
          null,
          sl(l || 256).map(function (t) {
            return t * h;
          })
        );
      super({
        attributions: e.attributions,
        attributionsCollapsible: e.attributionsCollapsible,
        cacheSize: e.cacheSize,
        crossOrigin: e.crossOrigin,
        interpolate: e.interpolate,
        projection: e.projection,
        reprojectionErrorThreshold: e.reprojectionErrorThreshold,
        state: e.state,
        tileClass: C,
        tileGrid: S,
        tilePixelRatio: e.tilePixelRatio,
        tileUrlFunction: function (t, e, s) {
          let l, h;
          const f = t[0];
          if (f > v) return;
          const S = t[1],
            C = t[2],
            w = d[f];
          if (
            !(
              void 0 === S ||
              void 0 === C ||
              void 0 === w ||
              S < 0 ||
              Math.ceil(o / w / y) <= S ||
              C < 0 ||
              Math.ceil(a / w / x) <= C
            )
          ) {
            if (_ || m) {
              const t = S * y * w,
                e = C * x * w;
              let i = y * w,
                r = x * w,
                s = y,
                c = x;
              if (
                (t + i > o && (i = o - t),
                e + r > a && (r = a - e),
                t + y * w > o && (s = Math.floor((o - t + w - 1) / w)),
                e + x * w > a && (c = Math.floor((a - e + w - 1) / w)),
                0 == t && i == o && 0 == e && r == a)
              )
                l = "full";
              else if (!_ || g.includes("regionByPx"))
                l = t + "," + e + "," + i + "," + r;
              else if (g.includes("regionByPct")) {
                l =
                  "pct:" +
                  lm((t / o) * 100) +
                  "," +
                  lm((e / a) * 100) +
                  "," +
                  lm((i / o) * 100) +
                  "," +
                  lm((r / a) * 100);
              }
              n != em || (_ && !g.includes("sizeByWh"))
                ? !_ || g.includes("sizeByW")
                  ? (h = s + ",")
                  : g.includes("sizeByH")
                  ? (h = "," + c)
                  : g.includes("sizeByWh")
                  ? (h = s + "," + c)
                  : g.includes("sizeByPct") && (h = "pct:" + lm(100 / w))
                : (h = s + "," + c);
            } else if (((l = "full"), p)) {
              const t = r[f][0],
                e = r[f][1];
              h =
                n == em
                  ? t == o && e == a
                    ? "max"
                    : t + "," + e
                  : t == o
                  ? "full"
                  : t + ",";
            } else h = n == em ? "max" : "full";
            return i + l + "/" + h + "/0/" + u + "." + c;
          }
        },
        transition: e.transition,
      }),
        (this.zDirection = e.zDirection);
    }
  };
  var cm = class extends ts {
    constructor(t, e, i, n, r, s, o) {
      let a = t.getExtent();
      a && t.canWrapX() && ((a = a.slice()), (a[0] = -1 / 0), (a[2] = 1 / 0));
      let l = e.getExtent();
      l && e.canWrapX() && ((l = l.slice()), (l[0] = -1 / 0), (l[2] = 1 / 0));
      const h = l ? Te(i, l) : i,
        c = yg(t, e, Ce(h), n),
        u = new gg(t, e, h, a, 0.5 * c, n),
        d = u.calculateSourceExtent(),
        g = Le(d) ? null : s(d, c, r),
        f = g ? Vr : Hr,
        p = g ? g.getPixelRatio() : 1;
      super(i, n, p, f),
        (this.targetProj_ = e),
        (this.maxSourceExtent_ = a),
        (this.triangulation_ = u),
        (this.targetResolution_ = n),
        (this.targetExtent_ = i),
        (this.sourceImage_ = g),
        (this.sourcePixelRatio_ = p),
        (this.interpolate_ = o),
        (this.canvas_ = null),
        (this.sourceListenerKey_ = null);
    }
    disposeInternal() {
      this.state == Xr && this.unlistenSource_(), super.disposeInternal();
    }
    getImage() {
      return this.canvas_;
    }
    getProjection() {
      return this.targetProj_;
    }
    reproject_() {
      const t = this.sourceImage_.getState();
      if (t == Zr) {
        const t = Fe(this.targetExtent_) / this.targetResolution_,
          e = Re(this.targetExtent_) / this.targetResolution_;
        this.canvas_ = vg(
          t,
          e,
          this.sourcePixelRatio_,
          qf(this.sourceImage_.getResolution()),
          this.maxSourceExtent_,
          this.targetResolution_,
          this.targetExtent_,
          this.triangulation_,
          [
            {
              extent: this.sourceImage_.getExtent(),
              image: this.sourceImage_.getImage(),
            },
          ],
          0,
          void 0,
          this.interpolate_
        );
      }
      (this.state = t), this.changed();
    }
    load() {
      if (this.state == Vr) {
        (this.state = Xr), this.changed();
        const t = this.sourceImage_.getState();
        t == Zr || t == Kr
          ? this.reproject_()
          : ((this.sourceListenerKey_ = M(
              this.sourceImage_,
              v,
              function (t) {
                const e = this.sourceImage_.getState();
                (e != Zr && e != Kr) ||
                  (this.unlistenSource_(), this.reproject_());
              },
              this
            )),
            this.sourceImage_.load());
      }
    }
    unlistenSource_() {
      k(this.sourceListenerKey_), (this.sourceListenerKey_ = null);
    }
  };
  const um = 4,
    dm = "imageloadstart",
    gm = "imageloadend",
    fm = "imageloaderror";
  class pm extends e {
    constructor(t, e) {
      super(t), (this.image = e);
    }
  }
  function mm(t, e) {
    t.getImage().src = e;
  }
  function _m(t, e, i, n) {
    const r = e / i,
      s = Ce(t),
      o = Ci(Fe(t) / r, um),
      a = Ci(Re(t) / r, um);
    return We(s, r, 0, [
      o + 2 * Ci(((n - 1) * o) / 2, um),
      a + 2 * Ci(((n - 1) * a) / 2, um),
    ]);
  }
  var ym = class extends Iu {
    constructor(t) {
      super({
        attributions: t.attributions,
        projection: t.projection,
        state: t.state,
        interpolate: void 0 === t.interpolate || t.interpolate,
      }),
        this.on,
        this.once,
        this.un,
        (this.loader = t.loader || null),
        (this.resolutions_ = void 0 !== t.resolutions ? t.resolutions : null),
        (this.reprojectedImage_ = null),
        (this.reprojectedRevision_ = 0),
        (this.image = null),
        this.wantedExtent_,
        this.wantedResolution_,
        (this.static_ = !!t.loader && 0 === t.loader.length);
    }
    getResolutions() {
      return this.resolutions_;
    }
    setResolutions(t) {
      this.resolutions_ = t;
    }
    findNearestResolution(t) {
      const e = this.getResolutions();
      if (e) {
        t = e[a(e, t, 0)];
      }
      return t;
    }
    getImage(t, e, i, n) {
      const r = this.getProjection();
      if (!r || !n || ln(r, n))
        return r && (n = r), this.getImageInternal(t, e, i, n);
      if (this.reprojectedImage_) {
        if (
          this.reprojectedRevision_ == this.getRevision() &&
          ln(this.reprojectedImage_.getProjection(), n) &&
          this.reprojectedImage_.getResolution() == e &&
          ce(this.reprojectedImage_.getExtent(), t)
        )
          return this.reprojectedImage_;
        this.reprojectedImage_.dispose(), (this.reprojectedImage_ = null);
      }
      return (
        (this.reprojectedImage_ = new cm(
          r,
          n,
          t,
          e,
          i,
          (t, e, i) => this.getImageInternal(t, e, i, r),
          this.getInterpolate()
        )),
        (this.reprojectedRevision_ = this.getRevision()),
        this.reprojectedImage_
      );
    }
    getImageInternal(t, e, i, n) {
      if (this.loader) {
        const n = _m(t, e, i, 1),
          r = this.findNearestResolution(e);
        if (
          this.image &&
          (this.static_ ||
            (((this.wantedExtent_ && ie(this.wantedExtent_, n)) ||
              ie(this.image.getExtent(), n)) &&
              ((this.wantedResolution_ && qf(this.wantedResolution_) === r) ||
                qf(this.image.getResolution()) === r)))
        )
          return this.image;
        (this.wantedExtent_ = n),
          (this.wantedResolution_ = r),
          (this.image = new ts(n, r, i, this.loader)),
          this.image.addEventListener(v, this.handleImageChange.bind(this));
      }
      return this.image;
    }
    handleImageChange(t) {
      const e = t.target;
      let i;
      switch (e.getState()) {
        case Xr:
          (this.loading = !0), (i = dm);
          break;
        case Zr:
          (this.loading = !1), (i = gm);
          break;
        case Kr:
          (this.loading = !1), (i = fm);
          break;
        default:
          return;
      }
      this.hasListener(i) && this.dispatchEvent(new pm(i, e));
    }
  };
  function xm(t, e) {
    const i = [];
    Object.keys(e).forEach(function (t) {
      null !== e[t] &&
        void 0 !== e[t] &&
        i.push(t + "=" + encodeURIComponent(e[t]));
    });
    const n = i.join("&");
    return (t = t.replace(/[?&]$/, "")), (t += t.includes("?") ? "&" : "?") + n;
  }
  function vm(t, e, i, n, r, s) {
    const o = r
        .getCode()
        .split(/:(?=\d+$)/)
        .pop(),
      a = i / n,
      l = [vi(Fe(e) / a, um), vi(Re(e) / a, um)];
    (s.SIZE = l[0] + "," + l[1]),
      (s.BBOX = e.join(",")),
      (s.BBOXSR = o),
      (s.IMAGESR = o),
      (s.DPI = Math.round(s.DPI ? s.DPI * n : 90 * n));
    const h = t
      .replace(/MapServer\/?$/, "MapServer/export")
      .replace(/ImageServer\/?$/, "ImageServer/exportImage");
    if (h == t) throw new Error("`options.featureTypes` should be an Array");
    return xm(h, s);
  }
  function Sm(t) {
    const e = t.load ? t.load : Jr,
      i = tn(t.projection || "EPSG:3857");
    return function (n, r, s) {
      s = t.hidpi ? s : 1;
      const o = { F: "image", FORMAT: "PNG32", TRANSPARENT: !0 };
      Object.assign(o, t.params), (n = _m(n, r, s, t.ratio));
      const a = vm(t.url, n, r, s, i, o),
        l = new Image();
      return (
        null !== t.crossOrigin && (l.crossOrigin = t.crossOrigin),
        e(l, a).then((t) => {
          const e = (Fe(n) / t.width) * s;
          return { image: t, extent: n, resolution: e, pixelRatio: s };
        })
      );
    };
  }
  var Cm = class extends ym {
    constructor(t) {
      super({
        attributions: (t = t || {}).attributions,
        interpolate: t.interpolate,
        projection: t.projection,
        resolutions: t.resolutions,
      }),
        (this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null),
        (this.hidpi_ = void 0 === t.hidpi || t.hidpi),
        (this.url_ = t.url),
        (this.imageLoadFunction_ =
          void 0 !== t.imageLoadFunction ? t.imageLoadFunction : mm),
        (this.params_ = t.params || {}),
        (this.image_ = null),
        (this.imageSize_ = [0, 0]),
        (this.renderedRevision_ = 0),
        (this.ratio_ = void 0 !== t.ratio ? t.ratio : 1.5);
    }
    getParams() {
      return this.params_;
    }
    getImageInternal(t, e, i, n) {
      return void 0 === this.url_
        ? null
        : (this.loader ||
            (this.loader = Sm({
              crossOrigin: this.crossOrigin_,
              params: this.params_,
              projection: n,
              hidpi: this.hidpi_,
              url: this.url_,
              ratio: this.ratio_,
              load: (t, e) => (
                this.image.setImage(t),
                this.imageLoadFunction_(this.image, e),
                Jr(t)
              ),
            })),
          super.getImageInternal(t, e, i, n));
    }
    getImageLoadFunction() {
      return this.imageLoadFunction_;
    }
    getUrl() {
      return this.url_;
    }
    setImageLoadFunction(t) {
      (this.image_ = null), (this.imageLoadFunction_ = t), this.changed();
    }
    setUrl(t) {
      t != this.url_ && ((this.url_ = t), (this.image_ = null), this.changed());
    }
    updateParams(t) {
      Object.assign(this.params_, t), (this.image_ = null), this.changed();
    }
  };
  var wm = class extends ym {
    constructor(t) {
      super({
        attributions: (t = t || {}).attributions,
        interpolate: t.interpolate,
        projection: t.projection,
        resolutions: t.resolutions,
        state: t.state,
      }),
        (this.canvasFunction_ = t.canvasFunction),
        (this.canvas_ = null),
        (this.renderedRevision_ = 0),
        (this.ratio_ = void 0 !== t.ratio ? t.ratio : 1.5);
    }
    getImageInternal(t, e, i, n) {
      e = this.findNearestResolution(e);
      let r = this.canvas_;
      if (
        r &&
        this.renderedRevision_ == this.getRevision() &&
        r.getResolution() == e &&
        r.getPixelRatio() == i &&
        ie(r.getExtent(), t)
      )
        return r;
      Oe((t = t.slice()), this.ratio_);
      const s = [(Fe(t) / e) * i, (Re(t) / e) * i],
        o = this.canvasFunction_.call(this, t, e, i, s, n);
      return (
        o && (r = new es(t, e, i, o)),
        (this.canvas_ = r),
        (this.renderedRevision_ = this.getRevision()),
        r
      );
    }
  };
  function Wm(t, e, i, n, r, s, o) {
    const a = (function (t, e, i, n) {
        const r = Fe(t),
          s = Re(t),
          o = e[0],
          a = e[1],
          l = 0.0254 / n;
        return a * r > o * s ? (r * i) / (o * l) : (s * i) / (a * l);
      })(i, n, s, o),
      l = Ce(i),
      h = {
        OPERATION: r ? "GETDYNAMICMAPOVERLAYIMAGE" : "GETMAPIMAGE",
        VERSION: "2.0.0",
        LOCALE: "en",
        CLIENTAGENT: "ol/source/ImageMapGuide source",
        CLIP: "1",
        SETDISPLAYDPI: o,
        SETDISPLAYWIDTH: Math.round(n[0]),
        SETDISPLAYHEIGHT: Math.round(n[1]),
        SETVIEWSCALE: a,
        SETVIEWCENTERX: l[0],
        SETVIEWCENTERY: l[1],
      };
    return Object.assign(h, e), xm(t, h);
  }
  function Em(t) {
    const e = t.load || Jr;
    return function (i, n, r) {
      const s = new Image();
      null !== t.crossOrigin && (s.crossOrigin = t.crossOrigin);
      const o = Fe((i = _m(i, n, r, t.ratio))) / n,
        a = Re(i) / n,
        l = [o * r, a * r],
        h = Wm(
          t.url,
          t.params,
          i,
          l,
          t.useOverlay,
          t.metersPerUnit || 1,
          t.displayDpi || 96
        );
      return e(s, h).then((t) => ({ image: t, extent: i, pixelRatio: r }));
    };
  }
  var Rm = class extends ym {
    constructor(t) {
      super({
        interpolate: t.interpolate,
        projection: t.projection,
        resolutions: t.resolutions,
      }),
        (this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null),
        (this.displayDpi_ = void 0 !== t.displayDpi ? t.displayDpi : 96),
        (this.params_ = t.params || {}),
        (this.url_ = t.url),
        (this.imageLoadFunction_ =
          void 0 !== t.imageLoadFunction ? t.imageLoadFunction : mm),
        (this.hidpi_ = void 0 === t.hidpi || t.hidpi),
        (this.metersPerUnit_ =
          void 0 !== t.metersPerUnit ? t.metersPerUnit : 1),
        (this.ratio_ = void 0 !== t.ratio ? t.ratio : 1),
        (this.useOverlay_ = void 0 !== t.useOverlay && t.useOverlay),
        (this.image_ = null),
        (this.renderedRevision_ = 0);
    }
    getParams() {
      return this.params_;
    }
    getImageInternal(t, e, i, n) {
      return void 0 === this.url_
        ? null
        : (this.loader ||
            (this.loader = Em({
              crossOrigin: this.crossOrigin_,
              params: this.params_,
              hidpi: this.hidpi_,
              metersPerUnit: this.metersPerUnit_,
              url: this.url_,
              useOverlay: this.useOverlay_,
              ratio: this.ratio_,
              load: (t, e) => (
                this.image.setImage(t),
                this.imageLoadFunction_(this.image, e),
                Jr(t)
              ),
            })),
          super.getImageInternal(t, e, i, n));
    }
    getImageLoadFunction() {
      return this.imageLoadFunction_;
    }
    updateParams(t) {
      Object.assign(this.params_, t), this.changed();
    }
    setImageLoadFunction(t) {
      (this.image_ = null), (this.imageLoadFunction_ = t), this.changed();
    }
  };
  function Tm(t) {
    const e = t.load || Jr,
      i = t.imageExtent,
      n = new Image();
    return (
      null !== t.crossOrigin && (n.crossOrigin = t.crossOrigin),
      () =>
        e(n, t.url).then((t) => {
          const e = Fe(i) / t.width,
            n = Re(i) / t.height;
          return {
            image: t,
            extent: i,
            resolution: e !== n ? [e, n] : n,
            pixelRatio: 1,
          };
        })
    );
  }
  var Pm = class extends ym {
    constructor(t) {
      const e = void 0 !== t.crossOrigin ? t.crossOrigin : null,
        i = void 0 !== t.imageLoadFunction ? t.imageLoadFunction : mm;
      super({
        attributions: t.attributions,
        interpolate: t.interpolate,
        projection: tn(t.projection),
      }),
        (this.url_ = t.url),
        (this.imageExtent_ = t.imageExtent),
        (this.image = null),
        (this.image = new ts(
          this.imageExtent_,
          void 0,
          1,
          Tm({
            url: t.url,
            imageExtent: t.imageExtent,
            crossOrigin: e,
            load: (t, e) => (this.image.setImage(t), i(this.image, e), Jr(t)),
          })
        )),
        this.image.addEventListener(v, this.handleImageChange.bind(this));
    }
    getImageExtent() {
      return this.imageExtent_;
    }
    getImageInternal(t, e, i, n) {
      return Ie(t, this.image.getExtent()) ? this.image : null;
    }
    getUrl() {
      return this.url_;
    }
  };
  const bm = "1.3.0";
  function Fm(t, e, i, n, r) {
    (r.WIDTH = i[0]), (r.HEIGHT = i[1]);
    const s = n.getAxisOrientation();
    let o;
    const a = Wi(r.VERSION, "1.3") >= 0;
    return (
      (r[a ? "CRS" : "SRS"] = n.getCode()),
      (o = a && "ne" == s.substr(0, 2) ? [e[1], e[0], e[3], e[2]] : e),
      (r.BBOX = o.join(",")),
      xm(t, r)
    );
  }
  function Im(t, e, i, n, r, s, o) {
    s = Object.assign({ REQUEST: "GetMap" }, s);
    const a = e / i,
      l = [vi(Fe(t) / a, um), vi(Re(t) / a, um)];
    if (1 != i)
      switch (o) {
        case "geoserver":
          const t = (90 * i + 0.5) | 0;
          "FORMAT_OPTIONS" in s
            ? (s.FORMAT_OPTIONS += ";dpi:" + t)
            : (s.FORMAT_OPTIONS = "dpi:" + t);
          break;
        case "mapserver":
          s.MAP_RESOLUTION = 90 * i;
          break;
        case "carmentaserver":
        case "qgis":
          s.DPI = 90 * i;
          break;
        default:
          throw new Error("Unknown `serverType` configured");
      }
    return Fm(r, t, l, n, s);
  }
  function Lm(t, e) {
    return Object.assign(
      {
        REQUEST: e,
        SERVICE: "WMS",
        VERSION: bm,
        FORMAT: "image/png",
        STYLES: "",
        TRANSPARENT: !0,
      },
      t
    );
  }
  function Mm(t) {
    const e = void 0 === t.hidpi || t.hidpi,
      i = tn(t.projection || "EPSG:3857"),
      n = t.ratio || 1.5,
      r = t.load || Jr;
    return (s, o, a) => {
      (s = _m(s, o, a, n)), 1 == a || (e && void 0 !== t.serverType) || (a = 1);
      const l = Im(s, o, a, i, t.url, Lm(t.params, "GetMap"), t.serverType),
        h = new Image();
      return (
        null !== t.crossOrigin && (h.crossOrigin = t.crossOrigin),
        r(h, l).then((t) => ({ image: t, extent: s, pixelRatio: a }))
      );
    };
  }
  const Om = [101, 101];
  var km = class extends ym {
    constructor(t) {
      super({
        attributions: (t = t || {}).attributions,
        interpolate: t.interpolate,
        projection: t.projection,
        resolutions: t.resolutions,
      }),
        (this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null),
        (this.url_ = t.url),
        (this.imageLoadFunction_ =
          void 0 !== t.imageLoadFunction ? t.imageLoadFunction : mm),
        (this.params_ = t.params),
        (this.serverType_ = t.serverType),
        (this.hidpi_ = void 0 === t.hidpi || t.hidpi),
        (this.renderedRevision_ = 0),
        (this.ratio_ = void 0 !== t.ratio ? t.ratio : 1.5);
    }
    getFeatureInfoUrl(t, e, i, n) {
      if (void 0 === this.url_) return;
      const r = tn(i),
        s = this.getProjection();
      s && s !== r && ((e = yg(s, r, t, e)), (t = un(t, r, s)));
      const o = We(t, e, 0, Om),
        a = { QUERY_LAYERS: this.params_.LAYERS };
      Object.assign(a, Lm(this.params_, "GetFeatureInfo"), n);
      const l = Si((t[0] - o[0]) / e, um),
        h = Si((o[3] - t[1]) / e, um),
        c = Wi(a.VERSION, "1.3") >= 0;
      return (
        (a[c ? "I" : "X"] = l),
        (a[c ? "J" : "Y"] = h),
        Fm(this.url_, o, Om, s || r, a)
      );
    }
    getLegendUrl(t, e) {
      if (void 0 === this.url_) return;
      const i = {
        SERVICE: "WMS",
        VERSION: bm,
        REQUEST: "GetLegendGraphic",
        FORMAT: "image/png",
      };
      if (void 0 === e || void 0 === e.LAYER) {
        const t = this.params_.LAYERS;
        if (!(!Array.isArray(t) || 1 === t.length)) return;
        i.LAYER = t;
      }
      if (void 0 !== t) {
        const e = this.getProjection()
            ? this.getProjection().getMetersPerUnit()
            : 1,
          n = 28e-5;
        i.SCALE = (t * e) / n;
      }
      return Object.assign(i, e), xm(this.url_, i);
    }
    getParams() {
      return this.params_;
    }
    getImageInternal(t, e, i, n) {
      return void 0 === this.url_
        ? null
        : (this.loader ||
            (this.loader = Mm({
              crossOrigin: this.crossOrigin_,
              params: this.params_,
              projection: n,
              serverType: this.serverType_,
              hidpi: this.hidpi_,
              url: this.url_,
              ratio: this.ratio_,
              load: (t, e) => (
                this.image.setImage(t),
                this.imageLoadFunction_(this.image, e),
                Jr(t)
              ),
            })),
          super.getImageInternal(t, e, i, n));
    }
    getImageLoadFunction() {
      return this.imageLoadFunction_;
    }
    getUrl() {
      return this.url_;
    }
    setImageLoadFunction(t) {
      (this.imageLoadFunction_ = t), this.changed();
    }
    setUrl(t) {
      t != this.url_ && ((this.url_ = t), (this.loader = null), this.changed());
    }
    updateParams(t) {
      Object.assign(this.params_, t), this.changed();
    }
    changed() {
      (this.image = null), super.changed();
    }
  };
  function Am(t, e, i, n) {
    const r = document.createElement("script"),
      s = "olc_" + j(e);
    function o() {
      delete window[s], r.parentNode.removeChild(r);
    }
    (r.async = !0),
      (r.src = t + (t.includes("?") ? "&" : "?") + (n || "callback") + "=" + s);
    const a = setTimeout(function () {
      o(), i && i();
    }, 1e4);
    (window[s] = function (t) {
      clearTimeout(a), o(), e(t);
    }),
      document.head.appendChild(r);
  }
  class Nm extends Error {
    constructor(t) {
      super("Unexpected response status: " + t.status),
        (this.name = "ResponseError"),
        (this.response = t);
    }
  }
  class Dm extends Error {
    constructor(t) {
      super("Failed to issue request"),
        (this.name = "ClientError"),
        (this.client = t);
    }
  }
  function Gm(t) {
    return new Promise(function (e, i) {
      const n = new XMLHttpRequest();
      n.addEventListener("load", function (t) {
        const n = t.target;
        if (!n.status || (n.status >= 200 && n.status < 300)) {
          let t;
          try {
            t = JSON.parse(n.responseText);
          } catch (t) {
            const e = "Error parsing response text as JSON: " + t.message;
            return void i(new Error(e));
          }
          e(t);
        } else i(new Nm(n));
      }),
        n.addEventListener("error", function (t) {
          i(new Dm(t.target));
        }),
        n.open("GET", t),
        n.setRequestHeader("Accept", "application/json"),
        n.send();
    });
  }
  function Bm(t, e) {
    return e.includes("://") ? e : new URL(e, t).href;
  }
  let jm;
  const zm = {
      "image/png": !0,
      "image/jpeg": !0,
      "image/gif": !0,
      "image/webp": !0,
    },
    Um = {
      "application/vnd.mapbox-vector-tile": !0,
      "application/geo+json": !0,
    };
  function qm(t, e) {
    let i, n;
    for (let r = 0; r < t.length; ++r) {
      const s = t[r];
      if ("item" === s.rel) {
        if (s.type === e) {
          i = s.href;
          break;
        }
        (zm[s.type] || (!n && s.type.startsWith("image/"))) && (n = s.href);
      }
    }
    if (!i) {
      if (!n) throw new Error('Could not find "item" link');
      i = n;
    }
    return i;
  }
  function Vm(t, e, i) {
    let n, r;
    const s = {};
    for (let i = 0; i < t.length; ++i) {
      const o = t[i];
      if (((s[o.type] = o.href), "item" === o.rel)) {
        if (o.type === e) {
          n = o.href;
          break;
        }
        Um[o.type] && (r = o.href);
      }
    }
    if (!n && i)
      for (let t = 0; t < i.length; ++t) {
        const e = i[t];
        if (s[e]) {
          n = s[e];
          break;
        }
      }
    if (!n) {
      if (!r) throw new Error('Could not find "item" link');
      n = r;
    }
    return n;
  }
  function Xm(t, e, i, n) {
    let r = t.projection;
    if (!r && ((r = tn(e.crs)), !r))
      throw new Error(`Unsupported CRS: ${e.crs}`);
    const s = "en" !== r.getAxisOrientation().substr(0, 2),
      o = e.tileMatrices,
      a = {};
    for (let t = 0; t < o.length; ++t) {
      const e = o[t];
      a[e.id] = e;
    }
    const l = {},
      h = [];
    if (n)
      for (let t = 0; t < n.length; ++t) {
        const e = n[t],
          i = e.tileMatrix;
        h.push(i), (l[i] = e);
      }
    else
      for (let t = 0; t < o.length; ++t) {
        const e = o[t].id;
        h.push(e);
      }
    const c = h.length,
      u = new Array(c),
      d = new Array(c),
      g = new Array(c),
      f = new Array(c),
      p = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    for (let t = 0; t < c; ++t) {
      const e = h[t],
        i = a[e],
        n = i.pointOfOrigin;
      (u[t] = s ? [n[1], n[0]] : n),
        (d[t] = i.cellSize),
        (g[t] = [i.matrixWidth, i.matrixHeight]),
        (f[t] = [i.tileWidth, i.tileHeight]);
      const r = l[e];
      if (r) {
        const e = i.cellSize * i.tileWidth,
          n = u[t][0] + r.minTileCol * e,
          s = u[t][0] + (r.maxTileCol + 1) * e,
          o = i.cellSize * i.tileHeight;
        let a, l;
        "bottomLeft" === i.cornerOfOrigin
          ? ((a = u[t][1] + r.minTileRow * o),
            (l = u[t][1] + (r.maxTileRow + 1) * o))
          : ((a = u[t][1] - (r.maxTileRow + 1) * o),
            (l = u[t][1] - r.minTileRow * o)),
          Te(p, [n, a, s, l], p);
      }
    }
    const m = new dp({
        origins: u,
        resolutions: d,
        sizes: g,
        tileSizes: f,
        extent: n ? p : void 0,
      }),
      _ = t.context,
      y = t.url;
    return {
      grid: m,
      urlTemplate: i,
      urlFunction: function (t, e, r) {
        if (!t) return;
        const s = h[t[0]],
          o = a[s],
          c = "bottomLeft" === o.cornerOfOrigin,
          u = { tileMatrix: s, tileCol: t[1], tileRow: c ? -t[2] - 1 : t[2] };
        if (n) {
          const t = l[o.id];
          if (
            u.tileCol < t.minTileCol ||
            u.tileCol > t.maxTileCol ||
            u.tileRow < t.minTileRow ||
            u.tileRow > t.maxTileRow
          )
            return;
        }
        Object.assign(u, _);
        const d = i.replace(/\{(\w+?)\}/g, function (t, e) {
          return u[e];
        });
        return Bm(y, d);
      },
    };
  }
  function Zm(t) {
    return Gm(t.url).then(function (e) {
      return (function (t, e) {
        const i = e.tileMatrixSetLimits;
        let n;
        if ("map" === e.dataType) n = qm(e.links, t.mediaType);
        else {
          if ("vector" !== e.dataType)
            throw new Error(
              'Expected tileset data type to be "map" or "vector"'
            );
          n = Vm(e.links, t.mediaType, t.supportedMediaTypes);
        }
        if (e.tileMatrixSet) return Xm(t, e.tileMatrixSet, n, i);
        const r = e.links.find(
          (t) =>
            "http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme" === t.rel
        );
        if (!r)
          throw new Error(
            "Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet"
          );
        const s = r.href;
        return Gm(Bm(t.url, s)).then(function (e) {
          return Xm(t, e, n, i);
        });
      })(t, e);
    });
  }
  var Km = class extends Fp {
    constructor(t) {
      super({
        attributions: t.attributions,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        interpolate: t.interpolate,
        projection: t.projection,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        state: "loading",
        tileLoadFunction: t.tileLoadFunction,
        wrapX: void 0 === t.wrapX || t.wrapX,
        transition: t.transition,
      });
      Zm({
        url: t.url,
        projection: this.getProjection(),
        mediaType: t.mediaType,
        context: t.context || null,
      })
        .then(this.handleTileSetInfo_.bind(this))
        .catch(this.handleError_.bind(this));
    }
    handleTileSetInfo_(t) {
      (this.tileGrid = t.grid),
        this.setTileUrlFunction(t.urlFunction, t.urlTemplate),
        this.setState("ready");
    }
    handleError_(t) {
      Zi(t), this.setState("error");
    }
  };
  var Hm = class extends rt {
    constructor(t, e, i, n, r, s) {
      super(t, e, s),
        (this.extent = null),
        (this.format_ = n),
        (this.features_ = null),
        this.loader_,
        (this.projection = null),
        this.resolution,
        (this.tileLoadFunction_ = r),
        (this.url_ = i),
        (this.key = i);
    }
    getFormat() {
      return this.format_;
    }
    getFeatures() {
      return this.features_;
    }
    load() {
      this.state == H &&
        (this.setState(Y),
        this.tileLoadFunction_(this, this.url_),
        this.loader_ &&
          this.loader_(this.extent, this.resolution, this.projection));
    }
    onLoad(t, e) {
      this.setFeatures(t);
    }
    onError() {
      this.setState($);
    }
    setFeatures(t) {
      (this.features_ = t), this.setState(Q);
    }
    setLoader(t) {
      this.loader_ = t;
    }
  };
  const Ym = [];
  var Qm = class extends rt {
    constructor(t, e, i, n) {
      super(t, e, { transition: 0 }),
        (this.context_ = {}),
        (this.executorGroups = {}),
        (this.declutterExecutorGroups = {}),
        (this.loadingSourceTiles = 0),
        (this.hitDetectionImageData = {}),
        (this.replayState_ = {}),
        (this.sourceTiles = []),
        (this.errorTileKeys = {}),
        this.wantedResolution,
        (this.getSourceTiles = n.bind(void 0, this)),
        (this.wrappedTileCoord = i);
    }
    getContext(t) {
      const e = j(t);
      return (
        e in this.context_ || (this.context_[e] = mt(1, 1, Ym)),
        this.context_[e]
      );
    }
    hasContext(t) {
      return j(t) in this.context_;
    }
    getImage(t) {
      return this.hasContext(t) ? this.getContext(t).canvas : null;
    }
    getReplayState(t) {
      const e = j(t);
      return (
        e in this.replayState_ ||
          (this.replayState_[e] = {
            dirty: !1,
            renderedRenderOrder: null,
            renderedResolution: NaN,
            renderedRevision: -1,
            renderedTileResolution: NaN,
            renderedTileRevision: -1,
            renderedTileZ: -1,
          }),
        this.replayState_[e]
      );
    }
    load() {
      this.getSourceTiles();
    }
    release() {
      for (const t in this.context_) {
        const e = this.context_[t];
        _t(e), Ym.push(e.canvas), delete this.context_[t];
      }
      super.release();
    }
  };
  var $m = class extends Pp {
    constructor(t) {
      const e = t.projection || "EPSG:3857",
        i = t.extent || xp(e),
        n =
          t.tileGrid ||
          mp({
            extent: i,
            maxResolution: t.maxResolution,
            maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 22,
            minZoom: t.minZoom,
            tileSize: t.tileSize || 512,
          });
      super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        cacheSize: t.cacheSize,
        interpolate: !0,
        opaque: !1,
        projection: e,
        state: t.state,
        tileGrid: n,
        tileLoadFunction: t.tileLoadFunction ? t.tileLoadFunction : Jm,
        tileUrlFunction: t.tileUrlFunction,
        url: t.url,
        urls: t.urls,
        wrapX: void 0 === t.wrapX || t.wrapX,
        transition: t.transition,
        zDirection: void 0 === t.zDirection ? 1 : t.zDirection,
      }),
        (this.format_ = t.format ? t.format : null),
        (this.sourceTileCache = new ap(this.tileCache.highWaterMark)),
        (this.overlaps_ = null == t.overlaps || t.overlaps),
        (this.tileClass = t.tileClass ? t.tileClass : Hm),
        (this.tileGrids_ = {});
    }
    getFeaturesInExtent(t) {
      const e = [],
        i = this.tileCache;
      if (0 === i.getCount()) return e;
      const n = Ag(i.peekFirstKey())[0],
        r = this.tileGrid;
      return (
        i.forEach(function (i) {
          if (i.tileCoord[0] !== n || i.getState() !== Q) return;
          const s = i.getSourceTiles();
          for (let i = 0, n = s.length; i < n; ++i) {
            const n = s[i],
              o = n.tileCoord;
            if (Ie(t, r.getTileCoordExtent(o))) {
              const i = n.getFeatures();
              if (i)
                for (let n = 0, r = i.length; n < r; ++n) {
                  const r = i[n],
                    s = r.getGeometry();
                  Ie(t, s.getExtent()) && e.push(r);
                }
            }
          }
        }),
        e
      );
    }
    getOverlaps() {
      return this.overlaps_;
    }
    clear() {
      this.tileCache.clear(), this.sourceTileCache.clear();
    }
    expireCache(t, e) {
      const i = this.getTileCacheForProjection(t),
        n = Object.keys(e).reduce((t, e) => {
          const n = kg(e),
            r = i.peek(n);
          if (r) {
            const e = r.sourceTiles;
            for (let i = 0, n = e.length; i < n; ++i) t[e[i].getKey()] = !0;
          }
          return t;
        }, {});
      super.expireCache(t, e), this.sourceTileCache.expireCache(n);
    }
    getSourceTiles(t, e, i) {
      if (i.getState() === H) {
        i.setState(Y);
        const n = i.wrappedTileCoord,
          r = this.getTileGridForProjection(e),
          s = r.getTileCoordExtent(n),
          o = n[0],
          a = r.getResolution(o);
        $t(s, -a, s);
        const l = this.tileGrid,
          h = l.getExtent();
        h && Te(s, h, s);
        const c = l.getZForResolution(a, this.zDirection);
        l.forEachTileCoord(s, c, (n) => {
          const r = this.tileUrlFunction(n, t, e),
            s = this.sourceTileCache.containsKey(r)
              ? this.sourceTileCache.get(r)
              : new this.tileClass(
                  n,
                  r ? H : J,
                  r,
                  this.format_,
                  this.tileLoadFunction
                );
          i.sourceTiles.push(s);
          const o = s.getState();
          if (o < Q) {
            const t = (e) => {
              this.handleTileChange(e);
              const n = s.getState();
              if (n === Q || n === $) {
                const e = s.getKey();
                e in i.errorTileKeys
                  ? s.getState() === Q && delete i.errorTileKeys[e]
                  : i.loadingSourceTiles--,
                  n === $
                    ? (i.errorTileKeys[e] = !0)
                    : s.removeEventListener(v, t),
                  0 === i.loadingSourceTiles &&
                    i.setState(y(i.errorTileKeys) ? Q : $);
              }
            };
            s.addEventListener(v, t), i.loadingSourceTiles++;
          }
          o === H &&
            ((s.extent = l.getTileCoordExtent(n)),
            (s.projection = e),
            (s.resolution = l.getResolution(n[0])),
            this.sourceTileCache.set(r, s),
            s.load());
        }),
          i.loadingSourceTiles ||
            i.setState(i.sourceTiles.some((t) => t.getState() === $) ? $ : Q);
      }
      return i.sourceTiles;
    }
    getTile(t, e, i, n, r) {
      const s = Mg(t, e, i),
        o = this.getKey();
      let a;
      if (
        this.tileCache.containsKey(s) &&
        ((a = this.tileCache.get(s)), a.key === o)
      )
        return a;
      const l = [t, e, i];
      let h = this.getTileCoordForTileUrlFunction(l, r);
      const c = this.getTileGrid().getExtent(),
        u = this.getTileGridForProjection(r);
      if (h && c) {
        const e = u.getTileCoordExtent(h);
        $t(e, -u.getResolution(t), e), Ie(c, e) || (h = null);
      }
      let d = !0;
      if (null !== h) {
        const e = this.tileGrid,
          i = u.getResolution(t),
          s = e.getZForResolution(i, 1),
          o = u.getTileCoordExtent(h);
        $t(o, -i, o),
          e.forEachTileCoord(o, s, (t) => {
            d = d && !this.tileUrlFunction(t, n, r);
          });
      }
      const g = new Qm(l, d ? J : H, h, this.getSourceTiles.bind(this, n, r));
      return (
        (g.key = o),
        a
          ? ((g.interimTile = a),
            g.refreshInterimChain(),
            this.tileCache.replace(s, g))
          : this.tileCache.set(s, g),
        g
      );
    }
    getTileGridForProjection(t) {
      const e = t.getCode();
      let i = this.tileGrids_[e];
      if (!i) {
        const t = this.tileGrid,
          n = t.getResolutions().slice(),
          r = n.map(function (e, i) {
            return t.getOrigin(i);
          }),
          s = n.map(function (e, i) {
            return t.getTileSize(i);
          }),
          o = As + 1;
        for (let t = n.length; t < o; ++t)
          n.push(n[t - 1] / 2), r.push(r[t - 1]), s.push(s[t - 1]);
        (i = new dp({
          extent: t.getExtent(),
          origins: r,
          resolutions: n,
          tileSizes: s,
        })),
          (this.tileGrids_[e] = i);
      }
      return i;
    }
    getTilePixelRatio(t) {
      return t;
    }
    getTilePixelSize(t, e, i) {
      const n = sl(
        this.getTileGridForProjection(i).getTileSize(t),
        this.tmpSize
      );
      return [Math.round(n[0] * e), Math.round(n[1] * e)];
    }
    updateCacheSize(t, e) {
      super.updateCacheSize(2 * t, e),
        (this.sourceTileCache.highWaterMark =
          this.getTileCacheForProjection(e).highWaterMark);
    }
  };
  function Jm(t, e) {
    t.setLoader(function (i, n, r) {
      ju(e, t.getFormat(), i, n, r, t.onLoad.bind(t), t.onError.bind(t));
    });
  }
  var t_ = class extends $m {
    constructor(t) {
      super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        cacheSize: t.cacheSize,
        format: t.format,
        overlaps: t.overlaps,
        projection: t.projection,
        tileClass: t.tileClass,
        transition: t.transition,
        wrapX: t.wrapX,
        zDirection: t.zDirection,
        state: "loading",
      });
      Zm({
        url: t.url,
        projection: this.getProjection(),
        mediaType: t.mediaType,
        supportedMediaTypes: t.format.supportedMediaTypes,
        context: t.context || null,
      })
        .then(this.handleTileSetInfo_.bind(this))
        .catch(this.handleError_.bind(this));
    }
    handleTileSetInfo_(t) {
      (this.tileGrid = t.grid),
        this.setTileUrlFunction(t.urlFunction, t.urlTemplate),
        this.setState("ready");
    }
    handleError_(t) {
      Zi(t), this.setState("error");
    }
  };
  const e_ =
    '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
  var i_ = class extends Mp {
    constructor(t) {
      let e;
      e = void 0 !== (t = t || {}).attributions ? t.attributions : [e_];
      const i = void 0 !== t.crossOrigin ? t.crossOrigin : "anonymous",
        n =
          void 0 !== t.url
            ? t.url
            : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
      super({
        attributions: e,
        attributionsCollapsible: !1,
        cacheSize: t.cacheSize,
        crossOrigin: i,
        interpolate: t.interpolate,
        maxZoom: void 0 !== t.maxZoom ? t.maxZoom : 19,
        opaque: void 0 === t.opaque || t.opaque,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        tileLoadFunction: t.tileLoadFunction,
        transition: t.transition,
        url: n,
        wrapX: t.wrapX,
        zDirection: t.zDirection,
      });
    }
  };
  let n_,
    r_ = !0;
  try {
    new ImageData(10, 10);
  } catch (t) {
    r_ = !1;
  }
  function s_(t, e, i) {
    if (r_) return new ImageData(t, e, i);
    n_ || (n_ = document.createElement("canvas").getContext("2d"));
    const n = n_.createImageData(e, i);
    return n.data.set(t), n;
  }
  function o_(t) {
    let e = !0;
    try {
      new ImageData(10, 10);
    } catch (t) {
      e = !1;
    }
    function i(t, i, n) {
      return e ? new ImageData(t, i, n) : { data: t, width: i, height: n };
    }
    return function (e) {
      const n = e.buffers,
        r = e.meta,
        s = e.imageOps,
        o = e.width,
        a = e.height,
        l = n.length,
        h = n[0].byteLength;
      if (s) {
        const e = new Array(l);
        for (let t = 0; t < l; ++t) e[t] = i(new Uint8ClampedArray(n[t]), o, a);
        return t(e, r).data.buffer;
      }
      const c = new Uint8ClampedArray(h),
        u = new Array(l),
        d = new Array(l);
      for (let t = 0; t < l; ++t)
        (u[t] = new Uint8ClampedArray(n[t])), (d[t] = [0, 0, 0, 0]);
      for (let e = 0; e < h; e += 4) {
        for (let t = 0; t < l; ++t) {
          const i = u[t];
          (d[t][0] = i[e]),
            (d[t][1] = i[e + 1]),
            (d[t][2] = i[e + 2]),
            (d[t][3] = i[e + 3]);
        }
        const i = t(d, r);
        (c[e] = i[0]), (c[e + 1] = i[1]), (c[e + 2] = i[2]), (c[e + 3] = i[3]);
      }
      return c.buffer;
    };
  }
  function a_(t, e) {
    const i = Object.keys(t.lib || {})
        .map(function (e) {
          return "const " + e + " = " + t.lib[e].toString() + ";";
        })
        .concat([
          "const __minion__ = (" + o_.toString() + ")(",
          t.operation.toString(),
          ");",
          'self.addEventListener("message", function(event) {',
          "  const buffer = __minion__(event.data);",
          "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);",
          "});",
        ]),
      n = new Worker(
        "undefined" == typeof Blob
          ? "data:text/javascript;base64," +
            Buffer.from(i.join("\n"), "binary").toString("base64")
          : URL.createObjectURL(new Blob(i, { type: "text/javascript" }))
      );
    return n.addEventListener("message", e), n;
  }
  class l_ extends n {
    constructor(t) {
      let e;
      super(),
        (this._imageOps = !!t.imageOps),
        (e = 0 === t.threads ? 0 : this._imageOps ? 1 : t.threads || 1);
      const i = new Array(e);
      if (e)
        for (let n = 0; n < e; ++n)
          i[n] = a_(t, this._onWorkerMessage.bind(this, n));
      else
        i[0] = (function (t, e) {
          const i = o_(t.operation);
          let n = !1;
          return {
            postMessage: function (t) {
              setTimeout(function () {
                n || e({ data: { buffer: i(t), meta: t.meta } });
              }, 0);
            },
            terminate: function () {
              n = !0;
            },
          };
        })(t, this._onWorkerMessage.bind(this, 0));
      (this._workers = i),
        (this._queue = []),
        (this._maxQueueLength = t.queue || 1 / 0),
        (this._running = 0),
        (this._dataLookup = {}),
        (this._job = null);
    }
    process(t, e, i) {
      this._enqueue({ inputs: t, meta: e, callback: i }), this._dispatch();
    }
    _enqueue(t) {
      for (this._queue.push(t); this._queue.length > this._maxQueueLength; )
        this._queue.shift().callback(null, null);
    }
    _dispatch() {
      if (this._running || 0 === this._queue.length) return;
      const t = this._queue.shift();
      this._job = t;
      const e = t.inputs[0].width,
        i = t.inputs[0].height,
        n = t.inputs.map(function (t) {
          return t.data.buffer;
        }),
        r = this._workers.length;
      if (((this._running = r), 1 === r))
        return void this._workers[0].postMessage(
          {
            buffers: n,
            meta: t.meta,
            imageOps: this._imageOps,
            width: e,
            height: i,
          },
          n
        );
      const s = t.inputs[0].data.length,
        o = 4 * Math.ceil(s / 4 / r);
      for (let s = 0; s < r; ++s) {
        const r = s * o,
          a = [];
        for (let t = 0, e = n.length; t < e; ++t) a.push(n[t].slice(r, r + o));
        this._workers[s].postMessage(
          {
            buffers: a,
            meta: t.meta,
            imageOps: this._imageOps,
            width: e,
            height: i,
          },
          a
        );
      }
    }
    _onWorkerMessage(t, e) {
      this.disposed ||
        ((this._dataLookup[t] = e.data),
        --this._running,
        0 === this._running && this._resolveJob());
    }
    _resolveJob() {
      const t = this._job,
        e = this._workers.length;
      let i, n;
      if (1 === e)
        (i = new Uint8ClampedArray(this._dataLookup[0].buffer)),
          (n = this._dataLookup[0].meta);
      else {
        const r = t.inputs[0].data.length;
        (i = new Uint8ClampedArray(r)), (n = new Array(e));
        const s = 4 * Math.ceil(r / 4 / e);
        for (let t = 0; t < e; ++t) {
          const e = this._dataLookup[t].buffer,
            r = t * s;
          i.set(new Uint8ClampedArray(e), r), (n[t] = this._dataLookup[t].meta);
        }
      }
      (this._job = null),
        (this._dataLookup = {}),
        t.callback(null, s_(i, t.inputs[0].width, t.inputs[0].height), n),
        this._dispatch();
    }
    disposeInternal() {
      for (let t = 0; t < this._workers.length; ++t)
        this._workers[t].terminate();
      this._workers.length = 0;
    }
  }
  const h_ = "beforeoperations",
    c_ = "afteroperations";
  class u_ extends e {
    constructor(t, e, i) {
      super(t),
        (this.extent = e.extent),
        (this.resolution = e.viewState.resolution / e.pixelRatio),
        (this.data = i);
    }
  }
  class d_ extends ym {
    constructor(t) {
      super({ projection: null }),
        this.on,
        this.once,
        this.un,
        (this.processor_ = null),
        (this.operationType_ =
          void 0 !== t.operationType ? t.operationType : "pixel"),
        (this.threads_ = void 0 !== t.threads ? t.threads : 1),
        (this.layers_ = (function (t) {
          const e = t.length,
            i = new Array(e);
          for (let n = 0; n < e; ++n) i[n] = p_(t[n]);
          return i;
        })(t.sources));
      const e = this.changed.bind(this);
      for (let t = 0, i = this.layers_.length; t < i; ++t)
        this.layers_[t].addEventListener(v, e);
      var i;
      (this.useResolutions_ = null !== t.resolutions),
        (this.tileQueue_ = new la(function () {
          return 1;
        }, this.processSources_.bind(this))),
        this.requestedFrameState_,
        (this.renderedImageCanvas_ = null),
        this.renderedRevision_,
        (this.frameState_ = {
          animate: !1,
          coordinateToPixelTransform: [1, 0, 0, 1, 0, 0],
          declutterTree: null,
          extent: null,
          index: 0,
          layerIndex: 0,
          layerStatesArray:
            ((i = this.layers_),
            i.map(function (t) {
              return t.getLayerState();
            })),
          pixelRatio: 1,
          pixelToCoordinateTransform: [1, 0, 0, 1, 0, 0],
          postRenderFunctions: [],
          size: [0, 0],
          tileQueue: this.tileQueue_,
          time: Date.now(),
          usedTiles: {},
          viewState: { rotation: 0 },
          viewHints: [],
          wantedTiles: {},
          mapId: j(this),
          renderTargets: {},
        }),
        this.setAttributions(function (e) {
          const i = [];
          for (let n = 0, r = t.sources.length; n < r; ++n) {
            const r = t.sources[n],
              s = r instanceof Iu ? r : r.getSource();
            if (!s) continue;
            const o = s.getAttributions();
            if ("function" == typeof o) {
              const t = o(e);
              i.push.apply(i, t);
            }
          }
          return 0 !== i.length ? i : null;
        }),
        void 0 !== t.operation && this.setOperation(t.operation, t.lib);
    }
    setOperation(t, e) {
      this.processor_ && this.processor_.dispose(),
        (this.processor_ = new l_({
          operation: t,
          imageOps: "image" === this.operationType_,
          queue: 1,
          lib: e,
          threads: this.threads_,
        })),
        this.changed();
    }
    updateFrameState_(t, e, i) {
      const n = Object.assign({}, this.frameState_);
      n.viewState = Object.assign({}, n.viewState);
      const r = Ce(t);
      (n.size[0] = Math.ceil(Fe(t) / e)),
        (n.size[1] = Math.ceil(Re(t) / e)),
        (n.extent = [
          r[0] - (n.size[0] * e) / 2,
          r[1] - (n.size[1] * e) / 2,
          r[0] + (n.size[0] * e) / 2,
          r[1] + (n.size[1] * e) / 2,
        ]),
        (n.time = Date.now());
      const s = n.viewState;
      return (s.center = r), (s.projection = i), (s.resolution = e), n;
    }
    allSourcesReady_() {
      let t,
        e = !0;
      for (let i = 0, n = this.layers_.length; i < n; ++i)
        if (
          ((t = this.layers_[i].getSource()), !t || "ready" !== t.getState())
        ) {
          e = !1;
          break;
        }
      return e;
    }
    getImage(t, e, i, n) {
      if (!this.allSourcesReady_()) return null;
      this.tileQueue_.loadMoreTiles(16, 16),
        (e = this.findNearestResolution(e));
      const r = this.updateFrameState_(t, e, n);
      if (((this.requestedFrameState_ = r), this.renderedImageCanvas_)) {
        const t = this.renderedImageCanvas_.getResolution(),
          i = this.renderedImageCanvas_.getExtent();
        (e === t && ce(r.extent, i)) || (this.renderedImageCanvas_ = null);
      }
      return (
        (this.renderedImageCanvas_ &&
          this.getRevision() === this.renderedRevision_) ||
          this.processSources_(),
        r.animate && requestAnimationFrame(this.changed.bind(this)),
        this.renderedImageCanvas_
      );
    }
    processSources_() {
      const t = this.requestedFrameState_,
        e = this.layers_.length,
        i = new Array(e);
      for (let n = 0; n < e; ++n) {
        (t.layerIndex = n), (t.renderTargets = {});
        const e = f_(this.layers_[n], t);
        if (!e) return;
        i[n] = e;
      }
      const n = {};
      this.dispatchEvent(new u_(h_, t, n)),
        this.processor_.process(i, n, this.onWorkerComplete_.bind(this, t));
    }
    onWorkerComplete_(t, e, i, n) {
      if (e || !i) return;
      const r = t.extent,
        s = t.viewState.resolution;
      if (
        s !== this.requestedFrameState_.viewState.resolution ||
        !ce(r, this.requestedFrameState_.extent)
      )
        return;
      let o;
      if (this.renderedImageCanvas_)
        o = this.renderedImageCanvas_.getImage().getContext("2d");
      else {
        (o = mt(Math.round(Fe(r) / s), Math.round(Re(r) / s))),
          (this.renderedImageCanvas_ = new es(r, s, 1, o.canvas));
      }
      o.putImageData(i, 0, 0),
        t.animate
          ? requestAnimationFrame(this.changed.bind(this))
          : this.changed(),
        (this.renderedRevision_ = this.getRevision()),
        this.dispatchEvent(new u_(c_, t, n));
    }
    getResolutions(t) {
      if (!this.useResolutions_) return null;
      let e = super.getResolutions();
      if (!e)
        for (let i = 0, n = this.layers_.length; i < n; ++i) {
          if (((e = this.layers_[i].getSource().getResolutions(t)), e)) break;
        }
      return e;
    }
    disposeInternal() {
      this.processor_ && this.processor_.dispose(), super.disposeInternal();
    }
  }
  d_.prototype.dispose;
  let g_ = null;
  function f_(t, e) {
    const i = t.getRenderer();
    if (!i) throw new Error("Unsupported layer type: " + t);
    if (!i.prepareFrame(e)) return null;
    const n = e.size[0],
      r = e.size[1];
    if (0 === n || 0 === r) return null;
    const s = i.renderFrame(e, null);
    let o;
    if (s instanceof HTMLCanvasElement) o = s;
    else {
      if ((s && (o = s.firstElementChild), !(o instanceof HTMLCanvasElement)))
        throw new Error("Unsupported rendered element: " + o);
      if (o.width === n && o.height === r) {
        return o.getContext("2d").getImageData(0, 0, n, r);
      }
    }
    if (g_) {
      const t = g_.canvas;
      t.width !== n || t.height !== r
        ? (g_ = mt(n, r, void 0, { willReadFrequently: !0 }))
        : g_.clearRect(0, 0, n, r);
    } else g_ = mt(n, r, void 0, { willReadFrequently: !0 });
    return g_.drawImage(o, 0, 0, n, r), g_.getImageData(0, 0, n, r);
  }
  function p_(t) {
    let e;
    return (
      t instanceof Iu
        ? t instanceof Sp
          ? (e = new Uf({ source: t }))
          : t instanceof ym && (e = new Df({ source: t }))
        : (e = t),
      e
    );
  }
  var m_ = d_;
  const __ = {
      stamen_terrain: { extension: "png", opaque: !0 },
      stamen_terrain_background: { extension: "png", opaque: !0 },
      stamen_terrain_labels: { extension: "png", opaque: !1 },
      stamen_terrain_lines: { extension: "png", opaque: !1 },
      stamen_toner_background: { extension: "png", opaque: !0 },
      stamen_toner: { extension: "png", opaque: !0 },
      stamen_toner_labels: { extension: "png", opaque: !1 },
      stamen_toner_lines: { extension: "png", opaque: !1 },
      stamen_toner_lite: { extension: "png", opaque: !0 },
      stamen_watercolor: { extension: "jpg", opaque: !0 },
      alidade_smooth: { extension: "png", opaque: !0 },
      alidade_smooth_dark: { extension: "png", opaque: !0 },
      outdoors: { extension: "png", opaque: !0 },
      osm_bright: { extension: "png", opaque: !0 },
    },
    y_ = {
      stamen_terrain: { minZoom: 0, maxZoom: 18, retina: !0 },
      stamen_toner: { minZoom: 0, maxZoom: 20, retina: !0 },
      stamen_watercolor: { minZoom: 1, maxZoom: 18, retina: !1 },
    };
  var x_ = class extends Mp {
    constructor(t) {
      const e = t.layer.indexOf("-"),
        i = -1 == e ? t.layer : t.layer.slice(0, e),
        n = y_[i] || { minZoom: 0, maxZoom: 20, retina: !0 },
        r = __[t.layer],
        s = t.apiKey ? "?api_key=" + t.apiKey : "",
        o = n.retina && t.retina ? "@2x" : "",
        a =
          void 0 !== t.url
            ? t.url
            : "https://tiles.stadiamaps.com/tiles/" +
              t.layer +
              "/{z}/{x}/{y}" +
              o +
              "." +
              r.extension +
              s,
        l = [
          '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>',
          '&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>',
          e_,
        ];
      t.layer.startsWith("stamen_") &&
        l.splice(
          1,
          0,
          '&copy; <a href="https://stamen.com/" target="_blank">Stamen Design</a>'
        ),
        super({
          attributions: l,
          cacheSize: t.cacheSize,
          crossOrigin: "anonymous",
          interpolate: t.interpolate,
          maxZoom: void 0 !== t.maxZoom ? t.maxZoom : n.maxZoom,
          minZoom: void 0 !== t.minZoom ? t.minZoom : n.minZoom,
          opaque: r.opaque,
          reprojectionErrorThreshold: t.reprojectionErrorThreshold,
          tileLoadFunction: t.tileLoadFunction,
          transition: t.transition,
          url: a,
          tilePixelRatio: o ? 2 : 1,
          wrapX: t.wrapX,
          zDirection: t.zDirection,
        });
    }
  };
  var v_ = class extends Fp {
    constructor(t) {
      super({
        attributions: (t = t || {}).attributions,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        interpolate: t.interpolate,
        projection: t.projection,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        tileGrid: t.tileGrid,
        tileLoadFunction: t.tileLoadFunction,
        url: t.url,
        urls: t.urls,
        wrapX: void 0 === t.wrapX || t.wrapX,
        transition: t.transition,
        zDirection: t.zDirection,
      }),
        (this.params_ = t.params || {}),
        (this.hidpi_ = void 0 === t.hidpi || t.hidpi),
        (this.tmpExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        this.setKey(this.getKeyForParams_());
    }
    getKeyForParams_() {
      let t = 0;
      const e = [];
      for (const i in this.params_) e[t++] = i + "-" + this.params_[i];
      return e.join("/");
    }
    getParams() {
      return this.params_;
    }
    getRequestUrl_(t, e, i, n, r, s) {
      const o = this.urls;
      if (!o) return;
      let a;
      if (1 == o.length) a = o[0];
      else {
        a = o[_i(Ng(t), o.length)];
      }
      return vm(
        a,
        i,
        (this.tileGrid || this.getTileGridForProjection(r)).getResolution(t[0]),
        n,
        r,
        s
      );
    }
    getTilePixelRatio(t) {
      return this.hidpi_ ? t : 1;
    }
    updateParams(t) {
      Object.assign(this.params_, t), this.setKey(this.getKeyForParams_());
    }
    tileUrlFunction(t, e, i) {
      let n = this.getTileGrid();
      if (
        (n || (n = this.getTileGridForProjection(i)),
        n.getResolutions().length <= t[0])
      )
        return;
      1 == e || this.hidpi_ || (e = 1);
      const r = n.getTileCoordExtent(t, this.tmpExtent_);
      let s = sl(n.getTileSize(t[0]), this.tmpSize);
      1 != e && (s = rl(s, e, this.tmpSize));
      const o = { F: "image", FORMAT: "PNG32", TRANSPARENT: !0 };
      return (
        Object.assign(o, this.params_), this.getRequestUrl_(t, s, r, e, i, o)
      );
    }
  };
  var S_ = class extends Mp {
    constructor(t) {
      super({
        opaque: !1,
        projection: (t = t || {}).projection,
        tileGrid: t.tileGrid,
        wrapX: void 0 === t.wrapX || t.wrapX,
        zDirection: t.zDirection,
        url: t.template || "z:{z} x:{x} y:{y}",
        tileLoadFunction: (t, e) => {
          const i = t.getTileCoord()[0],
            n = sl(this.tileGrid.getTileSize(i)),
            r = mt(n[0], n[1]);
          (r.strokeStyle = "grey"),
            r.strokeRect(0.5, 0.5, n[0] + 0.5, n[1] + 0.5),
            (r.fillStyle = "grey"),
            (r.strokeStyle = "white"),
            (r.textAlign = "center"),
            (r.textBaseline = "middle"),
            (r.font = "24px sans-serif"),
            (r.lineWidth = 4),
            r.strokeText(e, n[0] / 2, n[1] / 2, n[0]),
            r.fillText(e, n[0] / 2, n[1] / 2, n[0]),
            t.setImage(r.canvas);
        },
      });
    }
  };
  var C_ = class extends Fp {
    constructor(t) {
      if (
        (super({
          attributions: t.attributions,
          cacheSize: t.cacheSize,
          crossOrigin: t.crossOrigin,
          interpolate: t.interpolate,
          projection: tn("EPSG:3857"),
          reprojectionErrorThreshold: t.reprojectionErrorThreshold,
          state: "loading",
          tileLoadFunction: t.tileLoadFunction,
          wrapX: void 0 === t.wrapX || t.wrapX,
          transition: t.transition,
          zDirection: t.zDirection,
        }),
        (this.tileJSON_ = null),
        (this.tileSize_ = t.tileSize),
        t.url)
      )
        if (t.jsonp)
          Am(
            t.url,
            this.handleTileJSONResponse.bind(this),
            this.handleTileJSONError.bind(this)
          );
        else {
          const e = new XMLHttpRequest();
          e.addEventListener("load", this.onXHRLoad_.bind(this)),
            e.addEventListener("error", this.onXHRError_.bind(this)),
            e.open("GET", t.url),
            e.send();
        }
      else {
        if (!t.tileJSON)
          throw new Error(
            "Either `url` or `tileJSON` options must be provided"
          );
        this.handleTileJSONResponse(t.tileJSON);
      }
    }
    onXHRLoad_(t) {
      const e = t.target;
      if (!e.status || (e.status >= 200 && e.status < 300)) {
        let t;
        try {
          t = JSON.parse(e.responseText);
        } catch (t) {
          return void this.handleTileJSONError();
        }
        this.handleTileJSONResponse(t);
      } else this.handleTileJSONError();
    }
    onXHRError_(t) {
      this.handleTileJSONError();
    }
    getTileJSON() {
      return this.tileJSON_;
    }
    handleTileJSONResponse(t) {
      const e = tn("EPSG:4326"),
        i = this.getProjection();
      let n;
      if (void 0 !== t.bounds) {
        const r = hn(e, i);
        n = Ae(t.bounds, r);
      }
      const r = xp(i),
        s = t.minzoom || 0,
        o = mp({
          extent: r,
          maxZoom: t.maxzoom || 22,
          minZoom: s,
          tileSize: this.tileSize_,
        });
      if (
        ((this.tileGrid = o),
        (this.tileUrlFunction = wp(t.tiles, o)),
        t.attribution && !this.getAttributions())
      ) {
        const e = void 0 !== n ? n : r;
        this.setAttributions(function (i) {
          return Ie(e, i.extent) ? [t.attribution] : null;
        });
      }
      (this.tileJSON_ = t), this.setState("ready");
    }
    handleTileJSONError() {
      this.setState("error");
    }
  };
  var w_ = class extends Fp {
    constructor(t) {
      t = t || {};
      const e = Object.assign({}, t.params),
        i = !("TRANSPARENT" in e) || e.TRANSPARENT;
      super({
        attributions: t.attributions,
        attributionsCollapsible: t.attributionsCollapsible,
        cacheSize: t.cacheSize,
        crossOrigin: t.crossOrigin,
        interpolate: t.interpolate,
        opaque: !i,
        projection: t.projection,
        reprojectionErrorThreshold: t.reprojectionErrorThreshold,
        tileClass: t.tileClass,
        tileGrid: t.tileGrid,
        tileLoadFunction: t.tileLoadFunction,
        url: t.url,
        urls: t.urls,
        wrapX: void 0 === t.wrapX || t.wrapX,
        transition: t.transition,
        zDirection: t.zDirection,
      }),
        (this.gutter_ = void 0 !== t.gutter ? t.gutter : 0),
        (this.params_ = e),
        (this.v13_ = !0),
        (this.serverType_ = t.serverType),
        (this.hidpi_ = void 0 === t.hidpi || t.hidpi),
        (this.tmpExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        this.updateV13_(),
        this.setKey(this.getKeyForParams_());
    }
    getFeatureInfoUrl(t, e, i, n) {
      const r = tn(i),
        s = this.getProjection() || r;
      let o = this.getTileGrid();
      o || (o = this.getTileGridForProjection(s));
      const a = un(t, r, s),
        l = yg(s, r, t, e),
        h = o.getZForResolution(l, this.zDirection),
        c = o.getResolution(h),
        u = o.getTileCoordForCoordAndZ(a, h);
      if (o.getResolutions().length <= u[0]) return;
      let d = o.getTileCoordExtent(u, this.tmpExtent_);
      const g = this.gutter_;
      0 !== g && (d = $t(d, c * g, d));
      const f = { QUERY_LAYERS: this.params_.LAYERS };
      Object.assign(f, Lm(this.params_, "GetFeatureInfo"), n);
      const p = Math.floor((a[0] - d[0]) / c),
        m = Math.floor((d[3] - a[1]) / c);
      return (
        (f[this.v13_ ? "I" : "X"] = p),
        (f[this.v13_ ? "J" : "Y"] = m),
        this.getRequestUrl_(u, d, 1, s || r, f)
      );
    }
    getLegendUrl(t, e) {
      if (void 0 === this.urls[0]) return;
      const i = {
        SERVICE: "WMS",
        VERSION: bm,
        REQUEST: "GetLegendGraphic",
        FORMAT: "image/png",
      };
      if (void 0 === e || void 0 === e.LAYER) {
        const t = this.params_.LAYERS;
        if (!(!Array.isArray(t) || 1 === t.length)) return;
        i.LAYER = t;
      }
      if (void 0 !== t) {
        const e = this.getProjection()
            ? this.getProjection().getMetersPerUnit()
            : 1,
          n = 28e-5;
        i.SCALE = (t * e) / n;
      }
      return Object.assign(i, e), xm(this.urls[0], i);
    }
    getGutter() {
      return this.gutter_;
    }
    getParams() {
      return this.params_;
    }
    getRequestUrl_(t, e, i, n, r) {
      const s = this.urls;
      if (!s) return;
      let o;
      if (1 == s.length) o = s[0];
      else {
        o = s[_i(Ng(t), s.length)];
      }
      return Im(
        e,
        (this.tileGrid || this.getTileGridForProjection(n)).getResolution(t[0]),
        i,
        n,
        o,
        r,
        this.serverType_
      );
    }
    getTilePixelRatio(t) {
      return this.hidpi_ && void 0 !== this.serverType_ ? t : 1;
    }
    getKeyForParams_() {
      let t = 0;
      const e = [];
      for (const i in this.params_) e[t++] = i + "-" + this.params_[i];
      return e.join("/");
    }
    updateParams(t) {
      Object.assign(this.params_, t),
        this.updateV13_(),
        this.setKey(this.getKeyForParams_());
    }
    updateV13_() {
      const t = this.params_.VERSION || bm;
      this.v13_ = Wi(t, "1.3") >= 0;
    }
    tileUrlFunction(t, e, i) {
      let n = this.getTileGrid();
      if (
        (n || (n = this.getTileGridForProjection(i)),
        n.getResolutions().length <= t[0])
      )
        return;
      1 == e || (this.hidpi_ && void 0 !== this.serverType_) || (e = 1);
      const r = n.getResolution(t[0]);
      let s = n.getTileCoordExtent(t, this.tmpExtent_);
      const o = this.gutter_;
      0 !== o && (s = $t(s, r * o, s));
      const a = Object.assign({}, Lm(this.params_, "GetMap"));
      return this.getRequestUrl_(t, s, e, i, a);
    }
  };
  class W_ extends rt {
    constructor(t, e, i, n, r, s) {
      super(t, e),
        (this.src_ = i),
        (this.extent_ = n),
        (this.preemptive_ = r),
        (this.grid_ = null),
        (this.keys_ = null),
        (this.data_ = null),
        (this.jsonp_ = s);
    }
    getImage() {
      return null;
    }
    getData(t) {
      if (!this.grid_ || !this.keys_) return null;
      const e = (t[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]),
        i = (t[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]),
        n = this.grid_[Math.floor((1 - i) * this.grid_.length)];
      if ("string" != typeof n) return null;
      let r = n.charCodeAt(Math.floor(e * n.length));
      r >= 93 && r--, r >= 35 && r--, (r -= 32);
      let s = null;
      if (r in this.keys_) {
        const t = this.keys_[r];
        s = this.data_ && t in this.data_ ? this.data_[t] : t;
      }
      return s;
    }
    forDataAtCoordinate(t, e, i) {
      this.state == J && !0 === i
        ? ((this.state = H),
          O(
            this,
            v,
            function (i) {
              e(this.getData(t));
            },
            this
          ),
          this.loadInternal_())
        : !0 === i
        ? setTimeout(() => {
            e(this.getData(t));
          }, 0)
        : e(this.getData(t));
    }
    getKey() {
      return this.src_;
    }
    handleError_() {
      (this.state = $), this.changed();
    }
    handleLoad_(t) {
      (this.grid_ = t.grid),
        (this.keys_ = t.keys),
        (this.data_ = t.data),
        (this.state = Q),
        this.changed();
    }
    loadInternal_() {
      if (this.state == H)
        if (((this.state = Y), this.jsonp_))
          Am(
            this.src_,
            this.handleLoad_.bind(this),
            this.handleError_.bind(this)
          );
        else {
          const t = new XMLHttpRequest();
          t.addEventListener("load", this.onXHRLoad_.bind(this)),
            t.addEventListener("error", this.onXHRError_.bind(this)),
            t.open("GET", this.src_),
            t.send();
        }
    }
    onXHRLoad_(t) {
      const e = t.target;
      if (!e.status || (e.status >= 200 && e.status < 300)) {
        let t;
        try {
          t = JSON.parse(e.responseText);
        } catch (t) {
          return void this.handleError_();
        }
        this.handleLoad_(t);
      } else this.handleError_();
    }
    onXHRError_(t) {
      this.handleError_();
    }
    load() {
      this.preemptive_ ? this.loadInternal_() : this.setState(J);
    }
  }
  var E_ = class extends Sp {
    constructor(t) {
      if (
        (super({
          projection: tn("EPSG:3857"),
          state: "loading",
          zDirection: t.zDirection,
        }),
        (this.preemptive_ = void 0 === t.preemptive || t.preemptive),
        (this.tileUrlFunction_ = Ep),
        (this.template_ = void 0),
        (this.jsonp_ = t.jsonp || !1),
        t.url)
      )
        if (this.jsonp_)
          Am(
            t.url,
            this.handleTileJSONResponse.bind(this),
            this.handleTileJSONError.bind(this)
          );
        else {
          const e = new XMLHttpRequest();
          e.addEventListener("load", this.onXHRLoad_.bind(this)),
            e.addEventListener("error", this.onXHRError_.bind(this)),
            e.open("GET", t.url),
            e.send();
        }
      else {
        if (!t.tileJSON)
          throw new Error(
            "Either `url` or `tileJSON` options must be provided"
          );
        this.handleTileJSONResponse(t.tileJSON);
      }
    }
    onXHRLoad_(t) {
      const e = t.target;
      if (!e.status || (e.status >= 200 && e.status < 300)) {
        let t;
        try {
          t = JSON.parse(e.responseText);
        } catch (t) {
          return void this.handleTileJSONError();
        }
        this.handleTileJSONResponse(t);
      } else this.handleTileJSONError();
    }
    onXHRError_(t) {
      this.handleTileJSONError();
    }
    getTemplate() {
      return this.template_;
    }
    forDataAtCoordinateAndResolution(t, e, i, n) {
      if (this.tileGrid) {
        const r = this.tileGrid.getZForResolution(e, this.zDirection),
          s = this.tileGrid.getTileCoordForCoordAndZ(t, r);
        this.getTile(
          s[0],
          s[1],
          s[2],
          1,
          this.getProjection()
        ).forDataAtCoordinate(t, i, n);
      } else
        !0 === n
          ? setTimeout(function () {
              i(null);
            }, 0)
          : i(null);
    }
    handleTileJSONError() {
      this.setState("error");
    }
    handleTileJSONResponse(t) {
      const e = tn("EPSG:4326"),
        i = this.getProjection();
      let n;
      if (void 0 !== t.bounds) {
        const r = hn(e, i);
        n = Ae(t.bounds, r);
      }
      const r = xp(i),
        s = t.minzoom || 0,
        o = mp({ extent: r, maxZoom: t.maxzoom || 22, minZoom: s });
      (this.tileGrid = o), (this.template_ = t.template);
      const a = t.grids;
      if (a) {
        if (((this.tileUrlFunction_ = wp(a, o)), void 0 !== t.attribution)) {
          const e = void 0 !== n ? n : r;
          this.setAttributions(function (i) {
            return Ie(e, i.extent) ? [t.attribution] : null;
          });
        }
        this.setState("ready");
      } else this.setState("error");
    }
    getTile(t, e, i, n, r) {
      const s = Mg(t, e, i);
      if (this.tileCache.containsKey(s)) return this.tileCache.get(s);
      const o = [t, e, i],
        a = this.getTileCoordForTileUrlFunction(o, r),
        l = this.tileUrlFunction_(a, n, r),
        h = new W_(
          o,
          void 0 !== l ? H : J,
          void 0 !== l ? l : "",
          this.tileGrid.getTileCoordExtent(o),
          this.preemptive_,
          this.jsonp_
        );
      return this.tileCache.set(s, h), h;
    }
    useTile(t, e, i) {
      const n = Mg(t, e, i);
      this.tileCache.containsKey(n) && this.tileCache.get(n);
    }
  };
  class R_ extends dp {
    constructor(t) {
      super({
        extent: t.extent,
        origin: t.origin,
        origins: t.origins,
        resolutions: t.resolutions,
        tileSize: t.tileSize,
        tileSizes: t.tileSizes,
        sizes: t.sizes,
      }),
        (this.matrixIds_ = t.matrixIds);
    }
    getMatrixId(t) {
      return this.matrixIds_[t];
    }
    getMatrixIds() {
      return this.matrixIds_;
    }
  }
  var T_ = R_;
  function P_(t, e, i) {
    const n = [],
      r = [],
      s = [],
      o = [],
      a = [];
    i = void 0 !== i ? i : [];
    const l = "TileMatrix",
      h = "Identifier",
      c = "ScaleDenominator",
      u = "TopLeftCorner",
      d = tn(t.SupportedCRS),
      g = d.getMetersPerUnit(),
      f = "ne" == d.getAxisOrientation().substr(0, 2);
    return (
      t[l].sort(function (t, e) {
        return e[c] - t[c];
      }),
      t[l].forEach(function (e) {
        let d;
        if (
          ((d =
            !(i.length > 0) ||
            i.find(function (i) {
              return (
                e[h] == i[l] ||
                (!e[h].includes(":") && t[h] + ":" + e[h] === i[l])
              );
            })),
          d)
        ) {
          r.push(e[h]);
          const t = (28e-5 * e[c]) / g,
            i = e.TileWidth,
            l = e.TileHeight;
          f ? s.push([e[u][1], e[u][0]]) : s.push(e[u]),
            n.push(t),
            o.push(i == l ? i : [i, l]),
            a.push([e.MatrixWidth, e.MatrixHeight]);
        }
      }),
      new R_({
        extent: e,
        origins: s,
        resolutions: n,
        matrixIds: r,
        tileSizes: o,
        sizes: a,
      })
    );
  }
  var b_ = class extends Fp {
    constructor(t) {
      const e = void 0 !== t.requestEncoding ? t.requestEncoding : "KVP",
        i = t.tileGrid;
      let n = t.urls;
      void 0 === n && void 0 !== t.url && (n = Rp(t.url)),
        super({
          attributions: t.attributions,
          attributionsCollapsible: t.attributionsCollapsible,
          cacheSize: t.cacheSize,
          crossOrigin: t.crossOrigin,
          interpolate: t.interpolate,
          projection: t.projection,
          reprojectionErrorThreshold: t.reprojectionErrorThreshold,
          tileClass: t.tileClass,
          tileGrid: i,
          tileLoadFunction: t.tileLoadFunction,
          tilePixelRatio: t.tilePixelRatio,
          urls: n,
          wrapX: void 0 !== t.wrapX && t.wrapX,
          transition: t.transition,
          zDirection: t.zDirection,
        }),
        (this.version_ = void 0 !== t.version ? t.version : "1.0.0"),
        (this.format_ = void 0 !== t.format ? t.format : "image/jpeg"),
        (this.dimensions_ = void 0 !== t.dimensions ? t.dimensions : {}),
        (this.layer_ = t.layer),
        (this.matrixSet_ = t.matrixSet),
        (this.style_ = t.style),
        (this.requestEncoding_ = e),
        this.setKey(this.getKeyForDimensions_()),
        n &&
          n.length > 0 &&
          (this.tileUrlFunction = Wp(
            n.map(this.createFromWMTSTemplate.bind(this))
          ));
    }
    setUrls(t) {
      this.urls = t;
      const e = t.join("\n");
      this.setTileUrlFunction(
        Wp(t.map(this.createFromWMTSTemplate.bind(this))),
        e
      );
    }
    getDimensions() {
      return this.dimensions_;
    }
    getFormat() {
      return this.format_;
    }
    getLayer() {
      return this.layer_;
    }
    getMatrixSet() {
      return this.matrixSet_;
    }
    getRequestEncoding() {
      return this.requestEncoding_;
    }
    getStyle() {
      return this.style_;
    }
    getVersion() {
      return this.version_;
    }
    getKeyForDimensions_() {
      const t = this.urls ? this.urls.slice(0) : [];
      for (const e in this.dimensions_) t.push(e + "-" + this.dimensions_[e]);
      return t.join("/");
    }
    updateDimensions(t) {
      Object.assign(this.dimensions_, t),
        this.setKey(this.getKeyForDimensions_());
    }
    createFromWMTSTemplate(t) {
      const e = this.requestEncoding_,
        i = {
          layer: this.layer_,
          style: this.style_,
          tilematrixset: this.matrixSet_,
        };
      "KVP" == e &&
        Object.assign(i, {
          Service: "WMTS",
          Request: "GetTile",
          Version: this.version_,
          Format: this.format_,
        }),
        (t =
          "KVP" == e
            ? xm(t, i)
            : t.replace(/\{(\w+?)\}/g, function (t, e) {
                return e.toLowerCase() in i ? i[e.toLowerCase()] : t;
              }));
      const n = this.tileGrid,
        r = this.dimensions_;
      return function (i, s, o) {
        if (!i) return;
        const a = {
          TileMatrix: n.getMatrixId(i[0]),
          TileCol: i[1],
          TileRow: i[2],
        };
        Object.assign(a, r);
        let l = t;
        return (
          (l =
            "KVP" == e
              ? xm(l, a)
              : l.replace(/\{(\w+?)\}/g, function (t, e) {
                  return a[e];
                })),
          l
        );
      };
    }
  };
  function F_(t) {
    t instanceof no
      ? t.setMapInternal(null)
      : t instanceof zo && t.getLayers().forEach(F_);
  }
  function I_(t, e) {
    if (t instanceof no) t.setMapInternal(e);
    else if (t instanceof zo) {
      const i = t.getLayers().getArray();
      for (let t = 0, n = i.length; t < n; ++t) I_(i[t], e);
    }
  }
  class L_ extends U {
    constructor(t) {
      super(), (t = t || {}), this.on, this.once, this.un;
      const e = (function (t) {
        let e = null;
        void 0 !== t.keyboardEventTarget &&
          (e =
            "string" == typeof t.keyboardEventTarget
              ? document.getElementById(t.keyboardEventTarget)
              : t.keyboardEventTarget);
        const i = {},
          n =
            t.layers && "function" == typeof t.layers.getLayers
              ? t.layers
              : new zo({ layers: t.layers });
        let r, s, o;
        (i[ia] = n),
          (i[ra] = t.target),
          (i[sa] = t.view instanceof eo ? t.view : new eo()),
          void 0 !== t.controls &&
            (Array.isArray(t.controls)
              ? (r = new K(t.controls.slice()))
              : (Ft(
                  "function" == typeof t.controls.getArray,
                  "Expected `controls` to be an array or an `ol/Collection.js`"
                ),
                (r = t.controls)));
        void 0 !== t.interactions &&
          (Array.isArray(t.interactions)
            ? (s = new K(t.interactions.slice()))
            : (Ft(
                "function" == typeof t.interactions.getArray,
                "Expected `interactions` to be an array or an `ol/Collection.js`"
              ),
              (s = t.interactions)));
        void 0 !== t.overlays
          ? Array.isArray(t.overlays)
            ? (o = new K(t.overlays.slice()))
            : (Ft(
                "function" == typeof t.overlays.getArray,
                "Expected `overlays` to be an array or an `ol/Collection.js`"
              ),
              (o = t.overlays))
          : (o = new K());
        return {
          controls: r,
          interactions: s,
          keyboardEventTarget: e,
          overlays: o,
          values: i,
        };
      })(t);
      this.renderComplete_,
        (this.loaded_ = !0),
        (this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this)),
        (this.maxTilesLoading_ =
          void 0 !== t.maxTilesLoading ? t.maxTilesLoading : 16),
        (this.pixelRatio_ = void 0 !== t.pixelRatio ? t.pixelRatio : ut),
        this.postRenderTimeoutHandle_,
        this.animationDelayKey_,
        (this.animationDelay_ = this.animationDelay_.bind(this)),
        (this.coordinateToPixelTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.pixelToCoordinateTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.frameIndex_ = 0),
        (this.frameState_ = null),
        (this.previousExtent_ = null),
        (this.viewPropertyListenerKey_ = null),
        (this.viewChangeListenerKey_ = null),
        (this.layerGroupPropertyListenerKeys_ = null),
        (this.viewport_ = document.createElement("div")),
        (this.viewport_.className =
          "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "")),
        (this.viewport_.style.position = "relative"),
        (this.viewport_.style.overflow = "hidden"),
        (this.viewport_.style.width = "100%"),
        (this.viewport_.style.height = "100%"),
        (this.overlayContainer_ = document.createElement("div")),
        (this.overlayContainer_.style.position = "absolute"),
        (this.overlayContainer_.style.zIndex = "0"),
        (this.overlayContainer_.style.width = "100%"),
        (this.overlayContainer_.style.height = "100%"),
        (this.overlayContainer_.style.pointerEvents = "none"),
        (this.overlayContainer_.className = "ol-overlaycontainer"),
        this.viewport_.appendChild(this.overlayContainer_),
        (this.overlayContainerStopEvent_ = document.createElement("div")),
        (this.overlayContainerStopEvent_.style.position = "absolute"),
        (this.overlayContainerStopEvent_.style.zIndex = "0"),
        (this.overlayContainerStopEvent_.style.width = "100%"),
        (this.overlayContainerStopEvent_.style.height = "100%"),
        (this.overlayContainerStopEvent_.style.pointerEvents = "none"),
        (this.overlayContainerStopEvent_.className =
          "ol-overlaycontainer-stopevent"),
        this.viewport_.appendChild(this.overlayContainerStopEvent_),
        (this.mapBrowserEventHandler_ = null),
        (this.moveTolerance_ = t.moveTolerance),
        (this.keyboardEventTarget_ = e.keyboardEventTarget),
        (this.targetChangeHandlerKeys_ = null),
        (this.targetElement_ = null),
        (this.resizeObserver_ = new ResizeObserver(() => this.updateSize())),
        (this.controls = e.controls || fa()),
        (this.interactions = e.interactions || il({ onFocusOnly: !0 })),
        (this.overlays_ = e.overlays),
        (this.overlayIdIndex_ = {}),
        (this.renderer_ = null),
        (this.postRenderFunctions_ = []),
        (this.tileQueue_ = new la(
          this.getTilePriority.bind(this),
          this.handleTileChange_.bind(this)
        )),
        this.addChangeListener(ia, this.handleLayerGroupChanged_),
        this.addChangeListener(sa, this.handleViewChanged_),
        this.addChangeListener(na, this.handleSizeChanged_),
        this.addChangeListener(ra, this.handleTargetChanged_),
        this.setProperties(e.values);
      const i = this;
      !t.view ||
        t.view instanceof eo ||
        t.view.then(function (t) {
          i.setView(new eo(t));
        }),
        this.controls.addEventListener(q, (t) => {
          t.element.setMap(this);
        }),
        this.controls.addEventListener(V, (t) => {
          t.element.setMap(null);
        }),
        this.interactions.addEventListener(q, (t) => {
          t.element.setMap(this);
        }),
        this.interactions.addEventListener(V, (t) => {
          t.element.setMap(null);
        }),
        this.overlays_.addEventListener(q, (t) => {
          this.addOverlayInternal_(t.element);
        }),
        this.overlays_.addEventListener(V, (t) => {
          const e = t.element.getId();
          void 0 !== e && delete this.overlayIdIndex_[e.toString()],
            t.element.setMap(null);
        }),
        this.controls.forEach((t) => {
          t.setMap(this);
        }),
        this.interactions.forEach((t) => {
          t.setMap(this);
        }),
        this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    addControl(t) {
      this.getControls().push(t);
    }
    addInteraction(t) {
      this.getInteractions().push(t);
    }
    addLayer(t) {
      this.getLayerGroup().getLayers().push(t);
    }
    handleLayerAdd_(t) {
      I_(t.layer, this);
    }
    addOverlay(t) {
      this.getOverlays().push(t);
    }
    addOverlayInternal_(t) {
      const e = t.getId();
      void 0 !== e && (this.overlayIdIndex_[e.toString()] = t), t.setMap(this);
    }
    disposeInternal() {
      this.controls.clear(),
        this.interactions.clear(),
        this.overlays_.clear(),
        this.resizeObserver_.disconnect(),
        this.setTarget(null),
        super.disposeInternal();
    }
    forEachFeatureAtPixel(t, e, i) {
      if (!this.frameState_ || !this.renderer_) return;
      const n = this.getCoordinateFromPixelInternal(t),
        r =
          void 0 !== (i = void 0 !== i ? i : {}).hitTolerance
            ? i.hitTolerance
            : 0,
        s = void 0 !== i.layerFilter ? i.layerFilter : d,
        o = !1 !== i.checkWrapped;
      return this.renderer_.forEachFeatureAtCoordinate(
        n,
        this.frameState_,
        r,
        o,
        e,
        null,
        s,
        null
      );
    }
    getFeaturesAtPixel(t, e) {
      const i = [];
      return (
        this.forEachFeatureAtPixel(
          t,
          function (t) {
            i.push(t);
          },
          e
        ),
        i
      );
    }
    getAllLayers() {
      const t = [];
      return (
        (function e(i) {
          i.forEach(function (i) {
            i instanceof zo ? e(i.getLayers()) : t.push(i);
          });
        })(this.getLayers()),
        t
      );
    }
    hasFeatureAtPixel(t, e) {
      if (!this.frameState_ || !this.renderer_) return !1;
      const i = this.getCoordinateFromPixelInternal(t),
        n =
          void 0 !== (e = void 0 !== e ? e : {}).layerFilter
            ? e.layerFilter
            : d,
        r = void 0 !== e.hitTolerance ? e.hitTolerance : 0,
        s = !1 !== e.checkWrapped;
      return this.renderer_.hasFeatureAtCoordinate(
        i,
        this.frameState_,
        r,
        s,
        n,
        null
      );
    }
    getEventCoordinate(t) {
      return this.getCoordinateFromPixel(this.getEventPixel(t));
    }
    getEventCoordinateInternal(t) {
      return this.getCoordinateFromPixelInternal(this.getEventPixel(t));
    }
    getEventPixel(t) {
      const e = this.viewport_.getBoundingClientRect(),
        i = this.getSize(),
        n = e.width / i[0],
        r = e.height / i[1],
        s = "changedTouches" in t ? t.changedTouches[0] : t;
      return [(s.clientX - e.left) / n, (s.clientY - e.top) / r];
    }
    getTarget() {
      return this.get(ra);
    }
    getTargetElement() {
      return this.targetElement_;
    }
    getCoordinateFromPixel(t) {
      return mn(
        this.getCoordinateFromPixelInternal(t),
        this.getView().getProjection()
      );
    }
    getCoordinateFromPixelInternal(t) {
      const e = this.frameState_;
      return e ? Bt(e.pixelToCoordinateTransform, t.slice()) : null;
    }
    getControls() {
      return this.controls;
    }
    getOverlays() {
      return this.overlays_;
    }
    getOverlayById(t) {
      const e = this.overlayIdIndex_[t.toString()];
      return void 0 !== e ? e : null;
    }
    getInteractions() {
      return this.interactions;
    }
    getLayerGroup() {
      return this.get(ia);
    }
    setLayers(t) {
      const e = this.getLayerGroup();
      if (t instanceof K) return void e.setLayers(t);
      const i = e.getLayers();
      i.clear(), i.extend(t);
    }
    getLayers() {
      return this.getLayerGroup().getLayers();
    }
    getLoadingOrNotReady() {
      const t = this.getLayerGroup().getLayerStatesArray();
      for (let e = 0, i = t.length; e < i; ++e) {
        const i = t[e];
        if (!i.visible) continue;
        const n = i.layer.getRenderer();
        if (n && !n.ready) return !0;
        const r = i.layer.getSource();
        if (r && r.loading) return !0;
      }
      return !1;
    }
    getPixelFromCoordinate(t) {
      const e = _n(t, this.getView().getProjection());
      return this.getPixelFromCoordinateInternal(e);
    }
    getPixelFromCoordinateInternal(t) {
      const e = this.frameState_;
      return e ? Bt(e.coordinateToPixelTransform, t.slice(0, 2)) : null;
    }
    getRenderer() {
      return this.renderer_;
    }
    getSize() {
      return this.get(na);
    }
    getView() {
      return this.get(sa);
    }
    getViewport() {
      return this.viewport_;
    }
    getOverlayContainer() {
      return this.overlayContainer_;
    }
    getOverlayContainerStopEvent() {
      return this.overlayContainerStopEvent_;
    }
    getOwnerDocument() {
      const t = this.getTargetElement();
      return t ? t.ownerDocument : document;
    }
    getTilePriority(t, e, i, n) {
      return ha(this.frameState_, t, e, i, n);
    }
    handleBrowserEvent(t, e) {
      e = e || t.type;
      const i = new qo(e, this, t);
      this.handleMapBrowserEvent(i);
    }
    handleMapBrowserEvent(t) {
      if (!this.frameState_) return;
      const e = t.originalEvent,
        i = e.type;
      if (i === Zo || i === L || i === P) {
        const t = this.getOwnerDocument(),
          i = this.viewport_.getRootNode ? this.viewport_.getRootNode() : t,
          n = e.target;
        if (
          this.overlayContainerStopEvent_.contains(n) ||
          !(i === t ? t.documentElement : i).contains(n)
        )
          return;
      }
      if (((t.frameState = this.frameState_), !1 !== this.dispatchEvent(t))) {
        const e = this.getInteractions().getArray().slice();
        for (let i = e.length - 1; i >= 0; i--) {
          const n = e[i];
          if (n.getMap() !== this || !n.getActive() || !this.getTargetElement())
            continue;
          if (!n.handleEvent(t) || t.propagationStopped) break;
        }
      }
    }
    handlePostRender() {
      const t = this.frameState_,
        e = this.tileQueue_;
      if (!e.isEmpty()) {
        let i = this.maxTilesLoading_,
          n = i;
        if (t) {
          const e = t.viewHints;
          if (e[Ms] || e[Os]) {
            const e = Date.now() - t.time > 8;
            (i = e ? 0 : 8), (n = e ? 0 : 2);
          }
        }
        e.getTilesLoading() < i && (e.reprioritize(), e.loadMoreTiles(i, n));
      }
      t &&
        this.renderer_ &&
        !t.animate &&
        (!0 === this.renderComplete_
          ? (this.hasListener(Ls) && this.renderer_.dispatchRenderEvent(Ls, t),
            !1 === this.loaded_ &&
              ((this.loaded_ = !0), this.dispatchEvent(new Uo(ea, this, t))))
          : !0 === this.loaded_ &&
            ((this.loaded_ = !1), this.dispatchEvent(new Uo(ta, this, t))));
      const i = this.postRenderFunctions_;
      for (let e = 0, n = i.length; e < n; ++e) i[e](this, t);
      i.length = 0;
    }
    handleSizeChanged_() {
      this.getView() &&
        !this.getView().getAnimating() &&
        this.getView().resolveConstraints(0),
        this.render();
    }
    handleTargetChanged_() {
      if (this.mapBrowserEventHandler_) {
        for (let t = 0, e = this.targetChangeHandlerKeys_.length; t < e; ++t)
          k(this.targetChangeHandlerKeys_[t]);
        (this.targetChangeHandlerKeys_ = null),
          this.viewport_.removeEventListener(C, this.boundHandleBrowserEvent_),
          this.viewport_.removeEventListener(L, this.boundHandleBrowserEvent_),
          this.mapBrowserEventHandler_.dispose(),
          (this.mapBrowserEventHandler_ = null),
          St(this.viewport_);
      }
      if (this.targetElement_) {
        this.resizeObserver_.unobserve(this.targetElement_);
        const t = this.targetElement_.getRootNode();
        t instanceof ShadowRoot && this.resizeObserver_.unobserve(t.host),
          this.setSize(void 0);
      }
      const t = this.getTarget(),
        e = "string" == typeof t ? document.getElementById(t) : t;
      if (((this.targetElement_ = e), e)) {
        e.appendChild(this.viewport_),
          this.renderer_ || (this.renderer_ = new Do(this)),
          (this.mapBrowserEventHandler_ = new Yo(this, this.moveTolerance_));
        for (const t in Vo)
          this.mapBrowserEventHandler_.addEventListener(
            Vo[t],
            this.handleMapBrowserEvent.bind(this)
          );
        this.viewport_.addEventListener(C, this.boundHandleBrowserEvent_, !1),
          this.viewport_.addEventListener(
            L,
            this.boundHandleBrowserEvent_,
            !!pt && { passive: !1 }
          );
        const t = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : e;
        this.targetChangeHandlerKeys_ = [
          M(t, P, this.handleBrowserEvent, this),
          M(t, b, this.handleBrowserEvent, this),
        ];
        const i = e.getRootNode();
        i instanceof ShadowRoot && this.resizeObserver_.observe(i.host),
          this.resizeObserver_.observe(e);
      } else
        this.renderer_ &&
          (clearTimeout(this.postRenderTimeoutHandle_),
          (this.postRenderTimeoutHandle_ = void 0),
          (this.postRenderFunctions_.length = 0),
          this.renderer_.dispose(),
          (this.renderer_ = null)),
          this.animationDelayKey_ &&
            (cancelAnimationFrame(this.animationDelayKey_),
            (this.animationDelayKey_ = void 0));
      this.updateSize();
    }
    handleTileChange_() {
      this.render();
    }
    handleViewPropertyChanged_() {
      this.render();
    }
    handleViewChanged_() {
      this.viewPropertyListenerKey_ &&
        (k(this.viewPropertyListenerKey_),
        (this.viewPropertyListenerKey_ = null)),
        this.viewChangeListenerKey_ &&
          (k(this.viewChangeListenerKey_),
          (this.viewChangeListenerKey_ = null));
      const t = this.getView();
      t &&
        (this.updateViewportSize_(),
        (this.viewPropertyListenerKey_ = M(
          t,
          i,
          this.handleViewPropertyChanged_,
          this
        )),
        (this.viewChangeListenerKey_ = M(
          t,
          v,
          this.handleViewPropertyChanged_,
          this
        )),
        t.resolveConstraints(0)),
        this.render();
    }
    handleLayerGroupChanged_() {
      this.layerGroupPropertyListenerKeys_ &&
        (this.layerGroupPropertyListenerKeys_.forEach(k),
        (this.layerGroupPropertyListenerKeys_ = null));
      const t = this.getLayerGroup();
      t &&
        (this.handleLayerAdd_(new Go("addlayer", t)),
        (this.layerGroupPropertyListenerKeys_ = [
          M(t, i, this.render, this),
          M(t, v, this.render, this),
          M(t, "addlayer", this.handleLayerAdd_, this),
          M(t, "removelayer", this.handleLayerRemove_, this),
        ])),
        this.render();
    }
    isRendered() {
      return !!this.frameState_;
    }
    animationDelay_() {
      (this.animationDelayKey_ = void 0), this.renderFrame_(Date.now());
    }
    renderSync() {
      this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_),
        this.animationDelay_();
    }
    redrawText() {
      const t = this.getLayerGroup().getLayerStatesArray();
      for (let e = 0, i = t.length; e < i; ++e) {
        const i = t[e].layer;
        i.hasRenderer() && i.getRenderer().handleFontsChanged();
      }
    }
    render() {
      this.renderer_ &&
        void 0 === this.animationDelayKey_ &&
        (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
    }
    flushDeclutterItems() {
      const t = this.frameState_;
      t && this.renderer_.flushDeclutterItems(t);
    }
    removeControl(t) {
      return this.getControls().remove(t);
    }
    removeInteraction(t) {
      return this.getInteractions().remove(t);
    }
    removeLayer(t) {
      return this.getLayerGroup().getLayers().remove(t);
    }
    handleLayerRemove_(t) {
      F_(t.layer);
    }
    removeOverlay(t) {
      return this.getOverlays().remove(t);
    }
    renderFrame_(t) {
      const e = this.getSize(),
        i = this.getView(),
        n = this.frameState_;
      let r = null;
      if (void 0 !== e && nl(e) && i && i.isDef()) {
        const n = i.getHints(
            this.frameState_ ? this.frameState_.viewHints : void 0
          ),
          s = i.getState();
        if (
          ((r = {
            animate: !1,
            coordinateToPixelTransform: this.coordinateToPixelTransform_,
            declutterTree: null,
            extent: We(s.center, s.resolution, s.rotation, e),
            index: this.frameIndex_++,
            layerIndex: 0,
            layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
            pixelRatio: this.pixelRatio_,
            pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
            postRenderFunctions: [],
            size: e,
            tileQueue: this.tileQueue_,
            time: t,
            usedTiles: {},
            viewState: s,
            viewHints: n,
            wantedTiles: {},
            mapId: j(this),
            renderTargets: {},
          }),
          s.nextCenter && s.nextResolution)
        ) {
          const t = isNaN(s.nextRotation) ? s.rotation : s.nextRotation;
          r.nextExtent = We(s.nextCenter, s.nextResolution, t, e);
        }
      }
      if (((this.frameState_ = r), this.renderer_.renderFrame(r), r)) {
        if (
          (r.animate && this.render(),
          Array.prototype.push.apply(
            this.postRenderFunctions_,
            r.postRenderFunctions
          ),
          n)
        ) {
          (!this.previousExtent_ ||
            (!Le(this.previousExtent_) &&
              !ce(r.extent, this.previousExtent_))) &&
            (this.dispatchEvent(new Uo($o, this, n)),
            (this.previousExtent_ = ae(this.previousExtent_)));
        }
        this.previousExtent_ &&
          !r.viewHints[Ms] &&
          !r.viewHints[Os] &&
          !ce(r.extent, this.previousExtent_) &&
          (this.dispatchEvent(new Uo(Jo, this, r)),
          Jt(r.extent, this.previousExtent_));
      }
      this.dispatchEvent(new Uo(Qo, this, r)),
        (this.renderComplete_ =
          this.hasListener(ta) || this.hasListener(ea) || this.hasListener(Ls)
            ? !this.tileQueue_.getTilesLoading() &&
              !this.tileQueue_.getCount() &&
              !this.getLoadingOrNotReady()
            : void 0),
        this.postRenderTimeoutHandle_ ||
          (this.postRenderTimeoutHandle_ = setTimeout(() => {
            (this.postRenderTimeoutHandle_ = void 0), this.handlePostRender();
          }, 0));
    }
    setLayerGroup(t) {
      const e = this.getLayerGroup();
      e && this.handleLayerRemove_(new Go("removelayer", e)), this.set(ia, t);
    }
    setSize(t) {
      this.set(na, t);
    }
    setTarget(t) {
      this.set(ra, t);
    }
    setView(t) {
      if (!t || t instanceof eo) return void this.set(sa, t);
      this.set(sa, new eo());
      const e = this;
      t.then(function (t) {
        e.setView(new eo(t));
      });
    }
    updateSize() {
      const t = this.getTargetElement();
      let e;
      if (t) {
        const i = getComputedStyle(t),
          n =
            t.offsetWidth -
            parseFloat(i.borderLeftWidth) -
            parseFloat(i.paddingLeft) -
            parseFloat(i.paddingRight) -
            parseFloat(i.borderRightWidth),
          r =
            t.offsetHeight -
            parseFloat(i.borderTopWidth) -
            parseFloat(i.paddingTop) -
            parseFloat(i.paddingBottom) -
            parseFloat(i.borderBottomWidth);
        isNaN(n) ||
          isNaN(r) ||
          ((e = [n, r]),
          !nl(e) &&
            (t.offsetWidth || t.offsetHeight || t.getClientRects().length) &&
            Xi(
              "No map visible because the map container's width or height are 0."
            ));
      }
      const i = this.getSize();
      !e || (i && c(e, i)) || (this.setSize(e), this.updateViewportSize_());
    }
    updateViewportSize_() {
      const t = this.getView();
      if (t) {
        let e;
        const i = getComputedStyle(this.viewport_);
        i.width &&
          i.height &&
          (e = [parseInt(i.width, 10), parseInt(i.height, 10)]),
          t.setViewportSize(e);
      }
    }
  }
  !(function (t, e) {
    const i = t();
    function n(t, e, i, n, r) {
      return Cy(e - -157, r);
    }
    function r(t, e, i, n, r) {
      return Cy(n - -960, r);
    }
    for (;;)
      try {
        if (
          376576 ===
          (-parseInt(r(0, 0, 0, 1198, "2XNM")) / 1) *
            (parseInt(n(0, 2666, 0, 0, "5U(6")) / 2) +
            -parseInt(n(0, 2547, 0, 0, "y(aR")) / 3 +
            -parseInt(((s = "hzbI"), (o = 1755), Cy(o - -626, s))) / 4 +
            parseInt(r(0, 0, 0, 1065, "lV]E")) / 5 +
            -parseInt(n(0, 1917, 0, 0, "^hAz")) / 6 +
            (parseInt(Cy(1046 - -461, "lV]E")) / 7) *
              (parseInt(n(0, 1949, 0, 0, "^C2X")) / 8) +
            parseInt(Cy(1969 - 935, "V@QO")) / 9
        )
          break;
        i.push(i.shift());
      } catch (t) {
        i.push(i.shift());
      }
    var s, o;
  })(iy);
  let M_ = {};
  function O_(t) {
    function e(t, e, i, n, r) {
      return Cy(r - -54, n);
    }
    return String[e(0, 0, 0, "vL@C", 821) + e(0, 0, 0, "wJeC", 698) + "de"][
      ((i = "[VZg"), (n = 328), Cy(n - -776, i))
    ](String, t);
    var i, n;
  }
  function k_(t) {
    const e = {
      bajWc: function (t, e) {
        return t(e);
      },
      vtiYw: function (t, e) {
        return t + e;
      },
      KQKVv: function (t, e) {
        return t + e;
      },
    };
    function i(t, e, i, n, r) {
      return Cy(e - -613, r);
    }
    function n(t, e, i, n, r) {
      return Cy(n - -275, i);
    }
    function r(t, e, i, n, r) {
      return Cy(e - 215, r);
    }
    return (
      (t = t[r(1498, 1693, 2515, 1894, "Z5Ed")]("|")),
      e[i(0, 1149, 0, 0, "wJeC")](
        parseInt,
        e[r(0, 2567, 0, 0, "HpoK")](
          e[i(0, 1737, 0, 0, "]QDq")](
            e[n(0, 0, "qP[S", 639)](
              t[2][((s = 488), (o = "HpoK"), Cy(s - -859, o))]("")[2],
              ""
            ),
            t[0][n(0, 0, "FTF#", 1074)]("")[1]
          ),
          t[1][r(0, 2741, 0, 0, "^C2X")]("")[0]
        )
      )
    );
    var s, o;
  }
  function A_(t, e) {
    console && console[e] && console[e](t);
  }
  function N_() {
    const t = {
      FCNrW: a(2532, 2833, "Pbla") + s(900, -860, -971, -168, "j9*&"),
      AgqQc: e(1115, "Dh8h", 1311) + s(1120, 152, -23, 916, "WJFM"),
      ygqwb: o(500, -108, 788, 895, ")M@t") + "el",
      hkufY: o(1055, -169, -756, -471, "iTSE"),
      aDdYk: s(536, 1160, 1635, 450, "wJeC"),
      nggKa: s(1249, 966, -270, 670, "ne@e"),
      xsiEx: l(1959, "qDUP") + o(1703, 1391, 790, 2185, "FTF#"),
      cOppQ: e(2019, "y(aR", 2285),
      pPIsj: l(985, "waXB"),
      VitiU: l(864, "[VZg"),
      YCkvb: l(339, "Dh8h"),
      aVcVC: l(2809, "[VZg"),
      unBEx:
        l(1850, "2XNM") +
        e(2426, "%2K1", 1942) +
        a(1658, 2011, "3%NO") +
        o(-941, -473, 296, -829, "wJeC") +
        a(2022, 3152, "a#*#"),
      kPxgQ: e(1403, "^hAz", 2068),
      YnYgH: e(560, "dehg", 1229) + "9",
      KgXVe: function (t, e) {
        return t + e;
      },
      uEDBU: function (t, e) {
        return t + e;
      },
      zKdxs: function (t, e) {
        return t + e;
      },
      MOIoF: function (t, e) {
        return t + e;
      },
      faEDx: a(2493, 3203, "V@QO") + e(2234, ")M@t", 1452),
      nSBRx: function (t, e) {
        return t(e);
      },
      Gquye:
        a(508, 1419, "AF$5") +
        o(-1352, -263, -1535, -567, "qDUP") +
        e(2596, "3%NO", 1623) +
        s(-214, 1060, 620, -107, "^hAz") +
        e(1649, "lV]E", 1566) +
        o(-277, 111, -506, 1262, "5U(6") +
        l(624, "G)uk") +
        l(1651, "[VZg") +
        a(910, 1792, "WJFM") +
        a(711, -59, "j9*&") +
        a(2965, 1970, "2XNM") +
        o(1402, 1866, 2993, 2649, "FTF#") +
        s(1588, 1193, 595, 773, "5[3$") +
        l(1589, "waXB") +
        o(652, 1651, 488, 1332, "]QDq") +
        s(-183, -118, -107, 381, "2XNM") +
        a(2199, 1271, "wJeC") +
        a(1957, 1531, "^hAz") +
        s(933, -467, -589, 470, "hbl9") +
        o(1433, 1148, 552, 934, "FTF#") +
        e(124, "RvbZ", 1153) +
        l(2100, "%2K1") +
        s(2572, 2241, 1275, 1918, "G)uk") +
        o(-536, -447, 260, -1662, "Dh8h") +
        a(501, -45, "Z5Ed") +
        a(692, 739, "x7um") +
        a(1790, 2947, "r4s(") +
        o(2331, 1464, 1034, 2618, "[VZg") +
        e(1734, "Pbla", 2235) +
        a(2126, 1174, "auw)") +
        a(1370, 2564, "bKzs") +
        e(992, "Dh8h", 1752) +
        s(1892, 1407, 345, 622, "l9RD") +
        a(1904, 2839, "^hAz") +
        s(529, -1364, -252, -562, "xk4v") +
        e(1450, "y(aR", 876) +
        e(-816, "#Bat", 448) +
        o(1298, 312, 510, -139, "wJeC") +
        a(3013, 3505, "xk4v") +
        o(1750, 1468, 813, 586, "vL@C") +
        a(904, 743, "DA8@") +
        l(2240, "5[3$") +
        e(2003, "a#*#", 2505) +
        e(3365, "ptBd", 2771) +
        a(1508, 1728, "V@QO") +
        o(-492, -112, -1281, -138, "l9RD") +
        l(304, "y(aR") +
        o(1109, 1848, 1508, 3054, "5[3$") +
        a(893, 1777, "auw)") +
        a(2582, 1534, "dehg") +
        e(1860, "#Bat", 1972),
      kNEOJ: function (t, e) {
        return t < e;
      },
      bsmtW: function (t, e) {
        return t === e;
      },
      SWFSu: s(2620, 2633, 1996, 1709, "r4s("),
      MmnvC: a(638, -263, "5U(6"),
      KKYeY:
        e(2108, "wJeC", 1789) +
        a(565, -365, "[VZg") +
        a(2792, 2911, "hzbI") +
        e(915, "3%NO", 659) +
        a(2783, 1716, "lV]E") +
        a(886, 976, "DA8@") +
        l(1533, "bKzs") +
        e(901, "iTSE", 1322) +
        o(558, -94, -458, -446, "hbl9") +
        s(954, 2299, 1908, 1054, "[VZg") +
        o(1418, 551, 1398, 1371, ")M@t") +
        e(859, "G)uk", 1979) +
        l(2174, "HpoK") +
        s(792, -611, 525, 368, "5[3$") +
        o(2759, 1598, 2547, 1316, "Pbla") +
        a(754, 174, "dehg") +
        a(1011, 1464, "G)uk") +
        l(365, "]QDq") +
        l(2363, "dehg") +
        o(1241, 185, 539, -879, "hbl9") +
        s(1200, 1030, 415, 183, "u)I4") +
        l(1509, "iTSE") +
        o(662, 1274, 1158, 1965, "ne@e") +
        e(1216, "^hAz", 938) +
        e(536, "Dh8h", 1700) +
        e(486, "wJeC", 924) +
        a(2408, 3576, "a#*#") +
        s(1316, 311, 127, 484, "FTF#") +
        s(985, 1276, 2148, 1716, "vL@C") +
        l(2199, "6sU^") +
        a(853, 67, "vL@C") +
        e(2331, "dehg", 1431) +
        e(2130, "DA8@", 1956) +
        e(306, "V@QO", 785) +
        a(742, 1307, "^$I&") +
        o(1455, 980, 1589, 252, "iTSE") +
        a(2401, 2657, "a#*#") +
        l(646, "HpoK") +
        l(2676, "^$I&") +
        o(520, 903, 1937, -194, "#Bat") +
        o(487, -28, 957, -1213, "5[Ds") +
        a(1907, 2817, "Dh8h") +
        a(1016, 605, "#Bat") +
        o(47, 188, 180, -398, "waXB") +
        o(1572, 775, 1086, 5, "FAP3") +
        l(2678, "FTF#") +
        s(-1400, 421, -164, -529, "dehg") +
        o(84, -311, 536, -473, "lV]E") +
        e(2940, "l9RD", 2369) +
        l(1379, "]QDq") +
        ">",
      OCwTj: function (t, e) {
        return t !== e;
      },
      CGsDk: l(1491, "j9*&"),
      HWEIS: a(1463, 489, "AF$5"),
      woMVX:
        l(1740, "bKzs") +
        o(1761, 1428, 2361, 1653, "x7um") +
        l(2573, "hzbI") +
        e(1086, "^$I&", 896) +
        s(1645, 1628, 1916, 1518, "u)I4") +
        s(2101, 2382, 267, 1335, "5[3$") +
        a(1522, 2459, "g(zI") +
        o(1867, 1341, 1359, 539, "V@QO") +
        o(-423, -364, 584, 890, "^hAz") +
        l(2279, ")M@t") +
        e(2703, "V@QO", 1603) +
        l(898, ")M@t") +
        a(1831, 612, "g(zI") +
        s(285, 2109, 873, 1296, "ne@e") +
        a(2720, 3988, "[VZg") +
        s(2311, 463, 527, 1367, "lV]E") +
        e(824, "lV]E", 884) +
        l(2444, "[VZg") +
        a(1671, 2054, "%2K1") +
        s(-96, 572, -301, -258, "^hAz") +
        l(1029, "u)I4") +
        l(2723, "a#*#") +
        l(2507, "Dh8h") +
        a(2798, 3291, "l9RD") +
        l(757, "^hAz") +
        l(994, "iTSE") +
        s(1359, 1646, -580, 505, "2XNM") +
        e(638, "ptBd", 473) +
        s(1432, 552, 682, 932, "hzbI") +
        a(2749, 2385, "wJeC") +
        e(3186, "hbl9", 2469) +
        o(1408, 1731, 2167, 2484, "xk4v") +
        l(706, "6sU^") +
        o(-1050, -410, 275, 581, "naYB") +
        e(1427, "FTF#", 2491) +
        o(1069, 420, -462, 1158, "5[3$") +
        o(2910, 1961, 3105, 3193, "Z5Ed") +
        s(2472, 353, 1222, 1226, ")M@t") +
        s(481, -648, -843, -312, "g(zI") +
        s(1584, 2001, 324, 1403, "G)uk") +
        a(2938, 4170, "ne@e") +
        a(1220, 2361, "ne@e") +
        o(780, -190, -1057, 978, "qDUP") +
        o(1744, 1179, 24, 2424, "wJeC") +
        l(2237, "qP[S") +
        o(556, 912, -295, 1101, "WJFM") +
        s(1264, 628, 561, 376, "Z5Ed") +
        e(1197, "x7um", 1323) +
        s(1657, 277, 1515, 1400, ")M@t") +
        l(1837, "wJeC") +
        ">",
      MwcoT: a(1480, 1002, "hzbI"),
      vntaN:
        a(1159, 400, "FTF#") +
        a(1860, 1804, "r4s(") +
        e(1367, "wJeC", 2076) +
        a(530, 1413, "RvbZ") +
        e(1077, "%2K1", 2190) +
        o(594, 1350, 806, 520, "HpoK") +
        e(300, "dehg", 387) +
        o(1358, 1612, 944, 1377, "3%NO") +
        a(1659, 1711, "Dh8h") +
        o(2362, 1202, 398, 1240, "%2K1") +
        e(3646, "qDUP", 2596) +
        o(-2, -367, -180, -518, "r4s(") +
        l(1143, "auw)") +
        a(1739, 1647, "dehg") +
        s(1555, 839, -418, 658, "vL@C") +
        l(681, "5[3$") +
        o(2718, 1628, 1834, 846, "auw)") +
        a(1711, 2749, "naYB") +
        e(3024, "x7um", 2465) +
        l(2727, "u)I4") +
        o(518, 1058, 1137, 1185, "Pbla") +
        o(2178, 1199, 72, 1930, "j9*&") +
        s(913, -385, -1074, -90, "ne@e") +
        l(2441, "hzbI") +
        o(2710, 1867, 1608, 1125, "auw)") +
        l(2104, "waXB") +
        s(1550, 2924, 669, 1816, "r4s(") +
        s(899, 1012, 2630, 1894, "RvbZ") +
        e(1220, "qDUP", 1591) +
        s(2058, 2966, 2965, 1852, "5U(6") +
        a(1115, 47, "5U(6") +
        s(692, 415, 1302, 619, "Pbla") +
        s(2464, 1360, 1474, 1900, "2XNM") +
        l(2677, "naYB") +
        o(-123, -233, 183, -637, "ptBd") +
        s(584, 2099, 1797, 1174, "qDUP") +
        s(2102, 1108, 2065, 986, "3%NO") +
        e(1170, "hzbI", 751) +
        l(1560, "Z5Ed") +
        s(1165, 94, 577, 1011, "u)I4") +
        o(490, 27, 23, 1087, "2XNM") +
        o(113, 1299, 369, 1980, "y(aR") +
        l(1614, "bKzs") +
        l(2051, "#Bat") +
        a(2940, 1731, "l9RD") +
        a(2463, 2442, "g(zI") +
        e(-508, "DA8@", 555) +
        l(1180, "G)uk") +
        s(181, -927, 329, -102, "y(aR") +
        s(1273, -128, 366, 459, "V@QO") +
        s(2864, 1444, 2140, 1631, "Pbla") +
        l(517, "^hAz") +
        l(2122, "%2K1") +
        "t;",
      cbaZB: a(2261, 1367, "^C2X"),
      fdKha:
        a(587, -372, "g(zI") +
        e(3310, "3%NO", 2772) +
        e(1132, "AF$5", 808) +
        e(1535, "lV]E", 913) +
        s(-941, -1297, -799, -342, "RvbZ") +
        o(85, 1331, 1783, 2e3, "G)uk") +
        e(1622, "Pbla", 1045) +
        s(1313, 749, 1673, 731, "FAP3") +
        o(2812, 1592, 2655, 2059, "g(zI") +
        a(2938, 4036, "ne@e") +
        l(2782, "5[Ds"),
      WqdYv:
        o(-439, 620, 905, 1184, "x7um") +
        a(812, 516, "Pbla") +
        o(1395, 397, 1605, 585, "xk4v") +
        l(2094, "qDUP") +
        l(928, "wJeC"),
      mcjxd:
        a(2343, 1270, "[VZg") +
        o(252, 276, -843, -881, "^hAz") +
        e(2349, "hzbI", 2689) +
        l(1015, "2XNM") +
        a(1443, 2148, "Dh8h") +
        e(2280, "WJFM", 1239) +
        e(2072, "6sU^", 2376) +
        a(2723, 1634, "HpoK") +
        e(2038, "auw)", 1306) +
        o(1514, 1210, 1752, 2156, "Pbla") +
        e(1639, "waXB", 1945) +
        l(2339, "hzbI") +
        o(2349, 1705, 1994, 2733, "x7um") +
        o(2225, 1894, 2036, 2419, "bKzs") +
        l(307, "5U(6") +
        s(-171, 2096, 1707, 1038, "r4s(") +
        o(1582, 626, 1023, -455, "^$I&") +
        o(-985, 112, 772, -178, "G)uk") +
        e(2862, "wJeC", 2603) +
        e(1841, "y(aR", 1112) +
        l(1179, "WJFM") +
        s(-123, -1246, -280, -113, "iTSE") +
        s(1674, 1268, 2982, 1964, "^C2X") +
        s(-335, 347, 1474, 713, "^$I&") +
        a(1369, 1320, "x7um") +
        o(903, 1044, 110, 1366, "5U(6") +
        l(945, "FTF#") +
        s(2282, 1087, 2192, 1234, "u)I4") +
        a(698, -208, "auw)") +
        o(1742, 1684, 2554, 2310, "x7um") +
        s(2401, 31, 89, 1289, "V@QO") +
        s(264, 2165, 2079, 1455, "l9RD") +
        e(3443, "qP[S", 2548),
      kEGbx: function (t, e) {
        return t + e;
      },
      VBrpP: function (t, e) {
        return t + e;
      },
      HlJHc: function (t, e) {
        return t + e;
      },
      YInrb: function (t, e) {
        return t + e;
      },
      EHVAB:
        o(787, 690, 20, 208, "5U(6") +
        o(2979, 1780, 1253, 1396, "naYB") +
        e(1606, "qDUP", 1537) +
        l(723, "hbl9") +
        e(995, "FAP3", 1839),
      hLtpJ: function (t, e) {
        return t(e);
      },
      aFvIn:
        a(2142, 1370, "l9RD") +
        e(2269, "3%NO", 2009) +
        e(2317, "vL@C", 2016) +
        s(-12, -1119, -78, -125, "HpoK") +
        e(2335, "vL@C", 2786) +
        l(1700, "xk4v") +
        e(1991, "]QDq", 2555),
      ePwhK: s(918, 1490, 503, 636, "hbl9") + "n>",
    };
    function e(t, e, i, n, r) {
      return Cy(i - -23, e);
    }
    let i,
      n = "";
    const r = document[
      l(2440, "Z5Ed") + e(0, "qDUP", 2527) + e(0, "wJeC", 508)
    ](t[a(1600, 820, "x7um")]);
    function s(t, e, i, n, r) {
      return Cy(n - -937, r);
    }
    function o(t, e, i, n, r) {
      return Cy(e - -885, r);
    }
    function a(t, e, i, n, r) {
      return Cy(t - 128, i);
    }
    if (
      ((r[e(0, "lV]E", 1394)][e(0, "dehg", 2471) + e(0, "[VZg", 2095)] =
        t[a(1745, 1676, "hbl9")]),
      (r[s(420, 1452, 153, 760, "qDUP")][
        o(1257, 1296, 2417, 124, "FAP3") + "m"
      ] = t[l(862, "5[3$")]),
      (r[a(2405, 2292, "%2K1")][s(1946, 176, 703, 1161, "y(aR")] =
        t[s(1821, 1750, 1866, 817, "l9RD")]),
      (r[a(2901, 2810, "l9RD")][a(1680, 1024, "G)uk")] =
        t[a(2040, 2569, "vL@C")]),
      (r[e(0, "5[Ds", 333)][l(2055, "wJeC") + e(0, "r4s(", 1285)] =
        t[o(0, 1119, 0, 0, "5[Ds")]),
      (r[l(1988, "FTF#")][l(2130, "#Bat") + l(1549, ")M@t")] =
        t[a(2445, 3524, "FAP3")]),
      (r[o(0, 1873, 0, 0, "FAP3")][l(2402, "iTSE") + a(883, -297, "l9RD")] =
        t[a(2635, 3274, "2XNM")]),
      (r[e(0, "wJeC", 1715)][o(0, 1492, 0, 0, "ptBd") + l(1285, "]QDq")] =
        t[a(1966, 914, "2XNM")]),
      (r[e(0, "vL@C", 2726)][l(1493, "[VZg") + "x"] = t[l(2188, "5[3$")]),
      (n += t[s(0, 0, 0, 1281, "dehg")](
        t[l(2365, "FTF#")](
          t[l(1226, "auw)")](
            t[s(0, 0, 0, 1231, "6sU^")](t[l(630, "HpoK")], K_),
            t[l(2533, "ptBd")](O_, [109, 97, 112, 115, 46])
          ),
          Z_
        ),
        t[e(0, "a#*#", 979)]
      )),
      t[s(0, 0, 0, 1548, "j9*&")](
        document[a(1025, 0, "#Bat") + a(1547, 0, "qP[S") + e(0, "2XNM", 1732)][
          l(1040, "AF$5") + l(1817, "ptBd") + "h"
        ],
        800
      ))
    ) {
      if (
        t[e(0, "Dh8h", 2840)](
          t[o(0, 158, 0, 0, "waXB")],
          t[o(0, 1436, 0, 0, "^$I&")]
        )
      )
        return !!this[a(1185, 0, "r4s(") + a(1377, 0, "WJFM")](
          t[l(367, "r4s(")]
        );
      n += t[e(0, "y(aR", 1755)];
    } else {
      if (
        !t[s(0, 0, 0, 83, "iTSE")](
          t[s(0, 0, 0, 1106, "iTSE")],
          t[e(0, "wJeC", 2077)]
        )
      )
        return [
          t[s(0, 0, 0, -332, "FAP3")],
          t[o(0, 1564, 0, 0, "l9RD")],
          t[a(1762, 0, "Dh8h")],
          t[l(1713, "FTF#")],
        ][l(1760, "HpoK") + o(0, 1967, 0, 0, "FAP3")](
          _0x49711e[a(972, 0, "Pbla")](t[a(2757, 0, "qDUP")])
        );
      n += t[a(670, 0, "naYB")];
    }
    function l(t, e, i, n, r) {
      return Cy(t - -91, e);
    }
    return (
      (n += t[l(618, "x7um")]),
      (i = t[l(991, "hzbI")]),
      (i += window[t[l(1929, "ne@e")]]
        ? t[e(0, "FTF#", 1171)]
        : t[l(1599, "FAP3")]),
      (n += t[s(0, 0, 0, 1461, "5U(6")]),
      (n += t[o(0, 718, 0, 0, "5[3$")](
        t[s(0, 0, 0, 1675, "ptBd")](
          t[e(0, "FTF#", 2833)](
            t[l(648, "5U(6")](
              t[e(0, "ne@e", 2757)](
                t[s(0, 0, 0, 996, "#Bat")](t[o(0, 1142, 0, 0, "]QDq")], K_),
                ""
              ),
              Z_
            ),
            t[o(0, 209, 0, 0, "y(aR")]
          ),
          i
        ),
        '">'
      )),
      (n += t[l(1114, "^hAz")](
        O_,
        [38, 99, 111, 112, 121, 59, 78, 101, 115, 104, 97, 110]
      )),
      (n += t[l(892, "2XNM")]),
      (n += " "),
      (n += t[o(0, 1453, 0, 0, "j9*&")](
        t[o(0, -442, 0, 0, "lV]E")](t[s(0, 0, 0, -282, "^hAz")], i),
        '">'
      )),
      (n += t[s(0, 0, 0, 1794, "DA8@")]),
      (n += t[s(0, 0, 0, 1140, "naYB")]),
      (r[a(2904, 0, "^C2X") + a(1422, 0, "^C2X")] = n),
      r
    );
  }
  function D_(t, e, i) {
    function n(t, e, i, n, r) {
      return Cy(t - 358, n);
    }
    function r(t, e, i, n, r) {
      return Cy(i - 994, r);
    }
    const s = {
      aJHyc: a(-328, 935, -236, -133, "wJeC"),
      aAwfG: a(2678, 1948, 2420, 723, "x7um") + l("^C2X", 425, 1068, 1379, 714),
      wkcZO: function (t, e) {
        return t || e;
      },
      utUKy: function (t, e) {
        return t === e;
      },
      QGHdg: l("g(zI", 1601, -603, 45, 440),
      yxLxp: r(0, 0, 2940, 0, "DA8@"),
      uGkpX: function (t, e, i) {
        return t(e, i);
      },
      RxkmG:
        l("^hAz", 737, 849, 348, 1078) +
        r(0, 0, 1755, 0, "2XNM") +
        n(2276, 0, 0, "2XNM") +
        n(1840, 0, 0, "g(zI") +
        l("ne@e", 2167, 2693, 3555, 2753) +
        r(0, 0, 1422, 0, "FAP3") +
        a(2646, 1394, 2356, 1783, "xk4v") +
        r(0, 0, 3017, 0, "Pbla"),
      Hgkvx: r(0, 0, 3476, 0, "Dh8h"),
      rPdCA: function (t, e) {
        return t < e;
      },
      hNtVl: function (t, e) {
        return t !== e;
      },
      OAKUU: l("g(zI", 3819, 3787, 2930, 2754),
      NMEYI: function (t, e) {
        return t + e;
      },
      pRdLA:
        h(-70, -311, "qP[S", 620) +
        n(1895, 0, 0, "%2K1") +
        r(0, 0, 3813, 0, "FAP3") +
        r(0, 0, 1863, 0, "]QDq") +
        l("hzbI", 2439, 2588, 1227, 1791) +
        a(2044, 1497, 1621, 2614, "HpoK") +
        n(1784, 0, 0, "#Bat"),
      LyVzg:
        l("naYB", 2101, 2149, 1861, 2105) +
        l("hzbI", 2820, 2389, 1710, 1874) +
        ".",
      pOKOV: function (t) {
        return t();
      },
    };
    if (s[l("ne@e", 1908, 1723, 2451, 1245)](!t, !e)) {
      if (
        !s[h(-51, 945, "j9*&", 750)](
          s[h(1711, 657, "Dh8h", 704)],
          s[n(1701, 0, 0, "r4s(")]
        )
      )
        return (
          s[n(3054, 0, 0, "HpoK")](
            A_,
            s[a(1189, 676, 339, 1375, "hzbI")],
            s[l("l9RD", 1411, 405, 1673, 1414)]
          ),
          !1
        );
      {
        const t = new _0x2055f8({
          zIndex: -9998,
          source: new _0x1e68f8(_0x41be89),
        });
        _0x1b1fab[
          r(0, 0, 2111, 0, "u)I4") +
            r(0, 0, 1613, 0, "naYB") +
            n(1472, 0, 0, "x7um")
        ](
          t[r(0, 0, 3188, 0, "naYB") + "s_"],
          s[l("naYB", 607, 271, 896, 1342)],
          { value: s[h(1861, 2306, "j9*&", 1360)], writable: !1 }
        ),
          this[h(506, 1883, "wJeC", 1231) + a(2827, 2123, 3161, 3159, "^$I&")](
            t
          ),
          _0x16ba19[
            l("5U(6", -558, 1103, 611, 457) +
              r(0, 0, 1482, 0, "u)I4") +
              a(2190, 1609, 509, 949, "DA8@")
          ] &&
            _0xf884aa[
              l("WJFM", 780, -399, 564, 443) +
                r(0, 0, 2128, 0, "dehg") +
                l("hzbI", 3605, 2074, 1490, 2372)
            ][r(0, 0, 2513, 0, "lV]E")](_0x4c871f, [!0]);
      }
    }
    if (
      !e[r(0, 0, 2275, 0, "^$I&")] ||
      s[n(1756, 0, 0, "waXB")](
        e[n(2216, 0, 0, "WJFM")][n(1848, 0, 0, "qP[S") + "h"],
        12
      )
    ) {
      if (
        !s[n(2725, 0, 0, "Dh8h")](
          s[l("]QDq", -420, -447, 1524, 743)],
          s[r(0, 0, 2213, 0, "r4s(")]
        )
      )
        return (
          s[n(1944, 0, 0, "wJeC")](
            A_,
            s[a(2384, 1390, 2569, 1668, "vL@C")](
              s[h(-680, 930, "AF$5", 105)](
                s[l("u)I4", 1172, 132, 243, 377)](
                  s[h(1701, 1773, "]QDq", 1557)],
                  K_
                ),
                s[l("iTSE", 875, 2615, 782, 1805)]
              ),
              Z_
            ),
            s[n(2994, 0, 0, "#Bat")]
          ),
          !1
        );
      _0x3a7227[_0x2be0a4[l("DA8@", 1790, 988, 1194, 1129) + "t"]][
        h(2079, 1644, "Z5Ed", 1315) + "d"
      ] = !0;
    }
    i[r(0, 0, 2240, 0, "hzbI") + r(0, 0, 1860, 0, "ptBd")] = t;
    const o = {};
    function a(t, e, i, n, r) {
      return Cy(e - -452, r);
    }
    function l(t, e, i, n, r) {
      return Cy(r - -96, t);
    }
    function h(t, e, i, n, r) {
      return Cy(n - -348, i);
    }
    return (
      (o[l("ne@e", 1407, -337, 801, 824) + "ic"] =
        e[a(1530, 985, 319, 1701, "hbl9") + "ic"]),
      (o[l("xk4v", 1490, -8, 1098, 1210)] =
        e[l("AF$5", 596, 2243, 2587, 1420)]),
      (M_[t] = {
        mapType: null,
        prevMaptype: null,
        labelCode: null,
        isCustomMaptype: !1,
        layers: o,
        key: e[l("hzbI", 0, 0, 0, 1920)],
        failed: !1,
        logo: s[h(1009, 2824, "hbl9", 2079)](N_),
        poiListener:
          e[
            a(0, 2159, 0, 0, "wJeC") +
              h(73, 1084, "ptBd", 259) +
              a(0, 1351, 0, 0, "y(aR") +
              h(796, 1201, "iTSE", 2059)
          ],
        trafficListener:
          e[
            l("]QDq", 0, 0, 0, 1734) +
              h(2245, 1700, "2XNM", 1070) +
              r(0, 0, 1503, 0, "naYB") +
              n(1648, 0, 0, "Z5Ed") +
              "ed"
          ],
        maptypeListener:
          e[
            h(-13, 1435, "naYB", 615) +
              a(0, 780, 0, 0, "vL@C") +
              n(2273, 0, 0, "iTSE") +
              "ed"
          ],
        isTrafficQuotaSent: !1,
      }),
      delete e[h(0, 0, "5U(6", 937)],
      e
    );
  }
  function G_(t) {
    function e(t, e, i, n, r) {
      return Cy(e - 814, i);
    }
    return t[e(0, 1985, "l9RD")]("")
      [((i = 2364), (n = "[VZg"), Cy(i - -523, n) + "se")]()
      [e(0, 3112, "hbl9")]("");
    var i, n;
  }
  function B_(t, e, i, n, r) {
    const s = {};
    function o(t, e, i, n, r) {
      return Cy(e - -18, t);
    }
    function a(t, e, i, n, r) {
      return Cy(t - 586, e);
    }
    function l(t, e, i, n, r) {
      return Cy(n - -651, t);
    }
    function h(t, e, i, n, r) {
      return Cy(r - -204, n);
    }
    (s[o("x7um", 432)] = l("bKzs", 81, 1547, 457)),
      (s[l("Dh8h", 2215, 1428, 1525)] =
        h(3182, 3061, 3430, "FTF#", 2296) + a(3030, "^$I&")),
      (s[l("y(aR", 1848, 1e3, 626)] = function (t, e) {
        return t + e;
      }),
      (s[l("ne@e", 1174, -327, 164)] = function (t, e) {
        return t < e;
      }),
      (s[_(1987, 2499, 1916, "Dh8h", 2958)] = function (t, e) {
        return t !== e;
      }),
      (s[_(1708, 1563, 2421, "Z5Ed", 1603)] = _(
        2234,
        2925,
        2850,
        "Z5Ed",
        2225
      )),
      (s[o("HpoK", 1041)] = a(3262, "hzbI")),
      (s[o("2XNM", 2392)] = function (t, e) {
        return t > e;
      }),
      (s[h(1716, 2483, 1131, "r4s(", 1494)] = function (t, e) {
        return t * e;
      }),
      (s[o("a#*#", 898)] = function (t, e) {
        return t + e;
      }),
      (s[o("x7um", 2062)] = a(1557, "^C2X"));
    const c = s;
    let u,
      d,
      g,
      f,
      p,
      m = "";
    function _(t, e, i, n, r) {
      return Cy(r - 901, n);
    }
    for (
      d = [],
        u = [e, i, t, n],
        r = c[l("V@QO", 0, 0, 1503)]("", r)[o("iTSE", 1937)](""),
        f = 2,
        g = 2,
        p = 0;
      c[a(2368, "^hAz")](p, 4);
      ++g, ++p
    )
      if (
        c[o("[VZg", 374)](c[l("bKzs", 0, 0, 1694)], c[_(0, 0, 0, "g(zI", 1442)])
      )
        c[o("^hAz", 807)](g, 3) && (g = 0),
          (d[p] = c[l("waXB", 0, 0, 2132)](u[g], r[g])),
          (m += c[h(0, 0, 0, "5U(6", 2036)]("", d[p])[
            h(0, 0, 0, "]QDq", 996) + "h"
          ]);
      else {
        const t = new _0x1e01e7({
          zIndex: -9998,
          source: new _0x44724c(_0x41fe47),
        });
        _0x6a70d2[
          h(0, 0, 0, "FAP3", 2445) + l("y(aR", 0, 0, 1836) + l("6sU^", 0, 0, 16)
        ](t[_(0, 0, 0, "a#*#", 3153) + "s_"], c[a(1841, "^C2X")], {
          value: c[o("ne@e", 1206)],
          writable: !1,
        }),
          this[l("RvbZ", 0, 0, 2005) + h(0, 0, 0, "RvbZ", 805)](t);
      }
    return (
      (m += 2),
      d[h(0, 0, 0, "FAP3", 2416) + "ft"](m),
      c[h(0, 0, 0, "6sU^", 1329)](
        c[_(0, 0, 0, "^hAz", 2651)],
        d[h(0, 0, 0, "%2K1", 1756)]("")
      )
    );
  }
  function j_(t) {
    const e = {
      HZWKv: function (t, e) {
        return t(e);
      },
      XkLoK: function (t, e) {
        return t !== e;
      },
      trLiq: i(436, -327, 472, "5[3$", 421),
    };
    function i(t, e, i, n, r) {
      return Cy(r - -607, n);
    }
    let n,
      r = {};
    for (n in t)
      if (
        e[i(0, 0, 0, "2XNM", 594)](
          e[((u = "g(zI"), (d = 2398), Cy(d - 924, u))],
          e[((h = "WJFM"), (c = 2252), Cy(c - 697, h))]
        )
      ) {
        const t = {};
        (t[((a = "qP[S"), (l = -214), Cy(l - -877, a) + "d")] = !0),
          e[i(0, 0, 0, "iTSE", 1674)](_0x3e942c, t);
      } else
        t[
          i(0, 0, 0, "iTSE", 732) +
            ((s = 3310), (o = "hzbI"), Cy(s - 872, o)) +
            i(0, 0, 0, "a#*#", 1212)
        ](n) && (r[n] = t[n]);
    var s, o, a, l, h, c, u, d;
    return r;
  }
  function z_(t) {
    function e(t, e, i, n, r) {
      return Cy(r - -813, n);
    }
    const i = {
      fcSlX: u(3594, "qDUP", 2358) + "nd",
      tknZJ: function (t, e, i) {
        return t(e, i);
      },
      WpnLl: function (t, e) {
        return t(e);
      },
      BCrZZ: function (t, e) {
        return t !== e;
      },
      SnyKa: n(393, "3%NO", 503, 1783, 1097),
      LPZly: function (t, e) {
        return t <= e;
      },
      lrBNP: function (t, e) {
        return t === e;
      },
      Rywvr: d(1906, 1886, 1162, "qDUP"),
      eLBzI: e(0, 0, 0, "3%NO", 908),
      VlxCq: n(1385, "DA8@", 530, 725, 505),
      RtOXL: function (t, e, i) {
        return t(e, i);
      },
      rAVgN: function (t, e) {
        return t <= e;
      },
      lVhwL: n(1688, "^hAz", 1786, 1373, 1460),
      RmvwY: u(3725, "RvbZ", 2838),
    };
    function n(t, e, i, n, r) {
      return Cy(r - -163, e);
    }
    let r, s, o, a, l, h, c;
    if (((r = []), (s = /{([a-z])-([a-z])}/[e(0, 0, 0, "a#*#", 688)](t)), s)) {
      if (
        !i[n(0, "3%NO", 0, 0, 1529)](
          i[n(0, "G)uk", 0, 0, 1915)],
          i[u(2928, "^C2X", 2467)]
        )
      ) {
        for (
          o = s[1][n(0, "V@QO", 0, 0, 2680) + e(0, 0, 0, "FTF#", 924)](0),
            a = s[2][e(0, 0, 0, "ptBd", 1280) + n(0, "u)I4", 0, 0, 982)](0),
            l = o;
          i[d(414, -110, 514, "2XNM")](l, a);
          ++l
        )
          i[g("qP[S", -774, 288)](
            i[g("g(zI", 1826, 1332)],
            i[d(242, 766, 862, "dehg")]
          )
            ? i[n(0, "naYB", 0, 0, 848)](_0x13acad, _0x4c52af, _0x51a5db)
            : r[g("3%NO", 564, 1283)](
                t[g("FAP3", -276, 207) + "ce"](
                  s[0],
                  String[
                    u(2703, "x7um", 3663) + n(0, "V@QO", 0, 0, 1441) + "de"
                  ](l)
                )
              );
        return r;
      }
      this.un(
        i[u(3703, "Dh8h", 2524)],
        this[u(2517, "iTSE", 3281) + d(1810, 2224, 1257, "hbl9")]
      ),
        (this[g("RvbZ", 2762, 1720) + e(0, 0, 0, "HpoK", -348)] = null);
    }
    function u(t, e, i, n, r) {
      return Cy(i - 797, e);
    }
    if (((s = /{(\d+)-(\d+)}/[u(4698, "AF$5", 3502)](t)), s)) {
      if (
        i[d(2724, 3502, 3365, "#Bat")](
          i[d(1395, 2043, 1620, "5U(6")],
          i[g("#Bat", 912, -160)]
        )
      ) {
        for (
          h = i[e(0, 0, 0, "AF$5", 1324)](parseInt, s[2], 10),
            c = i[n(0, "naYB", 0, 0, 848)](parseInt, s[1], 10);
          i[d(1335, 1876, 2500, "j9*&")](c, h);
          ++c
        )
          if (
            i[u(0, ")M@t", 2602)](
              i[e(0, 0, 0, "V@QO", 1707)],
              i[n(0, "g(zI", 0, 0, 288)]
            )
          )
            r[n(0, "5[3$", 0, 0, 860)](
              t[u(0, "6sU^", 3066) + "ce"](
                s[0],
                c[d(1131, 1221, 2112, "V@QO") + u(0, "bKzs", 2595)]()
              )
            );
          else {
            const t = {};
            (t[g("naYB", 1253, 20) + "d"] = !1),
              i[g("hzbI", 915, 405)](_0x5b8d84, t);
          }
        return r;
      }
      _0x578ab3[u(0, "iTSE", 3677)](
        _0x2db6b1[n(0, "5[3$", 0, 0, 2009) + "ce"](
          _0x5497a9[0],
          _0x1f20b9[d(1257, 2326, 803, "[VZg") + g("qDUP", 3057, 1903) + "de"](
            _0x59e551
          )
        )
      );
    }
    function d(t, e, i, n, r) {
      return Cy(t - -109, n);
    }
    function g(t, e, i, n, r) {
      return Cy(i - -834, t);
    }
    return r[u(0, "g(zI", 1913)](t), r;
  }
  function U_(t, e) {
    function i(t, e, i, n, r) {
      return Cy(n - -695, r);
    }
    function n(t, e, i, n, r) {
      return Cy(n - -247, r);
    }
    const r = {
      KPJys: function (t, e, i) {
        return t(e, i);
      },
      Afpyj: function (t, e) {
        return t <= e;
      },
      XPAKK: function (t, e) {
        return t === e;
      },
      DZejF: c(1197, 199, 1695, "ne@e"),
      vMKrW: c(1624, 635, 2157, "RvbZ"),
      FetyZ: n(0, 0, 0, 2556, "xk4v") + "el",
      JksDw: n(0, 0, 0, 653, "%2K1"),
      KCfRX: u(3125, "iTSE"),
      GoLIx: function (t, e) {
        return t + e;
      },
      mFtjO: i(0, 0, 0, 1097, "naYB") + "c.",
      xaDvL: function (t, e) {
        return t > e;
      },
      bQCRW: function (t, e) {
        return t !== e;
      },
      iPHGO: u(1118, "wJeC"),
      JKVjt: c(1907, 3089, 1738, "FAP3"),
      vzmHN: c(1325, 1586, 1029, "hzbI") + "t",
      QnghR: function (t, e) {
        return t < e;
      },
      RzwrS: function (t, e) {
        return t === e;
      },
      GCyZx: c(1901, 2418, 2959, "Dh8h"),
      gsFIh: function (t, e) {
        return t === e;
      },
      TGFiz: function (t, e) {
        return t + e;
      },
      YddXA: function (t, e) {
        return t !== e;
      },
      EVSUP: d(1560, "]QDq"),
      tXvuD: d(449, "5U(6"),
      vKlIJ: u(1989, "a#*#"),
      IewHW: function (t, e, i) {
        return t(e, i);
      },
      qlEqe: i(0, 0, 0, 811, "Dh8h"),
      MTcpQ: n(0, 0, 0, 1354, "6sU^"),
      UJoSg: c(3304, 3544, 2979, "naYB"),
    };
    let s, o, a, l, h;
    function c(t, e, i, n, r) {
      return Cy(t - 681, n);
    }
    if (t && r[c(1599, 0, 0, "^$I&")](t[d(-157, "G)uk") + "h"], 0))
      if (r[i(0, 0, 0, 304, "FTF#")](r[u(1872, "5[Ds")], r[d(1743, "u)I4")]))
        for (
          s = t[0][
            n(0, 0, 0, 1928, "6sU^") +
              d(560, "bKzs") +
              n(0, 0, 0, 1499, "HpoK") +
              n(0, 0, 0, 1115, "#Bat")
          ](r[d(375, "naYB")]),
            a = 0,
            l = s[n(0, 0, 0, 953, "]QDq") + "h"];
          r[c(3446, 0, 0, "Z5Ed")](a, l) && !o;
          ++a
        ) {
          if (
            !r[i(0, 0, 0, 1397, "FTF#")](r[d(493, "5[Ds")], r[d(1671, ")M@t")])
          ) {
            for (
              _0x514921 = r[c(2703, 0, 0, "[VZg")](_0x41c939, _0x3c2181[2], 10),
                _0x3ddd6c = r[u(3368, "iTSE")](_0x4a7cf2, _0x56df89[1], 10);
              r[d(1575, "DA8@")](_0x3930d9, _0x357b45);
              ++_0x3f1a62
            )
              _0x20b9de[i(0, 0, 0, 1422, "3%NO")](
                _0x50fad0[u(3172, "^$I&") + "ce"](
                  _0x2c2bb5[0],
                  _0x2f4ba2[c(1208, 0, 0, "Z5Ed") + i(0, 0, 0, 962, "y(aR")]()
                )
              );
            return _0x4bb095;
          }
          (h = s[a][u(1303, "x7um") + u(3300, "y(aR") + "te"](
            r[d(1881, "hbl9")]
          )),
            h &&
              r[i(0, 0, 0, 2006, "5U(6")](
                h[u(2956, "DA8@") + "Of"](
                  r[c(3254, 0, 0, "^C2X")](r[d(913, "xk4v")], Z_)
                ),
                8
              ) &&
              (r[u(2664, "FAP3")](r[d(733, "vL@C")], r[n(0, 0, 0, 963, "RvbZ")])
                ? _0x2338fc[c(2988, 0, 0, "l9RD")][
                    i(0, 0, 0, 9, "ne@e") + n(0, 0, 0, 1725, "%2K1")
                  ]([0, 0])
                : (o = s[a][
                    c(3017, 0, 0, "%2K1") + i(0, 0, 0, -247, "qP[S") + "te"
                  ](r[d(-3, "%2K1")])[d(1023, "vL@C")](/callback=([^&]*)/)));
        }
      else _0xb4dc27 = _0x4ac015;
    function u(t, e, i, n, r) {
      return Cy(t - 634, e);
    }
    function d(t, e, i, n, r) {
      return Cy(t - -936, e);
    }
    if (o) {
      if (
        r[c(1892, 0, 0, "AF$5")](r[u(1745, "HpoK")], r[c(3244, 0, 0, "hbl9")])
      )
        o[1] &&
          window[o[1]] &&
          r[i(0, 0, 0, 1898, "3%NO")](
            setTimeout,
            function () {
              function t(t, e, i, r, s) {
                return n(0, 0, 0, r - 708, i);
              }
              function e(t, e, n, r, s) {
                return i(0, 0, 0, n - 776, t);
              }
              var s, a, l, h;
              r[e("WJFM", 0, 1505)](
                r[e("ptBd", 0, 448)],
                r[((l = 2417), (h = "wJeC"), n(0, 0, 0, l - 1162, h))]
              )
                ? ((_0xba3fcb[
                    ((s = 2371), (a = "5[Ds"), c(s - -982, 0, 0, a))
                  ] = _0x51b187),
                  (_0x594241[t(0, 0, "#Bat", 983) + "pe"] = _0x356fa4),
                  (_0x5301a4[
                    t(0, 0, "^hAz", 1940) +
                      e("dehg", 0, 439) +
                      t(0, 0, "hzbI", 1183)
                  ] = !0))
                : window[o[1]]();
            },
            10
          );
      else if (
        ((_0x4e6eea[d(654, "%2K1") + u(1610, "g(zI")] = _0x2060c6),
        this[c(3437, 0, 0, "#Bat") + n(0, 0, 0, 2047, "FTF#") + "r"](
          this[n(0, 0, 0, 1997, "xk4v") + n(0, 0, 0, 1663, "dehg")](
            r[d(1732, "u)I4")]
          )
        ),
        _0x41a444)
      ) {
        this[
          d(1733, "y(aR") + i(0, 0, 0, 1949, "j9*&") + c(2623, 0, 0, "qDUP")
        ](
          _0x70c371,
          _0x9ccc3d[u(1211, "AF$5") + n(0, 0, 0, 2580, "j9*&")],
          _0x255f6b
        );
        const t = new _0x169fab({
          zIndex: -9997,
          useInterimTilesOnError: !1,
          source: new _0x13ad99(_0x3b76d3),
        });
        _0x12ea1b[
          i(0, 0, 0, -276, "qP[S") +
            i(0, 0, 0, -336, "FAP3") +
            i(0, 0, 0, 1739, "WJFM")
        ](t[u(1560, "^C2X") + "s_"], r[c(2352, 0, 0, "HpoK")], {
          value: r[d(911, "ptBd")],
          writable: !1,
        }),
          this[n(0, 0, 0, 2553, "y(aR") + d(833, "2XNM")](t);
      }
    } else
      !e &&
        (r[n(0, 0, 0, 347, "^C2X")](
          r[n(0, 0, 0, 1375, "%2K1")],
          r[n(0, 0, 0, 666, "y(aR")]
        )
          ? r[i(0, 0, 0, 284, "2XNM")](
              U_,
              document[
                i(0, 0, 0, 1146, "r4s(") +
                  u(1731, "hbl9") +
                  i(0, 0, 0, 164, "FTF#") +
                  u(1996, "#Bat")
              ](r[c(1697, 0, 0, "Dh8h")]),
              !0
            )
          : ((_0x4f8bf6 = _0x139b87[_0x10a382][
              n(0, 0, 0, 593, "FTF#") + c(2329, 0, 0, ")M@t") + "te"
            ](r[n(0, 0, 0, 314, "vL@C")])),
            _0x2ff157 &&
              (_0xb65e41 ||
                r[i(0, 0, 0, 882, "ptBd")](
                  _0x1bcf6e[u(2449, "^$I&") + "Of"](
                    r[u(3516, "bKzs")](r[i(0, 0, 0, 1529, "x7um")], _0x37f107)
                  ),
                  8
                )) &&
              (_0x4b542f = _0x2b7b8a[_0x30391d][
                d(72, "^C2X") + i(0, 0, 0, 2165, "FTF#") + "te"
              ](r[i(0, 0, 0, 1694, "r4s(")])[n(0, 0, 0, 103, "wJeC")](
                /callback=([^&]*)/
              ))));
  }
  const q_ = parseInt(O_([50, 53, 49, 56])),
    V_ = [
      my(2008, "Z5Ed", 2936) + "y",
      uy(2597, 1602, 1641, 2692, "hzbI") + my(1155, "ptBd", 1448) + "d",
      my(2007, "5[Ds", 3092) + "n",
      my(1543, "xk4v", 1245) + uy(1416, 2706, 2140, 1311, "^hAz") + "ay",
      Wy("Z5Ed", 716) +
        ny(1732, 548, 1239, 670, "^hAz") +
        uy(-251, 1744, 914, 749, ")M@t"),
      ny(2102, 1029, 901, 1089, ")M@t") + ny(-598, 536, 1027, 1098, "FTF#"),
    ];
  let X_ =
    O_([38, 99, 111, 112, 121, 59]) +
    O_(
      window[my(2937, "qP[S", 2266)]
        ? [79, 112, 101, 110, 83, 116, 114, 101, 101, 116, 77, 97, 112]
        : [79, 83, 77]
    ) +
    " " +
    O_([67, 111, 110, 116, 114, 105, 98, 117, 116, 111, 114, 115]);
  const Z_ = G_("gr" + Wy("auw)", 1781) + ny(2384, 1108, 1033, 1636, "Pbla")),
    K_ = G_("//:" + my(3813, "FAP3", 2678)),
    H_ = k_(
      my(2409, "auw)", 1963) +
        uy(1317, 1532, 255, 1487, "x7um") +
        my(2896, "xk4v", 2397)
    ),
    Y_ =
      K_ +
      O_([
        111, 112, 101, 110, 115, 116, 114, 101, 101, 116, 109, 97, 112, 46, 111,
        114, 103,
      ]),
    Q_ =
      K_ +
      G_(uy(649, -948, 44, -554, "[VZg") + "ts") +
      Z_ +
      "/" +
      O_([115, 100, 107, 47, 105, 109, 97, 103, 101, 115]) +
      "/",
    $_ = K_ + O_([116, 105, 108, 101, 123, 53, 45, 56, 125]) + "." + Z_ + "/",
    J_ = K_ + O_([116, 114, 116, 115, 123, 49, 45, 52, 125]) + "." + Z_ + "/",
    ty = K_ + O_([116, 105, 108, 101, 123, 49, 45, 52, 125]) + "." + Z_ + "/",
    ey = {};
  function iy() {
    const t = [
      "qmkpW4DYxG",
      "WQ7cQ8kKyWe",
      "WRdcI1VdU8oq",
      "WP5sW6ddMCoi",
      "WOFcRSkzmc8",
      "A8ooW5ddO1y",
      "awP3WO4K",
      "WQ/cRmkgFW",
      "W4RdOCojkmkY",
      "WQSiWPNcLcO",
      "FSkmW4ddU1G",
      "mmk6kmk5WOK",
      "t0v0W6ZcLG",
      "W55/W6NdSmom",
      "W4bsBSoBya",
      "BGvpiCoH",
      "ihZcMdpcSa",
      "lCoRW5ddHSk3",
      "vCkhW70",
      "WQi1mSkotW",
      "WQmwnSoGWPi",
      "z8kNWObTFW",
      "W4xdN8oIfSkZ",
      "y0tcUrZdSa",
      "W6DsESoYvq",
      "p3RcQSo7WR0",
      "W5jAW73dVCoE",
      "WQdcImox",
      "jSk/W4mkBq",
      "W5C0W50",
      "W7zZD8oZDq",
      "aSkEnSk6WPO",
      "u11pW7NcGG",
      "WPBcPCkmmsG",
      "W7nDW5xdR8of",
      "WQ3cN8kgosq",
      "FSoTW4pdTvi",
      "W4HXWOJdSKW",
      "gCk7W6eGxW",
      "uCkrW7GnuG",
      "aSoOW7BdMCkt",
      "k3RcR8oiWPq",
      "emkZgmk/WR4",
      "dCk+W6GPBa",
      "r09aW7tcSq",
      "W4y4W4ZdRa",
      "W7ddQCoaWPCq",
      "vSohW77dOdK",
      "W7ldH8onWOHn",
      "WQRcPSkwo0i",
      "tCoUW5iYWOu",
      "i1JdNmofWRK",
      "WQ3dGHiMWRW",
      "uCo9W5u0WPW",
      "mmkLWPZdLGm",
      "n8koW5issq",
      "CSoEdq",
      "geBcMaFcTa",
      "wCowW6pdQq",
      "xvHNW6NcLq",
      "WRBcSmovWPHu",
      "BmoIa8o+WP8",
      "pf3cSrZdRq",
      "WQhdRda1WPi",
      "W4TsBSoBya",
      "WPeOhSoqWRO",
      "rmkfWPHQrq",
      "WP7cPCkepZi",
      "WPxcKSoBWPCh",
      "WQWOjCoYWO8",
      "jmkTpW",
      "nh7cVa",
      "WR4ZACoigW",
      "m8keW4mQyq",
      "jCksm8khWR4",
      "WR4zjmovWQK",
      "DLxcRd7dPq",
      "W5ldVSosWQHA",
      "WP/dHqu+WQe",
      "WRVdTCoqfIa",
      "zhFcSWldNa",
      "Ea1EdSoH",
      "W5y4W4RdL0a",
      "k8kjcSk7WQa",
      "vH0MrG",
      "umoeW4JdHsG",
      "tM/cRaddPq",
      "WQtcJSosWP8d",
      "cmkLWO5IW4JdQCksWRZcLhFcIrlcHq",
      "tKjLWPG",
      "oNTXwxm",
      "lSk6lG",
      "tsRcRSkPWO0",
      "WONdKHi2WOK",
      "hCk9gYbO",
      "rmosWQ7dUIK",
      "WRxdMSkCWP5h",
      "WQXRBcmv",
      "E3JdJb3cPW",
      "nhFcHCoDWQa",
      "W4OuW6hdNua",
      "wN0gWQiM",
      "WPldNIKoWQ0",
      "WRFcGSokWQLb",
      "WPFcJmklism",
      "t2z0WPKV",
      "uL9YWOG",
      "CmomW4KbWOq",
      "FmkOkbddPW",
      "omkAWOpdKb4",
      "trKW",
      "FeHaW4FcQG",
      "W43dNmoG",
      "WQb2uW",
      "W6nnW7TGxW",
      "mmoUwIJdQa",
      "aCk8WO/dGJG",
      "W6RcVCkRW7ddJW",
      "W6FdTqG7cG",
      "WO0CmSoUWPm",
      "W63cT8k2",
      "W5DAW7/dQSoi",
      "WQhcN8onWP1x",
      "WQ7cP8k7qHG",
      "FhXHW6BcTq",
      "DLxcRdpdSa",
      "wSk1dIBdPW",
      "W5ldOmordmkq",
      "WRn2st8",
      "sCovW6/dJ08",
      "s2VcVSoHW54",
      "W4qWW4FdRXO",
      "WRZcHSoCWP9c",
      "W4mLW5ddT0q",
      "uMv6zKC",
      "oCkRz8ovWOS",
      "x8o4WPNcLs0",
      "W4K4pmkema",
      "xCoVW4OKWOm",
      "BSoAW7ldKa8",
      "WPKummo5WPW",
      "sbjx",
      "WOhcTmktncm",
      "xu5LWQZcSq",
      "mmkCW4msAW",
      "DCouW4hdSI8",
      "W45MW65JwW",
      "xCo5W5BdUtW",
      "W5bvW74",
      "W618W6HLFq",
      "W48yCCk7",
      "bwBcSSklW6K",
      "WQpcT8ozjK0",
      "BCo/pSkuWPS",
      "ch/cGG/cLa",
      "uh5zWOVdRq",
      "WP9RW6hdJmog",
      "lSkHWORdIbi",
      "WQzNuJK9",
      "WR3cImoeW5Dm",
      "gcxdOmkKWO0",
      "WOZcNWVcSmkQ",
      "uhWsWR4S",
      "qeD2W6dcGq",
      "q8kzdHldLG",
      "WQuVmSkmrG",
      "WOKlWOxcIsW",
      "WRD0tsin",
      "xKb2h8kT",
      "W4pdTSoFB3BcOmklWRrduItdO8kK",
      "beHPW7FdNG",
      "W6ZcQSkpDG8",
      "W496mCodEq",
      "dmkxW6pdRti",
      "WQxcOSkmyGW",
      "vCoZW5W/",
      "W6LGW6m",
      "WOJcISoUWQ5b",
      "W4VdGmo/g8kK",
      "FtNdJ0ddOa",
      "ttJdVSkGWPe",
      "wejcWOldSq",
      "a8k5gJfT",
      "sgpcLGVdLq",
      "wmo4W58CWPe",
      "nCkXW4WPyG",
      "WQhcSCkxWQq",
      "FSkOWOzKvq",
      "W4v3W70",
      "gr/dVmkGWPK",
      "WQxdQ8omjde",
      "WOlcR8kdfc8",
      "j8kFW4jCka",
      "W5i9W4JdTuO",
      "Fmk2da3dTa",
      "W5PrW4T+zW",
      "z8o1WP3dIXK",
      "l3JcIbRcOG",
      "WORdPmotW7qe",
      "hx3dOq",
      "WRTxnmk3zW",
      "WPVcI8opWQG4",
      "WO3dIaGRW4S",
      "W5lcSSkpktm",
      "zhzGANS",
      "W6mBzG",
      "hCkzhCkCWP4",
      "bConW4ddPdOhoW",
      "WQJcRCkwqWW",
      "W4X9W6y",
      "DmodfmoGWOy",
      "amkeW44d",
      "W6ZdISobkCkI",
      "W4lcJSkFWQrw",
      "W4pdL8o/p8kM",
      "qSoLW7/dPCkD",
      "WOGEl8o3WP4",
      "WOCdh8oyWRO",
      "c8oEW6pdQ2a",
      "ymojW5m8WPi",
      "yxjqW5BcJq",
      "p8kdhSkMWQ8",
      "WP85oCoVWOK",
      "nh7cVmoeWR4",
      "WP8AW6tdHmox",
      "rsCkW6KO",
      "tK9YW4pcKG",
      "E3HvW6FcGa",
      "WQXwFmkZEG",
      "WOxcSmkd",
      "WOCYW6jSvW",
      "W4SFmSo4WO8",
      "CNTsW5FcQW",
      "zSo7frhcPG",
      "fY1MWOSS",
      "W50WW5NdR1G",
      "WPBcPCkz",
      "brVdP8k5WPO",
      "n8oqWOOwAq",
      "WRiJoSkgtG",
      "aCkDlSkfWRG",
      "k8k2kanW",
      "n8kEW4CCra",
      "WQJcQ8kvzqC",
      "i8kTnCkxWP0",
      "xmoqW5OYWPu",
      "hstdQCkU",
      "FXnwfmoc",
      "W5H1W6ZdHmoc",
      "WP7dOSo3bq0",
      "nwNcP8oZWPi",
      "WQlcRCkr",
      "p8k6pCkr",
      "WOxdKrmXWPe",
      "DNDWFhu",
      "FKlcRbpdQG",
      "AmoEfCoZWOS",
      "C8ond8oMW54",
      "imkeW44d",
      "omkVoCkhWPW",
      "zulcUrtdOG",
      "umkAW7G",
      "hMBdSCohWR4",
      "astdP8knWPy",
      "W5ZdKdeQ",
      "ySoJeCoMWOW",
      "BKvkW4BcIW",
      "dMrXWO4",
      "q33cTZxdIq",
      "tmkyWPaOvq",
      "uhXmW7TK",
      "uba1tCoR",
      "rmoFW4/dQYO",
      "WPebpSk/zG",
      "t09+WPBdQG",
      "W5HEW7NdRmol",
      "WO3dP8kGubG",
      "FsOUsCoP",
      "WOxcKmkgmty",
      "j8ojCGhdQW",
      "w8o7W6/dTsu",
      "BCoiW4FdOa",
      "WR/cI8on",
      "WPBcV8kDWRum",
      "tGeX",
      "bstdVSo7W58",
      "DmkIgrddGW",
      "W6bKW7NdImov",
      "C8ovdCo3W5G",
      "DSoaW5BdTf8",
      "cSkuoI5i",
      "jKbwcCo7",
      "WPVcO8kMmtu",
      "WP4aj8oLWOC",
      "kSkGdCkWWQS",
      "Dmoygmo+WOa",
      "t8kyWP4Lra",
      "g8k3frLG",
      "WPFcKmkynZy",
      "WQ92Dc4k",
      "EuX1W4tcMa",
      "zqVdUbddQW",
      "svTJWPdcSG",
      "khxcNW",
      "WQ84WOVcNJy",
      "W5pcO8o2era",
      "W6ddQmoUemkm",
      "WP/cSmkfkJi",
      "WQRcPSkwrXq",
      "dSk8hbHG",
      "emo4srpdHq",
      "jCkRpCkBWPW",
      "W5v/W79Ixq",
      "W7fZW78TwW",
      "vSonW4PRwa",
      "jepdOCobWR8",
      "kg3cG1xdTa",
      "x8oUW7pdNbC",
      "WOWJjCoZWQ0",
      "crP0WPRcPW",
      "sSksW4emoq",
      "WOKLp8kjrW",
      "WP7cOCktptq",
      "uSooWQ7dPtm",
      "o8kDn8ksWPG",
      "fdZdVSkUWO0",
      "Cmk5WPZdGXG",
      "D3X5WOZdJa",
      "WQdcImomWO5p",
      "W6pcLCkbW5tcPa",
      "tKz2AMW",
      "wdCOzmo9",
      "dhZdVmkqW7S",
      "sGvylCo8",
      "xCoZW4XQW5a",
      "o3RcPSo6WR0",
      "W69svCkuEW",
      "q8owW6ddUhS",
      "WPJdRmoPbaK",
      "xmoQW4SgWRu",
      "C8k6fq7dOW",
      "q8kTW7VdUmkc",
      "t8o5etLX",
      "dLtcQW",
      "rxBcIbFdLG",
      "WO7dIGmXWPi",
      "fmorEIZdLq",
      "cSk0etPK",
      "W459W65asa",
      "f8kSvtbK",
      "agxdNmoCWPi",
      "DSoeW5hcUXC",
      "u8osW7JdQsW",
      "v8o9W5y1",
      "wKnPWPFdQG",
      "W6H4C8orwG",
      "WOWukCoaWOm",
      "W4NdSsSUha",
      "W6GsC8k3za",
      "Fmo0W4xdVNK",
      "gCo8xY7dKG",
      "twaFWRKH",
      "jZncWQuj",
      "WR7cR8onWOXM",
      "W6pdRGWgdW",
      "WQpcO8otWPml",
      "bCkmW70BhW",
      "WPZcR8kEEdu",
      "WO/cUmotWPTE",
      "CqvDfa",
      "sKnVWQW",
      "tSodiSoMWRm",
      "WRxdPColWPyp",
      "qmk8W70ecG",
      "pNZcNG",
      "WPhcSCkgWRnu",
      "qXK3fCk7",
      "j0alqmk0",
      "WOhcL8kUDq0",
      "BSolcCoM",
      "suypWQSX",
      "F8kkgrtdSa",
      "FmkHW7OAdq",
      "uSkdWOTRuW",
      "W5P0W73dNCoo",
      "gvT8WPmT",
      "WQ7cRmksFXi",
      "W7GfFmk8FW",
      "WO7dLriM",
      "pg/cI8oMWOy",
      "htvfWQG5",
      "W68yCCk7",
      "zxDfWQlcNa",
      "BvqMWR4g",
      "tKr2",
      "ghSBWQS7",
      "dCk7W6eVtW",
      "W6HbuSogrW",
      "ldDFWRas",
      "u8oLW7q2WPi",
      "xCoFW5m5WPW",
      "WRvNrIuS",
      "WQuZkSketa",
      "o8kWo8kA",
      "x0pcSa",
      "WQNcI8oBW4Cm",
      "W4ddSSotWPvE",
      "WQf9C8kgrG",
      "WRevk8knBG",
      "EelcVrBcQG",
      "WOybmSoKWP4",
      "wL5JW6hcLG",
      "WQxdQImgWQ8",
      "vSoYW4G",
      "W7JdSmksFKa",
      "FhzT",
      "vCkfWOTJuq",
      "WPX9W70Tqa",
      "ymojfCohWPC",
      "n23cLqxcSa",
      "tSo9W4ZdGwy",
      "z8oBW57dUtu",
      "W4TKiCkw",
      "xmotW4ddTMq",
      "e8o0WRlcTmkB",
      "dbyQxmo4",
      "ucldO8kXWPa",
      "WOldHcO2WPu",
      "c8opuahdLW",
      "fI7dUSkxWPy",
      "WOVcU8kxW68",
      "eaDdWRaj",
      "WROPjCogWQW",
      "umk5jqFdKq",
      "hMrGWPKR",
      "WP7cKSk5sSk6",
      "sfvUWO/cPW",
      "W49uW6tdPCoo",
      "WQhcJmkcWRD6",
      "W7FcUSkKW7S",
      "W4tdHdabfG",
      "cSkQdc0",
      "W43dKCkMfmkV",
      "WO8XhSksFa",
      "W7ZdSSoKW7ZcGG",
      "pSkXnW",
      "gCkKW6yGtq",
      "kbzsWRif",
      "WQZcUSkhDdm",
      "r8oLW7tdMa8",
      "WPdcGvxdHSoD",
      "xM5CWPRdVG",
      "CSoifCoeWQq",
      "umkAW7Cn",
      "WO4PjCo7WOm",
      "uSkEhXVdRq",
      "yv1WW5ZcMa",
      "W5X2FCoAza",
      "dgRcHbtcRq",
      "W63cVCkWW7RcQG",
      "EgfGuxO",
      "WOyqlCocWPm",
      "a8k8nSk+WRC",
      "gcBdVSkUWO0",
      "WRpcTCkgkde",
      "WO7cJ8ktDHe",
      "W4H9W5X5xq",
      "netdKmo/WOG",
      "W7zMoSkfwq",
      "W4VdGdyoga",
      "FSopW5y",
      "oCkQgSkzWPO",
      "A2DDW6hcOa",
      "WPhdGSoZwSoR",
      "aJZdP8k1WPW",
      "aZvRWPyc",
      "W58HW4ZdQvi",
      "v8o9W5ldOsq",
      "WPZdSCo6fG4",
      "W6PKtI8S",
      "prfYWRyd",
      "WRRcRmkVudG",
      "WR3cHSooWQ5x",
      "E3j2vxG",
      "WP4dpSoZ",
      "d8krW6G2ya",
      "BujMu2y",
      "cmkakmkyWPG",
      "igVcPmo3WQu",
      "gvtcN8owWOm",
      "W51+W7SWdq",
      "mCk6WPtdIW",
      "q8ofW6/dQIy",
      "nfxcQCoZWRq",
      "zCodW5ldMJq",
      "W7LiW71Gsa",
      "wCoyW6ddRq",
      "WPHmuYOQ",
      "W6pcT8kXW4BcGa",
      "ymoIamo/WOa",
      "W7SsW4/dIxK",
      "cGPgWQW0",
      "W55cW6JdM8oI",
      "j3RcPSoQW6O",
      "c2r7WP8B",
      "oYPsWRet",
      "WQtdRSoDhaq",
      "W5PDW5JdGCo9",
      "W6dcLmkWW7VcJa",
      "amk8W5ddKde",
      "WPRcJCkfcqC",
      "xf43WR0M",
      "t8o1m8oeWQO",
      "bCojW70fhW",
      "F8kCfmoYW68",
      "ruTKW6RcNW",
      "r1TIWP7cUq",
      "dCo2sZpdNq",
      "WPBcTCkBWQvN",
      "twtdRCozWQ8",
      "WPhcR8kgnZq",
      "FNLDAei",
      "jSolWOSpzq",
      "WQZcSKNdPSoJ",
      "oYPAWR0v",
      "eCoVW6hdMmkb",
      "WPhcLeNdPmk3",
      "cSkUdtXu",
      "cmk9dbHG",
      "Dmk3fqpdTq",
      "W7WczSk2",
      "WO/dPSoViWC",
      "eaFdOmkxWOu",
      "eXRdJCktWQG",
      "dCo4WQNcTCku",
      "b13cMmo7WOm",
      "pc9AWQSd",
      "ySoeW5a",
      "qe1UW7VcVW",
      "r1vNWPq",
      "WQJcR8klAau",
      "WO/cV8khWQjF",
      "vMnC",
      "BqvycCoZ",
      "WRpcP8kBcsu",
      "WOZdSCo+equ",
      "W6JdK8oYh8k4",
      "nZj9xwq",
      "DSkDWRPrCW",
      "WOFcKSksWRHs",
      "zuT/W6RcGq",
      "l8kkW5nCka",
      "WPajWOVcNt4",
      "thVdPCoBWRq",
      "Abjybq",
      "Da5q",
      "xSo5W48dWP8",
      "WO0TWQJcRbW",
      "WQJcK8kqAra",
      "W6uerCkXyW",
      "g8oWwGVdNq",
      "W5HEW7NcLmkf",
      "WPBcHvtdVSo/",
      "xCoXW4ldUsC",
      "jYWjW79s",
      "cmkWdg4H",
      "iSkAkmkCWOa",
      "m8kHWPBdLG",
      "wSowW7BdLI8",
      "WOhdRCkHufG",
      "W6qwW4ldRw0",
      "kSkoW5K",
      "BComgmkZWRW",
      "W6RdH8oSWPvm",
      "WPquWOm",
      "AH8exmoE",
      "cSogW5VdTmkg",
      "buBdUSokWR0",
      "WORdRmo/cq",
      "rmkoWQDqyq",
      "imkhW4mdzG",
      "WPJdM8oMhCoQ",
      "ESk3oCkCWO8",
      "WQpcHmomWPnE",
      "WPBcLexdNCo7",
      "xSovW7JdTey",
      "W53cN8oSfCkM",
      "EetcSr3dQG",
      "W6K4xSkQrq",
      "bCkcoqXM",
      "vCkcWOD/EW",
      "W5pdL8oPeCkJ",
      "aSkilSkaWRS",
      "mLZcRSoeWRm",
      "DLvIExO",
      "WQZcV1VdTSou",
      "umosW7RdJYu",
      "WQuIj8kLsa",
      "uhuEWQ8y",
      "zbiHzSoV",
      "idz+WR4q",
      "qXGQrmoG",
      "W6OwFmkYBW",
      "rsT3iCoL",
      "oSoiW4/dP1G",
      "sKPWWPFcRa",
      "WOdcG0xdQq",
      "gSo7vGZdSa",
      "nh7cVmoFWQu",
      "uSoDW4pdNGe",
      "fs/dP8kVWPG",
      "WOVcUCkBWRu",
      "W711DCoaCW",
      "WR0DjCovWPS",
      "pSk8emkCWPS",
      "z3FcGXVcSa",
      "l8oHyqVdRW",
      "WRNcTSkpFcW",
      "ldn5wxO",
      "zSkYcei",
      "W5m+W5NdOLm",
      "EJVdJLxcPG",
      "ubO3sCoT",
      "vYS2W5X/",
      "WPhdVSkAWRix",
      "nh7cVmonWR4",
      "W57dQIemda",
      "WPhcISodWRCp",
      "WQjhtIC9",
      "BGvplCo0",
      "vrDnm8o+",
      "WOddNsKDWPe",
      "jSkKW5Osyq",
      "WP8um8oZWPG",
      "WP9nW6JdM8ot",
      "vCkyWODivG",
      "zI/cTmkTW6m",
      "WP/cSSoeWQLK",
      "AmoOW4ZdKK8",
      "WOmEWP7cTZK",
      "wSowW77dMdK",
      "W5DvW4TIwa",
      "vJldPCocWRu",
      "zSk+cchdOW",
      "WPZcUmk5ueC",
      "WPhcQSkkWQ1s",
      "kCk0WP3dKeW",
      "ltavW7ZcRG",
      "hMZcQ8oXWOu",
      "WPGEkmoKWOK",
      "x8oUW5BdJa",
      "z21RW6RcSG",
      "WQuZnSkgta",
      "WPyEWOFcLc4",
      "WRiImmkhwW",
      "W7pdUJiTea",
      "cmk9dajO",
      "DMBcVX7dOq",
      "WOBcR8okAgy",
      "WP8dpmoWWOW",
      "D1hcNtBdVa",
      "WQdcK8ohWOPl",
      "W4nNB8ohCq",
      "W5f3W6P0yG",
      "W54LWPlcU0W",
      "W7FcVCkWW6FcJa",
      "hCk9ftT3",
      "W5fiWPRcG3G",
      "xZ4KW5L8W4PxW4fWWRZcS8kVW5u",
      "WPdcQSksWQ9d",
      "W6VdVConf8kE",
      "x1LTWO3dRG",
      "DCk+WQ1qyW",
      "WOCqjmoZWPG",
      "WRZdQmoVnJi",
      "AtDklmos",
      "pfJcVrVdOW",
      "W4/dIIyN",
      "F8oBW4tdHcm",
      "EmooW4BdSG",
      "sCobc8oOWPu",
      "WRBcQCoaWPyf",
      "WQBdKGa7WQm",
      "xmo6W4VdLG",
      "sCkNWOvSEW",
      "WO3cKf/dTmo2",
      "kCkEa8k/WO0",
      "l8oDWPldQWy",
      "EJbCkmoZ",
      "DanAdmk4",
      "CGXueSkV",
      "C8oaW5ddLfG",
      "W74IW4e",
      "W4DHmCoADq",
      "pmk4WPRdIa4",
      "WOBdT8kGuau",
      "WOtcK8oIf8k6",
      "x8o0wdxdMW",
      "WPVdRmoUaGS",
      "W4qJW4JdVuC",
      "lSkEc8k3WRO",
      "WO/dGcaNgG",
      "W6NdHXSNlG",
      "W5/dPZSwga",
      "g8o1W4/dHti",
      "WQretXWW",
      "kxtcP8oZ",
      "ixBcNHBcSa",
      "jCknW4mf",
      "WOdcN2ddM8oy",
      "WRhcNSoBWOG",
      "WQxcU8kOW6xcGa",
      "jCo4WOddJby",
      "WR/cKmkeW5Pa",
      "jhBcNaZcPW",
      "hmo9vJdcHG",
      "y3vMWRRdQq",
      "WOBdT8kGuaS",
      "WROIpCkpxq",
      "W60hzCkYCW",
      "W4RdPmosd8kj",
      "W5lcO8o1hWy",
      "rmkBWOnRuG",
      "hmkAaqbG",
      "WPGfomo4WO8",
      "tNaCWO8h",
      "maddL8kYWRS",
      "qLrKWP7cRq",
      "nmkWmmkAWPO",
      "ubaWwmo2",
      "WR/cUSoDWPSo",
      "d8oTwcNdIa",
      "nSkfpCkcWRy",
      "W4ddSreshW",
      "nmkYerldQq",
      "WOhcImk9oGG",
      "WOhcHvNcQSk6",
      "W4qzW43dOKi",
      "o8oxtmkLWQC",
      "t0n+W7S",
      "W6zWW6jSzq",
      "W4XmW6tdNCoe",
      "WRFcQCoFWPDl",
      "cXfL",
      "emohWPP9",
      "u8kdWOTRqW",
      "FSomW4FdUum",
      "ksDeW63dOW",
      "FHjsemoH",
      "fY3dP8kI",
      "cfTNWOq4",
      "DetdPvddMW",
      "WOqBW6ddImoF",
      "WRVdQSkjWOKu",
      "CSkjctFdTq",
      "W5FcKSoIcCoQ",
      "WORcV8kDWQvB",
      "g03cG8ojWQC",
      "qSkeW5KRhG",
      "jJ9BWQS",
      "WR/dPSo4pqe",
      "qSoRW5ddGN0",
      "aNTWWPK8",
      "W43dIZz5wq",
      "qL5+vxW",
      "WRSMk8kYrG",
      "E3XZxW",
      "W4H7W6bJ",
      "ESkZm8ksWOC",
      "Fde0q2a",
      "hHOHWPlcUa",
      "WP4WjCk7qG",
      "xv5/WQNdRG",
      "WO0iWQNcJIS",
      "vSoKWPyJWPG",
      "W64aE8kgsq",
      "WOBcSCkeW7Sx",
      "bSk/ecbn",
      "DLm9WO4b",
      "mmk6kmk0WPW",
      "rbOXBCo4",
      "gMjHWOGG",
      "W4DLDmoa",
      "cM5H",
      "W6XnCCoqDW",
      "bCkZhHzP",
      "nCk6eHBdRW",
      "DN1GcZq",
      "a8k5cW5z",
      "WQxcQCotWOjK",
      "pSk6WOpdNqu",
      "WQesnSoeWRK",
      "ECk+qua",
      "WQVcOSklAGu",
      "WOO9m8oaWPa",
      "gmkih8k9WQG",
      "BSobeCo9WPC",
      "DN9AW7q",
      "jmkDjCkHWOK",
      "W77dKmo5p8kT",
      "WOhdPSo/xG",
      "zhXHqNC",
      "W4DLDmoaxa",
      "ACoCkmoCWPW",
      "WP/cQCkeaIK",
      "W4pdL8o/",
      "mSkPkCkDWR0",
      "W6hcNSkKW6ZcIG",
      "ugatWR96",
      "rtSIrCo8",
      "hJNdUSkGWPe",
      "Dg9mWRtdGG",
      "W71zW5z+AW",
      "vITLWOq7",
      "W5yJW4BdTMi",
      "kttcNbNcTa",
      "WOiuWOtcJ3u",
      "WQdcP8oaWRyj",
      "tgavWR4",
      "W6LkW4rdAa",
      "DaDtfa",
      "WOiqfmoyWRG",
      "W6r3i8kqcq",
      "W57dIJCShq",
      "qSkMW7ufcG",
      "rrWTeSk5",
      "rmk+WQDpqG",
      "W4ShomoKWP4",
      "xSo5W48",
      "W4TBtmoDyq",
      "lmkzW54hzG",
      "cM3cHCoKWOq",
      "jdjyWQud",
      "ChzGANS",
      "WRr2uW",
      "W6bKW7NdHmox",
      "WO8EpSoJWOC",
      "W493W7TmwW",
      "v8o5WPTXWPK",
      "WOOAWOFcNG",
      "W6ZcS8kRW7hcGW",
      "WOpdHHuqWPe",
      "c3pdOCohWR4",
      "lCk0WOhdLXi",
      "W4HJDCoyDq",
      "CSk+ca",
      "f8oyW6qqtW",
      "tK9Y",
      "D8ojW7KFWPq",
      "tbOTtCk5",
      "uSkFWOTR",
      "o8knaSkMW7u",
      "DmoiW5GGWQe",
      "W7OdFmkhFq",
      "WR/dJZurWOe",
      "WRxcKCkPWQX2",
      "B3PSW6FcUW",
      "fxpdJmoDWPC",
      "uddcQSklWQG",
      "yCkPhqtdOa",
      "oCo3yYpdNW",
      "dmkFWO9Sua",
      "eCo4qcldJG",
      "W4e8u8k/AW",
      "W5lcV8kRW5FcVG",
      "bYRdOSk0WPO",
      "D2eE",
      "vSkQW608dG",
      "W55TDq",
      "WOBdHH4fWOK",
      "eMVcGa",
      "FCooW5ddKLy",
      "WQ84WOZcQqa",
      "WQxcOSkrsrC",
      "lCknd8k5WQK",
      "vCkhW6yCdG",
      "W4vuW6ldHa",
      "CmomW44KWRm",
      "m2ZcNHdcLa",
      "W6DsACoauW",
      "tCoxW6tdTdO",
      "WQNcQmooWRHO",
      "mmoTW7FdHSkI",
      "ECovxSoMW77cJCoQF0biW7K",
      "t0TVW6pcLG",
      "W5JdGcWNcW",
      "DSoiW4ZcUL8",
      "WPJdLWO2WPi",
      "xSoVccWH",
      "WPSEna",
      "WOtcGuhdVmoJ",
      "rmodW6/dUdu",
      "W6FcNCk1W6xcVG",
      "W5jsW6pdS8oi",
      "auj0hW",
      "tbqUtq",
      "gmkKgYpdLq",
      "v8oOWOa",
      "zmkUgrhdSG",
      "WP3dSCo4fq",
      "EMn7qMa",
      "W5HEW7NdUSoi",
      "WQlcRCkVzXa",
      "WOtcKCk8tCo9",
      "kXddQKldTa",
      "k3ZcIGe",
      "WOBcRmkwWQbA",
      "W40Nxmo+yq",
      "W51MW7T/rG",
      "WOFdRCkHuaq",
      "qNVcVW",
      "W74yyCk/FG",
      "AGz6fCoK",
      "CKD9xhe",
      "jhBcIba",
      "ddDxWRO",
      "BIDOkSoV",
      "WRSKWP7cMIO",
      "bmk8jSkRWR0",
      "DdKaB8oE",
      "mSkycSk0WQy",
      "i3H9",
      "aSkBd8k9WPO",
      "jmkWWOe",
      "axpdQSooWRC",
      "mmkYpCkDWPS",
      "umoEW6dcTMa",
      "FgyoWRyt",
      "crL6WQpcQW",
      "W4xcPSk/W5RcLq",
      "WRFcGSokWR9c",
      "WO4Lnmo6WO8",
      "DgdcQH3dTa",
      "WPlcSCkbWRvw",
      "amoJW7ZdOCka",
      "q8osW7BdUg0",
      "WR8Pp8kbrW",
      "W4m0W50",
      "nCkoh8kNWR8",
      "lSkSaHT7",
      "WPBcHf7dVCoJ",
      "WQxcR8kgWRHs",
      "W47cG8k/W6pcVq",
      "yujNWPxcMa",
      "wmoWW49TW5i",
      "WP7cKSoPg8k5",
      "lvNcTrxcPa",
      "fI7dUSkaWOS",
      "gSoPW6a",
      "DN7cUr/dOq",
      "WRNcQmkmxcO",
      "emoPvJxdIa",
      "WPZcMCkdldy",
      "tmkCW70haq",
      "zK0cWROM",
      "scPum8oY",
      "n8ksW5Od",
      "wKuEWOW8",
      "DCovWPK",
      "W6pdPJuweW",
      "W5HEW7K",
      "FmkaW6aYbq",
      "W7tcP8k2W70",
      "aNZdUW",
      "Egn1qwe",
      "DfftzLi",
      "F8owamohWOO",
      "W7BcKmkIW63cMG",
      "BSkfaCkIWQe",
      "WQtcOCogWPq",
      "mCkWmSkbW4u",
      "DxHDWRao",
      "ue1sWOldRa",
      "kseaWQldU1/dLIaNW6hcSmkXEWu",
      "iSkZlCkGWOe",
      "Bmo/lmkAWPS",
      "W51azCoGCq",
      "a2P4WO4",
      "W7GaW47dTNy",
      "rWD2W6pcKG",
      "WOdcPCkAncC",
      "astdVmk1WP4",
      "WPreyrGT",
      "WO7cSCkuWQ4",
      "W4NdK8o/gCkI",
      "qf0WWPm1",
      "i3RcUSoTWRq",
      "nSkXkmooW4G",
      "oSkWWOFdQby",
      "ESoZW581",
      "k8orWOPxpW",
      "tcDZbmoY",
      "o8k6mSksWPW",
      "WOqFdCo5WOm",
      "W6xcOSk1W7NcLG",
      "ldDdWQys",
      "W4LNAmo4Cq",
      "W7P7rCoauq",
      "y3NcMrVdPW",
      "y2PnD3K",
      "sMytWRuX",
      "FbLEeG",
      "lSkIWPRdKbq",
      "tmklW7ueqG",
      "EmotW4FdTKm",
      "B09tWPlcRa",
      "ymoDW6FdJrW",
      "dgz8WOCX",
      "yNDGzLu",
      "W6VdQmoeWPmo",
      "oSkBWPldIri",
      "WRNcPCozWPus",
      "WQ5WrID1",
      "W5foW4VdHCov",
      "W5VdP8okW7Go",
      "W7yMvZm",
      "mCkzWPldNri",
      "W4RdNCoIdSkP",
      "vZa3qCoX",
      "mmk6kmkGWPO",
      "W6jJzCoryG",
      "WQBcICokWPTG",
      "FurDW7NcPG",
      "WRG9mmkKrq",
      "W4hdJcXVeq",
      "WOFdS8o+aHW",
      "ohL5",
      "BgjvW7pcPq",
      "CSotW4SiWOa",
      "acrpW6nKW47dKaJdKSoZbLm",
      "oYfdWROZ",
      "yCk6eHBcVq",
      "ura3",
      "FmouW60rWRi",
      "se5IW4pcKG",
      "jMNcQ8o7",
      "WRxcPComWPqu",
      "nSkFW78TCq",
      "sXSK",
      "pt1EWRaw",
      "lr/cUuW",
      "W63cT8kdDaC",
      "DgxdMWNdPq",
      "qWuZrmoG",
      "W6/cPmkpW6tcQq",
      "pCkjd8kMWQC",
      "ymojfCoxWOK",
      "r0TRW6O",
      "WQWfCmkVFW",
      "wwb8",
      "zwJcRGFdGa",
      "a8k3hZS",
      "gmowstpdLq",
      "nMNcVmoN",
      "C8kbW54Eaq",
      "pY1aWRC",
      "WO/dGGa2WOG",
      "WONcTmkyWRTu",
      "p8koj8krWQu",
      "W4BdKa87WPi",
      "WOaRWOVcOXW",
      "W6afv8kqwG",
      "W5JdLYmKhW",
      "ebPOWP7cVa",
      "WPFcGCkOlr4",
      "WPVdPSoPgq4",
      "jmoIsvdcVMJcJbFdKh/dGmkimG",
      "WOlcN8ovWPDP",
      "WPGFnmo1WRm",
      "obRdP8kRWPS",
      "sfzPWP7cUW",
      "tmkBW4qhbG",
      "jr9kWPKu",
      "bSk7nd1Y",
      "wSo3WPTXWPK",
      "p8k6d8kqWRO",
      "WOJdIbyMWPq",
      "sx0FWPC9",
      "W6VcVmkGW6FcNq",
      "aSk5cab4",
      "DmkIgra",
      "W5C0W53dL0a",
      "W4FdOsKioa",
      "W4zxW6JcLmkf",
      "WOtdGWmEWPi",
      "WPVcRSkb",
      "W4xdLWG4",
      "WOdcH0hdHSoF",
      "WPVcH8ocWPub",
      "DN1GcZK",
      "WQv4tJ91",
      "W5jHW6O",
      "FwjaW6W",
      "WP/dLqC5WOa",
      "m3ZcGHdcPW",
      "W4C4zCkgEG",
      "W49MW65JsW",
      "BNzM",
      "W5OIj8owFW",
      "WORdGWKOW5W",
      "n2bGsxG",
      "a8kSWPxdIwW",
      "C8ojd8o3WPC",
      "Ex9VW7/cSG",
      "W5RdTHG7oG",
      "zbqaxSo3",
      "aw5zWOqP",
      "zelcUXC",
      "WQpcV8oaWO4d",
      "WO8ulG",
      "lSkLWP/dJqm",
      "W5xdU8oGh8kZ",
      "DhfwW7dcRW",
      "wNjKega",
      "zK0cWRyK",
      "dmo+W6BdTmkC",
      "w09+WPFdQG",
      "W4JcSSkQaba",
      "uCk1ldxdTW",
      "WRNcSCkdyay",
      "WRZcP8ooWPu",
      "gCoWsYldNW",
      "cNFdVmo4WRq",
      "DmkPgWFdSG",
      "WRjqDtm+",
      "CSopW4hdU0i",
      "t8oUW4hdKa",
      "WOv5FWum",
      "wN4FWR46",
      "nCkfWPZdJtS",
      "EgJcTt3dSG",
      "emooW6VdGCkt",
      "WRhcVmoCWOGf",
      "mCk7f8kDWOK",
      "WPZdPSo1frO",
      "WRGMpSkn",
      "ESopW5BcRbO",
      "Bmk+dG",
      "sK5GW53cHa",
      "vxCyWRWG",
      "f8khimk9WOu",
      "pGzDbSoZ",
      "W5pcOSohWR0b",
      "sZKHrSoR",
      "F19Gqf4",
      "qghdOmokWR8",
      "WOJdIai6",
      "WRVcRCoq",
      "WRqPgCkDyG",
      "jSoAW4hdGmkI",
      "swTdWQNcGG",
      "mMpdPCoPWRG",
      "W5uJW53dOG",
      "W4NdQmoBm8kH",
      "kctdU8kaWPy",
      "uaeIrSoT",
      "xw1vWRtcHq",
      "WOe3eCoJWO0",
      "W6fdv8oHrq",
      "uIfAoSoL",
      "WQBcLCk6",
      "CHjpaCo7",
      "fIpdUSo7W58",
      "ESkzlGtdNW",
      "cCo4sYddMq",
      "WRVcH8k4kri",
      "WOBdJGGfWOK",
      "i2hcVSo5WQi",
      "omksWQxdPtK",
      "W500W5RdQea",
      "vComW4PYxG",
      "W4qOW5NdVNi",
      "Cgv7xh4",
      "aCk8W4ddMI8",
      "W4xdIYK",
      "j8kShH1O",
      "ngrpWOGQ",
      "BSo8kCovWQO",
      "WOFcL8oqWRzc",
      "Bh9NW6hcSq",
      "CNlcPCoUWR4",
      "xreMWQlcHa",
      "WRJcS8omWPTi",
      "WRfFusyl",
      "WRmii8kCqa",
      "WO/cUmokWPTC",
      "mCk0WORdGqu",
      "Ah9D",
      "WPhdPSoP",
      "W4a+W4ddL0G",
      "W4/dQSkdWRKx",
      "vSoHqw04",
      "W6Gsy8k7zG",
      "WRxdPCk1W63dJW",
      "hJ/dJCk5WQG",
      "W7G0W4JdV0q",
      "zCk0fs7dRW",
      "pYatWR4v",
      "ECoZW4BdKa",
      "hx3cPGxcKa",
      "f8oTW6ddSSkx",
      "WPZdSCk7uqe",
      "WP0PWP7cGZ8",
      "WPFcOSkbmti",
      "W5dcNd56bq",
      "fWLcWOyT",
      "ACona8o+WOa",
      "emo8W77dVmkg",
      "z0zZsgu",
      "WOxdS8o0aHW",
      "WRGZC8otsW",
      "xu9OW6RcGq",
      "tLLLWR3dVa",
      "jCkmfCoZWPC",
      "qvT2WPRcPG",
      "W5jEW6JdKmoQ",
      "CCojW5GcWPm",
      "W4KmWOpcNYW",
      "qMRcKGRdJG",
      "tmoUW5C",
      "bNFdSq",
      "fSoxW4TSwG",
      "W60IymkZza",
      "WO/cL8ozWPuj",
      "xmosW7C",
      "WRtcSCkdDdO",
      "hc7dQ8k4WRi",
      "mmk6kmkZWO0",
      "CmkIWPRdGam",
      "W4T7W7TUrW",
      "kMNcSmohWR0",
      "qSooomo3WRi",
      "x0nzWRZcUa",
      "or/dG8kn",
      "W5VdJGWhmG",
      "WQuIpCkm",
      "W57dSCkaWRfw",
      "jSkfW7STsG",
      "h8kaiCktWQm",
      "WOlcOxFdM8oy",
      "WQpcL8osWPnA",
      "W6pdQc8OeW",
      "W6mtCmkFFG",
      "WPhdPSoPaW",
      "W7BcPSkKW7VcMW",
      "uCkyWOm",
      "WPVcK8olWQ1A",
      "W4jRE8oA",
      "WRZcQCoqWP8s",
      "W7pcRSkDWPXt",
      "WRVcUCkptI4",
      "zXWoymob",
      "W5L+W6zJsG",
      "wmoZfCoGWOq",
      "CG4bqmo5",
      "W73cT8k3",
      "qmoxW4BdJs4",
      "imkEgmkZWQa",
      "y39gWPtcNa",
      "W6bKW7NdM8og",
      "WONcVmkCWOjw",
      "iSknctPv",
      "aI1vWRSL",
      "W4z/W6DyAq",
      "oxLzW6xcRa",
      "svv4W5BcPG",
      "WOlcSSoWWOO0",
      "iSkFW4mjzG",
      "v8o9W5ddKJq",
      "WPNdLaK5WPe",
      "W6JcL8og",
      "smkyWOq",
      "q8kjW70ecG",
      "qJ9waCoL",
      "F3rOWPNcGa",
      "cwRcHa",
      "W6iszSk2AW",
      "W7XmDmoTCq",
      "W4tdHdendG",
      "sCoOW5VdMtG",
      "ySkWhZJdIq",
      "qCkCW7XstW",
      "W5D6umomya",
      "ntnNqNC",
      "WOZcHcSVcq",
      "CZRcOCoZWQe",
      "yKdcTbVdSa",
      "Cx4oWRxdSW",
      "jmkVmmkCWPW",
      "WPhdIHpcSmk1",
      "W6BcS8kMW77cIa",
      "W6ZdImoFW4q",
      "FCoHxfpcSq",
      "WOFdS8o6ar0",
      "WO3cU8kKWOzV",
      "vu1IWQ8",
      "ax3dR8oe",
      "aY7dO8kUWOK",
      "W4xcSmkCW6ZcQa",
      "v8oZW4W",
      "EGvpxCk3",
      "WOW/pmo7WO8",
      "jmkAjSkJWOG",
      "e8kMWPS",
      "b8oPW7tdVmkC",
      "raCSrCoA",
      "WQiOpSkLsa",
      "WOtdJdaNWOS",
      "F8oPW5uZWOq",
      "W4DkDSo2qG",
      "WOmEWP4",
      "WQJcKSogWPun",
      "xxCvWRqM",
      "W4r8W4VdTfK",
      "C8k0dIFdPW",
      "ugGt",
      "aLtdV8oHWRm",
      "ySoLlmoyWPa",
      "W5TGW5HHsq",
      "BdapW7FcRa",
      "W4xdHSo+cmkV",
      "ff7cVCo0WPu",
      "jZLDWRSm",
      "D8oycmo9WOS",
      "DSo+W77dLc0",
      "W5PjW7/dHSov",
      "DCoaW4/dSG",
      "hMBdRCofWR4",
      "vCo4w2m2",
      "W6XRW71xAa",
      "bSoaW7pdRmkx",
      "WPxcPCkEhsO",
      "xLnZW7BcUq",
      "jJyjW79q",
      "v8kwWOzWuG",
      "ExrBW6ldUq",
      "WRtcVhldN8oG",
      "WRvdqWGz",
      "WOnlFCkJW5K",
      "nN3dTCk8W7m",
      "W4VdGdyhfq",
      "WOyqjComWOu",
      "W75CW4tdGmoq",
      "WOxdIaG6W4y",
      "evJcIr3cOa",
      "w3/cLXVdNq",
      "W7dcPSogWPqf",
      "gxjLWO4",
      "eCoJW6FdU8kw",
      "bt7dO8k7WRm",
      "iNtcIrVcOq",
      "cCoGyaddKq",
      "kHdcSbFdRq",
      "zCk0dHBdPW",
      "jhBcGGhcPW",
      "jmoLW53dKmk8",
      "vSkCW60ecG",
      "kCkkbCkXWOi",
      "W6KzyCkBzG",
      "WRrJsYiS",
      "BCo/BSofWPG",
      "WOVcRCkJWQ5E",
      "w3FcGrNdQG",
      "WRddK8oAoYm",
      "pmkba8k9WRO",
      "WPGykCk2",
      "eItdVSk4WO0",
      "tSoUW4pdKZS",
      "qmoVgmoiWP0",
      "sCkjW7ynaW",
      "WOpdKXiV",
      "jCkkW4mkBq",
      "Fmk4maVdTq",
      "nCkNWPBdGG",
      "W4dcP8kwW7ZcLG",
      "wf5IW6hcQW",
      "WQtcUSoiWPWg",
      "WQZcICkQFWm",
      "W4DpWQddJCoc",
      "C8o1W5ddTLe",
      "bSo6W6ldG8k3",
      "kSkfc8k6WRO",
      "h1/dP8ozWO0",
      "mCkQW7WbrG",
      "k8kFcSkqWRK",
      "WPVdLqmPWQS",
      "BrrcemoW",
      "ASoCdSoGWPe",
      "DColW4FdHXK",
      "cCkXnb1f",
      "WORcJ8kmzXa",
      "agxdQ8oNWOm",
      "xvHNW6hcGa",
      "dSkGvsnO",
      "jsTEuNVdR8oiEW",
      "DhHrWRas",
      "o8oxtSoYW6e",
      "WQytkSkyta",
      "WONdVYmvWQe",
      "xgyFWRG1",
      "lCk6WPRdQb4",
      "n2dcIdBcPq",
      "Cmk2dbBdVW",
      "WQpcOCotWP9A",
      "W74AD8kT",
      "WPlcHmkBWRj1",
      "dHP6WQpcQW",
      "x3jKWOlcTG",
      "WPBcH8kLWOXK",
      "tsLuW7T7",
      "WRpdIJylWOK",
      "pxZcR8ovWRa",
      "FmoGW6BdPYi",
      "oYP/WRyr",
      "wuW3W7K",
      "W4qJW4ddUvq",
      "umo/W7C5WOm",
      "W49IW6nKwW",
      "FMbxrwC",
      "kSoRW4tdOCk8",
      "o8ooW5dcT1G",
      "pYXAWRao",
      "W68yzCkNEa",
      "WOiClCo5WPG",
      "W7lcU8kGW6i",
      "rCoyW7VdOIq",
      "bCojBrtdVW",
      "cgbfWP8F",
      "WOulWPRcLYe",
      "W6asE8k5FG",
      "uCkyWPHXvG",
      "W7DTW4BdVSor",
      "WRmZBSokDG",
      "lJrhW6jc",
      "nCk+bCk6WOK",
      "teDJW6hcHW",
      "jCk2o8kDWPW",
      "CKnMx2q",
      "WPBcRmkAWQnc",
      "gxL0WO0U",
      "WOFcPSkwWQi",
      "BCoSW6NdPwa",
      "oSo9xsRdJG",
      "yCoBW7BdJZe",
      "mhtcPmoXWQm",
      "zszbkSoD",
      "f8oqW54kadSgoa",
      "ESoKW4W0WRu",
      "DMfWhxO",
      "fCkYWPJdKG8",
      "axpdSCkrW7S",
      "uquVqCoT",
      "y8k6ebFdOW",
      "WPFcHvddVSoU",
      "vgDLWORdIG",
      "w1vP",
      "ruHRWONcTa",
      "tSkzWPK",
      "rmkyW6qefG",
      "rSkhW6qrhq",
      "q8ovW5u0WPu",
      "uuv8WR7dRG",
      "ELxcOq",
      "m2dcGbddQa",
      "W5/dKIS2gG",
      "WRnMvs4z",
      "l8koW4Ws",
      "WRhcG8oAWRzp",
      "W7uZW7ddVNy",
      "ztxdJchcVa",
      "Da9vwSk1",
      "WQFcGCkegWi",
      "WRlcVMVdVCoB",
      "q8kyjqRdHa",
      "qCowW6ldUsu",
      "zCoBd8okWQy",
      "WOecW4RcKIS",
      "bJbsWPue",
      "kN7cUG",
      "fKdcOWlcLG",
      "q8kwWOLUua",
      "WPZdTSo2cIq",
      "WPypWOVcLsW",
      "W4JdK8oPh8kM",
      "WOBcSSkdoJm",
      "WOVcHqRcSmk3",
      "FCoChmkQW64",
      "WQ3cOSkgosG",
      "DCogW6NdVcm",
      "W5hcPCkppq",
      "w092W6pcKG",
      "WRuOp8khwW",
      "W512ECoADq",
      "FSotW5BdRG",
      "WPZdSCoxgrK",
      "xsS0WOiL",
      "WPRcHmkCWQ5A",
      "W6TdW4z/xq",
      "Cmk3WPZdNfO",
      "W6bzW6hdImoj",
      "W5juW7VdJmoc",
      "fGX/WOuA",
      "WQtcHSomWP1l",
      "uqaSrCoG",
      "W5NdLdGXfa",
      "W6xcTSkHW5NcJG",
      "W5PwW6JdH8ot",
      "W5StW4hdNKW",
      "WOKHW791dW",
      "mLr5WOOQ",
      "WPCEWP7cUd0",
      "vMixWQOH",
      "W6ZdP8oAWOOb",
      "WQtdNmkEW5Dz",
      "fCkxW7RdRti",
      "cXRdOCk5WO8",
      "W7ZdOSokmCkb",
      "h8k5W67cPW",
      "ESofW4BdM1y",
      "f8oPW7ZdOq",
      "W5LLW79Ixq",
      "k8kBW6GfEW",
      "W7BdO8opCqu",
      "wdWTtmo8",
      "WRGZAmoira",
      "BSoMW4NdP28",
      "D8k7WQ9sCq",
      "W4pdLZyJfW",
      "xmkeW7fvtq",
      "WOGAWOJcNJq",
      "W4tdHcWMfq",
      "jMNcNbNcRa",
      "W7FcSCk3W7ZcNW",
      "W55fxSoYxa",
      "W54+W4FdVGe",
      "emopW54",
      "WROJgSkEqq",
      "cSk1jmk1WPO",
      "ru1OWQldPa",
      "W4tcN2jZtG",
      "WQBcG0ldISoV",
      "W4hdN8o7dSkZ",
      "W4NcNCkmW7RcQq",
      "ChfgW5BcRa",
      "l8keW40j",
      "Cq9CdW",
      "uCkskG",
      "WRJcT8orWPnI",
      "omkmWOVdQJ4",
      "WORcISkbWQbr",
      "c8k9cM4H",
      "tf90WQJcUG",
      "C2z+W6tcHq",
      "W41pW6ZdH8ot",
      "WOSvWP7dLJ4",
      "WOzLsG8j",
      "WQJcU8oaWR8y",
      "vf4WW7VcUq",
      "bNlcIcdcVG",
      "wLXcWP/cUq",
      "nupcLqlcLG",
      "WPuxWQ/cIJ0",
      "FLr8FNm",
      "qeq8WQ/dGW",
      "WRC0a8kVwG",
      "FgrCWQ/dOW",
      "W6ddH8oye8kZ",
      "WOufzSk2WOW",
      "WOlcLeu",
      "r8kwWOnPuG",
      "WR3cHSooWO5x",
      "dSo8gthdLq",
      "x3mFWRCX",
      "DqTobSom",
      "DmotW5BdTLK",
      "gCkSna",
      "bG5QWQCW",
      "WP90WRTRha",
      "WQ5Qimkasa",
      "senLWRu",
      "W6JcVCkIW7O",
      "tx1WWPK8",
      "WOahf8oNWQW",
      "WRrXBYWB",
      "F3vaW4BcRa",
      "ghVcGbtcUW",
      "AmoJW5VdG1y",
      "sfHJWRNdVG",
      "FmoeW5BdHfG",
      "qcBdUmotW7S",
      "W5n8W6OTdG",
      "W7dcT8kRW7dcNq",
      "bmkIW6mLBW",
      "smo5g8obWQ8",
      "vCoyW4ZdJwy",
      "vMPBWQG8",
      "umoYW5W",
      "WQ8nbSkktG",
      "zK0AWRO2",
      "WPpcRmkdpYG",
      "cenRW7/cNa",
      "WO5VFCogDW",
      "W5PZW6zHsG",
      "CLPbDfG",
      "rLnUWQhcUG",
      "zgr9rhC",
      "kd1h",
      "W4JdOmk4nYq",
      "W7uhW7RdJNe",
      "iIxdT8kkWP4",
      "w1VcQZBdSW",
      "WP7cLmow",
      "WOdcR8kFnIi",
      "cmkeWPldJrW",
      "W41EW7VdJmov",
      "WQRcQmk5aGi",
      "WP1+AcmQ",
      "WOFcKCkdWRvE",
      "wwDJW4pcLW",
      "W6CWehXV",
      "gSkXWPFdIqu",
      "oCk4b8kzWQa",
      "AhbVWO3cUa",
      "WRqUkCo7WPO",
      "lehcOGdcMq",
      "nmk3pCkhWQS",
      "Bq9s",
      "wKvZW73cKa",
      "W61TEmor",
      "WQxcSCkoata",
      "dWnW",
      "bvRcNI/cJW",
      "W7GfW6tdLW",
      "WPxcPCkEfcC",
      "kHrsWQyf",
      "W6bZAmoFuW",
      "W4XpW7tdHCoc",
      "W55LDSoDrq",
      "vSo9W5VdKc8",
      "CmkWlbBdKq",
      "sCovW4ZdScu",
      "wvH4WRtdUq",
      "BJfEWQ8p",
      "WRDHDq0m",
      "s0v+WQlcGa",
      "amkKd8kvWRW",
      "WQ7dJISxWR4",
      "iSkQW50atW",
      "WOKsWOtcOtC",
      "W6VcVSkQW6FdLq",
      "sSo5W67dNc4",
      "hgJcU8oXWQm",
      "gSkQgZe",
      "WPBcHxbYcq",
      "dLbeWRpdSqpdHq",
      "W7BcImk8W6lcRa",
      "BxnfWQZdIa",
      "qvr5WPRcMW",
      "DbLogSo/",
      "WRNcR8obWO4S",
      "jv/cLrtcMG",
      "W4ucymk3qa",
      "Fa5pw8k1",
      "WQdcImonWPnA",
      "xuTOW7VdIa",
      "x8oZW4KvWPe",
      "EWnOdmon",
      "v8o5W5hcMx0",
      "cXTPWPBcPq",
      "W7BcVCkXW7tcMW",
      "WPVcS8kPltu",
      "W51RzSorkG",
      "kSkmW4is",
      "x8oRWO3cHYS",
      "WORdHruWWOO",
      "yConcmo+WOa",
      "omk7oCk0WPW",
      "AmovW5VdU1i",
      "WR8Poa",
      "gKzzWOue",
      "cM5HWRGN",
      "qWeQr8o3",
      "wSoZW5uKWOi",
      "xSopW4pdTvS",
      "sSkgW6C",
      "yNlcOsBdPq",
      "W4NdK8oZimkL",
      "gmk8W5hdHZ4",
      "W6hcL8kPW7dcGG",
      "xhjNCwm",
      "kmoRvq",
      "W6hcVSkSW7VcIG",
      "WQzJvYCH",
      "lCkfWRRdLX0",
      "kSkbcCk8WRO",
      "W5P7W6XbtG",
      "WOhdRmo1sKG",
      "yCkUerJdIG",
      "WPRcPSkcibe",
      "WOtdLri+WOG",
      "nuvzWReJ",
      "ECoaW4JdGfq",
      "eSo7W4tdPCkf",
      "hmkOfd11",
      "wmoOW5iMWPu",
      "WRBcImomWPLl",
      "ueneW5RcMW",
      "WQJcTCkxBJu",
      "nSkjhG",
      "W63cTCkTW6hcOW",
      "BNX0W6hcTq",
      "WOldNq02WR8",
      "jCkWkCkBWOW",
      "kX5gWRed",
      "EajqcCoH",
      "zhT1vhS",
      "WO/dPSoV",
      "CSoxW6i1WQK",
      "AqfvfmkU",
      "v8o5cmoIWQq",
      "uSo5W4pdKq",
      "CefHzwC",
      "W5GWW4FdV00",
      "BwjxW7a",
      "uL/cVbC",
      "F0n7wvG",
      "bstdO8kmWP4",
      "W5SbjCk2W4S",
      "W4ToFCowDq",
      "serhWRJdRW",
      "a8oxWPLXtG",
      "WR7cT8kdCGK",
      "W63cOSkmCGK",
      "WOGElCoVWPG",
      "pK18WPGj",
      "umoWW4RdJqS",
      "W5lcO8o5erS",
      "qerH",
      "uCk/W70mgW",
      "BCkoWR5cuq",
      "Cmo7xqVdQW",
      "Fmk8WP7dLbG",
      "ASoRW5iKWPm",
      "eCkCeSkhWR8",
      "FML4WOhdKq",
      "cdldGCkqWRq",
      "a8kScG",
      "gxtdP8ozWRy",
      "zSkSfrBdPq",
      "v3xcOIBdVG",
      "W4FcNfddOSo9",
      "j8oiW4/dSbC",
      "qSknW6aTaW",
      "vSknW6a6cG",
      "bhZdRmooWQm",
      "mhtcPSoQWQm",
      "y3jMv3e",
      "hLxdM8oHWQe",
      "WOFcRmkhWRG",
      "WOxcU8khWObd",
      "WPNcPCkt",
      "g2jWWPW",
      "EW9jjCo0",
      "WPhcQSkwWQ9s",
      "WPRdVSosWQHA",
      "oIfeWPWt",
      "nrXjWOCi",
      "WPRdT8o6hHW",
      "zxDXqI4",
      "vNWIWQK1",
      "funRW6JdKW",
      "WP3cGmoQWP0y",
      "lGflWPe5",
      "W5ddGmoIgmk/",
      "n3BcHq",
      "w05PWPtcUW",
      "W5PWFCosDG",
      "jmk8fmk1WP8",
      "x0vUWR4",
      "WQNcRCoBWOK",
      "W4LNAmoXFa",
      "W74CW6ZdGMG",
      "chFcMWtcGa",
      "WOlcUmokEs8",
      "vSoRWOfWWP4",
      "uCksWOLSuq",
      "W6ldL8o/a8kq",
      "WO9svdmb",
      "tmkXWP5VEa",
      "W5LgW6zHsG",
      "Ef7cUX7dSq",
      "rra3BCo1",
      "WPZdUSoRfq",
      "w8osW6ddQZq",
      "W4m0W53dLKa",
      "wN0sWR4",
      "wKvWWPxdGW",
      "WOpdPSoI",
      "WPJdGHipWPq",
      "oMlcVCoKWRS",
      "hYldQCkOWO0",
      "WOVcRmkpzwq",
      "BgDbW5JcUW",
      "W78syCktAW",
      "W57dKsmSdq",
      "a1NdRSoXWPW",
      "WRKJnSkPxq",
      "WOytWOlcQX0",
      "WQJdH8kFWPnd",
      "WO3dLqKYWQu",
      "uKO4WQ4y",
      "W7OECmkP",
      "W5vXW65HaG",
      "WRNcHmoYWPnD",
      "WQldNWSVWP4",
      "WPbaW4RcJZ0",
      "WOhcSmkElc4",
      "WPquWOpcTZe",
      "lCkeW55gEW",
      "W5JdVSkbWQrB",
      "dSkzo8kNWQq",
      "a8knfCk3WRW",
      "W5fIW6b/wW",
      "yKtcVrZdOq",
      "wNj8W7VcUq",
      "W4H0W6b/qG",
      "W7dcT8osWP9p",
      "tK9YW5VcMG",
      "WO/cR8krWRf+",
      "B8ouW4/dRxS",
      "WPhdIaKY",
      "Ah1PWONdIa",
      "u8ofW7eCWOa",
      "WPhcU8kbWQHr",
      "fCoLW7FdOG",
      "aCkBcCkgWQq",
      "W4xdNSoIhCkK",
      "tmkBW5CDha",
      "W5K8W5NdTfm",
      "AG1xlCoA",
      "W6ddNbq4hG",
      "aqThWR0m",
      "WPGukCogWPG",
      "W4DVBmoByG",
      "suasWPCv",
      "WPqVWPpcIZ0",
      "hSoXwdxdVW",
      "W5ddPCoIhSk+",
      "Ef3cQb3dTG",
      "fSk9cG",
      "WO3cRSksWRbc",
      "W6y4W53dSNq",
      "gGS0W4ZdRCkRW47dKxP9BstdPrC",
      "D8oaW4ddSLS",
      "W5VdJdyHeq",
      "dmkZwhvO",
      "umkSrq",
      "B8kdhSoYWQe",
      "WP7cU8ob",
      "vrW3s8oX",
      "WPNdGHuVWOK",
      "uvb1W6JcKG",
      "AMRcHbtcSq",
      "W49uW6q",
      "W57dHmoepCkS",
      "m3BcVWhcPW",
      "i2tdPmoPWPe",
      "B8kAWOdcTXG",
      "rCodW6/dOJq",
      "yCk+eGFdTa",
      "WRNcOSkmCLS",
      "jSkbhmk9WRW",
      "WRi4m8oKWOG",
      "W4NcP8kJW7hcQG",
      "WQRcPSkwqau",
      "Bmo5W5C5WOq",
      "DtafwCoF",
      "DMPXqG",
      "a8k9lszT",
      "FMTFu3a",
      "BCkKcCk+WRG",
      "W6PjW6e",
      "hMz6WOq8",
      "uCkIWO19rG",
      "tuvLW7RcNG",
      "hmoxsYZdPG",
      "tNCuWRa9",
      "WOldIHyWWPq",
      "yLxdUatdRq",
      "xmoWvdFdKW",
      "y8okW4mlEa",
      "hsRdT8kKWO0",
      "dSkdW70Yuq",
      "W7Gwz8k5BW",
      "W5/dLs4Rdq",
      "W5NdLYeN",
      "m8kCnmkCWOq",
      "p8k0jSkIWP0",
      "W50WW53dUeK",
      "WO4uWOpcLq",
      "nSkzeCoQ",
      "e8oWxI7dJG",
      "CqfcbCoN",
      "W5BcV8kNW7RcJa",
      "WOepWOpcMdK",
      "swypWQSX",
      "xmo9W4VdMtG",
      "WRDRbYOT",
      "u8oZW4W",
      "WR/cL8oBWOHD",
      "WOpcMfldNmo7",
      "WOOpWO/cIq",
      "dmoGW6e",
      "WOtdPSo1fXW",
      "WO5MDCohya",
      "ENP6hxW",
      "u8oYW4ZdKc8",
      "mxtcVmoQWR4",
      "gCoTux3cNa",
      "W7dcHCkSW7hcMW",
      "x8owW6ddQcW",
      "W4hdHdiwaa",
      "a8kugs1K",
      "WQvMuYi3",
      "pmkUfCkgWQ8",
      "x8o9W5i8WPu",
      "zv/cQeJcPa",
      "pSkpWPldRrG",
      "WRJdUSoPkI8",
      "u1LNW7BdQq",
      "vK5Jx8oW",
      "WQlcV3JdK8o3",
      "n8otqr/dRW",
      "wmkUgGBdGW",
      "W5btyW",
      "W6VdH8otWPTw",
      "W51QWQj6rG",
      "vCoUW5BdLdm",
      "wSkoeHtdTa",
      "renOWQlcMW",
      "ymkRW7i/ja",
      "W6DWi8kqcq",
      "tSoOW58DWOe",
      "xSoVcSoKWOC",
      "WQv5vG89",
      "qmkdWP53xG",
      "WRD2rci+",
      "W7FcUCk/W7ZcHa",
      "W49MW7zHsG",
      "s0TLW6tcLa",
      "zSkzbtBdPW",
      "uSoNW7ZdOZa",
      "W4JdGcqRfW",
      "yCk0W5pdJau",
      "W7zoW5ZdP8oH",
      "WRVcGSoh",
      "x0TQW7RcLG",
      "WRv7tsmI",
      "D8odca",
      "DSk5htJdHa",
      "W5jZW6jO",
      "AsujuCoQ",
      "bg5XW4u",
      "xvvZWRtcHa",
      "fmoEWQfFx2PDjadcKmoBm38",
      "W5C0W53dJuG",
      "x3mZWP8S",
      "fN3cVatcNG",
      "xNCcWPC1",
      "WQVcPmkoaaC",
      "WOyxWOVcLtm",
      "iN/dKvFdTW",
      "D8o+nCkyWPG",
      "omkXlW",
      "dNRdJSooWRO",
      "ymojfCoiWOO",
      "W6FdNCoVhW",
      "EL9KWRJdVW",
      "WPaLW4JdQuy",
      "CmkxhrVdOW",
      "emoFW4pdNCk9",
      "lMRcUaFcTa",
      "W6/dOJegeG",
      "fConsYBdMG",
      "g8k5cJnK",
      "jCkTbCkJWOe",
      "tNvWWO/cVa",
      "WO3cQSk8WOTF",
      "BsaTxSoR",
      "W55zW77dHSol",
      "W70KW4/dV2q",
      "oCkChmk1WR4",
      "rvjNWRRcRW",
      "aCo1W6BdOSkw",
      "zCk0fq",
      "pZDbWQSb",
      "zYjqlmoX",
      "xh8tWRuG",
      "WOGwWRRcUIa",
      "u8oHW4NdGbi",
      "cCo8vYldJG",
      "W6OrFmk9rG",
      "W5L/W6PJwW",
      "CSocW4pdUXO",
      "WQlcGwFdQmoF",
      "aI7dUSkaWOS",
      "ESorW5ldSLK",
      "detcVmoZWQe",
      "hM57",
      "wrvOcCoS",
      "B8kAWOldTvG",
      "o8k+pSkqWOq",
      "nw3dGrC",
      "jsyLaIdcSmkBw8oLkWuelG",
      "WQdcTmkbsJG",
      "WO/dKCoJfs8",
      "WQJcK8kvBIS",
      "WOuPkSkJsa",
      "jmkRjCkzWO0",
      "ghRcU8oFWQy",
      "zmoddCo9WPC",
      "t8khW70g",
      "WRtcLCoBWPTd",
      "k8kcW4qbmG",
      "u1PRWQRdVG",
      "W5vkW6jcwq",
      "WOOuWOtcNNG",
      "qmo2W5JdPHC",
      "WQtcPmkkCG",
      "hYtdOmkKW58",
      "jInKsa",
      "bCkLk8khWRS",
      "W4FdMSoQcmkj",
      "EmkyWP9exG",
      "aZe1W4z5",
      "W5nIW6PJ",
      "dI1FWQ8x",
      "vCo5W50K",
      "o8kqWPpdP08",
      "u8o2W6FdNMq",
      "l3LgWRiY",
      "xCouW5ZdOba",
      "W6P+tIuX",
      "W6xcOSkXW6ZcNW",
      "wgXbWRpdQa",
      "sh3cT8o5W4/cUSkuW70WWO/dPmop",
      "DSolW4GPWR0",
      "dSkOcdH4",
      "W49dWQ3cImoo",
      "nLtcUmoQWRG",
      "W4SwW6/dHSoF",
      "tmo4W48gWRe",
      "bmoPW6BdGCkB",
      "qmkgW6aTaW",
      "WQdcQSkdBHC",
      "xCoOW5nQW5a",
      "n2ZcNX0",
      "sXOT",
      "ruT/W6RcGq",
      "FwVcPSo5",
      "WOesWO3cKYW",
      "Ag97WQNdOa",
      "WOFdGIOWWOC",
      "dCkxW6ddOY4",
      "sCoSW7ldVc4",
      "nCo9ys3dNG",
      "DNDWwxO",
      "WOtdKYKvWO4",
      "ArjAbSoZ",
      "k3BcIXO",
      "WR/cPSkpAry",
      "zHStF8oO",
      "aYBdRmkY",
      "WOddP8oXjI4",
      "W5HGW6PSqG",
      "iJfDWOup",
      "Eu5pWQpcMq",
      "ErrtwSk1",
      "pLCmvW",
      "WP4CWQFcVHu",
      "cCoRwcNdJW",
      "WOmqoCo5WP0",
      "wXaQW6VcQW",
      "WRnQFGW1",
      "ECoKW7/dVI4",
      "B8oeW5RdO3y",
      "yCode8oXWOa",
      "t8kNWPHQrW",
      "vSooW6VdVG",
      "tHq6tCoR",
      "W7LisSo7sq",
      "BtrcemoW",
      "W70ZrsOR",
      "uevxW4FcOa",
      "WQOHfmk2WOe",
      "W6asqmkSzG",
      "WO0EWPK",
      "ECoEvmoJW73dOSo1senoW6hdQG",
      "zCkJxepdRW",
      "xYr3kSoW",
      "D8oQW68uWP4",
      "W492CW",
      "eujVWRldRa",
      "CSopcSoDWRq",
      "hcRdVSkvWOy",
      "hsfeWQKs",
      "chLNWOq6",
      "WQJcVNJdV8oC",
      "WRhdL8oAbWS",
      "WP18ssuq",
      "WOldKW8WWOG",
      "W7BcT8k1W7NcJG",
      "gdNdQ8kLW5e",
      "WRFcGSokWRzp",
      "WOlcLexdLCo2",
      "CIjPbSom",
      "aIddTmkOWPq",
      "W65lW4zFAq",
      "WOWLeSkyEG",
      "f8kwW6FdOta",
      "WPdcR8kElcK",
      "fmoKW7VdOCkx",
      "WQ9Yss80",
      "fmoXW5qQW50",
      "W49uW7/dNCog",
      "uunKWOhdPa",
      "CCk+W7W7ba",
      "kYXBW6va",
      "WRa9WRRcNGO",
      "kNJcNchcRa",
      "WPbaW4RcIZK",
      "FfhcQcBdVq",
      "BSkgW4uCjq",
      "WRVcOSkoCWu",
      "WQz3qYi2",
      "p8k0WPddJXa",
      "FCoNW7FdJ3e",
      "WOiFmCo/WOq",
      "W59BWOFcMIO",
      "WOWukCoAWOS",
      "WQNcPSkuyWW",
      "W6ldKJC4oG",
      "WPhcLf/dTCoO",
      "umoFW7RcTMa",
      "W7dcUSomWOSv",
      "WRNdUmoaoa",
      "WO4mW73dKCkh",
      "jN9GWRW8",
      "W6BdUmkrW41t",
      "zZL4jSof",
      "WQJcJ8kdFWu",
      "dgNcUb3cHW",
      "WOSjWP7cMJy",
      "xCoFf8oNWQ8",
      "hGyZsCo3",
      "WRKPj8oftW",
      "fmo3vYldJG",
      "jmk/iajK",
      "WRzbycuc",
      "sSoiW5VdHtG",
      "WO8yl8oZWOK",
      "vCkYW4ZdLdu",
      "WP8dnmo0WP8",
      "pL3cVmo0WP4",
      "zxz5x2i",
      "odfDW7JcSW",
      "a8kAWOT3ua",
      "ChzGzN0",
      "CWvicmo0",
      "W5zXW4tdImot",
      "icaEWQWi",
      "o8kEdCk0WQG",
      "z8kVhqZdSG",
      "vIWvzCok",
      "zqVdUaBdOq",
      "W7FcOmkM",
      "FbrpeSo8",
      "uI8Rw8oB",
      "dSkVWONdIrW",
      "ymo4W5tdOqe",
      "xSo5W48wWPu",
      "W5xcGuNcSmk7",
      "ENjSANS",
      "rSksWP5jvG",
      "tLDWWO/cRa",
      "W4ZdK8oLhSkM",
      "CmkAW7G",
      "WQ3cPxZdNa",
      "u1upWP0G",
      "W4NcVCk/W7NcMG",
      "hgRdM8ohWP4",
      "WPtcV8kFWRrs",
      "cwDVWPWJ",
      "WQFdKaq7WPu",
      "W4K0W5S",
      "WQRcVfZdUSoW",
      "W4H3W6fOxq",
      "tsP8WOy4",
      "W7OXbwSR",
      "ura3ACoT",
      "W4DAFa",
      "WR/cJSoEWRai",
      "WR/cPSoA",
      "dgldUmohWQi",
      "mfNcTqldQW",
      "rHyVECoB",
      "wmoDW7KsWP0",
      "WPVdIa8",
      "WPFcLehdVmo7",
      "bf1xWRWm",
      "CSogW4RdO3S",
      "WQBcV8kKW6FcIa",
      "W5NdVSkEWQbp",
      "W4DHumoDyW",
      "DCkxoCkzWP4",
      "iSkRoq",
      "WPCpWPpcLZ0",
      "eSkeWQpdIt8",
      "W53cVmkCW7lcPW",
      "WOFcT8kuWQLd",
      "W6tdVXujdW",
      "W512FCoaEq",
      "DCosW4C",
      "FWfyc8oY",
      "WRRcRL3dSCo4",
      "WPqIp8kbjq",
      "h254WOq+",
      "vh3cLsldHq",
      "W5n8W6nItG",
      "WPxcNKpdPmo7",
      "ACojeSo6WOq",
      "vf7cUrddQa",
      "pmkjgmkcWRW",
      "mSktpCkmWO0",
      "B8oiW43dUq",
      "W6pcT8kXW4pcHG",
      "A8ooW4S",
      "WRRcP8oaWPq",
      "WQPYvsWX",
      "dmkvWRa",
      "CSkZcfJcPG",
      "WPJdJbW2WO0",
      "gIPF",
      "qSkaW6bstW",
      "W5P0W6zU",
      "DuOoWRih",
      "k8k8WPBdKW",
      "aCoSW4m",
      "W6CYtIyO",
      "FSojWOHgEW",
      "qL1OWO/cMq",
      "xmknW6yB",
      "mNFcVmkJW7m",
      "qSk4W7mGcq",
      "dGLHWQSQ",
      "WQuIj8kPxq",
      "WPpcLSkjdGu",
      "CSooW4W",
      "W4mJW4O",
      "W50WW5NdJ1G",
      "ih/dPSoDWPG",
      "fmo3xsldHa",
      "yKrVW6lcVq",
      "FSoUW5ldO14",
      "jmk6ka",
      "sSoOW54+WPu",
      "uwOZWP04",
      "W60BFmk5za",
      "t8oTWO/dLJq",
      "k8kdd8kNWQm",
      "WQtcVmkQW7VcIG",
      "ih7cVmooWQm",
      "dxpcJrdcPW",
      "tSoPW4/dJXe",
      "kNGsWRyn",
      "WOmEWP7cUIW",
      "u1H+WRRdPq",
      "fCkPW5Gwwa",
      "WOuvWP7dGhG",
      "W6y3k8oica",
      "CL/cVbC",
      "fhJcTHdcSW",
      "kGfJWRyr",
      "WQiZbIi1",
      "qM1cW6dcHa",
      "WRxcJSozWPjA",
      "fCoRtGZdHG",
      "CxPyEva",
      "sXT5cmkP",
      "CKm9WO0I",
      "gfuHsCoQ",
      "z0tcSsVdSW",
      "W58PWOtdQeK",
      "WPxcNLG",
      "WQzWCHWr",
      "Ex5aWQ7dOW",
      "EwbDWRS",
      "hx3dUSoFWRO",
      "WOFdHGq6WOO",
      "WPO2gmkFsa",
      "i2ZcLrdcOW",
      "s8osWRrfxG",
      "hmkVesbI",
      "WPXDWRNdJ8ku",
      "jheuW73cSq",
      "W4PjW67dJa",
      "Ds5pnSo5",
      "w8oyW60rWOu",
      "WQNcRCoB",
      "sbeQWQZdOG",
      "kgBdKSoiWQO",
      "t15VWRxdRG",
      "W4ZdM8oLhCoW",
      "WPaxoCkayq",
      "nSoqtbBdQq",
      "W4pcT8kEWRfy",
      "W4ldNCoLdSkz",
      "qhCe",
      "W4mtW5ddJ0a",
      "cSkcdCkWWQi",
      "W6BdNSkmW44EWPZdV8kCWQC/W78",
      "WOdcVvddSSo/",
      "q8kmWQ7dUYK",
      "W6VcOSkGW6FcMW",
      "W5ddPCo6nSkn",
      "thnwW6BcGG",
      "Dfn8WRldHa",
      "gCk9W5i9WOa",
      "W6vbESoMsa",
      "q046W5VdPW",
      "ohtcSSo7WQq",
      "mSkNWOFdHrK",
      "reT1E2u",
      "WOyoWP7cKJC",
      "iqJdUmk0WO0",
      "BG9oeSo2",
      "eaDhWRiq",
      "wSouW6tdTcq",
      "WOJcGv7dOSoU",
      "detcVmoSWRa",
      "WR/cICon",
      "W4RdHSkRqCkO",
      "xvP6WRFdSG",
      "mLrHWPKP",
      "s8o4W54IW4O",
      "WQjdvsqO",
      "W4tdGcy",
      "a3pdQSohWR4",
      "bSo+W6BdRa",
      "gSkHbSk3WQy",
      "uge1WQ4N",
      "v2znW7S5",
      "W6JcU8kIW7S",
      "rfxcTbVdSa",
      "a2lcUSoeWPy",
      "qLrR",
      "uHOQzmoW",
      "ymowW4KfWRO",
      "i8k5atfZ",
      "p3RcSCo7WQm",
      "W4NdOmkhmsG",
      "WRZdRmotCa",
      "hSk6WPFdGq",
      "aCkzWOvRuG",
      "W5BdUmogdmk7",
      "ixtcVCoWWRu",
      "WQdcH8oIWRu2",
      "sfX/WRtdPa",
      "mCk5nCkwWQq",
      "WQtcImkEW4Oo",
      "WP3cRSk+kIC",
      "WOupWOxcJG",
      "WRZcN8ooWQW1",
      "WO3dSCoVcq",
      "W6hdKmooWOio",
      "D0bAW5RcJG",
      "W5u2yCk7sa",
      "WR7cT8omWPvE",
      "WQlcGSotWPvy",
      "WOVcVCk/WQHe",
      "nSkhWPNdIde",
      "teDcW6dcSa",
      "bhfW",
      "c3tdOCoi",
      "cSk8htPu",
      "W6JcS8k8W7dcNq",
      "WRb4Aq4t",
      "g8kTfs5n",
      "jmkYWOldKXu",
      "W4hdHdOyfG",
      "aSkXfG5U",
      "WPtcKSkfWQXK",
      "h2z3WPG",
      "hCkSgtP1",
      "WP/dNGO6W5S",
      "iSkAgmk3WR0",
      "yvlcKZhdRW",
      "WQBcSmoRWRv+",
      "lM3cHrRcUW",
      "nCorW4ZdSa",
      "gmoGDbldQG",
      "WPKulCo6WOS",
      "cCk+W78wtq",
      "od5YWQOr",
      "WQxcPCkjfs8",
      "W5bEW650sG",
      "ff3dJSoJWRO",
      "WQtcGSoqWP9C",
      "eGu7cmk4",
      "WQ9dsciu",
      "CCo5W4pdMIK",
      "bxVdICo+WOS",
      "sfHRWR3dRq",
      "lSkWWOFdVHG",
      "ihZcMddcUq",
      "mXdcQWBdVq",
      "icXCW79b",
      "WQmTWPJcLr4",
      "xmo1W5W4WOq",
      "jZ1x",
      "vSoSW5OHWOu",
      "Ebjjd8oN",
      "vIT9WO4H",
      "W7pdUJyVcq",
      "kmkLW68PqG",
      "bmo6W7/dKSkB",
      "xmomW4K/WOa",
      "mxdcOCoQW7W",
      "W4DjWOVdIw4",
      "WOZdIXmQWQG",
      "W5/dLYe",
      "WR7cVmksW5On",
      "W4RdIIW2pW",
      "h8k3cZ11",
      "CCkrW40ClG",
      "q3qeWPGh",
      "jhBcNHtcOq",
      "WPiulW",
      "Dmk/gc7dPW",
      "cmkakmkhWOK",
      "WP/dGGG6WPq",
      "Eh1Xedu",
      "cxFdRSocWRu",
      "W7ddHSoxWPDE",
      "sSo+W7ddUdW",
      "bmk4hSkSWQa",
      "oSkclSkxWRy",
      "W5b9W6HI",
      "vXK2F8oB",
      "WQmJaSkWqa",
      "pmo/st7dLG",
      "W5xdGda",
      "smoOW4pdMYK",
      "DSk2mCkfWOC",
      "W5H3W6LKqq",
      "bLtdOSoVWO0",
      "seXGxwq",
      "W5zpW6tdHSoj",
      "W4NdNgiRcG",
      "DezCW6lcJW",
      "o8k6WP3dKde",
      "tevJ",
      "hCkojSkdWRO",
      "WO/dJCo6hq0",
      "emo8xd7dSq",
      "aJVdOSkOWOS",
      "vurH",
      "W4ldV8kAWQXh",
      "qmkfW7eggW",
      "WQtcQCohWO5B",
      "W59GW6PSwW",
      "WRhcI8oxWPTD",
      "bCoJW7ZdOCoF",
      "uL9Y",
      "aXWUwmo2",
      "gtmFWRyK",
      "ahVdPSkgWRm",
      "h3FdUmohWRO",
      "ihpdUmklWQ8",
      "WOZdIcmWhG",
      "lIPuWROu",
      "taeMwG",
      "jSkgW48iFa",
      "WRhcL8ooWP9a",
      "a2DwWR8m",
      "jmkAWOpdPJe",
      "mupcRaVdQa",
      "wmopW4VdGIi",
      "WQNcT8kkpea",
      "W5P+W6hdJmok",
      "W6CsBa",
      "mmk6kmkWWOq",
      "k8oMW5xdOCk1",
      "pmotW6BdUmkc",
      "qCknfdhdRq",
      "W4NdTXuncq",
      "zhzGFxu",
      "W7GfnCo/yW",
      "vvjbWRJdRW",
      "WR52vq",
      "vCoSW4FdHY4",
      "m8k6lSopW4G",
      "WQBcG8ofWRmQ",
      "W6JcS8kNW7dcGW",
      "WPDqut4Q",
      "s2yxWRuG",
      "AN9bW7VcPW",
      "twv6WOuT",
      "mM/cOCoOWRq",
      "eGPUW6RcMG",
      "W7Hmn8oG",
      "o8kEbCkWWRS",
      "jqZdImkOWOu",
      "W5rcW6bKyW",
      "fhFdUG",
      "jGZdGCkSWRu",
      "v0DrW6FcHW",
      "vxDlW7K",
      "aqGOW7VdUa",
      "tSo9W5ddKJG",
      "WOtdL8oiia4",
      "DMfWhxa",
      "BY5wWQ0u",
      "aSo1W7FdP8kH",
      "W4XMW7z9sG",
      "WPRcL3PZsGVdOWpcKchcLSkf",
      "C0H0W4RcLa",
      "WP4oWQxcRcK",
      "lSkzibHN",
      "zMVcSmk+W7a",
      "WPCmWOpcJZS",
      "gvuRtCoW",
      "dNZcMZ3cGG",
      "ySovW4JdHbK",
      "Cf7cReNcPa",
      "wCoyW6FdUcm",
      "kxZdJftcVa",
      "BrGBqCo8",
      "zuaAcCo4",
      "BmkoqCoHWPe",
      "x8otW5ldGtq",
      "d8o6sGRdJW",
      "W4ubm8oX",
      "WPCpWO/cLt0",
      "WPpcUCkpkG",
      "WQ7cRmkgyW",
      "E2LZWOhdSW",
      "W5LKxCobyq",
      "W58bW4FdLgW",
      "WOxcU8khWPvE",
      "DmopW7ldUf4",
      "W4/dT8omgmkY",
      "W68oW53dULm",
      "bCkPhSk1WRq",
      "WPZdJSk4tCo7",
    ];
    return (iy = function () {
      return t;
    })();
  }
  function ny(t, e, i, n, r) {
    return Cy(e - -961, r);
  }
  function ry(t, e, i, n, r) {
    return Cy(e - 805, n);
  }
  ey[ry(818, 2085, 2629, "y(aR")] =
    Q_ +
    (Wy("hzbI", 2262) +
      ny(0, 1284, 0, 0, "AF$5") +
      ry(2009, 3265, 2800, "wJeC"));
  const sy = {};
  (sy[ny(0, 246, 0, 0, "u)I4")] = -1),
    (sy[ny(0, -384, 0, 0, "AF$5")] = !1),
    (sy[my(1162, "^hAz", 1628)] = "v3"),
    (sy[uy(429, 2110, 985, 391, "^C2X") + ry(0, 1686, 0, "Dh8h")] = ""),
    (sy[
      ry(0, 1580, 0, "3%NO") +
        ny(0, -123, 0, 0, "dehg") +
        ny(0, -455, 0, 0, "FTF#")
    ] = my(2577, "AF$5", 2076) + ry(0, 1614, 0, "Dh8h") + ":;"),
    (sy[uy(1152, 2437, 1842, 2866, "Dh8h") + ry(0, 3231, 0, "x7um")] = Wy(
      "FAP3",
      1109
    )),
    (sy[Wy("Pbla", 54) + ry(0, 3530, 0, "l9RD") + ry(0, 3672, 0, "naYB")] = ey);
  const oy = {};
  oy.__ = sy;
  const ay = oy,
    ly = {};
  (ly[ny(0, -332, 0, 0, "5U(6") + "om"] = 19),
    (ly[ry(0, 3256, 0, "dehg") + "om"] = 4),
    (ly[ry(0, 2159, 0, "WJFM") + "e"] = !1);
  const hy = {};
  (hy[uy(2228, 1075, 1397, 1999, ")M@t")] = H_ + 3),
    (hy[my(1007, "V@QO", 1974)] = 120 + H_ - 20),
    (hy[uy(2549, 1228, 2373, 1659, "^$I&")] = 246 + H_ - 46),
    (hy[ny(0, 1901, 0, 0, "^C2X")] = "v3"),
    (hy[my(523, "naYB", 1248) + my(3528, "naYB", 2890)] = X_),
    (hy[
      ny(0, 1756, 0, 0, "]QDq") +
        uy(-834, 379, 157, 779, "bKzs") +
        ny(0, -345, 0, 0, "Dh8h")
    ] = Y_),
    (hy[ry(0, 2346, 0, "xk4v") + ry(0, 2578, 0, "FTF#")] =
      Wy("iTSE", 321) + "e8"),
    (hy[
      ry(0, 1564, 0, "WJFM") +
        uy(2709, 2226, 2159, 3260, "auw)") +
        ry(0, 1829, 0, "^$I&")
    ] = ly),
    (ay[V_[3]] = hy);
  const cy = {};
  function uy(t, e, i, n, r) {
    return Cy(i - -442, r);
  }
  (cy[ry(0, 3048, 0, "^hAz") + "om"] = 19),
    (cy[ny(0, 748, 0, 0, "%2K1") + "om"] = 4),
    (cy[ry(0, 1830, 0, "^hAz") + "e"] = !1);
  const dy = {};
  (dy[Wy("naYB", 2165)] = 2 + H_),
    (dy[uy(0, 0, 2199, 0, "x7um")] = 90 + H_ + 11),
    (dy[ny(0, 1682, 0, 0, "hzbI")] = 180 + H_ + 21),
    (dy[ny(0, -361, 0, 0, "AF$5")] = "v3"),
    (dy[Wy("g(zI", 615) + Wy("g(zI", 379)] = X_),
    (dy[uy(0, 0, 1041, 0, "qP[S") + Wy("wJeC", 1830) + my(4103, "AF$5", 3217)] =
      Y_),
    (dy[ry(0, 2156, 0, "5[3$") + Wy("FAP3", 1232)] = Wy("qDUP", 1923) + "ef"),
    (dy[
      my(2914, "Dh8h", 3197) +
        uy(0, 0, 251, 0, "j9*&") +
        uy(0, 0, 1592, 0, "FTF#")
    ] = cy),
    (ay[V_[2]] = dy);
  const gy = {};
  (gy[ry(0, 1631, 0, "G)uk") + "om"] = 21),
    (gy[uy(0, 0, 785, 0, "u)I4") + "om"] = 12),
    (gy[uy(0, 0, 1699, 0, "DA8@") + ny(0, 53, 0, 0, "lV]E")] = 500),
    (ay[
      O_([116, 114, 97, 102, 102, 105, 99, 45, 110, 101, 115, 104, 97, 110])
    ] = {
      code: k_(
        Wy("hbl9", 1768) + Wy("[VZg", 2343) + my(3434, "ptBd", 3416) + "53"
      ),
      sourceOptions: gy,
    });
  const fy = {};
  (fy[ry(0, 2552, 0, "ptBd") + "om"] = 19),
    (fy[my(1476, "AF$5", 2466) + "om"] = 4),
    (fy[ry(0, 2377, 0, "]QDq") + "e"] = !1);
  const py = {};
  function my(t, e, i, n, r) {
    return Cy(i - 801, e);
  }
  (py[ry(0, 1545, 0, "wJeC")] = 1 + H_),
    (py[uy(0, 0, 1472, 0, "wJeC")] = 100 + H_),
    (py[ry(0, 2640, 0, "3%NO")] = 200 + H_),
    (py[ry(0, 3313, 0, "Z5Ed")] = "v3"),
    (py[ny(0, -280, 0, 0, "vL@C") + Wy("r4s(", 402)] = X_),
    (py[Wy("lV]E", 1079) + Wy("AF$5", 1870) + my(0, "FAP3", 1947)] = Y_),
    (py[Wy("bKzs", 1569) + ny(0, 448, 0, 0, "RvbZ")] =
      uy(0, 0, 1196, 0, "Z5Ed") + "ef"),
    (py[Wy("5[3$", 285) + Wy("DA8@", 672) + ry(0, 2550, 0, "lV]E")] = fy),
    (ay[V_[1]] = py);
  const _y = {};
  (_y[my(0, "#Bat", 2203) + "om"] = 19),
    (_y[ry(0, 2032, 0, "u)I4") + "om"] = 4),
    (_y[Wy(")M@t", 1644) + "e"] = !1);
  const yy = {};
  (yy[ry(0, 1543, 0, "iTSE")] = H_),
    (yy[ry(0, 2349, 0, "ptBd")] = 100 + H_),
    (yy[Wy("6sU^", 1913)] = 300 + H_ - 100),
    (yy[my(0, "hbl9", 1982)] = "v3"),
    (yy[my(0, "g(zI", 1857) + ny(0, -118, 0, 0, "r4s(")] = X_),
    (yy[ny(0, 95, 0, 0, "g(zI") + Wy("5[3$", 1329) + my(0, "iTSE", 2036)] = Y_),
    (yy[uy(0, 0, 493, 0, "2XNM") + ry(0, 2291, 0, "5U(6")] =
      my(0, "hbl9", 2111) + "ef"),
    (yy[
      ry(0, 3201, 0, "Dh8h") +
        ny(0, 1920, 0, 0, "5[Ds") +
        ry(0, 3206, 0, "hzbI")
    ] = _y),
    (ay[V_[0]] = yy);
  const xy = {};
  (xy[uy(0, 0, 488, 0, "u)I4") + "om"] = 19),
    (xy[Wy("qDUP", 513) + "om"] = 4),
    (xy[uy(0, 0, 1469, 0, "a#*#") + "e"] = !1);
  const vy = {};
  (vy[my(0, "qP[S", 1253)] = 4 + H_),
    (vy[Wy("bKzs", 135)] = 90 + H_ + 12),
    (vy[my(0, "5[Ds", 2820)] = 180 + H_ + 22),
    (vy[Wy("j9*&", 1164)] = my(0, "RvbZ", 2983) + ry(0, 2496, 0, "[VZg")),
    (vy[ny(0, -280, 0, 0, "vL@C") + ry(0, 2538, 0, "j9*&")] = X_),
    (vy[ry(0, 2325, 0, "lV]E") + my(0, "hbl9", 2521) + Wy("ptBd", 2287)] = Y_),
    (vy[ny(0, -598, 0, 0, "AF$5") + uy(0, 0, 442, 0, "iTSE")] =
      Wy("%2K1", 2048) + "26"),
    (vy[
      ny(0, -525, 0, 0, "a#*#") +
        my(0, "qDUP", 1246) +
        ny(0, 1302, 0, 0, "hbl9")
    ] = xy),
    (ay[V_[4]] = vy);
  const Sy = {};
  function Cy(t, e) {
    const i = iy();
    return (
      (Cy = function (e, n) {
        let r = i[(e -= 349)];
        if (void 0 === Cy.UkiUVs) {
          const e = function (t, e) {
            let i,
              n,
              r = [],
              s = 0,
              o = "";
            for (
              t = (function (t) {
                let e = "",
                  i = "";
                for (
                  let i, n, r = 0, s = 0;
                  (n = t.charAt(s++));
                  ~n && ((i = r % 4 ? 64 * i + n : n), r++ % 4)
                    ? (e += String.fromCharCode(255 & (i >> ((-2 * r) & 6))))
                    : 0
                )
                  n =
                    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=".indexOf(
                      n
                    );
                for (let t = 0, n = e.length; t < n; t++)
                  i += "%" + ("00" + e.charCodeAt(t).toString(16)).slice(-2);
                return decodeURIComponent(i);
              })(t),
                n = 0;
              n < 256;
              n++
            )
              r[n] = n;
            for (n = 0; n < 256; n++)
              (s = (s + r[n] + e.charCodeAt(n % e.length)) % 256),
                (i = r[n]),
                (r[n] = r[s]),
                (r[s] = i);
            (n = 0), (s = 0);
            for (let e = 0; e < t.length; e++)
              (n = (n + 1) % 256),
                (s = (s + r[n]) % 256),
                (i = r[n]),
                (r[n] = r[s]),
                (r[s] = i),
                (o += String.fromCharCode(
                  t.charCodeAt(e) ^ r[(r[n] + r[s]) % 256]
                ));
            return o;
          };
          (Cy.erxMDM = e), (t = arguments), (Cy.UkiUVs = !0);
        }
        const s = e + i[0],
          o = t[s];
        return (
          o
            ? (r = o)
            : (void 0 === Cy.vLLBJK && (Cy.vLLBJK = !0),
              (r = Cy.erxMDM(r, n)),
              (t[s] = r)),
          r
        );
      }),
      Cy(t, e)
    );
  }
  (Sy[uy(0, 0, 2008, 0, "iTSE") + "om"] = 19),
    (Sy[my(0, "g(zI", 2937) + "om"] = 4),
    (Sy[ny(0, 1520, 0, 0, "y(aR") + "e"] = !1);
  const wy = {};
  function Wy(t, e, i, n, r) {
    return Cy(e - -441, t);
  }
  function Ey(t, e = !1, i = !1) {
    function n(t, e, i, n, r) {
      return ny(0, i - 630, 0, 0, e);
    }
    const r = {
      FgbNv: s(844, "g(zI"),
      ZAExA: l(3392, 2888, 2205, "u)I4") + n(0, "FTF#", 1945),
      XKLAp: o(2630, "hzbI", 2237, 2130),
      kxKhM: a(1204, "5[Ds", 2429, 1166, 2055),
      dFKhc: n(0, "Dh8h", 1808),
      OfnzA: o(1140, "3%NO", 1872, 2542),
      mwTwI: o(2298, "dehg", 2713, 1780),
      BjXNT:
        o(2416, "FTF#", 3181, 2018) +
        l(1599, 1198, 1930, "]QDq") +
        a(-705, "a#*#", 1405, -585, 561) +
        o(3024, "auw)", 2634, 2514) +
        s(1166, "WJFM"),
      KVsWG: a(-62, "xk4v", 1518, 560, 899),
      IoCtV: a(278, "a#*#", 2341, 2300, 1169) + "9",
      DnPWq: function (t, e) {
        return t + e;
      },
      nvunw: s(2754, "3%NO") + o(1635, "r4s(", 1389, 886),
      HwvSk: function (t, e) {
        return t(e);
      },
      Rmboc:
        l(1779, 1561, 1103, "2XNM") +
        a(43, "qDUP", -243, 95, 716) +
        n(0, "G)uk", 51) +
        s(2640, "5[Ds") +
        l(1732, 1822, 936, "hzbI") +
        s(627, "6sU^") +
        l(1207, 3087, 1843, "]QDq") +
        l(2881, 1225, 1798, "j9*&") +
        n(0, "5U(6", 1793) +
        o(1448, "ne@e", 2707, 3217) +
        o(3035, "^$I&", 3264, 4101) +
        s(818, "WJFM") +
        l(1881, 1257, 1221, "Dh8h") +
        n(0, "ptBd", 633) +
        s(2880, "qDUP") +
        n(0, "^hAz", 190) +
        a(656, "HpoK", 1308, 1699, 456) +
        o(2309, "y(aR", 3311, 3323) +
        l(3661, 3868, 2894, "xk4v") +
        o(3335, "waXB", 3215, 3559) +
        s(1675, "wJeC") +
        o(4928, "j9*&", 3760, 3124) +
        a(-303, "^C2X", 1403, 1927, 765) +
        a(1682, "^C2X", 3203, 3285, 2840) +
        a(2733, "HpoK", 2160, 2827, 2003) +
        s(2787, "vL@C") +
        l(2237, 1930, 3010, "iTSE") +
        o(1016, "WJFM", 1536, 1549) +
        s(2428, "y(aR") +
        o(4781, "HpoK", 3777, 4393) +
        a(1276, "hzbI", 2036, 1074, 1668) +
        o(1623, "FAP3", 2170, 2417) +
        a(3069, "bKzs", 4018, 2289, 2880) +
        l(3046, 3385, 3251, "G)uk") +
        n(0, "G)uk", 137) +
        o(2645, "3%NO", 3503, 2804) +
        l(84, 1261, 838, "FAP3") +
        n(0, "^hAz", 819) +
        a(2974, "hzbI", 1855, 2170, 2869) +
        o(2596, "g(zI", 3137, 2247) +
        l(4440, 1952, 3229, ")M@t") +
        l(486, 1629, 1146, "3%NO") +
        a(1545, "x7um", 498, 1367, 1440) +
        s(911, "^C2X") +
        s(1199, "r4s(") +
        s(1679, "G)uk") +
        o(2777, "a#*#", 1743, 1569) +
        l(2175, 2299, 1874, "u)I4") +
        o(2770, "2XNM", 1935, 1790) +
        n(0, "FTF#", 41) +
        o(4480, "5U(6", 3206, 3462),
      zvOGf: function (t, e) {
        return t < e;
      },
      BbHnz:
        o(2997, "5U(6", 3740, 4346) +
        n(0, "y(aR", 674) +
        n(0, "auw)", 1417) +
        l(2091, 3217, 3049, ")M@t") +
        a(2821, "3%NO", 2580, 2707, 1618) +
        o(2856, "xk4v", 3133, 4069) +
        s(1388, "V@QO") +
        a(-282, "G)uk", 505, 1556, 623) +
        a(2714, "iTSE", 2158, 2172, 1682) +
        n(0, "2XNM", 468) +
        a(1822, "Dh8h", 2301, 3309, 2232) +
        o(4590, "hzbI", 3341, 3014) +
        n(0, "x7um", 910) +
        a(720, "a#*#", 238, -178, 824) +
        n(0, "bKzs", 2239) +
        l(3675, 1453, 2674, "5U(6") +
        n(0, "lV]E", 576) +
        s(1365, "V@QO") +
        a(934, "WJFM", 2100, 1491, 1922) +
        l(757, 132, 1173, "^$I&") +
        o(1244, "%2K1", 2184, 958) +
        l(2078, 259, 1521, "j9*&") +
        o(811, "RvbZ", 1391, 499) +
        n(0, "Z5Ed", 1552) +
        a(1372, "FTF#", 1847, -16, 1142) +
        l(2518, 3380, 2470, "bKzs") +
        a(3145, "%2K1", 2022, 3446, 2215) +
        a(1009, "HpoK", 1408, 212, 1059) +
        l(2586, 2131, 2295, "a#*#") +
        l(1500, 2174, 1961, "xk4v") +
        o(757, "WJFM", 1662, 1855) +
        l(1384, 2382, 1682, "x7um") +
        n(0, "j9*&", 2477) +
        s(989, "dehg") +
        n(0, "a#*#", 2045) +
        s(1868, "WJFM") +
        o(3215, "hzbI", 2902, 3568) +
        l(625, 2353, 1392, "xk4v") +
        l(2106, 2433, 2088, ")M@t") +
        a(1501, "6sU^", 1613, 2628, 2336) +
        n(0, "^C2X", 193) +
        a(1258, "auw)", 64, -562, 575) +
        l(4125, 1976, 3053, "g(zI") +
        l(264, 2070, 1534, "lV]E") +
        l(1442, 1933, 2130, "FAP3") +
        n(0, "[VZg", 2020) +
        s(641, "naYB") +
        s(2702, "hbl9") +
        o(936, "Dh8h", 2128, 1506) +
        a(626, "2XNM", 508, 2599, 1551) +
        ">",
      GIICg:
        a(2027, "HpoK", 1926, 1895, 1101) +
        l(840, 107, 1021, "Z5Ed") +
        l(2100, 1713, 2218, "auw)") +
        s(2350, "j9*&") +
        l(1939, 271, 819, "5[Ds") +
        a(1049, "6sU^", 2390, 3148, 1905) +
        s(2926, "]QDq") +
        o(1735, "j9*&", 2857, 2984) +
        l(1401, 315, 1341, "^C2X") +
        l(1413, 2234, 1701, "xk4v") +
        l(2895, 2658, 1812, "lV]E") +
        a(1665, "%2K1", -386, 869, 822) +
        n(0, "^C2X", 156) +
        s(770, "a#*#") +
        o(2617, "HpoK", 2319, 1903) +
        n(0, "^C2X", 892) +
        o(2551, ")M@t", 2373, 3456) +
        o(2017, "2XNM", 1935, 1073) +
        n(0, "xk4v", 475) +
        n(0, "Dh8h", 21) +
        n(0, "waXB", 209) +
        o(1604, "#Bat", 2305, 1061) +
        o(2113, "FAP3", 2750, 2175) +
        o(1374, "5[Ds", 2354, 3514) +
        a(2069, "%2K1", 1806, 1851, 2433) +
        n(0, "^$I&", 2206) +
        s(2519, "y(aR") +
        n(0, "iTSE", 1383) +
        s(545, "5[3$") +
        l(1879, 1690, 2526, "g(zI") +
        o(2876, "]QDq", 3318, 4367) +
        n(0, "Z5Ed", 1666) +
        s(2156, "y(aR") +
        s(1609, "Z5Ed") +
        l(1828, 2111, 1135, "wJeC") +
        n(0, "Z5Ed", 2431) +
        n(0, "WJFM", 35) +
        l(1198, 484, 1113, "FTF#") +
        s(2728, "G)uk") +
        o(231, "2XNM", 1481, 2220) +
        l(2815, 1952, 1542, "hbl9") +
        a(1470, "l9RD", -75, 1105, 801) +
        o(1467, "Pbla", 2548, 2281) +
        a(337, "Dh8h", 830, 1064, 844) +
        o(2793, "ptBd", 2803, 3578) +
        l(533, 1565, 1476, "ptBd") +
        n(0, "5[3$", 1421) +
        l(281, 489, 873, "dehg") +
        n(0, "wJeC", 1304) +
        n(0, "WJFM", 374) +
        ">",
      RzYpT: s(1141, "HpoK"),
      ViJvn:
        s(2573, "RvbZ") +
        n(0, "hbl9", 1133) +
        a(783, "WJFM", 406, 1666, 1272) +
        o(4768, "qP[S", 3750, 3543) +
        l(861, 208, 1261, "hbl9") +
        l(2225, 3154, 2346, "%2K1") +
        a(2376, "qDUP", 1010, 2579, 1533) +
        n(0, "#Bat", 2501) +
        n(0, "WJFM", 1426) +
        s(2130, "^C2X") +
        o(1856, "l9RD", 2708, 3252) +
        o(1707, "6sU^", 2420, 2508) +
        n(0, "g(zI", 1125) +
        a(2874, "FTF#", 2341, 3234, 2656) +
        o(2704, "[VZg", 1816, 3067) +
        n(0, "naYB", 2456) +
        l(1898, -82, 932, "waXB") +
        l(4075, 2725, 3202, "auw)") +
        s(1191, "waXB") +
        a(967, "%2K1", 1963, 705, 971) +
        n(0, "2XNM", 1094) +
        l(2305, 2536, 2843, "ptBd") +
        o(2907, "naYB", 2699, 1946) +
        o(745, "ne@e", 1496, 1303) +
        a(3533, "WJFM", 3922, 2896, 2986) +
        a(1080, "^hAz", 1973, 1465, 2221) +
        s(2183, ")M@t") +
        o(2027, "HpoK", 3171, 3402) +
        a(483, "DA8@", 1999, -196, 886) +
        o(3208, "%2K1", 3105, 2071) +
        s(926, "[VZg") +
        a(2771, "a#*#", 2484, 3558, 2787) +
        l(209, 2e3, 869, "WJFM") +
        n(0, "6sU^", 1215) +
        n(0, "]QDq", 1616) +
        o(2673, "vL@C", 2280, 1225) +
        l(491, 2757, 1676, "^$I&") +
        l(2769, 1319, 2315, "y(aR") +
        s(2542, "^hAz") +
        o(2591, "2XNM", 2838, 2563) +
        n(0, "bKzs", 1394) +
        n(0, "j9*&", 1862) +
        n(0, "AF$5", 995) +
        o(2589, "3%NO", 3719, 4211) +
        o(2610, "g(zI", 1938, 1567) +
        s(2384, "waXB") +
        l(458, -308, 859, "hzbI") +
        s(2442, "ptBd") +
        n(0, "]QDq", 1325) +
        a(968, "u)I4", 708, 75, 1254) +
        n(0, "#Bat", 2516) +
        n(0, "hzbI", 2173) +
        s(2912, "5[Ds") +
        "t;",
      izkiY: o(3107, "Pbla", 3359, 4322),
      KpThR:
        n(0, "5[Ds", 1750) +
        a(1177, "r4s(", 2092, 3165, 2380) +
        n(0, "V@QO", 377) +
        a(1586, "a#*#", -179, 1007, 1088) +
        o(1530, "#Bat", 2534, 2408) +
        a(672, "%2K1", 751, 2784, 1709) +
        o(2437, "ptBd", 3544, 2724) +
        a(-345, "hzbI", -223, 711, 728) +
        l(133, 981, 847, "3%NO") +
        s(1944, "r4s(") +
        s(1971, "naYB"),
      pbRMa:
        a(1746, "FAP3", 1675, 1517, 675) +
        o(3492, "dehg", 2295, 2755) +
        a(2996, "qP[S", 2410, 2222, 2910) +
        l(1721, 3158, 1884, "ne@e") +
        s(998, "y(aR"),
      NJTnb:
        n(0, "^C2X", 2465) +
        s(2587, "HpoK") +
        a(1190, "DA8@", 2138, 532, 1051) +
        n(0, "dehg", 2379) +
        a(2322, "WJFM", 794, 133, 1064) +
        n(0, "qP[S", 2227) +
        n(0, "%2K1", 2451) +
        o(3561, "%2K1", 3245, 2823) +
        a(1311, "waXB", 3117, 2772, 2393) +
        l(2283, 2852, 2832, "lV]E") +
        a(2140, "g(zI", 2541, 2502, 1352) +
        s(759, "FAP3") +
        a(136, "ptBd", 338, 685, 628) +
        o(1673, "#Bat", 2390, 1945) +
        a(2322, "hbl9", 3118, 2501, 2624) +
        s(467, "lV]E") +
        n(0, "j9*&", 281) +
        n(0, "#Bat", 1867) +
        a(625, "hbl9", -446, -312, 527) +
        a(2809, "dehg", 2499, 2398, 2010) +
        a(-672, "FAP3", -759, 634, 462) +
        l(508, 1672, 863, "^$I&") +
        l(2373, 1921, 2457, "HpoK") +
        o(3048, "a#*#", 2157, 994) +
        n(0, "DA8@", 1619) +
        o(2361, "[VZg", 2122, 1921) +
        l(594, 2355, 1344, "Pbla") +
        s(688, "HpoK") +
        s(1920, "a#*#") +
        s(1805, "y(aR") +
        n(0, "ptBd", 426) +
        o(535, "j9*&", 1797, 653) +
        n(0, "naYB", 1875),
      tHdyc: function (t, e) {
        return t + e;
      },
      gPgHf: function (t, e) {
        return t + e;
      },
      NqtkC:
        n(0, "5[Ds", 943) +
        n(0, "Dh8h", 1030) +
        s(1588, "FAP3") +
        l(535, 1155, 1284, "hbl9") +
        n(0, "qDUP", 813),
      oFwJh: function (t, e) {
        return t + e;
      },
      MKFaa:
        l(3055, 2297, 3178, "^C2X") +
        a(556, "x7um", 2290, 2288, 1494) +
        l(591, 2032, 1572, "naYB") +
        s(1533, "G)uk") +
        s(2071, "%2K1") +
        s(2516, "HpoK") +
        n(0, "ne@e", 522),
      xagVE: n(0, "a#*#", 966) + "n>",
      gGDAK: function (t, e, i) {
        return t(e, i);
      },
      kBhEm: s(679, "WJFM"),
      bDVAu: function (t, e) {
        return t !== e;
      },
      JxgnM: o(3508, "5[3$", 2265, 3528),
      IPfFE: a(846, "waXB", 2673, 735, 1942),
      Gddmr: function (t, e) {
        return t === e;
      },
      OnrDa: s(2756, "vL@C"),
      ZmOhr: l(2350, 1202, 1458, "]QDq"),
      YvMzU: a(1418, "qDUP", 2646, 2458, 1480),
      AAXLf: function (t, e) {
        return t === e;
      },
      ZonnH: a(2536, "HpoK", 3252, 1848, 2382),
      yiQPx: o(3014, "auw)", 3031, 4248),
      HxJSh: function (t, e) {
        return t !== e;
      },
      YouAi: s(2415, "DA8@"),
      lTSPf: function (t, e) {
        return t(e);
      },
      hMoQA: l(102, 32, 1271, "Z5Ed"),
      vosOQ: s(454, "y(aR"),
      Wdsof: s(1699, "]QDq") + "el",
      XNLZk: function (t, e, i) {
        return t(e, i);
      },
      WecMi: function (t, e) {
        return t + e;
      },
      YSNyQ:
        n(0, "r4s(", 66) +
        l(3796, 3733, 2989, "iTSE") +
        s(1149, "qP[S") +
        o(1956, "HpoK", 1376, 1257) +
        l(3025, 3235, 3299, "a#*#") +
        n(0, "5U(6", 2380) +
        n(0, "ne@e", 349),
      NPKIG: o(1466, "qP[S", 2159, 1489) + l(4227, 3274, 3031, "auw)") + ".",
      qIkey:
        o(975, "#Bat", 1626, 451) +
        o(923, "r4s(", 1660, 996) +
        n(0, "5[3$", 169),
      cdYDx: function (t, e) {
        return t === e;
      },
      AtzOz: n(0, "y(aR", 1562),
      otOJh: function (t, e) {
        return t + e;
      },
      uNmxJ: function (t, e) {
        return t + e;
      },
      PCvur: function (t, e) {
        return t + e;
      },
      aLnVz: l(3111, 3853, 2827, "V@QO"),
      tYVMS: function (t, e) {
        return t + e;
      },
      YTAwc: function (t, e) {
        return t + e;
      },
      bnJuK: s(2202, "r4s("),
      eRWOp: o(3264, "auw)", 3235, 3423) + "f",
      MUqnT: n(0, "3%NO", 1742),
      lBkgp: l(1340, 3177, 2204, "auw)"),
      Jjaer: function (t, e) {
        return t + e;
      },
      RNhYa: function (t, e) {
        return t + e;
      },
      kboCa: function (t, e) {
        return t(e);
      },
      WQIrr: n(0, "%2K1", 2101),
      dhHYz: o(2545, "naYB", 3328, 4304),
      bjqDe: o(3022, "dehg", 2823, 2983),
      yrxYl: function (t, e) {
        return t(e);
      },
      nlCTD: o(2264, "FAP3", 2127, 1753),
      YUbZx: function (t, e) {
        return t(e);
      },
      snicY: function (t, e) {
        return t + e;
      },
      LyTGf: function (t, e) {
        return t + e;
      },
      YoZcb: s(2301, "qP[S"),
    };
    function s(t, e, i, n, r) {
      return my(0, e, t - -761);
    }
    function o(t, e, i, n, r) {
      return uy(0, 0, i - 1348, 0, e);
    }
    function a(t, e, i, n, r) {
      return uy(0, 0, r - 536, 0, e);
    }
    function l(t, e, i, n, r) {
      return ry(0, i - -335, 0, n);
    }
    return new Promise((i) => {
      function s(t, e, i, r, s) {
        return n(0, r, s - -525);
      }
      function o(t, e, i, r, s) {
        return n(0, e, r - 148);
      }
      function a(t, e, i, n, r) {
        return l(0, 0, n - -1328, t);
      }
      function h(t, e, i, r, s) {
        return n(0, s, t - 892);
      }
      const c = {
        ECfWK: r[o(0, "AF$5", 0, 1841)],
        aGfZb: r[u(467, 1458, 2097, "2XNM")],
        QXxPF: function (t, e, i) {
          return r[
            ((n = 2395),
            (s = "Pbla"),
            (o = 2310),
            u(n - 470, o - -53, s - 323, s))
          ](t, e, i);
          var n, s, o;
        },
        eYPiq: function (t, e) {
          return r[
            ((i = 1855),
            (n = 2711),
            (s = 3848),
            (o = "FAP3"),
            u(i - 40, n - -356, s - 405, o))
          ](t, e);
          var i, n, s, o;
        },
        LfXFb: r[u(4151, 3401, 2337, "HpoK")],
        rOcNu: r[o(0, "j9*&", 0, 274)],
        fmoxy: r[o(0, "G)uk", 0, 321)],
        JckRS: r[a("ptBd", 0, 0, 314)],
      };
      function u(t, e, i, n, r) {
        return l(0, 0, e - 132, n);
      }
      if (
        r[s(0, 0, 0, "naYB", 1883)](
          r[h(1551, 0, 0, 0, "5[3$")],
          r[a("dehg", 0, 0, 142)]
        )
      ) {
        let n = new XMLHttpRequest();
        const l = r[h(2689, 0, 0, 0, "u)I4")](
          r[u(0, 1423, 0, "WJFM")](
            e
              ? r[a("^$I&", 0, 0, 519)](
                  r[a("hzbI", 0, 0, -8)](
                    r[u(0, 1781, 0, "ne@e")](
                      r[o(0, "waXB", 0, 2382)](K_, r[s(0, 0, 0, "^C2X", -263)]),
                      Z_
                    ),
                    "/"
                  ),
                  r[u(0, 3183, 0, "WJFM")](
                    G_,
                    r[u(0, 2071, 0, "a#*#")](
                      r[u(0, 3459, 0, "dehg")](
                        r[u(0, 2771, 0, "WJFM")](
                          r[s(0, 0, 0, "^C2X", 1539)](
                            r[a("G)uk", 0, 0, 351)],
                            r[s(0, 0, 0, "iTSE", 1700)]
                          ),
                          "fa"
                        ),
                        r[s(0, 0, 0, "dehg", 466)]
                      ),
                      r[a("FTF#", 0, 0, -473)]
                    )
                  )
                )
              : r[a("Dh8h", 0, 0, -464)](
                  r[h(2609, 0, 0, 0, "a#*#")](
                    r[u(0, 2935, 0, "3%NO")](
                      r[h(1899, 0, 0, 0, "r4s(")](
                        K_,
                        r[s(0, 0, 0, "#Bat", -1)]
                      ),
                      Z_
                    ),
                    "/"
                  ),
                  r[h(1882, 0, 0, 0, "a#*#")](
                    G_,
                    r[s(0, 0, 0, "[VZg", 1378)](
                      r[h(2119, 0, 0, 0, "Z5Ed")],
                      r[o(0, ")M@t", 0, 2614)]
                    )
                  )
                ),
            r[a("waXB", 0, 0, 1147)]
          ),
          Date[a("y(aR", 0, 0, 502)]()
        );
        n[a("Z5Ed", 0, 0, 1238)](
          r[o(0, "x7um", 0, 1108)](G_, r[a("Pbla", 0, 0, 1687)]),
          l
        ),
          n[
            u(0, 2416, 0, "lV]E") +
              s(0, 0, 0, "ne@e", 103) +
              u(0, 1858, 0, "vL@C") +
              "r"
          ](
            r[o(0, "^hAz", 0, 208)](
              G_,
              r[h(1690, 0, 0, 0, "#Bat")](
                r[u(0, 2402, 0, "xk4v")]("ye", r[h(1798, 0, 0, 0, "Pbla")]),
                "pA"
              )
            ),
            t
          ),
          (n[o(0, "Z5Ed", 0, 2106) + "d"] = function () {
            function t(t, e, i, n, r) {
              return u(0, t - 128, 0, e);
            }
            function e(t, e, i, n, r) {
              return h(t - -37, 0, 0, 0, n);
            }
            function s(t, e, i, n, r) {
              return o(0, n, 0, e - 434);
            }
            function a(t, e, i, n, r) {
              return h(t - -700, 0, 0, 0, r);
            }
            function l(t, e, i, n, r) {
              return o(0, i, 0, e - -26);
            }
            const d = {
              WjPTD: r[t(1390, "[VZg")],
              hrwKz: r[a(928, 0, 0, 0, "auw)")],
              VmnBQ: r[s(0, 915, 0, "Dh8h")],
              aABBm: r[s(0, 2964, 0, "waXB")],
              KOkoa: r[t(2835, ")M@t")],
              zDzXh: r[t(3500, "3%NO")],
              wPlip: r[l(0, 202, "^$I&")],
              QdPqK: r[e(1712, 0, 0, "waXB")],
              AvmDQ: r[a(249, 0, 0, 0, ")M@t")],
              dsqts: r[l(0, 223, "5[Ds")],
              EbYeW: function (t, e) {
                return r[((i = "[VZg"), (n = 1164), s(0, n - -1219, 0, i))](
                  t,
                  e
                );
                var i, n;
              },
              enQKB: r[l(0, 2660, "u)I4")],
              hxEFl: function (e, i) {
                return r[((n = 1056), (s = "bKzs"), t(n - -191, s))](e, i);
                var n, s;
              },
              qwVpw: r[e(2488, 0, 0, "5[3$")],
              UhyCC: function (t, e) {
                return r[((i = 2596), (n = "ptBd"), l(0, i - 880, n))](t, e);
                var i, n;
              },
              FNMVi: r[t(2615, "V@QO")],
              ijIXV: r[e(2177, 0, 0, "j9*&")],
              FPjhH: r[a(1188, 0, 0, 0, "hbl9")],
              iHCki: r[t(1845, "lV]E")],
              YUhlb: r[e(2296, 0, 0, "u)I4")],
              MHCgx: r[e(2736, 0, 0, "3%NO")],
              updVG: r[s(0, 2756, 0, "auw)")],
              ZbApS: r[e(3191, 0, 0, "^$I&")],
              iVBWD: function (e, i) {
                return r[((n = 1854), (s = "#Bat"), t(n - -1714, s))](e, i);
                var n, s;
              },
              cWhWh: function (t, e) {
                return r[((i = 540), (n = "vL@C"), a(i - -119, 0, 0, 0, n))](
                  t,
                  e
                );
                var i, n;
              },
              twuMx: function (t, e) {
                return r[((i = "AF$5"), (n = 1706), l(0, n - 447, i))](t, e);
                var i, n;
              },
              AkdUk: function (t, e) {
                return r[((i = 1460), (n = "lV]E"), a(i - -715, 0, 0, 0, n))](
                  t,
                  e
                );
                var i, n;
              },
              npINy: r[e(2220, 0, 0, "r4s(")],
              kDkJA: function (t, e) {
                return r[((i = "Dh8h"), (n = -127), a(n - -679, 0, 0, 0, i))](
                  t,
                  e
                );
                var i, n;
              },
              GFmWO: function (t, i) {
                return r[((n = "hbl9"), (s = 1891), e(s - -895, 0, 0, n))](
                  t,
                  i
                );
                var n, s;
              },
              gVgle: function (t, i) {
                return r[((n = "Dh8h"), (s = 545), e(s - -728, 0, 0, n))](t, i);
                var n, s;
              },
              acUWI: r[l(0, 715, "qP[S")],
              vTkKn: r[a(2518, 0, 0, 0, "x7um")],
              OWsyM: function (t, e, i) {
                return r[((n = "5U(6"), (s = 1124), l(0, s - -463, n))](
                  t,
                  e,
                  i
                );
                var n, s;
              },
              DnZdc: r[s(0, 1819, 0, "vL@C")],
            };
            if (
              r[a(373, 0, 0, 0, ")M@t")](
                r[a(865, 0, 0, 0, "AF$5")],
                r[t(3370, "r4s(")]
              )
            ) {
              let o, h;
              try {
                if (
                  r[a(1364, 0, 0, 0, "DA8@")](
                    r[l(0, 2533, "ne@e")],
                    r[a(1538, 0, 0, 0, "waXB")]
                  )
                ) {
                  let i,
                    n = "";
                  const r = _0x3a9cc0[
                    e(1589, 0, 0, "wJeC") + t(2479, "5[3$") + l(0, 322, "wJeC")
                  ](d[a(470, 0, 0, 0, "xk4v")]);
                  return (
                    (r[t(2070, "auw)")][
                      t(2454, "hzbI") + a(1193, 0, 0, 0, "xk4v")
                    ] = d[l(0, 2138, "DA8@")]),
                    (r[a(2739, 0, 0, 0, "^$I&")][e(2502, 0, 0, "x7um") + "m"] =
                      d[l(0, 716, "5[3$")]),
                    (r[s(0, 1668, 0, "lV]E")][e(2051, 0, 0, "j9*&")] =
                      d[t(2997, "y(aR")]),
                    (r[s(0, 2260, 0, "Z5Ed")][s(0, 1040, 0, "FTF#")] =
                      d[l(0, 940, "hbl9")]),
                    (r[e(3402, 0, 0, "^$I&")][
                      s(0, 2922, 0, "j9*&") + l(0, 2204, "5[3$")
                    ] = d[t(2557, "g(zI")]),
                    (r[e(1230, 0, 0, "a#*#")][
                      a(1043, 0, 0, 0, "DA8@") + s(0, 1079, 0, "Z5Ed")
                    ] = d[e(3418, 0, 0, "FAP3")]),
                    (r[l(0, 254, "G)uk")][
                      t(3251, "l9RD") + s(0, 913, 0, "[VZg")
                    ] = d[a(1889, 0, 0, 0, "3%NO")]),
                    (r[t(2809, "FTF#")][
                      a(426, 0, 0, 0, "Pbla") + e(2967, 0, 0, "Pbla")
                    ] = d[a(1477, 0, 0, 0, "waXB")]),
                    (r[l(0, 1488, "qDUP")][e(2045, 0, 0, "y(aR") + "x"] =
                      d[l(0, 2545, "y(aR")]),
                    (n += d[l(0, 1083, "5[Ds")](
                      d[t(1493, "iTSE")](
                        d[t(2259, "vL@C")](
                          d[e(1018, 0, 0, "ne@e")](
                            d[a(1159, 0, 0, 0, "j9*&")],
                            _0x758515
                          ),
                          d[l(0, 2118, "]QDq")](
                            _0x526cf7,
                            [109, 97, 112, 115, 46]
                          )
                        ),
                        _0x36828e
                      ),
                      d[a(1624, 0, 0, 0, "RvbZ")]
                    )),
                    d[l(0, 2482, "#Bat")](
                      _0x57feb2[
                        e(2854, 0, 0, "2XNM") +
                          l(0, 2615, "naYB") +
                          s(0, 1058, 0, "wJeC")
                      ][s(0, 892, 0, "j9*&") + a(1660, 0, 0, 0, "lV]E") + "h"],
                      800
                    )
                      ? (n += d[e(2995, 0, 0, "5U(6")])
                      : (n += d[t(1312, "^hAz")]),
                    (n += d[e(1441, 0, 0, "bKzs")]),
                    (i = d[t(1137, "DA8@")]),
                    (i += _0x9d3d95[d[t(3565, "y(aR")]]
                      ? d[s(0, 2083, 0, "hbl9")]
                      : d[l(0, 302, "6sU^")]),
                    (n += d[a(2040, 0, 0, 0, "G)uk")]),
                    (n += d[t(3e3, "Pbla")](
                      d[e(1542, 0, 0, "]QDq")](
                        d[s(0, 2114, 0, "V@QO")](
                          d[t(1496, "waXB")](
                            d[e(2143, 0, 0, "3%NO")](
                              d[t(1348, "%2K1")](
                                d[l(0, 561, "6sU^")],
                                _0x1e647d
                              ),
                              ""
                            ),
                            _0x4eae5c
                          ),
                          d[l(0, 655, "5[Ds")]
                        ),
                        i
                      ),
                      '">'
                    )),
                    (n += d[s(0, 1394, 0, "iTSE")](
                      _0x11c92a,
                      [38, 99, 111, 112, 121, 59, 78, 101, 115, 104, 97, 110]
                    )),
                    (n += d[a(2498, 0, 0, 0, "xk4v")]),
                    (n += " "),
                    (n += d[s(0, 3140, 0, "G)uk")](
                      d[s(0, 969, 0, "HpoK")](d[e(2879, 0, 0, "waXB")], i),
                      '">'
                    )),
                    (n += d[t(3104, "G)uk")]),
                    (n += d[s(0, 1933, 0, "2XNM")]),
                    (r[s(0, 2468, 0, "DA8@") + e(2772, 0, 0, "6sU^")] = n),
                    r
                  );
                }
                (o = JSON[t(1634, "l9RD")](
                  n[t(1520, "[VZg") + l(0, 943, "Z5Ed")]
                )) &&
                  o &&
                  (h = o[a(584, 0, 0, 0, "r4s(") + "ge"]) &&
                  r[a(251, 0, 0, 0, "5[3$")](A_, h, r[s(0, 1143, 0, "x7um")]);
              } catch (t) {}
              if (
                r[a(2229, 0, 0, 0, "y(aR")](n[e(1476, 0, 0, "5U(6") + "s"], 204)
              )
                if (
                  r[s(0, 2840, 0, "dehg")](
                    r[t(2900, "waXB")],
                    r[e(1317, 0, 0, "2XNM")]
                  )
                ) {
                  this[
                    t(1547, "a#*#") +
                      e(942, 0, 0, "iTSE") +
                      a(2108, 0, 0, 0, "lV]E")
                  ](
                    _0x509dce,
                    _0x166db4[a(2609, 0, 0, 0, "hzbI") + s(0, 2288, 0, "ptBd")],
                    _0x596984
                  );
                  const i = new _0x599d83({
                    zIndex: -9997,
                    useInterimTilesOnError: !1,
                    source: new _0x525c4e(_0x4a2211),
                  });
                  _0x2c852e[
                    t(3233, "^$I&") +
                      e(1517, 0, 0, "HpoK") +
                      a(572, 0, 0, 0, "auw)")
                  ](i[e(2776, 0, 0, "a#*#") + "s_"], c[t(2731, "lV]E")], {
                    value: c[a(515, 0, 0, 0, "x7um")],
                    writable: !1,
                  }),
                    this[l(0, 2290, "ne@e") + e(3099, 0, 0, "^$I&")](i);
                } else {
                  const n = {};
                  (n[t(2162, "j9*&") + "d"] = !0),
                    r[e(1356, 0, 0, "G)uk")](i, n);
                }
              else if (
                r[t(3558, "ptBd")](
                  r[l(0, 1885, "xk4v")],
                  r[s(0, 1466, 0, "^C2X")]
                )
              )
                _0x441b83[
                  l(0, 693, "u)I4") +
                    s(0, 2399, 0, "xk4v") +
                    s(0, 700, 0, "u)I4")
                ](_0x3baf86) && (_0x3d3faa[_0x475a78] = _0x44420a[_0x10b0cb]);
              else {
                const e = {};
                (e[t(1675, "bKzs") + "d"] = !1), r[l(0, 2562, ")M@t")](i, e);
              }
            } else
              d[e(2631, 0, 0, "y(aR")](
                _0x400f66,
                _0x2b56c7[
                  e(3076, 0, 0, "FTF#") +
                    e(3221, 0, 0, "Dh8h") +
                    e(1308, 0, 0, "dehg") +
                    l(0, 801, "HpoK")
                ](d[s(0, 1172, 0, "DA8@")]),
                !0
              );
          }),
          (n[h(1700, 0, 0, 0, "5[3$") + "or"] = function () {
            function t(t, e, i, n, r) {
              return a(t, 0, 0, n - 242);
            }
            function e(t, e, i, n, r) {
              return a(n, 0, 0, e - 321);
            }
            function n(t, e, i, n, r) {
              return s(0, 0, 0, r, t - 49);
            }
            if (
              !r[t("l9RD", 0, 0, 1065)](
                r[n(-236, 0, 0, 0, "FAP3")],
                r[t(")M@t", 0, 0, 899)]
              )
            )
              return (
                c[e(0, -44, 0, "#Bat")](
                  _0x2fde75,
                  c[e(0, 1849, 0, "bKzs")](
                    c[e(0, 1806, 0, "g(zI")](
                      c[n(83, 0, 0, 0, "r4s(")](
                        c[t("qDUP", 0, 0, 2034)],
                        _0x76cf97
                      ),
                      c[e(0, 150, 0, "iTSE")]
                    ),
                    _0x40e13d
                  ),
                  c[e(0, 2198, 0, "#Bat")]
                ),
                !1
              );
            {
              const t = {};
              (t[((o = 874), (l = "]QDq"), u(0, o - -1361, 0, l) + "d")] = !0),
                r[e(0, 257, 0, "iTSE")](i, t);
            }
            var o, l;
          }),
          n[o(0, "G)uk", 0, 1113)]();
      } else
        this[
          h(2744, 0, 0, 0, "waXB") + a("Z5Ed", 0, 0, 992) + a("DA8@", 0, 0, 893)
        ](
          _0x31dbd3,
          _0x23bc00[c[s(0, 0, 0, "#Bat", -4)]][h(1536, 0, 0, 0, "3%NO")],
          _0x528a9d
        );
    });
  }
  function Ry(t) {
    const e = {};
    function i(t, e, i, n, r) {
      return Wy(i, r - 6);
    }
    function n(t, e, i, n, r) {
      return ry(0, i - -940, 0, t);
    }
    function r(t, e, i, n, r) {
      return my(0, e, r - -571);
    }
    function s(t, e, i, n, r) {
      return ny(0, e - 742, 0, 0, t);
    }
    function o(t, e, i, n, r) {
      return uy(0, 0, r - 706, 0, n);
    }
    (e[s("y(aR", 719)] = o(0, 0, 0, "hzbI", 693) + o(0, 0, 0, "Pbla", 1672)),
      (e[s("RvbZ", 418)] = i(0, 0, "Pbla", 0, 1135) + "el"),
      (e[o(0, 0, 0, "u)I4", 1594)] = o(0, 0, 0, "hbl9", 1548)),
      (e[n("g(zI", 0, 998)] =
        r(0, "3%NO", 0, 0, 2903) + i(0, 0, "^C2X", 0, 375)),
      (e[o(0, 0, 0, "V@QO", 2841)] = n("Z5Ed", 0, 1886));
    const a = e;
    return [
      a[r(0, "r4s(", 0, 0, 1170)],
      a[s("qDUP", 2011)],
      a[r(0, ")M@t", 0, 0, 1503)],
      a[o(0, 0, 0, "]QDq", 2513)],
    ][n("wJeC", 0, 1051) + n("#Bat", 0, 1035)](
      t[o(0, 0, 0, "6sU^", 1893)](a[i(0, 0, "auw)", 0, 1014)])
    );
  }
  (wy[Wy("Pbla", 2442)] = H_ - 98),
    (wy[ny(0, 212, 0, 0, "V@QO")] = !1),
    (wy[ny(0, 83, 0, 0, "a#*#")] = "v3"),
    (wy[my(0, "g(zI", 1857) + ny(0, -521, 0, 0, "5[Ds")] = X_),
    (wy[my(0, "l9RD", 1652) + my(0, "r4s(", 1664) + ry(0, 3332, 0, ")M@t")] =
      Y_),
    (wy[ny(0, 1235, 0, 0, "l9RD") + Wy("V@QO", 2126)] = Wy("Dh8h", 761) + "fe"),
    (wy[
      ny(0, 1435, 0, 0, "Dh8h") + Wy("wJeC", 1883) + ny(0, -487, 0, 0, "y(aR")
    ] = Sy),
    (ay[V_[5]] = wy);
  class Ty extends L_ {
    constructor(t) {
      const e = {
        kjkzc: function (t, e, i) {
          return t(e, i);
        },
        ygbyo: r(2425, "Pbla", 2741),
        kXNuL: function (t, e) {
          return t(e);
        },
        tumzL: function (t, e) {
          return t + e;
        },
        meeyM: function (t, e) {
          return t === e;
        },
        WJVOY: function (t, e) {
          return t % e;
        },
        VLEWF: function (t, e, i, n, r, s) {
          return t(e, i, n, r, s);
        },
        pydCp: s(805, 902, 569, "ne@e"),
        gmahs: s(-1188, -157, 898, "3%NO"),
        gvolj: i(2843, "vL@C", 2267, 2732),
        kozeu:
          i(1861, "qP[S", 2205, 2240) +
          r(2568, "3%NO", 1450) +
          o(2235, 2895, 2424, 2784, "Z5Ed") +
          o(1178, 2274, 1496, 2004, "FTF#") +
          "-",
        sHWbN: s(986, 2117, 1233, "HpoK") + n(510, 1507, 268, "u)I4"),
        HjGtG: o(895, 1595, 685, 1602, "j9*&"),
        VAehu: n(2716, 3228, 2547, "FTF#"),
        OOFmT: function (t, e, i, n) {
          return t(e, i, n);
        },
        LqKwa: i(2866, "3%NO", 2740, 2371),
        eLAfr: n(3546, 2978, 3642, "6sU^"),
        TVhSk: i(2424, "Dh8h", 3434, 3575),
        YAteB: function (t, e) {
          return t !== e;
        },
        aUumn: i(3247, "y(aR", 3155, 3982),
        JOWHR: i(2702, "Z5Ed", 2840, 2580),
        nrkra: o(955, 2044, 1831, -164, "WJFM") + "y",
        sbHgC: s(2168, 2067, 2928, "bKzs"),
        hdjVF: function (t, e) {
          return t !== e;
        },
        HEFoI: n(2533, 1387, 1651, "5[Ds"),
        jyOfb: function (t, e) {
          return t !== e;
        },
        OMmjj: s(250, 1206, 704, "bKzs"),
        roaMg: function (t, e) {
          return t === e;
        },
        ABjMo: i(1086, "g(zI", 987, 659),
        uCRxf: i(2182, "G)uk", 1394, 3068),
        Mozlu: function (t, e, i, n) {
          return t(e, i, n);
        },
      };
      function i(t, e, i, n, r) {
        return uy(0, 0, t - 966, 0, e);
      }
      function n(t, e, i, n, r) {
        return Wy(n, e - 801);
      }
      function r(t, e, i, n, r) {
        return ry(0, i - -231, 0, e);
      }
      if (
        (t[n(796, 791, 1483, ")M@t")] ||
          (e[s(567, 1573, 1329, "WJFM")](
            e[s(576, 311, 76, ")M@t")],
            e[i(1843, "AF$5", 1772, 1177)]
          )
            ? (_0x2202b5 = _0x1b3ff7[o(1396, 994, 397, 1439, "x7um")](
                _0x5eb4bf[
                  i(2445, "u)I4", 3383, 3102) + s(1583, 1722, 874, "wJeC")
                ]
              )) &&
              _0x32fc54 &&
              (_0x9dc678 = _0x26f4c4[n(1663, 1590, 1385, "vL@C") + "ge"]) &&
              e[r(2058, "g(zI", 1467)](
                _0x44ca31,
                _0x412505,
                e[i(2123, ")M@t", 1687, 3064)]
              )
            : (t[s(3165, 2336, 2129, "wJeC")] = new eo({}))),
        !t[n(0, 3021, 0, "vL@C")][
          o(1006, 1705, 1992, 1633, "5U(6") + s(1242, 67, -593, "l9RD")
        ]())
      ) {
        if (
          e[o(809, 410, -25, 73, "y(aR")](
            e[n(0, 1662, 0, "iTSE")],
            e[o(2605, 2552, 3487, 3343, "6sU^")]
          )
        )
          return (
            (_0x138e99 = _0x3b73d3[o(2113, 2255, 3378, 2231, "dehg")]("|")),
            e[s(2203, 1124, 994, "3%NO")](
              _0x514abb,
              e[i(1175, "xk4v")](
                e[s(3100, 2297, 1623, "j9*&")](
                  e[n(0, 2694, 0, "auw)")](
                    _0x320446[2][s(-191, 387, 472, "u)I4")]("")[2],
                    ""
                  ),
                  _0x5d2833[0][n(0, 1872, 0, "[VZg")]("")[1]
                ),
                _0x415507[1][s(908, 740, 210, "hzbI")]("")[0]
              )
            )
          );
        t[r(0, "RvbZ", 2469)][
          o(1920, 1681, 2555, 705, "%2K1") + o(2891, 2063, 4099, 4039, "[VZg")
        ]([0, 0]);
      }
      if (!t[r(0, "Pbla", 2396)][o(1243, 323, 1424, 1753, "^hAz") + "om"]()) {
        if (
          e[s(399, -152, -352, "Z5Ed")](
            e[s(71, 127, 641, "hbl9")],
            e[n(0, 1545, 0, "waXB")]
          )
        ) {
          let t, s, o, a;
          return (
            (o = _0x514528[0]),
            (s = _0x333b1f[2]),
            (t = _0x59f815[1]),
            e[n(0, 1647, 0, "^C2X")](_0x31cac9, 1)
              ? (a = _0x1c2e87[0])
              : ((a =
                  _0x40b195[e[n(0, 2511, 0, "r4s(")](_0x487651, _0x6cdf47)]),
                _0x3492f7++),
            (a = e[i(2414, "wJeC")](
              e[n(0, 1038, 0, "naYB")](
                e[r(0, "WJFM", 2116)](
                  a,
                  e[n(0, 1947, 0, "xk4v")](
                    _0x2ab0ae,
                    o,
                    t,
                    s,
                    _0x46a867,
                    _0xf3f8fd
                  )
                ),
                "."
              ),
              _0x14236f
            )),
            a
          );
        }
        t[i(3421, "wJeC")][r(0, "l9RD", 3048) + "om"](1);
      }
      function s(t, e, i, n, r) {
        return ny(0, e - 400, 0, 0, n);
      }
      function o(t, e, i, n, r) {
        return uy(0, 0, t - 791, 0, r);
      }
      super(t),
        e[o(2599, 0, 0, 0, "5[3$")](Ey, t[i(2047, "HpoK")], !1, !0)[
          o(3049, 0, 0, 0, "[VZg")
        ]((s) => {
          function a(t, e, i, r, s) {
            return n(0, i - 22, 0, r);
          }
          function l(t, e, i, r, s) {
            return n(0, t - -447, 0, e);
          }
          function h(t, e, n, r, s) {
            return i(n - 34, e);
          }
          function c(t, e, i, n, r) {
            return o(r - -1221, 0, 0, 0, e);
          }
          function u(t, e, i, n, s) {
            return r(0, t, s - -1155);
          }
          const d = {
            NGmeA: e[h(0, "FTF#", 1544)],
            HQgmW: e[h(0, "^hAz", 1791)],
            jZAXg: function (t, i) {
              return e[((n = 1172), (r = "ne@e"), u(r, 0, 0, 0, n - -5))](t, i);
              var n, r;
            },
            KCaen: function (t, i) {
              return e[((n = "dehg"), (r = 2208), h(0, n, r - -798))](t, i);
              var n, r;
            },
            ldIvh: function (t, i) {
              return e[((n = 2045), (r = "^C2X"), u(r, 0, 0, 0, n - 1216))](
                t,
                i
              );
              var n, r;
            },
            UAjOr: e[l(2304, "x7um")],
            IVYxP: e[a(0, 0, 1178, "FAP3")],
          };
          if (e[l(1189, "qDUP")](e[h(0, "[VZg", 1194)], e[l(2466, "RvbZ")])) {
            if (
              (e[l(1031, "a#*#")](
                U_,
                document[
                  h(0, "iTSE", 1959) +
                    l(1324, "3%NO") +
                    c(0, "lV]E", 0, 0, 56) +
                    l(798, "lV]E")
                ](e[u("3%NO", 0, 0, 0, 824)]),
                !1
              ),
              !(t = e[l(644, "ptBd")](
                D_,
                t[u("auw)", 0, 0, 0, 1999) + "t"],
                t,
                this
              )))
            ) {
              if (
                !e[l(637, "Z5Ed")](
                  e[l(2273, "G)uk")],
                  e[c(0, "]QDq", 0, 0, -300)]
                )
              )
                return;
              _0x3169ca[c(0, "hzbI", 0, 0, -329) + "pe"] =
                e[c(0, "3%NO", 0, 0, 590)];
            }
            if (
              (s[a(0, 0, 2118, "5[Ds") + "d"] &&
                (e[c(0, "DA8@", 0, 0, 1653)](
                  e[h(0, "lV]E", 2745)],
                  e[u("ne@e", 0, 0, 0, 1974)]
                )
                  ? (M_[t[a(0, 0, 2336, "qP[S") + "t"]][
                      h(0, "^$I&", 1461) + "d"
                    ] = !0)
                  : _0x431f75[c(0, "y(aR", 0, 0, 1919)]
                      [
                        u("3%NO", 0, 0, 0, 1894) +
                          a(0, 0, 2440, "]QDq") +
                          h(0, "2XNM", 2543) +
                          a(0, 0, 942, "5[Ds")
                      ](d[a(0, 0, 1094, "bKzs")])[0]
                      [h(0, "G)uk", 2874) + a(0, 0, 1927, "FAP3") + "te"](
                        d[a(0, 0, 1421, "vL@C")],
                        d[u("dehg", 0, 0, 0, 69)](
                          d[l(278, "%2K1")](
                            d[c(0, "G)uk", 0, 0, 725)](
                              _0x271c15,
                              d[u("FTF#", 0, 0, 0, 2066)]
                            ),
                            _0x130290[a(0, 0, 1739, "^$I&")]
                          ),
                          d[u("g(zI", 0, 0, 0, 1056)]
                        )
                      )),
              !t[a(0, 0, 2125, "y(aR") + l(1886, "RvbZ")])
            ) {
              if (
                !e[h(0, "qP[S", 2995)](
                  e[l(1196, "qP[S")],
                  e[u("x7um", 0, 0, 0, -31)]
                )
              )
                return _0x455649[c(0, "waXB", 0, 0, 548)]("")
                  [u("qDUP", 0, 0, 0, 1094) + "se"]()
                  [c(0, "lV]E", 0, 0, 1210)]("");
              {
                const i = {};
                (i[h(0, "qDUP", 1495)] = !0),
                  (i[u("Dh8h", 0, 0, 0, 1656) + a(0, 0, 2776, "%2K1") + "n"] =
                    !1),
                  (i[h(0, "[VZg", 1241) + "e"] = !1),
                  (t[l(1328, "3%NO") + c(0, "[VZg", 0, 0, 1854)] = e[
                    c(0, "]QDq", 0, 0, 999)
                  ](fa, i));
              }
            }
            this[a(0, 0, 872, "^C2X") + a(0, 0, 1963, "Z5Ed") + "t"]()[
              h(0, "hzbI", 3102) + c(0, "y(aR", 0, 0, -411) + "d"
            ](M_[t[u("RvbZ", 0, 0, 0, 680) + "t"]][l(1519, "Dh8h")]),
              this[a(0, 0, 3272, ")M@t") + c(0, "G)uk", 0, 0, 586)](
                t[u("DA8@", 0, 0, 0, -210) + "pe"]
                  ? t[a(0, 0, 904, "#Bat") + "pe"]
                  : e[u("AF$5", 0, 0, 0, 936)]
              ),
              t[u(")M@t", 0, 0, 0, 1892) + "ic"] &&
                this[
                  u("%2K1", 0, 0, 0, 2010) +
                    u("wJeC", 0, 0, 0, 859) +
                    u("Z5Ed", 0, 0, 0, 1175) +
                    a(0, 0, 3186, "Z5Ed")
                ](!0),
              t[a(0, 0, 3207, "Z5Ed")] &&
                this[l(1579, "^hAz") + l(1103, "l9RD") + a(0, 0, 2320, "^hAz")](
                  e[l(1557, "waXB")]
                ),
              this[a(0, 0, 799, "#Bat") + "ew"]()[
                c(0, "^hAz", 0, 0, 1685) + c(0, "hbl9", 0, 0, 500)
              ](19);
          } else
            _0x1c0d7f &&
              _0x3b9b82[_0x175811] &&
              _0x4a4932[_0x29a141](_0x83594d);
        });
    }
    [ry(0, 1495, 0, "Dh8h") + Wy("Dh8h", 1711)](t) {
      const e = {
        hkzWu: function (t, e) {
          return t(e);
        },
        gRxeG: function (t, e, i) {
          return t(e, i);
        },
        gluuN:
          h(1442, -61, 816, 304, "wJeC") +
          h(2596, 2527, 2435, 2397, "]QDq") +
          "3",
        IQijd: function (t, e) {
          return t < e;
        },
        ehwcg: function (t, e, i) {
          return t(e, i);
        },
        ZPKFW: function (t, e) {
          return t + e;
        },
        uqzsm: function (t, e) {
          return t + e;
        },
        IhaJd:
          c(1635, 2244, 2078, 1303, "#Bat") +
          l(1657, 1082, 1074, 1358, "5U(6") +
          l(3616, 2903, 4178, 3498, "hbl9") +
          o(3369, 3622, 2761, "^C2X") +
          o(2221, 3129, 3360, "qDUP") +
          l(3191, 2330, 2913, 1135, "DA8@") +
          s(727, ")M@t"),
        KWhkb:
          l(302, 1111, 250, 1960, "5U(6") + o(1622, -18, 1125, "vL@C") + ".",
        EiMHX: h(2172, 2384, 883, 1258, ")M@t"),
        Kshax: function (t, e) {
          return t || e;
        },
        dPaXD:
          o(4399, 4046, 3127, "^$I&") +
          c(2069, 2630, 3255, 1695, "g(zI") +
          s(405, "Z5Ed") +
          h(345, 811, 256, 940, "5[Ds") +
          h(174, 609, 364, 241, "a#*#") +
          h(-1286, -407, -1340, -87, "xk4v") +
          c(-242, 693, 1511, 712, "Dh8h") +
          o(1418, 175, 1079, "a#*#"),
        Ixmpx: function (t) {
          return t();
        },
        wfAuq: s(331, "3%NO"),
        evuhU: h(1441, 2474, 765, 1792, "5[3$"),
        oPnOM: function (t, e) {
          return t + e;
        },
        EZrmg: function (t, e) {
          return t + e;
        },
        evpVE:
          c(1181, 2318, 3515, 2111, "Dh8h") +
          h(1721, 276, 730, 596, "bKzs") +
          h(1102, 114, 2223, 1364, "^$I&") +
          h(781, -411, 1037, -57, "l9RD") +
          "-",
        MhWTY: l(2292, 3301, 2662, 3332, "#Bat"),
        iaINR: l(1921, 1253, 657, 467, "auw)"),
        SZJxJ: h(2290, 3035, 1972, 2381, "Z5Ed"),
        qxsgy: o(4055, 1994, 3152, "5[3$"),
        SFisA: function (t, e) {
          return t(e);
        },
        iXmOv: function (t, e) {
          return t !== e;
        },
        PyrZG: c(2106, 2740, 3839, 2358, "FAP3") + "el",
        pUgxq: c(1898, 2763, 3693, 1698, "5U(6"),
        zuOWq: function (t, e) {
          return t % e;
        },
        wMLnL: function (t, e) {
          return t(e);
        },
        vWUOP: function (t, e) {
          return t !== e;
        },
        FzoeJ: c(1475, 1540, 1661, 2074, "naYB"),
        CJovm: c(3921, 2977, 2952, 2206, "5U(6"),
        rMorV: function (t, e) {
          return t === e;
        },
        udtVA: function (t, e) {
          return t === e;
        },
        kRjlF: l(3042, 3534, 3375, 4183, "V@QO"),
        zwIvq: l(3056, 2068, 1431, 1228, "r4s("),
        glMCq: c(4065, 2982, 2696, 2145, "[VZg") + o(813, 878, 1605, "j9*&"),
        JUUpE: function (t, e) {
          return t === e;
        },
        Nmjzp: s(1603, "FAP3"),
        UXKNG: l(1865, 2786, 3414, 1919, "auw)"),
        TWvus: function (t, e) {
          return t(e);
        },
        OHcGr: function (t, e) {
          return t === e;
        },
        kFjDV: function (t, e) {
          return t === e;
        },
        KnimN: c(1235, 2077, 1393, 2703, "l9RD"),
        Szzmk: c(1794, 1122, 1515, 921, ")M@t"),
        pGBFL: s(1529, "ptBd"),
        eABuX: function (t, e) {
          return t === e;
        },
        mqbpI: s(1358, "u)I4"),
        eyMUV: o(2536, 3074, 3013, "ptBd"),
        rcsMs: function (t, e) {
          return t === e;
        },
        AKYsD: c(853, 1293, 1038, 351, "[VZg"),
        sGSJz: l(2580, 2951, 1961, 3540, "Pbla"),
        BDLJe: function (t, e) {
          return t !== e;
        },
        PUipA: s(583, "6sU^"),
        xPTSC: c(2778, 2834, 2070, 2021, "wJeC"),
        edenU: s(1350, "HpoK"),
        ZOLFE: l(1143, 2178, 969, 1612, "RvbZ"),
        oxENb: h(886, 819, -552, 82, "naYB"),
        dVGLR: function (t, e) {
          return t + e;
        },
        TWcRC: function (t, e) {
          return t + e;
        },
        hkqzi: o(1439, 2019, 2691, "waXB") + l(3151, 2818, 1997, 3291, "x7um"),
        tbcaG: h(1385, 1685, 2509, 1399, "3%NO"),
        lasZX: c(1908, 1468, 856, 642, "Z5Ed"),
        tWqLG: function (t, e) {
          return t + e;
        },
        SXaKq: c(2473, 1523, 1927, 367, "l9RD"),
      };
      let i, n, r;
      function s(t, e, i, n, r) {
        return my(0, e, t - -874);
      }
      if (
        ((r =
          M_[
            this[
              l(2435, 3601, 4741, 4315, "qDUP") +
                l(1633, 2365, 1795, 2189, "g(zI")
            ]
          ]),
        !r)
      ) {
        if (
          e[h(2476, 2977, 1119, 2014, "hzbI")](
            e[s(343, "r4s(")],
            e[h(107, 1951, 2209, 1239, "AF$5")]
          )
        )
          return void e[l(538, 1077, 390, -189, "#Bat")](
            setTimeout,
            () => this[h(2014, 477, 1828, 1420, "qP[S") + s(1833, "%2K1")](t),
            250
          );
        !e[h(2486, 2649, 306, 1514, "FTF#")](_0x21a4cf, _0x40bbfe) &&
          e[l(1790, 2774, 3558, 3716, "WJFM")](_0x27a016, _0x4853f8, _0x34140c);
      }
      if (
        ((r[s(1373, "u)I4") + l(3625, 2802, 2221, 2946, "5[3$") + "e"] =
          r[h(-209, 1132, -482, 696, "dehg") + "pe"]),
        e[c(1709, 2779, 3867, 3438, "FTF#")](
          t,
          r[l(2500, 3340, 2072, 3361, "qDUP") + "pe"]
        ) ||
          (e[c(652, 1532, 1091, 2554, "^$I&")](t, "__") &&
            r[
              s(1658, "FAP3") +
                c(1528, 1456, 1109, 494, "G)uk") +
                h(1640, 2655, 1021, 2141, "Z5Ed")
            ]))
      ) {
        if (
          !e[l(1554, 2810, 2491, 3589, "y(aR")](
            e[c(3230, 2530, 3503, 3402, "l9RD")],
            e[o(3724, 2624, 3236, "bKzs")]
          )
        )
          return this;
        if (!_0x1e42d5[_0x2a34d5]) return this;
        this[
          h(1713, 1590, 1234, 1537, "5U(6") +
            l(342, 1132, 1374, 1510, "lV]E") +
            l(3114, 2449, 3584, 3484, "DA8@")
        ](_0xb9eaa6, _0xc4bb4c[o(3287, 2699, 2929, "HpoK")], _0x32ff6b),
          (_0xc8a7cf[o(3073, 3550, 3230, "qDUP") + "pe"] = _0x8d772d),
          (_0x1a5a9c[
            l(2540, 2596, 1407, 2637, "lV]E") +
              c(-157, 447, -254, 1182, "dehg") +
              l(1661, 2664, 2337, 2564, "]QDq")
          ] = !1);
      }
      function o(t, e, i, n, r) {
        return ny(0, i - 1549, 0, 0, n);
      }
      if (
        (this[
          l(504, 1425, 376, 754, "dehg") +
            c(1985, 2129, 2788, 2322, "ne@e") +
            "r"
        ](
          this[c(-30, 1138, 1748, -15, "l9RD") + c(878, 687, 258, -39, "wJeC")](
            e[l(1992, 1517, 1166, 1445, "lV]E")]
          )
        ),
        e[l(1741, 1211, 1189, 2479, "5[Ds")](t, null))
      ) {
        if (
          !e[s(2390, "j9*&")](
            e[o(0, 0, 1329, "5[Ds")],
            e[l(1660, 1578, 1481, 2587, "Z5Ed")]
          )
        )
          return (
            this[o(0, 0, 1688, "g(zI") + o(0, 0, 1198, "a#*#") + "r"](
              this[s(1621, "FAP3") + o(0, 0, 2498, "dehg")](e[s(1317, "Z5Ed")])
            ),
            (r[c(4056, 2837, 3304, 2378, "hzbI") + o(0, 0, 2277, "r4s(")] =
              null),
            this
          );
        (_0x61c34[s(2046, "bKzs") + "s"][o(0, 0, 2512, "qDUP")] = !1),
          _0x3b7013[
            c(3501, 2896, 2111, 3179, "FAP3") + s(2531, "%2K1") + "r"
          ] &&
            _0xabe15f[
              h(1184, 2062, 1105, 2245, "j9*&") +
                h(793, 1237, 1528, 1440, "HpoK") +
                "r"
            ][l(493, 1649, 1316, 1495, "6sU^")](this, [!1]);
      }
      if (
        ((n =
          !ay[t] || r[c(192, 1422, 677, 1273, "lV]E") + "d"] ? ay.__ : ay[t]),
        (i = e[o(0, 0, 3030, "V@QO")](
          j_,
          n[
            h(2728, 3389, 2631, 2382, "5[Ds") +
              l(1174, 1943, 2062, 1684, "G)uk") +
              l(2302, 3462, 4657, 3233, "qDUP")
          ]
        )),
        e[l(1314, 2404, 2976, 2428, "2XNM")](t, "__") ||
          (ay[t] && r[h(977, 106, 726, 219, "qP[S") + "d"]))
      )
        if (
          e[l(3624, 3214, 2028, 2517, "^$I&")](
            e[o(0, 0, 2911, "bKzs")],
            e[s(2166, "l9RD")]
          )
        ) {
          const t = e[s(2417, "u)I4")][h(-1095, 1332, -460, 105, "x7um")]("|");
          let i = 0;
          for (;;) {
            switch (t[i++]) {
              case "0":
                if (
                  !_0x2ebb62[h(1110, 2305, 2592, 2107, "qP[S")] ||
                  e[o(0, 0, 964, "^$I&")](
                    _0x1eee6d[o(0, 0, 1796, "hbl9")][
                      c(2034, 2063, 2563, 1387, "WJFM") + "h"
                    ],
                    12
                  )
                )
                  return (
                    e[h(1931, 1190, 3668, 2415, "naYB")](
                      _0xee6bfe,
                      e[h(2874, 1415, 2006, 2210, "j9*&")](
                        e[o(0, 0, 3483, "DA8@")](
                          e[h(-798, 252, 74, -90, "#Bat")](
                            e[s(1465, "g(zI")],
                            _0x487077
                          ),
                          e[o(0, 0, 2061, "5U(6")]
                        ),
                        _0x54d368
                      ),
                      e[c(657, 1796, 1262, 2066, "u)I4")]
                    ),
                    !1
                  );
                continue;
              case "1":
                _0x55752b[s(905, "%2K1") + c(1708, 995, 1803, 2145, "ne@e")] =
                  _0x6fa4ab;
                continue;
              case "2":
                delete _0x271b72[h(-576, -389, 715, 32, "^hAz")];
                continue;
              case "3":
                return _0x599060;
              case "4":
                if (e[o(0, 0, 1107, "3%NO")](!_0xecd9f5, !_0x44cfe2))
                  return (
                    e[l(397, 1167, 652, 2246, "G)uk")](
                      _0x176b39,
                      e[l(587, 1819, 815, 1880, "%2K1")],
                      e[l(1555, 2010, 2083, 3275, "[VZg")]
                    ),
                    !1
                  );
                continue;
              case "5":
                const t = {};
                (t[h(365, 518, 2182, 1393, "r4s(") + "ic"] =
                  _0x26236b[o(0, 0, 2025, "hbl9") + "ic"]),
                  (t[s(2195, "u)I4")] =
                    _0x458f51[h(16, -420, 430, 804, "V@QO")]),
                  (_0x42c528[_0x5915c8] = {
                    mapType: null,
                    prevMaptype: null,
                    labelCode: null,
                    isCustomMaptype: !1,
                    layers: t,
                    key: _0x15998e[o(0, 0, 2409, "FAP3")],
                    failed: !1,
                    logo: e[l(3275, 2573, 3222, 2998, "u)I4")](_0x476198),
                    poiListener:
                      _0xc60d3b[
                        s(981, "#Bat") +
                          l(2369, 3117, 4314, 3570, "dehg") +
                          h(-746, 1226, -72, 229, "r4s(") +
                          h(916, 2611, 2758, 2036, "g(zI")
                      ],
                    trafficListener:
                      _0x316151[
                        l(2161, 3129, 3362, 3548, "FAP3") +
                          c(2335, 2151, 2424, 1213, "qP[S") +
                          o(0, 0, 3172, "RvbZ") +
                          o(0, 0, 2508, "[VZg") +
                          "ed"
                      ],
                    maptypeListener:
                      _0x243129[
                        o(0, 0, 1249, "g(zI") +
                          h(1898, 1577, 926, 647, "g(zI") +
                          h(1209, 1051, 1589, 398, "Pbla") +
                          "ed"
                      ],
                    isTrafficQuotaSent: !1,
                  });
                continue;
            }
            break;
          }
        } else r[o(0, 0, 2570, "iTSE") + "pe"] = e[s(1521, "r4s(")];
      else if (
        e[h(-238, -82, 676, 681, "FAP3")](
          t[c(-158, 877, 427, 373, "AF$5") + "Of"](e[o(0, 0, 2477, "a#*#")]),
          -1
        )
      )
        if (
          e[o(0, 0, 2674, "Z5Ed")](
            e[c(2705, 2550, 2081, 2565, "DA8@")],
            e[o(0, 0, 1228, "xk4v")]
          )
        )
          _0x4286e4[o(0, 0, 2073, "5[3$")] = new _0x31926e({});
        else {
          if (!ay[t]) return this;
          this[
            l(1109, 1094, 1664, 2101, "x7um") +
              h(1762, 2198, 582, 1406, "Z5Ed") +
              c(1857, 2846, 2565, 1778, "Dh8h")
          ](ty, n[h(1605, 148, 1069, 1412, "]QDq")], i),
            (r[c(935, 627, 747, -624, "auw)") + "pe"] = t),
            (r[
              s(761, "%2K1") +
                h(1873, 372, 1974, 1343, "^C2X") +
                c(1464, 1536, 1397, 2188, "Dh8h")
            ] = !1);
        }
      else
        e[h(-823, -808, 597, 142, "RvbZ")](
          e[s(800, "Z5Ed")],
          e[c(558, 876, 492, 660, "^C2X")]
        )
          ? ((i[o(0, 0, 3465, "lV]E")] = t),
            (r[o(0, 0, 1289, "5U(6") + "pe"] = t),
            (r[
              o(0, 0, 2999, "]QDq") +
                c(458, 785, 1552, 1555, "xk4v") +
                s(407, "3%NO")
            ] = !0))
          : _0xf8d129[h(881, 2788, 876, 1686, "3%NO")]
              [
                h(1226, 1547, 3672, 2447, "qDUP") +
                  c(2946, 2152, 2250, 1082, "Z5Ed") +
                  s(1938, "ne@e") +
                  o(0, 0, 1659, "l9RD")
              ](e[h(-552, -678, -41, 529, "Dh8h")])[0]
              [
                c(2121, 987, 674, -51, "Z5Ed") +
                  l(1002, 1120, -80, 917, "]QDq") +
                  "te"
              ](
                e[l(674, 1286, 137, 1505, "dehg")],
                e[h(857, 1277, 928, 1121, "iTSE")](
                  e[s(2363, "V@QO")](
                    e[s(483, "Z5Ed")](
                      _0xfac1bb,
                      e[l(1389, 1098, 2202, -126, "y(aR")]
                    ),
                    _0x5d1dce[c(1583, 1270, 2215, 1274, "hbl9")]
                  ),
                  e[h(1807, 1551, 1232, 1509, "j9*&")]
                )
              );
      const a = new Uf({ zIndex: -9999, source: new Mp(i) });
      function l(t, e, i, n, r) {
        return ny(0, e - 1659, 0, 0, r);
      }
      if (
        (Object[
          o(0, 0, 2601, "iTSE") +
            c(3762, 2769, 2731, 3391, "r4s(") +
            o(0, 0, 1090, "dehg")
        ](
          a[l(0, 2233, 0, 0, "5U(6") + "s_"],
          e[c(2053, 2033, 2030, 1442, "xk4v")],
          { value: e[h(1035, 1728, 3153, 2271, "x7um")], writable: !1 }
        ),
        this[h(3049, 1425, 3513, 2426, "^hAz") + o(0, 0, 3122, "AF$5")](a),
        n[h(3073, 1133, 1625, 1915, "u)I4")])
      )
        e[c(1970, 1158, 1996, 1579, "^hAz")](
          e[o(0, 0, 2406, "^$I&")],
          e[h(1027, -167, 645, 533, "Dh8h")]
        )
          ? this[
              c(1373, 1680, 2566, 948, "iTSE") +
                c(2930, 1878, 1208, 1485, "r4s(") +
                h(1422, 2866, 3019, 2452, "5U(6") +
                "r"
            ]()
          : _0x58b347[s(518, "qP[S")](
              _0x208e17[l(0, 3160, 0, 0, "#Bat") + "ce"](
                _0x517da9[0],
                _0x39be9f[
                  l(0, 2624, 0, 0, "3%NO") + h(42, -305, 1004, 655, "[VZg")
                ]()
              )
            );
      else {
        if (
          e[c(1986, 2249, 1855, 1732, "Dh8h")](
            e[o(0, 0, 2368, "5[Ds")],
            e[l(0, 1862, 0, 0, "bKzs")]
          )
        )
          return !!this[s(457, "iTSE") + c(2567, 2587, 2589, 2970, "#Bat")](
            e[c(-7, 971, 555, 1960, "#Bat")]
          );
        (r[o(0, 0, 3229, "x7um") + c(990, 1065, 2042, -167, "g(zI")] = null),
          this[l(0, 2829, 0, 0, "naYB") + s(795, "5[3$") + "r"](
            this[l(0, 1398, 0, 0, "%2K1") + l(0, 1707, 0, 0, "RvbZ")](
              e[l(0, 3113, 0, 0, "x7um")]
            )
          );
      }
      if (
        r[h(690, 1346, 2112, 1508, "^C2X") + "s"][
          h(1181, 1906, 2110, 2432, "HpoK") + "ic"
        ]
      )
        if (
          e[h(2655, 904, 1628, 2158, "DA8@")](
            e[o(0, 0, 2075, "DA8@")],
            e[s(2372, "dehg")]
          )
        ) {
          let t, i, n, r;
          if (
            ((r = _0x1f2484[this[l(0, 3311, 0, 0, "vL@C") + s(1298, "%2K1")]]),
            (n =
              !_0x52d44d[r[c(1708, 2279, 1407, 2545, "3%NO") + "pe"]] ||
              r[h(1642, 1858, 2061, 1523, "auw)") + "d"]
                ? _0x44e037.__
                : _0x57eb6d[r[o(0, 0, 2753, "^C2X") + "pe"]]),
            (t =
              n[
                r[o(0, 0, 3008, "x7um") + "s"][o(0, 0, 2885, "wJeC")]
                  ? e[o(0, 0, 1867, "HpoK")]
                  : e[h(3004, 2938, 3077, 2294, "hzbI")]
              ]),
            (i = e[l(0, 2493, 0, 0, "Pbla")](
              _0x35d94d,
              n[
                s(789, "^hAz") +
                  l(0, 2376, 0, 0, "a#*#") +
                  o(0, 0, 2106, "xk4v")
              ]
            )),
            (i[s(1380, "bKzs") + h(3023, 921, 3046, 2015, "3%NO")] = 0),
            e[s(1118, "HpoK")](
              t,
              r[s(1999, "FTF#") + l(0, 1748, 0, 0, "y(aR")]
            ) &&
              ((r[h(3231, 1940, 2869, 2178, "Pbla") + s(2693, "qP[S")] = t),
              this[
                h(2280, 1824, 2597, 1995, "hzbI") +
                  l(0, 2393, 0, 0, "g(zI") +
                  "r"
              ](
                this[l(0, 1747, 0, 0, "l9RD") + l(0, 2237, 0, 0, "x7um")](
                  e[l(0, 2687, 0, 0, "WJFM")]
                )
              ),
              t))
          ) {
            this[
              s(673, "6sU^") + l(0, 1781, 0, 0, "V@QO") + o(0, 0, 1519, "3%NO")
            ](
              _0x508cb8,
              r[o(0, 0, 1132, "^hAz") + l(0, 2483, 0, 0, "HpoK")],
              i
            );
            const t = new _0x554032({
              zIndex: -9997,
              useInterimTilesOnError: !1,
              source: new _0x385869(i),
            });
            _0x1da8d6[
              h(2507, 3488, 3422, 2255, "2XNM") +
                c(2696, 1587, 317, 1928, "^hAz") +
                h(1299, 1328, 443, 709, "V@QO")
            ](
              t[o(0, 0, 3453, "WJFM") + "s_"],
              e[c(2133, 1358, 1468, 2626, "^hAz")],
              { value: e[c(2506, 1479, 228, 1140, "Z5Ed")], writable: !1 }
            ),
              this[o(0, 0, 2116, "hzbI") + o(0, 0, 2966, "]QDq")](t);
          }
        } else
          this[
            c(-479, 622, 145, 156, "V@QO") +
              s(1170, "hzbI") +
              h(82, -917, 944, 177, "DA8@") +
              c(2297, 1098, 1659, 694, "RvbZ")
          ](!0);
      if (
        e[h(-23, -145, 658, 686, "^C2X")](
          document[
            c(2647, 2034, 2992, 2560, "bKzs") +
              h(1581, 511, 1006, 1670, "lV]E") +
              l(0, 3227, 0, 0, "lV]E")
          ][o(0, 0, 1777, "]QDq") + o(0, 0, 2568, "5[3$") + "h"],
          800
        )
      )
        e[h(3077, 1713, 2208, 2317, "auw)")](
          e[c(1033, 596, 1550, 1130, "j9*&")],
          e[h(3045, 1157, 1694, 2104, "5U(6")]
        )
          ? ((_0x2521f4 =
              _0x9ae357[
                e[h(1583, 3292, 1425, 2144, "%2K1")](_0x4218fe, _0x345524)
              ]),
            _0x1258ec++)
          : r[c(723, 1201, -46, 1055, "dehg")]
              [
                o(0, 0, 2440, "[VZg") +
                  c(2980, 2632, 2577, 2030, "j9*&") +
                  c(1697, 1736, 1984, 2198, "wJeC") +
                  l(0, 1252, 0, 0, "x7um")
              ](e[s(2535, "r4s(")])[0]
              [
                c(3064, 2349, 2252, 1964, "[VZg") +
                  h(1138, 242, 120, 141, "g(zI") +
                  "te"
              ](
                e[l(0, 2466, 0, 0, "naYB")],
                e[o(0, 0, 2648, "5U(6")](
                  e[s(1819, ")M@t")](
                    e[o(0, 0, 3272, "hbl9")](Q_, e[s(1075, "6sU^")]),
                    n[o(0, 0, 1052, "FTF#")]
                  ),
                  e[h(494, -1139, -39, -21, "g(zI")]
                )
              );
      else if (
        e[c(1931, 1306, 2568, 2149, "AF$5")](
          e[o(0, 0, 3282, "u)I4")],
          e[c(-22, 938, 654, 920, "dehg")]
        )
      )
        r[c(1592, 2219, 2479, 1114, "3%NO")]
          [
            l(0, 1689, 0, 0, "hzbI") +
              c(2161, 1656, 1780, 2848, "qDUP") +
              c(1378, 1126, 854, 2269, "r4s(") +
              c(1838, 597, 865, 1764, "g(zI")
          ](e[s(2391, "g(zI")])[0]
          [c(3309, 2155, 1547, 2224, "^C2X") + l(0, 3270, 0, 0, "2XNM") + "te"](
            e[h(889, -448, -381, 423, "FTF#")],
            e[c(2561, 2474, 2390, 2659, "ptBd")](
              e[s(663, "Dh8h")](
                e[s(2536, "vL@C")](Q_, e[c(552, 1530, 1413, 2613, "RvbZ")]),
                n[l(0, 2339, 0, 0, "5[3$")]
              ),
              e[o(0, 0, 3394, "WJFM")]
            )
          );
      else {
        const t = {};
        (t[s(328, "ne@e") + "d"] = !0), e[o(0, 0, 2328, "Pbla")](_0x21b1b9, t);
      }
      function h(t, e, i, n, r) {
        return Wy(r, n - -3);
      }
      function c(t, e, i, n, r) {
        return my(0, r, e - -712);
      }
      return (
        r[c(2143, 1695, 2042, 741, "Dh8h")]
          [
            c(3047, 2919, 2855, 3407, "ptBd") +
              o(0, 0, 1999, "3%NO") +
              s(2306, "vL@C") +
              h(0, 0, 0, 426, "[VZg")
          ]("A")[2]
          [l(0, 3329, 0, 0, "Dh8h") + l(0, 2532, 0, 0, "ptBd") + "te"](
            e[o(0, 0, 2981, "^hAz")],
            n[s(1064, "u)I4") + h(0, 0, 0, 215, "]QDq") + o(0, 0, 2327, "G)uk")]
          ),
        (r[s(479, "l9RD")][
          h(0, 0, 0, 663, "5[Ds") +
            o(0, 0, 1395, "wJeC") +
            h(0, 0, 0, 748, "RvbZ") +
            s(2451, "WJFM")
        ]("A")[2][c(2529, 2066, 861, 2054, "auw)") + s(1620, "vL@C")] =
          n[o(0, 0, 2382, "#Bat") + l(0, 1370, 0, 0, "a#*#")]),
        r[o(0, 0, 3439, "vL@C") + s(1638, "auw)") + l(0, 1861, 0, 0, "5[Ds")] &&
          r[
            o(0, 0, 2219, "hzbI") +
              c(2053, 1800, 2539, 1724, "auw)") +
              l(0, 1970, 0, 0, "bKzs")
          ][o(0, 0, 3251, "5U(6")](this, [t]),
        this
      );
    }
    [ry(0, 1607, 0, "qDUP") + Wy("Z5Ed", 2133) + my(0, "Dh8h", 1863)](t) {
      function e(t, e, i, n, r) {
        return ny(0, t - 646, 0, 0, i);
      }
      const i = {
        yOFHa: function (t, e) {
          return t === e;
        },
        SgBYH: function (t, e) {
          return t % e;
        },
        GVrnF: function (t, e) {
          return t + e;
        },
        hiAUP: function (t, e, i, n, r, s) {
          return t(e, i, n, r, s);
        },
        ekPtW: function (t, e) {
          return t(e);
        },
        rZywC: function (t, e) {
          return t(e);
        },
        eIUDL: e(1546, 0, "^C2X") + r(1314, 417, "x7um", 889) + "c",
        nHsvH: e(1249, 0, "[VZg") + e(242, 0, "5U(6"),
        WEFqF: r(57, -1009, "bKzs", 1062),
        bhhPE: function (t, e) {
          return t(e);
        },
        fozNH:
          a(141, 858, 455, -226, "ptBd") +
          r(676, 743, "qDUP", 1748) +
          a(999, 2237, 2102, 759, "y(aR"),
        uckOQ: function (t, e, i) {
          return t(e, i);
        },
        ixKcd: function (t, e) {
          return t !== e;
        },
        gPFKB: s(2405, 3510, "Z5Ed"),
        pzvgs: r(388, -839, "]QDq", 1106),
        WGOmJ: function (t, e, i) {
          return t(e, i);
        },
        LXxiS: s(2630, 1467, "3%NO"),
        GYxde: r(1524, 2344, "bKzs", 1554),
        vZfOj: e(1703, 0, "waXB"),
        YFgRL: function (t, e) {
          return t !== e;
        },
        KtuWt: o(1262, 1920, ")M@t", 1320),
      };
      let n = M_[this[s(2526, 3359, "V@QO") + e(574, 0, "y(aR")]];
      function r(t, e, i, n, r) {
        return uy(0, 0, t - 44, 0, i);
      }
      function s(t, e, i, n, r) {
        return my(0, i, e - -102);
      }
      if (!n) {
        if (
          i[o(1039, 1003, "^hAz", 1470)](
            i[e(985, 0, "6sU^")],
            i[e(913, 0, "x7um")]
          )
        )
          return void i[s(0, 3275, "^C2X")](
            setTimeout,
            () =>
              this[
                s(0, 1234, "^C2X") +
                  o(-326, 1546, "xk4v", 275) +
                  o(1625, 1010, "ne@e", 671)
              ](t),
            250
          );
        (_0x18e685[a(762, 172, -487, 881, "auw)") + "s"][e(2319, 0, "lV]E")] =
          !0),
          _0x4ee547[r(2481, 0, "^C2X") + o(695, 810, "a#*#", 1354) + "r"] &&
            _0x2c945a[
              a(320, 358, 1565, -370, "ne@e") + e(308, 0, "6sU^") + "r"
            ][r(1866, 0, "^$I&")](this, [!0]);
      }
      if (
        i[s(0, 3166, "^$I&")](t, i[o(2353, 1792, "]QDq", 1836)]) ||
        (t &&
          !this[
            s(0, 1319, "qP[S") + s(0, 2581, "2XNM") + e(1977, 0, "HpoK") + "ed"
          ]())
      )
        if (
          i[a(1622, 369, 805, 1293, ")M@t")](
            i[e(2370, 0, "#Bat")],
            i[e(2486, 0, "j9*&")]
          )
        )
          (n[a(-203, -331, 364, 939, "#Bat") + "s"][e(614, 0, "r4s(")] = !0),
            n[r(100, 0, "qDUP") + e(1238, 0, "r4s(") + "r"] &&
              n[s(0, 1837, "]QDq") + r(387, 0, "#Bat") + "r"][
                a(1466, 1764, 929, 1878, ")M@t")
              ](this, [!0]);
        else {
          const t = {
              XQqYM: function (t, e) {
                return i[
                  ((n = 246),
                  (r = "]QDq"),
                  (s = 448),
                  a(s - 339, n - 489, r - 311, s - 487, r))
                ](t, e);
                var n, r, s;
              },
              yRtxg: function (t, n) {
                return i[((r = "FTF#"), (s = 2016), e(s - -175, 0, r))](t, n);
                var r, s;
              },
              fiLID: function (t, e) {
                return i[((n = 2760), (s = "%2K1"), r(n - 680, 0, s))](t, e);
                var n, s;
              },
              VLCGG: function (t, e) {
                return i[((n = 2413), (s = "bKzs"), r(n - 1040, 0, s))](t, e);
                var n, s;
              },
              okVxm: function (t, e, n, r, o, a) {
                return i[((l = 2908), (h = "^$I&"), s(0, l - -263, h))](
                  t,
                  e,
                  n,
                  r,
                  o,
                  a
                );
                var l, h;
              },
            },
            n = i[a(763, 1318, -6, -220, "ne@e")](_0x33b413, _0x56a1f4);
          _0x7fc66e[i[s(0, 2320, "3%NO")](_0x54469a, i[r(1266, 0, "^hAz")])] =
            i[a(551, 1450, 569, 838, "Pbla")](
              _0x11dd2a,
              i[o(-891, -1005, "hzbI", -46)]
            );
          const l = i[s(0, 2415, "5[3$")](_0x5bcf27, i[r(1539, 0, "[VZg")]),
            h = n[o(1582, 3426, "FAP3", 2213) + "h"];
          let c = 0;
          _0x5b3147[
            i[o(2069, 1190, "%2K1", 1398)](
              _0x248843,
              i[o(2329, 560, ")M@t", 1387)]
            )
          ] = function (e) {
            let i, r, u, d;
            function g(t, e, i, n, r) {
              return a(t - 403, e - 24, i - 114, n - 112, e);
            }
            var f, p, m, _, y;
            function x(t, e, i, n, r) {
              return s(0, i - -156, n);
            }
            return (
              (u = e[0]),
              (r = e[2]),
              (i = e[1]),
              t[g(732, "g(zI", 114, -244)](h, 1)
                ? (d = n[0])
                : ((d = n[t[g(729, "%2K1", -283, 833)](c, h)]), c++),
              (d = t[
                ((m = 1495),
                (_ = "dehg"),
                (y = 1253),
                o(m - 239, _ - 208, _, y - 273))
              ](
                t[x(698, 1257, 1523, "[VZg")](
                  t[x(2010, 1851, 2891, "^hAz")](
                    d,
                    t[((f = 2121), (p = "u)I4"), s(0, f - 54, p))](
                      _0x15194b,
                      u,
                      i,
                      r,
                      _0x5effbe,
                      _0x3daa9b
                    )
                  ),
                  "."
                ),
                l
              )),
              d
            );
          };
        }
      else
        !t &&
          n[a(372, -677, 496, 742, "hbl9") + "s"][s(0, 1628, "r4s(")] &&
          (i[o(1636, 1798, "FTF#", 1411)](
            i[r(1810, 0, "Pbla")],
            i[a(370, 1171, 591, 256, "hzbI")]
          )
            ? _0x2e7e44[1] &&
              _0x433d8e[_0x5be922[1]] &&
              i[o(480, 1175, "5[Ds", 1694)](
                _0x1cfad5,
                function () {
                  _0x5430c2[_0x3f7b09[1]]();
                },
                10
              )
            : ((n[r(525, 0, "DA8@") + "s"][o(1143, -1111, "%2K1", 165)] = !1),
              n[
                o(1629, -109, "vL@C", 780) +
                  a(1389, 2367, 869, 1553, "y(aR") +
                  "r"
              ] &&
                n[
                  o(2106, 2587, "[VZg", 1947) +
                    a(451, -514, 1713, 991, "^$I&") +
                    "r"
                ][a(816, 404, -178, 1019, "waXB")](this, [!1])));
      function o(t, e, i, n, r) {
        return uy(0, 0, n - -28, 0, i);
      }
      function a(t, e, i, n, r) {
        return Wy(r, t - -496);
      }
      return (
        this[
          e(1068, 0, "g(zI") +
            a(1445, 1591, 1727, 2648, "6sU^") +
            r(2498, 0, "5U(6") +
            "r"
        ](),
        this
      );
    }
    [uy(0, 0, 980, 0, "a#*#") +
      my(0, "bKzs", 1412) +
      ny(0, 1419, 0, 0, "2XNM") +
      "ed"]() {
      const t = {};
      function e(t, e, i, n, r) {
        return my(0, r, t - -1049);
      }
      function i(t, e, i, n, r) {
        return Wy(i, e - 157);
      }
      t[i(2662, 2163, "waXB")] = e(244, 1433, 1442, -894, "g(zI");
      const n = t;
      return !!this[i(0, 2408, "HpoK") + e(1662, 0, 0, 0, "dehg")](
        n[((r = "iTSE"), (s = 1518), ny(0, s - 1184, 0, 0, r))]
      );
      var r, s;
    }
    [Wy("j9*&", 2319) +
      uy(0, 0, 2363, 0, "^C2X") +
      Wy("vL@C", 2257) +
      ny(0, 1614, 0, 0, "^$I&")](t) {
      const e = {
        YTLZz:
          s(1098, "ptBd", 302, 1171, 516) +
          s(2251, "g(zI", 2547, 1317, 1368) +
          o("^hAz", 846, 727, 1381) +
          h(3906, "waXB", 2712, 3804, 2747) +
          l(2126, 2721, "3%NO", 1805) +
          o("Pbla", 2223, 1500, 2896) +
          o("6sU^", 2279, 2090, 1022) +
          o("AF$5", 1231, 1535, 254) +
          l(1473, 2606, "^C2X", 448) +
          l(2985, 4176, "5U(6", 3072) +
          l(3151, 3688, "naYB", 3218) +
          o("5[3$", 756, 809, -520) +
          s(805, "bKzs", 2343, 815, 1535) +
          h(3468, "5U(6", 2926, 1808, 2417) +
          h(2851, "AF$5", 1736, 2080, 1612) +
          a(3259, 2630, "ne@e", 2194) +
          h(2587, "2XNM", 2311, 2131, 2035) +
          s(1920, "x7um", 631, 1511, 1115) +
          h(3417, "]QDq", 2350, 2839, 3054) +
          h(2689, "FAP3", 2578, 4166, 2909) +
          a(370, 1358, "l9RD", 1182) +
          a(1457, 523, "ne@e", 1246) +
          l(2711, 2303, "qDUP", 3743) +
          o("DA8@", 514, 559, 1648) +
          h(2388, "V@QO", 1968, 3853, 2844) +
          h(2901, "^hAz", 1980, 2131, 2464) +
          a(2039, 1004, "hzbI", 2239) +
          h(189, "ptBd", -282, 1976, 984) +
          a(3046, 3525, "Dh8h", 2492) +
          l(1644, 1989, "^C2X", 1905) +
          l(2187, 2022, "G)uk", 2785) +
          s(3451, "r4s(", 2199, 3321, 2662) +
          a(3341, 2833, "g(zI", 2081) +
          h(3609, "qDUP", 2558, 3654, 2695) +
          s(-91, "ne@e", 441, -442, 669) +
          l(3241, 3969, "HpoK", 2237) +
          s(690, "qDUP", 992, 535, 687) +
          s(3149, "^hAz", 2813, 1815, 2580) +
          o("AF$5", 1892, 2545, 884) +
          h(3982, "[VZg", 2532, 3283, 2957) +
          h(2731, "vL@C", 3616, 2396, 2387) +
          s(3773, "a#*#", 1528, 3238, 2773) +
          o("^$I&", 82, -871, -401) +
          h(1660, "Z5Ed", 1262, 1568, 2361) +
          s(406, "FAP3", 1616, 927, 1534) +
          a(1082, 2243, "waXB", 2046) +
          o("xk4v", 285, 549, 1222) +
          h(1487, "5U(6", 3306, 2738, 2668) +
          s(2125, "u)I4", 1495, 422, 1634) +
          h(1369, "6sU^", 654, 2646, 1838) +
          ">",
        jFLug: function (t, e, i) {
          return t(e, i);
        },
        MufdE: function (t, e) {
          return t === e;
        },
        kvJqF: a(7, 784, "G)uk", 1089),
        iouoE: function (t, e) {
          return t(e);
        },
        tkhdP:
          a(1901, 1653, "a#*#", 1096) +
          s(1168, "iTSE", 670, 2135, 1139) +
          o("3%NO", 605, 1194, 1370) +
          h(2546, "RvbZ", 1566, 1282, 2066),
        vSZyC: l(2383, 1887, "auw)", 3095),
        EYHgT: function (t, e, i, n) {
          return t(e, i, n);
        },
        FaCvn: a(1781, 3065, "5[Ds", 2040),
        NvTDn: o("a#*#", 469, 1248, 1396) + "y",
        erQiJ: function (t, e) {
          return t(e);
        },
        YhtZj: function (t, e, i) {
          return t(e, i);
        },
        tyYGm: a(2439, 471, ")M@t", 1415) + "nd",
        pbKCk: function (t, e) {
          return t !== e;
        },
        LmFll: a(1746, 1366, "naYB", 1179),
        nhgAz: o("wJeC", 1157, 1138, 2236),
        gvmGi: function (t, e) {
          return t < e;
        },
        heSeR: h(4327, "bKzs", 3204, 2726, 3228),
        TFPeR:
          h(1709, "qDUP", 2228, 1036, 1808) + s(522, "auw)", 1422, -119, 618),
        GNICm: function (t, e) {
          return t !== e;
        },
        gUgiN: h(1287, "bKzs", -386, 330, 849),
        BOmdg: a(1978, 2678, "wJeC", 2090),
        duyev: function (t, e) {
          return t !== e;
        },
        lmPAx: a(3415, 1319, "u)I4", 2147),
        qRGnZ: l(2178, 2844, "^C2X", 2069),
        asPGs: function (t, e, i) {
          return t(e, i);
        },
        JJxXS: function (t, e) {
          return t === e;
        },
        RxXLS: l(2134, 1187, "FAP3", 920),
        rrYVi: s(1727, ")M@t", 1895, 2235, 2261),
        NwuzC: function (t, e) {
          return t(e);
        },
        HVKWv:
          a(998, -552, "xk4v", 370) +
          a(444, -156, "ptBd", 396) +
          a(847, -37, "xk4v", 804),
        HtfIi: function (t, e) {
          return t == e;
        },
        bwnXC: function (t, e) {
          return t !== e;
        },
        wyuyJ: s(-34, "xk4v", -121, 986, 607),
        AgIiw: s(1331, "FAP3", 2058, 952, 1633),
        bytwd: function (t, e) {
          return t >= e;
        },
        HdXjb: function (t, e) {
          return t === e;
        },
        mZPIk: a(320, 157, "u)I4", 585),
        vViFk: s(2953, "HpoK", 3377, 3863, 2758),
        TEqrk: a(2274, 1774, "RvbZ", 1309),
        ICxvy: l(1175, 233, "5[Ds", 2376),
        ZsvuJ: h(419, "bKzs", 1167, 2097, 1687),
        dclQB: s(1726, "g(zI", 577, 1857, 1776),
        YVXTS: function (t, e) {
          return t !== e;
        },
        pZhsB: l(2320, 2449, "AF$5", 3322),
      };
      let i,
        n =
          M_[
            this[
              s(790, "]QDq", 1344, 1793, 889) + s(1771, "bKzs", 1372, 260, 782)
            ]
          ],
        r = this;
      if (!n) {
        if (
          e[a(3032, 1895, "3%NO", 2254)](
            e[o("%2K1", 1561, 2508, 2728)],
            e[l(2821, 1563, "waXB", 3555)]
          )
        )
          return void e[o("G)uk", 1127, 1281, 394)](
            setTimeout,
            () =>
              this[
                o("l9RD", 565, 840, 16) +
                  a(2156, 2409, "a#*#", 1503) +
                  l(1017, 432, ")M@t", 1552) +
                  o("FTF#", 2209, 1345, 989)
              ](t),
            250
          );
        _0x4b8eea += e[l(2164, 1713, "g(zI", 1316)];
      }
      function s(t, e, i, n, r) {
        return ry(0, r - -931, 0, e);
      }
      function o(t, e, i, n, r) {
        return uy(0, 0, e - -56, 0, t);
      }
      if (
        t &&
        !this[
          h(3220, "ne@e", 2362, 2758, 3212) +
            l(2664, 3810, "qP[S", 1566) +
            l(3504, 3572, "ne@e", 3961) +
            o("^$I&", 1910) +
            "d"
        ]()
      ) {
        if (
          e[h(1283, "DA8@", 3586, 1926, 2481)](
            e[h(947, "DA8@", 1160, 2187, 1165)],
            e[h(2682, "FTF#", 3737, 3570, 2534)]
          )
        )
          return void e[l(1820, 2472, "#Bat", 969)](
            _0x35fb9c,
            () =>
              this[
                h(1700, "hbl9", 431, 1513, 1657) +
                  a(2257, 1249, "hzbI", 1501) +
                  o("5U(6", 1651)
              ](_0x21772d),
            250
          );
        if (
          ((n[l(3048, 2174, "5[3$", 2153) + "s"][
            h(1701, "Pbla", 2798, 2066, 1988) + "ic"
          ] = !0),
          (i = e[a(1481, 2121, "iTSE", 2095)](
            j_,
            ay[e[h(878, "qDUP", 3143, 1947, 1980)]][
              o("bKzs", 1190) +
                l(2649, 3030, "AF$5", 1572) +
                a(2419, 2964, "FTF#", 1927)
            ]
          )),
          e[s(0, "dehg", 0, 0, 1110)](
            n[h(479, "hbl9", 749, 2201, 1230) + "d"],
            !1
          ) &&
            (e[h(1146, "qP[S", 2050, 576, 1324)](
              e[s(0, "bKzs", 0, 0, 1267)],
              e[s(0, "qDUP", 0, 0, 1277)]
            )
              ? this[
                  o("iTSE", 1093) +
                    h(1355, "#Bat", 2690, 1293, 1480) +
                    h(3973, "Z5Ed", 2636, 3714, 3280)
                ](
                  J_,
                  ay[e[a(1117, 1464, "x7um", 711)]][
                    h(3400, "j9*&", 3017, 2583, 3362)
                  ],
                  i
                )
              : !_0x48417a &&
                (e[s(0, "ne@e", 0, 0, 1868)](
                  _0x331859,
                  _0x4a280c[o("vL@C", 2147)]("id")
                ) ||
                  e[h(125, "u)I4", 90, 819, 1231)](
                    _0x12ed79,
                    _0x4a2b0b[a(3041, 1964, "x7um", 2580)](
                      e[a(1778, 1746, "#Bat", 1536)]
                    )
                  )) &&
                (_0x50475b = _0x4a08a3)),
          e[o("RvbZ", 1556)](
            this[l(2830, 2070, "^hAz", 2250) + "ew"]()[
              a(3858, 2945, "x7um", 2732) + "om"
            ](),
            i[o("FAP3", 367) + "om"]
          ))
        )
          if (
            e[o("DA8@", 1628)](
              e[s(0, "ptBd", 0, 0, 1088)],
              e[a(806, 1581, "DA8@", 382)]
            )
          ) {
            const t = {};
            (t[s(0, "x7um", 0, 0, 641)] = !0),
              (t[
                a(951, -352, "Z5Ed", 862) +
                  h(3375, "u)I4", 2554, 3666, 3197) +
                  "n"
              ] = !1),
              (t[s(0, "qP[S", 0, 0, 846) + "e"] = !1),
              (_0x1d82a3[
                a(1141, 711, "x7um", 1709) + s(0, "qP[S", 0, 0, 2695)
              ] = e[a(129, 1225, "5[3$", 413)](_0x25b365, t));
          } else {
            const t = new Uf({ zIndex: -9998, source: new Mp(i) });
            Object[
              s(0, "DA8@", 0, 0, 295) +
                o("waXB", 1908) +
                a(383, 860, "wJeC", 1447)
            ](t[o("xk4v", 897) + "s_"], e[s(0, "V@QO", 0, 0, 1487)], {
              value: e[h(2030, "x7um", 1980, 2170, 1084)],
              writable: !1,
            }),
              this[o("bKzs", 597) + h(1043, "3%NO", 302, 748, 923)](t);
          }
        if (
          (n[
            h(1641, "u)I4", 1473, 969, 1642) +
              o("hzbI", 1376) +
              a(3360, 2264, "Z5Ed", 2150)
          ] &&
            n[
              h(2081, "%2K1", -15, 1285, 1101) +
                a(494, 2120, "hzbI", 1767) +
                a(-433, 140, "iTSE", 839)
            ][l(2194, 1687, "3%NO", 1547)](this, [!0]),
          this[o("]QDq", 677) + o("V@QO", 105)])
        ) {
          if (
            !e[o("5[Ds", 1038)](
              e[a(1193, 1677, ")M@t", 2015)],
              e[a(131, 1255, "6sU^", 477)]
            )
          ) {
            let t,
              e = {};
            for (t in _0x19e75b)
              _0x1f1aa9[
                l(1536, 1204, "naYB", 489) + o("r4s(", 2132) + o("a#*#", 1321)
              ](t) && (e[t] = _0x2ebcbd[t]);
            return e;
          }
          this.un(
            e[o("waXB", 1646)],
            this[a(817, 2164, "x7um", 1961) + s(0, "3%NO", 0, 0, 1210)]
          );
        }
        (this[a(3402, 3727, "2XNM", 2551) + l(2238, 1533, "FTF#", 1307)] =
          function () {
            const t = {
              udQXi: function (t, i, n) {
                return e[((r = "lV]E"), (s = 475), Cy(s - -547, r))](t, i, n);
                var r, s;
              },
              qfBdl: e[c(2611, "AF$5", 2015, 1464, 1623)],
            };
            function s(t, e, i, n, r) {
              return a(t - 472, e - 430, i, r - 831);
            }
            function h(t, e, i, n, r) {
              return a(t - 224, e - 412, t, e - 841);
            }
            function c(t, e, i, n, r) {
              return o(e, r - 828);
            }
            function u(t, e, i, n, r) {
              return l(n - 120, e - 356, t, n - 383);
            }
            function d(t, e, i, n, r) {
              return a(t - 451, e - 4, n, t - -44);
            }
            if (
              e[c(0, "2XNM", 0, 0, 1449)](
                e[s(2148, 1366, "WJFM", 0, 1291)],
                e[u("AF$5", 2736, 0, 2775)]
              )
            ) {
              if (
                e[h("RvbZ", 3220)](
                  this[u("5[3$", 4202, 0, 3018) + "ew"]()[
                    c(0, "5[Ds", 0, 0, 2366) + "om"
                  ](),
                  i[h(")M@t", 2920) + "om"]
                )
              )
                if (
                  e[u("HpoK", 4206, 0, 3179)](
                    e[s(2140, 1727, "FTF#", 0, 1860)],
                    e[c(0, "waXB", 0, 0, 690)]
                  )
                ) {
                  const t =
                    e[s(2359, 2061, "a#*#", 0, 1303)][h("RvbZ", 2002)]("|");
                  let i = 0;
                  for (;;) {
                    switch (t[i++]) {
                      case "0":
                        _0x49c010[d(972, -129, 0, "iTSE") + "ic"] &&
                          this[
                            c(0, "dehg", 0, 0, 2693) +
                              u("DA8@", 2035, 0, 2766) +
                              h("6sU^", 2705) +
                              u("hbl9", 3298, 0, 3091)
                          ](!0);
                        continue;
                      case "1":
                        e[d(473, -366, 0, "5U(6")](
                          _0x3fb6fb,
                          _0x4f4d4e[
                            u("FAP3", 1844, 0, 2114) +
                              c(0, "u)I4", 0, 0, 736) +
                              u("iTSE", 1412, 0, 1486) +
                              c(0, "hzbI", 0, 0, 1133)
                          ](e[h("iTSE", 1899)]),
                          !1
                        );
                        continue;
                      case "2":
                        this[d(566, 677, 0, "dehg") + "ew"]()[
                          d(507, 223, 0, "G)uk") + c(0, "a#*#", 0, 0, 1887)
                        ](19);
                        continue;
                      case "3":
                        this[
                          c(0, "vL@C", 0, 0, 2356) +
                            c(0, "^C2X", 0, 0, 716) +
                            "t"
                        ]()[
                          d(1916, 2113, 0, "wJeC") +
                            s(1922, 3042, "FTF#", 0, 2681) +
                            "d"
                        ](
                          _0x48a794[
                            _0x2dbb95[s(1619, 1156, "hzbI", 0, 2287) + "t"]
                          ][d(1490, 2525, 0, "5[3$")]
                        );
                        continue;
                      case "4":
                        _0x624a0b = e[u("2XNM", 2330, 0, 2320)](
                          _0x565f0f,
                          _0xe016ef[d(1666, 617, 0, "^hAz") + "t"],
                          _0x8e6489,
                          this
                        );
                        continue;
                      case "5":
                        _0x5a10ec[d(1904, 1172, 0, "ne@e")] &&
                          this[
                            u("ne@e", 2804, 0, 2531) +
                              s(3812, 3888, "waXB", 0, 3194) +
                              u("hzbI", 1871, 0, 1493)
                          ](e[d(1015, 340, 0, "[VZg")]);
                        continue;
                      case "6":
                        if (!_0x12975b) return;
                        continue;
                      case "7":
                        this[
                          d(494, -730, 0, "6sU^") + u("auw)", 2963, 0, 2942)
                        ](
                          _0x417542[u("qDUP", 3613, 0, 3364) + "pe"]
                            ? _0x2606da[c(0, "vL@C", 0, 0, 2650) + "pe"]
                            : e[d(2010, 2849, 0, "y(aR")]
                        );
                        continue;
                      case "8":
                        if (
                          !_0x424da1[
                            s(1595, 522, "AF$5", 0, 1221) +
                              d(213, 607, 0, "3%NO")
                          ]
                        ) {
                          const t = {};
                          (t[c(0, "u)I4", 0, 0, 2221)] = !0),
                            (t[
                              s(3096, 3937, "xk4v", 0, 2730) +
                                s(1662, 3468, "waXB", 0, 2708) +
                                "n"
                            ] = !1),
                            (t[u("5[3$", 1771, 0, 2452) + "e"] = !1),
                            (_0x2ee7ee[
                              c(0, "RvbZ", 0, 0, 1325) +
                                s(3395, 4255, "hzbI", 0, 3622)
                            ] = e[s(2035, 482, "auw)", 0, 1102)](_0x5ac904, t));
                        }
                        continue;
                      case "9":
                        _0x30db42[u("r4s(", 364, 0, 1627) + "d"] &&
                          (_0x2b2013[_0x5ce0bc[h("dehg", 2779) + "t"]][
                            h("xk4v", 2364) + "d"
                          ] = !0);
                        continue;
                    }
                    break;
                  }
                } else
                  this[
                    d(2074, 1702, 0, "^hAz") +
                      s(3468, 3760, "naYB", 0, 2935) +
                      "r"
                  ](
                    this[h("FTF#", 3361) + s(2862, 1350, "x7um", 0, 2263)](
                      e[c(0, "]QDq", 0, 0, 784)]
                    )
                  ),
                    n[
                      u("ne@e", 2770, 0, 1642) +
                        d(1282, 680, 0, "ne@e") +
                        h("6sU^", 2937)
                    ] &&
                      n[
                        u("vL@C", 2384, 0, 1482) +
                          u("FTF#", 2018, 0, 1397) +
                          h("u)I4", 3235)
                      ][u("5[3$", 1912, 0, 1777)](r, [!1]);
              else if (
                r[u("^hAz", 4158, 0, 3239) + s(2953, 2194, "Pbla", 0, 1706)] &&
                !this[
                  d(2612, 3242, 0, "auw)") + s(2499, 1525, "ne@e", 0, 1922)
                ](e[h("HpoK", 1139)])
              ) {
                if (
                  !e[d(1841, 1431, 0, "6sU^")](
                    e[u("wJeC", 1988, 0, 1142)],
                    e[c(0, "r4s(", 0, 0, 1175)]
                  )
                )
                  return void t[s(3984, 4179, "G)uk", 0, 3234)](
                    _0x2da52c,
                    () =>
                      this[
                        c(0, "iTSE", 0, 0, 1855) +
                          d(487, 1334, 0, "^$I&") +
                          c(0, "6sU^", 0, 0, 2301) +
                          h("iTSE", 3246)
                      ](_0x12a222),
                    250
                  );
                {
                  const t = new Uf({ zIndex: -9998, source: new Mp(i) });
                  Object[
                    s(1691, 2128, "RvbZ", 0, 2089) +
                      h("5U(6", 2746) +
                      s(3493, 3018, "RvbZ", 0, 3133)
                  ](
                    t[s(3466, 3261, "ne@e", 0, 2237) + "s_"],
                    e[u("5[3$", 2670, 0, 1827)],
                    { value: e[u("auw)", 2479, 0, 3477)], writable: !1 }
                  ),
                    this[d(219, 635, 0, "dehg") + c(0, "vL@C", 0, 0, 2585)](t),
                    n[
                      u("bKzs", 3335, 0, 3397) +
                        s(1463, 1297, "y(aR", 0, 2201) +
                        u("5[3$", 1165, 0, 2374)
                    ] &&
                      n[
                        c(0, "G)uk", 0, 0, 2965) +
                          c(0, "FAP3", 0, 0, 683) +
                          c(0, "3%NO", 0, 0, 1485)
                      ][u("[VZg", 2021, 0, 1826)](r, [!0]);
                }
              }
            } else
              this.un(
                t[d(1469, 1127, 0, "AF$5")],
                this[
                  s(1179, 3213, "#Bat", 0, 2408) +
                    s(2644, 1899, "vL@C", 0, 1477)
                ]
              );
          }),
          this.on(
            e[h(2683, "^hAz", 2291, 1665, 1548)],
            this[l(3332, 2258, "Z5Ed", 2441) + a(686, -64, "]QDq", 820)]
          );
      } else if (
        !t &&
        n[h(2362, "[VZg", 2612, 3246, 2638) + "s"][
          h(2065, "Dh8h", 3658, 3097, 2617) + "ic"
        ]
      ) {
        if (
          e[s(0, "5[3$", 0, 0, 1808)](
            e[s(0, "5[Ds", 0, 0, 2088)],
            e[a(3131, 3077, "[VZg", 2159)]
          )
        )
          return _0x4bcd1a[o("u)I4", 1372) + o("iTSE", 3) + "de"][
            l(2091, 1923, "%2K1", 2386)
          ](_0x48f87b, _0x202378);
        if (
          ((n[a(-47, 1384, "DA8@", 816) + "s"][
            s(0, "naYB", 0, 0, 1054) + "ic"
          ] = !1),
          this[a(1219, 1864, "qDUP", 789) + o("l9RD", 866)])
        ) {
          if (
            e[l(1130, 592, "^$I&", 1757)](
              e[s(0, "a#*#", 0, 0, 1340)],
              e[h(3995, "[VZg", 2235, 2499, 2726)]
            )
          ) {
            let t = null;
            return (
              this[a(1955, 1182, "xk4v", 2137) + o("lV]E", 1814)]()[
                o("y(aR", 1228) + "ch"
              ](function (i) {
                function n(t, e, i, n, r) {
                  return h(t - 489, n, i - 335, n - 362, r - 421);
                }
                function r(t, e, i, n, r) {
                  return h(t - 276, t, i - 88, n - 237, n - -1306);
                }
                var s, o, l, c;
                !t &&
                  (e[n(2863, 0, 2792, "g(zI", 2232)](
                    _0xf0d815,
                    i[n(4189, 0, 3716, "waXB", 3638)]("id")
                  ) ||
                    e[r("vL@C", 0, 523, 1233)](
                      _0x3ef75e,
                      i[
                        ((s = -421),
                        (o = 881),
                        (l = 59),
                        (c = "Pbla"),
                        a(s - 70, o - 456, c, l - -678))
                      ](e[r("2XNM", 0, 337, 545)])
                    )) &&
                  (t = i);
              }),
              t
            );
          }
          this.un(
            e[s(0, "DA8@", 0, 0, 1286)],
            this[l(2999, 4072, "g(zI", 4123) + o("^hAz", 612)]
          ),
            (this[s(0, "FTF#", 0, 0, 422) + a(2389, 1023, "hzbI", 1565)] =
              null);
        }
        this[o("%2K1", 216) + o("FAP3", 2222) + "r"](
          this[s(0, "dehg", 0, 0, 463) + l(1586, 2812, "l9RD", 1958)](
            e[h(1434, "%2K1", 2616, 3571, 2677)]
          )
        ),
          n[
            s(0, "2XNM", 0, 0, 2106) +
              a(3071, 1748, "a#*#", 2333) +
              s(0, "#Bat", 0, 0, 568)
          ] &&
            n[
              a(503, 336, "V@QO", 981) +
                l(1736, 1974, "dehg", 695) +
                a(2210, 2255, "3%NO", 1048)
            ][a(593, 1510, "qP[S", 673)](this, [!1]);
      }
      function a(t, e, i, n, r) {
        return Wy(i, n - 334);
      }
      function l(t, e, i, n, r) {
        return uy(0, 0, t - 1044, 0, i);
      }
      function h(t, e, i, n, r) {
        return ry(0, r - -317, 0, e);
      }
      return this;
    }
    [Wy("3%NO", 1601) +
      ny(0, 1468, 0, 0, "FTF#") +
      uy(0, 0, 121, 0, "qDUP") +
      my(0, "5[Ds", 2068) +
      "d"]() {
      function t(t, e, i, n, r) {
        return uy(0, 0, t - -411, 0, r);
      }
      const e = {};
      var i, n;
      function r(t, e, i, n, r) {
        return ry(0, r - -311, 0, t);
      }
      e[((i = 3538), (n = "hzbI"), ny(0, i - 1706, 0, 0, n))] =
        t(1849, 0, 0, 0, "HpoK") + r("Z5Ed", 2275, 2475, 3859, 2799);
      const s = e;
      return !!this[
        t(1321, 0, 0, 0, "hzbI") +
          ((o = 323), (a = "RvbZ"), my(0, a, o - -1487))
      ](s[r("u)I4", 0, 0, 0, 1965)]);
      var o, a;
    }
    [ry(0, 3595, 0, "naYB") +
      uy(0, 0, 2210, 0, "wJeC") +
      uy(0, 0, 1541, 0, "dehg") +
      "r"]() {
      const t = {
        nzcLl: function (t, e) {
          return t(e);
        },
        eOKtO: l(3633, 2693, 3121, 1706, "5[Ds"),
        wKFAg: l(2423, 2104, 2892, 2796, "lV]E"),
        lWgVU: function (t, e) {
          return t(e);
        },
        JQzvR: function (t, e) {
          return t !== e;
        },
        zgMEM: o(4497, 3296, ")M@t"),
        FEzTz: o(2035, 2694, "g(zI"),
        YJrUJ: o(2789, 3153, "6sU^") + "el",
        TktFZ: function (t, e) {
          return t === e;
        },
        csgVe: o(2283, 3013, "5U(6"),
        LTLsm: l(2092, 1173, 1124, 1534, "a#*#"),
        QMCOz: a("[VZg", 1320, 1192),
      };
      let e, i, n, r;
      function s(t, e, i, n, r) {
        return my(0, i, e - -657);
      }
      function o(t, e, i, n, r) {
        return my(0, i, e - 67);
      }
      function a(t, e, i, n, r) {
        return ry(0, e - -441, 0, t);
      }
      function l(t, e, i, n, r) {
        return Wy(r, e - 1115);
      }
      function h(t, e, i, n, r) {
        return ny(0, i - 1105, 0, 0, r);
      }
      if (
        ((r =
          M_[this[l(2844, 3577, 4746, 2562, "qDUP") + s(2452, 2873, "waXB")]]),
        (n =
          !ay[r[s(1630, 2336, "HpoK") + "pe"]] || r[o(2317, 2854, "y(aR") + "d"]
            ? ay.__
            : ay[r[h(1436, 3268, 2334, 2106, "3%NO") + "pe"]]),
        (e =
          n[
            r[l(2222, 1057, 794, -12, "FAP3") + "s"][a(")M@t", 2886, 3846)]
              ? t[s(0, 793, "qP[S")]
              : t[h(430, 1836, 1085, 1622, "auw)")]
          ]),
        (i = t[o(0, 3301, "hbl9")](
          j_,
          n[
            h(0, 0, 854, 0, "#Bat") +
              l(0, 2784, 0, 0, "x7um") +
              s(0, 2545, "hzbI")
          ]
        )),
        (i[l(0, 1240, 0, 0, "g(zI") + h(0, 0, 2662, 0, "qDUP")] = 0),
        t[a("5[3$", 1367)](e, r[a("dehg", 3162) + h(0, 0, 1403, 0, "auw)")]))
      )
        if (t[a("FTF#", 2887)](t[s(0, 2284, "%2K1")], t[a("HpoK", 2174)])) {
          if (
            ((r[o(0, 1853, "^$I&") + l(0, 3097, 0, 0, "l9RD")] = e),
            this[h(0, 0, 2431, 0, "Pbla") + l(0, 3394, 0, 0, "FAP3") + "r"](
              this[l(0, 2703, 0, 0, "]QDq") + a("^$I&", 2939)](
                t[h(0, 0, 2562, 0, "y(aR")]
              )
            ),
            e)
          )
            if (t[a("WJFM", 1099)](t[o(0, 1600, ")M@t")], t[a("naYB", 803)]))
              _0x4703e1[l(0, 2546, 0, 0, "qP[S")][
                h(0, 0, 2964, 0, "^hAz") + "om"
              ](1);
            else {
              this[
                h(0, 0, 2390, 0, "ptBd") + a("waXB", 1053) + o(0, 1955, "Pbla")
              ]($_, r[l(0, 2218, 0, 0, "ptBd") + s(0, 2946, "a#*#")], i);
              const e = new Uf({
                zIndex: -9997,
                useInterimTilesOnError: !1,
                source: new Mp(i),
              });
              Object[
                h(0, 0, 2659, 0, "Z5Ed") + a("Pbla", 1175) + s(0, 1357, "vL@C")
              ](e[a("bKzs", 2381) + "s_"], t[s(0, 1541, "6sU^")], {
                value: t[o(0, 1690, "wJeC")],
                writable: !1,
              }),
                this[a("5[3$", 1930) + o(0, 2184, "5[3$")](e);
            }
        } else if (t[a("G)uk", 1448)](_0x116985, _0x2b762d)) {
          const t = () => {};
          (_0x57c08b[l(0, 1962, 0, 0, "FTF#") + s(0, 1525, "ptBd") + "s"] = t),
            (_0x42d5ec[s(0, 1039, "waXB")] = t),
            (_0x587701[
              s(0, 2003, "u)I4") + h(0, 0, 967, 0, "Pbla") + a("j9*&", 996)
            ] = t),
            (_0x2140d5[h(0, 0, 2863, 0, "hzbI") + a("WJFM", 1324)]()[
              h(0, 0, 2776, 0, "3%NO") +
                a("waXB", 3138) +
                h(0, 0, 843, 0, "wJeC") +
                s(0, 1724, "RvbZ")
            ] = t),
            (_0x56ad67[o(0, 2517, "wJeC") + s(0, 689, "#Bat")]()[
              h(0, 0, 2257, 0, "RvbZ") +
                s(0, 1311, "Pbla") +
                l(0, 2448, 0, 0, "g(zI") +
                l(0, 2969, 0, 0, "wJeC")
            ] = t),
            (_0x2aba83[s(0, 1106, "qDUP") + h(0, 0, 1023, 0, "]QDq")]()[
              l(0, 2787, 0, 0, "RvbZ") +
                h(0, 0, 2300, 0, "qP[S") +
                o(0, 2237, "y(aR") +
                o(0, 3186, "wJeC")
            ] = t),
            (_0x2f2b6a[l(0, 2286, 0, 0, "AF$5") + o(0, 1483, "Dh8h")]()[
              o(0, 1948, "FTF#") + "ls"
            ] = t),
            (_0x11e658[o(0, 1554, "x7um") + l(0, 3040, 0, 0, "qDUP")]()[
              l(0, 2999, 0, 0, "FTF#")
            ] = t),
            (_0x54b769[a("qDUP", 1326) + o(0, 2824, "iTSE")]()[
              a("x7um", 2696) + a("FTF#", 3239) + l(0, 2831, 0, 0, "%2K1")
            ] = t);
        }
    }
    [my(0, ")M@t", 1978) + ry(0, 1963, 0, "^hAz")](t) {
      const e = {};
      function i(t, e, i, n, r) {
        return uy(0, 0, t - -470, 0, n);
      }
      function n(t, e, i, n, r) {
        return my(0, i, e - -365);
      }
      function r(t, e, i, n, r) {
        return my(0, t, i - -190);
      }
      function s(t, e, i, n, r) {
        return Wy(i, t - 336);
      }
      function o(t, e, i, n, r) {
        return Wy(n, t - 1003);
      }
      (e[o(2216, 1073, 2463, "5[Ds")] = s(1488, 2574, "5[3$") + "t"),
        (e[s(541, 1018, "wJeC")] = function (t, e) {
          return t < e;
        }),
        (e[o(988, -49, 1675, "hbl9")] = n(3741, 3122, "FTF#")),
        (e[i(154, 0, 0, "AF$5")] = function (t, e) {
          return t === e;
        }),
        (e[o(2368, 2750, 3513, "^C2X")] = function (t, e) {
          return t + e;
        }),
        (e[s(782, 1938, "xk4v")] = n(2868, 2718, "r4s(") + "c."),
        (e[o(3221, 1975, 4432, "j9*&")] = o(3176, 2079, 2920, "2XNM")),
        (e[r("dehg", 0, 1457)] = r("5[Ds", 0, 3288)),
        (e[n(0, 1665, "l9RD")] = function (t, e) {
          return t === e;
        }),
        (e[r("x7um", 0, 2471)] = n(0, 1474, "Pbla")),
        (e[o(3156, 2783, 4364, "5U(6")] = function (t, e) {
          return t === e;
        }),
        (e[r("naYB", 0, 2686)] = s(1569, 0, "l9RD")),
        (e[n(0, 1895, "u)I4")] = s(377, 0, "5U(6"));
      const a = e;
      let l = null;
      return (
        this[r("vL@C", 0, 1753) + s(1735, 0, "hbl9")]()[
          o(1403, 0, 0, "[VZg") + "ch"
        ](function (e) {
          function r(t, e, i, r, s) {
            return n(0, i - -865, r);
          }
          function o(t, e, n, r, s) {
            return i(e - 42, 0, 0, t);
          }
          function h(t, e, i, n, r) {
            return s(r - 176, 0, t);
          }
          function c(t, e, i, n, r) {
            return s(i - 793, 0, e);
          }
          function u(t, e, i, r, s) {
            return n(0, t - -1405, s);
          }
          if (a[o("Dh8h", 1200)](a[o("y(aR", 39)], a[h("V@QO", 0, 0, 0, 2919)]))
            for (
              _0x2f7370 = _0x4a30f4[0][
                c(0, "lV]E", 2501) +
                  h("qDUP", 0, 0, 0, 1638) +
                  h("FTF#", 0, 0, 0, 930) +
                  h("qDUP", 0, 0, 0, 2935)
              ](a[c(0, "hzbI", 1386)]),
                _0x508fc3 = 0,
                _0x561f0a = _0x27a028[h("5U(6", 0, 0, 0, 1925) + "h"];
              a[o("^$I&", 1501)](_0x4b8fbd, _0x4ecafd) && !_0x2efa7c;
              ++_0x5afaba
            )
              (_0x260351 = _0x138799[_0x1f305d][
                h("HpoK", 0, 0, 0, 2812) + u(530, 0, 0, 0, "a#*#") + "te"
              ](a[u(1208, 0, 0, 0, "^C2X")])),
                _0x1e1882 &&
                  (_0x5ae1b9 ||
                    a[o("ptBd", 757)](
                      _0x1751a5[u(1809, 0, 0, 0, "]QDq") + "Of"](
                        a[r(0, 0, 2289, "u)I4")](
                          a[h("5[Ds", 0, 0, 0, 1449)],
                          _0x48fd25
                        )
                      ),
                      8
                    )) &&
                  (_0x52d8f6 = _0x22505d[_0x258ac5][
                    h("naYB", 0, 0, 0, 440) + u(1254, 0, 0, 0, "#Bat") + "te"
                  ](a[u(1039, 0, 0, 0, "5[3$")])[r(0, 0, 173, "a#*#")](
                    /callback=([^&]*)/
                  ));
          else
            !l &&
              (a[o("5[3$", 565)](t, e[o("qDUP", 151)]("id")) ||
                a[c(0, "FTF#", 1669)](
                  t,
                  e[u(402, 0, 0, 0, "%2K1")](a[h("Dh8h", 0, 0, 0, 1790)])
                )) &&
              (a[r(0, 0, 2298, "bKzs")](
                a[o("^$I&", 582)],
                a[h("u)I4", 0, 0, 0, 1530)]
              )
                ? (_0x176846 = _0x58b04b[_0x4588e4][
                    h("a#*#", 0, 0, 0, 1891) + h("vL@C", 0, 0, 0, 1547) + "te"
                  ](a[r(0, 0, 1873, "u)I4")])[h("ptBd", 0, 0, 0, 1116)](
                    /callback=([^&]*)/
                  ))
                : (l = e));
        }),
        l
      );
    }
    [ry(0, 1706, 0, "5[3$") + Wy("^hAz", 533) + uy(0, 0, 1861, 0, "g(zI")](
      t,
      e,
      i
    ) {
      const n = {
          PlMAm: function (t, e, i) {
            return t(e, i);
          },
          VCYhB:
            h(791, 582, 1702, "Z5Ed") +
            h(1322, 1392, 1481, "ne@e") +
            o(1451, 1572, 1365, 939, "wJeC") +
            h(3129, 2044, 1957, "AF$5") +
            s("ptBd", 1735, 943, 1574, 1306) +
            h(2880, 2087, 2935, "j9*&") +
            o(1800, 2098, 3196, 1758, "waXB") +
            a(1032, "WJFM", 1412, 1854),
          IuuiJ: o(1843, 2773, 2844, 2750, "xk4v"),
          zYCFP: function (t, e) {
            return t !== e;
          },
          QYOwC: h(3465, 2273, 3112, "6sU^"),
          TGkvL: function (t, e) {
            return t === e;
          },
          jcRlP: s("#Bat", 270, 521, 1824, 1005),
          wtdMq: a(2786, "2XNM", 2438, 2488),
          GEujD: function (t, e) {
            return t === e;
          },
          NgBSE: s("lV]E", 279, 1024, 480, 871),
          NvlBJ: h(629, 1123, 13, "u)I4"),
          UWruS: function (t, e) {
            return t % e;
          },
          CxwdE: function (t, e) {
            return t + e;
          },
          ZbrEg: function (t, e) {
            return t + e;
          },
          qxSlE: function (t, e, i, n, r, s) {
            return t(e, i, n, r, s);
          },
          KOpXp: function (t, e) {
            return t(e);
          },
          nVYuC:
            u(1974, 2237, 2415, 2790, "DA8@") +
            u(2637, 2099, 2990, 2266, "%2K1") +
            "c",
          OQPmH: function (t, e) {
            return t(e);
          },
          RuqNP: u(1013, 573, 1537, -234, "6sU^") + a(2735, "V@QO", 1819, 1851),
          Aulpw: function (t, e) {
            return t(e);
          },
          nKfZG: h(3204, 3053, 3678, "a#*#"),
          aYxNY:
            s("5U(6", 4165, 4221, 2107, 3086) +
            s("FTF#", 750, 835, 2258, 1022) +
            o(3347, 2505, 1892, 3187, "HpoK"),
        },
        r = n[a(949, "y(aR", 2666, 2082)](z_, t);
      function s(t, e, i, n, r) {
        return ry(0, r - -315, 0, t);
      }
      function o(t, e, i, n, r) {
        return ry(0, e - -714, 0, r);
      }
      function a(t, e, i, n, r) {
        return uy(0, 0, n - 1435, 0, e);
      }
      i[n[u(1168, 111, 1316, 1540, "qP[S")](G_, n[o(0, 872, 0, 0, "ptBd")])] =
        n[u(2290, 3180, 3089, 1865, "l9RD")](
          G_,
          n[h(2079, 3030, 1981, "2XNM")]
        );
      const l = n[h(735, 733, 754, "FAP3")](G_, n[o(0, 1957, 0, 0, "^$I&")]);
      function h(t, e, i, n, r) {
        return Wy(n, e - 649);
      }
      const c = r[o(0, 1144, 0, 0, "FTF#") + "h"];
      function u(t, e, i, n, r) {
        return uy(0, 0, t - 454, 0, r);
      }
      let d = 0;
      i[n[s("g(zI", 0, 0, 0, 2587)](G_, n[s("g(zI", 0, 0, 0, 2323)])] =
        function (t) {
          function i(t, e, i, n, r) {
            return h(0, e - -911, 0, n);
          }
          function s(t, e, i, n, r) {
            return u(e - -872, 0, 0, 0, n);
          }
          function a(t, e, i, n, r) {
            return o(0, t - -885, 0, 0, i);
          }
          function g(t, e, i, n, r) {
            return u(t - -585, 0, 0, 0, r);
          }
          function f(t, e, i, n, r) {
            return h(0, i - -73, 0, r);
          }
          if (
            !n[f(0, 0, 2816, 0, "#Bat")](
              n[f(0, 0, 1852, 0, ")M@t")],
              n[s(0, 680, 0, "3%NO")]
            )
          ) {
            let o, h, u, p;
            if (
              ((u = t[0]),
              (h = t[2]),
              (o = t[1]),
              n[i(0, -72, 0, "vL@C")](c, 1))
            ) {
              if (
                !n[g(1637, 0, 0, 0, "Dh8h")](
                  n[i(0, 1399, 0, "5U(6")],
                  n[i(0, 1300, 0, "y(aR")]
                )
              )
                return (
                  n[a(505, 0, "2XNM")](
                    _0x48742f,
                    n[g(961, 0, 0, 0, "ne@e")],
                    n[s(0, 862, 0, "qP[S")]
                  ),
                  !1
                );
              p = r[0];
            } else
              n[f(0, 0, 1517, 0, "x7um")](
                n[g(2060, 0, 0, 0, "RvbZ")],
                n[a(1133, 0, "^$I&")]
              )
                ? _0x1875b9[_0x126f41[1]]()
                : ((p = r[n[s(0, -207, 0, "FTF#")](d, c)]), d++);
            return (
              (p = n[f(0, 0, 1643, 0, "y(aR")](
                n[s(0, 1727, 0, "bKzs")](
                  n[f(0, 0, 995, 0, "ptBd")](
                    p,
                    n[s(0, 1391, 0, "^$I&")](B_, u, o, h, e, q_)
                  ),
                  "."
                ),
                l
              )),
              p
            );
          }
          this[
            s(0, 523, 0, "g(zI") +
              g(2288, 0, 0, 0, "y(aR") +
              g(1893, 0, 0, 0, "Z5Ed") +
              "r"
          ]();
        };
    }
    [uy(0, 0, 490, 0, "wJeC") +
      my(0, "naYB", 3418) +
      my(0, "waXB", 2327) +
      ny(0, -515, 0, 0, "Pbla") +
      "l"](t, e, i) {
      function n(t, e, i, n, r) {
        return my(0, i, e - -1199);
      }
      const r = {
        OUnvr: function (t, e, i) {
          return t(e, i);
        },
        ejMRA: function (t, e) {
          return t === e;
        },
        SvKfH: s(1634, 2396, 2509, 3755, "hzbI"),
        uluWB:
          s(2354, 2111, 2057, 1113, "5[Ds") + s(505, 534, 1487, 631, "auw)"),
        uEtih: function (t, e) {
          return t !== e;
        },
        TyYtA: a("ne@e", -22),
        AwWVT: function (t, e) {
          return t(e);
        },
        ulqUi: s(1807, 2703, 1756, 1545, "FAP3"),
        prRFT: o("iTSE", 1452, 592, 1307, 542),
      };
      function s(t, e, i, n, r) {
        return uy(0, 0, i - 1185, 0, r);
      }
      function o(t, e, i, n, r) {
        return ry(0, r - -688, 0, t);
      }
      function a(t, e, i, n, r) {
        return my(0, t, e - -1265);
      }
      return super[
        n(0, 1425, "Dh8h") +
          ((l = 1186), (h = "^$I&"), my(0, h, l - -1650)) +
          n(0, 541, "3%NO") +
          n(0, 2455, "^C2X") +
          "l"
      ](
        t,
        (t, i) => {
          function n(t, e, i, n, r) {
            return s(t - 179, e - 389, n - -1591, n - 485, r);
          }
          function l(t, e, i, n, r) {
            return o(r, e - 313, i - 374, n - 146, i - -873);
          }
          function h(t, e, i, n, r) {
            return o(e, e - 283, i - 159, n - 24, t - -317);
          }
          function c(t, e, i, n, r) {
            return a(i, t - -245);
          }
          function u(t, e, i, n, r) {
            return s(t - 4, e - 158, n - 9, n - 65, r);
          }
          if (
            r[h(879, "[VZg", -393, 319)](
              r[h(2295, "lV]E", 2510, 2591)],
              r[h(858, "r4s(", 1263, 146)]
            )
          ) {
            let t =
              _0x349ae9[this[c(-151, 0, "waXB") + h(1577, "WJFM", 1791, 1916)]];
            return t
              ? (r[l(0, -708, -86, 362, "5U(6")](
                  _0x4eff6d,
                  r[c(1986, 0, "WJFM")]
                ) ||
                (_0x238408 &&
                  !this[
                    c(423, 0, "lV]E") +
                      h(881, "r4s(", 46, 166) +
                      u(1564, 2633, 0, 2496, "wJeC") +
                      "ed"
                  ]())
                  ? ((t[h(1047, "l9RD", 110, 1211) + "s"][
                      u(2176, 1821, 0, 2439, "Dh8h")
                    ] = !0),
                    t[n(465, 462, 0, 1030, "%2K1") + c(4, 0, "G)uk") + "r"] &&
                      t[
                        u(2098, 1062, 0, 2213, "l9RD") +
                          h(272, "bKzs", -978, 12) +
                          "r"
                      ][l(0, -403, -90, 1185, "AF$5")](this, [!0]))
                  : !_0x6d8119 &&
                    t[c(1254, 0, "Dh8h") + "s"][h(750, "#Bat", 514, -247)] &&
                    ((t[h(1919, "bKzs", 2464, 3097) + "s"][
                      u(899, 1683, 0, 2e3, "V@QO")
                    ] = !1),
                    t[c(169, 0, "hbl9") + c(1663, 0, ")M@t") + "r"] &&
                      t[
                        n(1832, 926, 0, 1569, "[VZg") +
                          h(861, "]QDq", 1825, 737) +
                          "r"
                      ][l(0, 2557, 1352, 1138, "dehg")](this, [!1])),
                this[
                  c(1074, 0, "vL@C") +
                    u(454, 1606, 0, 1107, "2XNM") +
                    n(1353, -656, 0, 229, "l9RD") +
                    "r"
                ](),
                this)
              : void r[h(1799, "ne@e", 2941, 1209)](
                  _0x2bb57b,
                  () =>
                    this[
                      c(-112, 0, "g(zI") +
                        l(0, 1824, 1030, 3, "^hAz") +
                        u(2367, 2628, 0, 3357, "FAP3")
                    ](_0x45e302),
                  250
                );
          }
          !r[l(0, 290, 923, 1966, "V@QO")](Ry, i) &&
            (r[l(0, 276, -129, -1, "FTF#")](
              r[n(-729, 858, 0, 187, "FTF#")],
              r[h(1504, "waXB", 2039, 1882)]
            )
              ? r[l(0, 33, 1293, 1885, "[VZg")](e, t, i)
              : (this[
                  h(1158, "^C2X", 1071, 1914) +
                    u(2445, 3328, 0, 2143, "RvbZ") +
                    "r"
                ](
                  this[
                    l(0, 1825, 1444, 2175, "#Bat") +
                      u(2785, 2197, 0, 3312, "waXB")
                  ](r[u(2297, 3166, 0, 3261, "[VZg")])
                ),
                _0x52f82a[
                  n(-563, -1225, 0, -128, "#Bat") +
                    n(869, -345, 0, -173, "FTF#") +
                    n(-638, 1422, 0, 347, "WJFM")
                ] &&
                  _0x296774[
                    h(1228, "auw)", 370, 1247) +
                      h(2074, "r4s(", 2542, 1568) +
                      c(1221, 0, "ne@e")
                  ][h(1392, "3%NO", 1195, 574)](_0x40d4b9, [!1])));
        },
        i
      );
      var l, h;
    }
    [ny(0, 1881, 0, 0, "bKzs") + Wy("AF$5", 2281)]() {
      function t(t, e, i, n, r) {
        return uy(0, 0, i - 703, 0, t);
      }
      function e(t, e, i, n, r) {
        return ry(0, i - -1199, 0, r);
      }
      const i = {
        eYxNI: function (t, e) {
          return t <= e;
        },
        zQrcr: function (t, e, i) {
          return t(e, i);
        },
        yOpBF: function (t, e) {
          return t !== e;
        },
        cBGVF: n(309, 236, -997, "qDUP", 153),
        miahw: a(1799, "^hAz", 2110, 1204),
        vppgp: t("Pbla", 0, 2362),
        AQRtJ: n(1574, 2081, -104, "2XNM", 1030),
        NweTj: function (t, e) {
          return t(e);
        },
        JOOiY: function (t, e) {
          return t !== e;
        },
        vLvmS: e(0, 0, 2349, 0, "ptBd"),
      };
      function n(t, e, i, n, r) {
        return ry(0, r - -1220, 0, n);
      }
      const r = super[n(0, 0, 0, "iTSE", 115) + t("WJFM", 0, 1565)]();
      var s, o;
      function a(t, e, i, n, r) {
        return ny(0, t - 10, 0, 0, e);
      }
      return (
        r[((s = 1049), (o = "ne@e"), Wy(o, s - 115) + "ch")]((t) => {
          function r(t, i, n, r, s) {
            return e(0, 0, s - 1132, 0, r);
          }
          function s(t, e, i, r, s) {
            return n(0, 0, 0, r, s - 407);
          }
          function o(t, e, i, n, r) {
            return a(r - 1222, n, i - 106, n - 226);
          }
          function l(t, i, n, r, s) {
            return e(0, 0, n - -1, 0, i);
          }
          const h = {
            Bqgpc: function (t, e, n) {
              return i[((r = 1203), (s = "^hAz"), Cy(r - 656, s))](t, e, n);
              var r, s;
            },
          };
          function c(t, e, i, n, r) {
            return a(r - 118, t, i - 286, n - 265);
          }
          if (
            i[l(0, "hzbI", 547)](
              i[l(0, "^hAz", 631)],
              i[c("naYB", 0, 1104, 1176, 1282)]
            )
          )
            try {
              if (
                !i[s(0, 0, 0, "l9RD", 2538)](
                  i[c("2XNM", 0, 2128, 2462, 1219)],
                  i[r(0, 0, 0, "g(zI", 3053)]
                )
              )
                return this;
              if (i[s(0, 0, 0, "2XNM", 1888)](Ry, t)) {
                if (
                  i[c("HpoK", 0, -686, -340, 573)](
                    i[c("waXB", 0, 529, -144, 411)],
                    i[l(0, "a#*#", 2057)]
                  )
                ) {
                  for (
                    _0x3be46a =
                      _0x4df123[1][
                        c("DA8@", 0, 2003, -1, 1074) +
                          c("qP[S", 0, -38, 610, 470)
                      ](0),
                      _0x70169d =
                        _0x46d616[2][
                          o(0, 0, 1420, "FTF#", 1957) +
                            c("G)uk", 0, 478, 1353, 1034)
                        ](0),
                      _0x19d106 = _0x2e0b22;
                    i[r(0, 0, 0, "l9RD", 2347)](_0xe34eec, _0x526a5b);
                    ++_0x7a12ff
                  )
                    _0x398f2e[s(0, 0, 0, "3%NO", 2109)](
                      _0x3169b6[o(0, 0, 2272, "bKzs", 1822) + "ce"](
                        _0xe7440a[0],
                        _0x40faba[
                          s(0, 0, 0, "2XNM", 739) +
                            o(0, 0, 268, "iTSE", 772) +
                            "de"
                        ](_0xebb0b1)
                      )
                    );
                  return _0x49edac;
                }
                {
                  const e = () => {};
                  (t[s(0, 0, 0, "y(aR", 2233) + l(0, "hbl9", 798) + "s"] = e),
                    (t[c("[VZg", 0, -422, 893, 260)] = e),
                    (t[
                      c("#Bat", 0, 297, 1204, 1070) +
                        o(0, 0, 1347, "WJFM", 1357) +
                        l(0, "5[3$", 2341)
                    ] = e),
                    (t[
                      r(0, 0, 0, "Pbla", 2479) + c("HpoK", 0, -463, 512, 335)
                    ]()[
                      o(0, 0, 3050, "naYB", 2206) +
                        r(0, 0, 0, ")M@t", 1571) +
                        l(0, "auw)", 1306) +
                        s(0, 0, 0, "waXB", 2736)
                    ] = e),
                    (t[
                      c("V@QO", 0, -274, 1847, 812) +
                        o(0, 0, 1750, "V@QO", 2055)
                    ]()[
                      l(0, "bKzs", 1493) +
                        o(0, 0, 1193, "u)I4", 2394) +
                        o(0, 0, 1699, "5[3$", 840) +
                        r(0, 0, 0, "hbl9", 1768)
                    ] = e),
                    (t[s(0, 0, 0, "WJFM", 584) + r(0, 0, 0, "lV]E", 1252)]()[
                      c("a#*#", 0, 1474, 2872, 1777) +
                        c("dehg", 0, 2139, 1446, 1106) +
                        l(0, ")M@t", 1643) +
                        l(0, "auw)", 1574)
                    ] = e),
                    (t[
                      r(0, 0, 0, "^$I&", 1921) + o(0, 0, 2369, "auw)", 1458)
                    ]()[s(0, 0, 0, "5[Ds", 471) + "ls"] = e),
                    (t[o(0, 0, 2012, "5[3$", 830) + s(0, 0, 0, "x7um", 1088)]()[
                      r(0, 0, 0, "vL@C", 1736)
                    ] = e),
                    (t[
                      r(0, 0, 0, "y(aR", 1355) + c("dehg", 0, 1213, -17, 880)
                    ]()[
                      c("2XNM", 0, 953, 440, 1460) +
                        o(0, 0, 3493, "5[3$", 2655) +
                        l(0, "j9*&", 237)
                    ] = e);
                }
              }
            } catch (t) {}
          else
            h[s(0, 0, 0, "5U(6", 1541)](
              _0x69c43b,
              () =>
                this[
                  c("vL@C", 0, 721, 1935, 1022) +
                    c("]QDq", 0, -280, -1469, -392)
                ](_0x11b6db),
              250
            );
        }),
        r
      );
    }
  }
  var Py = Ty;
  const by = "http://www.w3.org/2001/XMLSchema-instance";
  function Fy(t, e) {
    return tx().createElementNS(t, e);
  }
  function Iy(t, e) {
    return Ly(t, e, []).join("");
  }
  function Ly(t, e, i) {
    if (t.nodeType == Node.CDATA_SECTION_NODE || t.nodeType == Node.TEXT_NODE)
      e
        ? i.push(String(t.nodeValue).replace(/(\r\n|\r|\n)/g, ""))
        : i.push(t.nodeValue);
    else {
      let n;
      for (n = t.firstChild; n; n = n.nextSibling) Ly(n, e, i);
    }
    return i;
  }
  function My(t) {
    return "documentElement" in t;
  }
  function Oy(t, e, i) {
    return t.getAttributeNS(e, i) || "";
  }
  function ky(t) {
    return new DOMParser().parseFromString(t, "application/xml");
  }
  function Ay(t, e) {
    return function (i, n) {
      const r = t.call(void 0 !== e ? e : this, i, n);
      if (void 0 !== r) {
        h(n[n.length - 1], r);
      }
    };
  }
  function Ny(t, e) {
    return function (i, n) {
      const r = t.call(void 0 !== e ? e : this, i, n);
      if (void 0 !== r) {
        n[n.length - 1].push(r);
      }
    };
  }
  function Dy(t, e) {
    return function (i, n) {
      const r = t.call(void 0 !== e ? e : this, i, n);
      void 0 !== r && (n[n.length - 1] = r);
    };
  }
  function Gy(t, e, i) {
    return function (n, r) {
      const s = t.call(void 0 !== i ? i : this, n, r);
      if (void 0 !== s) {
        const t = r[r.length - 1],
          i = void 0 !== e ? e : n.localName;
        let o;
        i in t ? (o = t[i]) : ((o = []), (t[i] = o)), o.push(s);
      }
    };
  }
  function By(t, e, i) {
    return function (n, r) {
      const s = t.call(void 0 !== i ? i : this, n, r);
      if (void 0 !== s) {
        r[r.length - 1][void 0 !== e ? e : n.localName] = s;
      }
    };
  }
  function jy(t, e) {
    return function (i, n, r) {
      t.call(void 0 !== e ? e : this, i, n, r);
      r[r.length - 1].node.appendChild(i);
    };
  }
  function zy(t, e) {
    let i, n;
    return function (e, r, s) {
      if (void 0 === i) {
        i = {};
        const r = {};
        (r[e.localName] = t), (i[e.namespaceURI] = r), (n = Uy(e.localName));
      }
      Hy(i, n, r, s);
    };
  }
  function Uy(t, e) {
    return function (i, n, r) {
      const s = n[n.length - 1].node;
      let o = t;
      void 0 === o && (o = r);
      return Fy(void 0 !== e ? e : s.namespaceURI, o);
    };
  }
  const qy = Uy();
  function Vy(t, e) {
    const i = e.length,
      n = new Array(i);
    for (let r = 0; r < i; ++r) n[r] = t[e[r]];
    return n;
  }
  function Xy(t, e, i) {
    let n, r;
    for (i = void 0 !== i ? i : {}, n = 0, r = t.length; n < r; ++n)
      i[t[n]] = e;
    return i;
  }
  function Zy(t, e, i, n) {
    let r;
    for (r = e.firstElementChild; r; r = r.nextElementSibling) {
      const e = t[r.namespaceURI];
      if (void 0 !== e) {
        const t = e[r.localName];
        void 0 !== t && t.call(n, r, i);
      }
    }
  }
  function Ky(t, e, i, n, r) {
    return n.push(t), Zy(e, i, n, r), n.pop();
  }
  function Hy(t, e, i, n, r, s) {
    const o = (void 0 !== r ? r : i).length;
    let a, l;
    for (let h = 0; h < o; ++h)
      (a = i[h]),
        void 0 !== a &&
          ((l = e.call(
            void 0 !== s ? s : this,
            a,
            n,
            void 0 !== r ? r[h] : void 0
          )),
          void 0 !== l && t[l.namespaceURI][l.localName].call(s, l, a, n));
  }
  function Yy(t, e, i, n, r, s, o) {
    return r.push(t), Hy(e, i, n, r, s, o), r.pop();
  }
  let Qy, $y;
  function Jy() {
    return (
      void 0 === Qy &&
        "undefined" != typeof XMLSerializer &&
        (Qy = new XMLSerializer()),
      Qy
    );
  }
  function tx() {
    return (
      void 0 === $y &&
        "undefined" != typeof document &&
        ($y = document.implementation.createDocument("", "", null)),
      $y
    );
  }
  function ex(t, e) {
    return 2 === e ? t : t.filter((t, i) => i % e < 2);
  }
  var ix = class {
    constructor() {
      (this.polygonBatch = {
        entries: {},
        geometriesCount: 0,
        verticesCount: 0,
        ringsCount: 0,
      }),
        (this.pointBatch = { entries: {}, geometriesCount: 0 }),
        (this.lineStringBatch = {
          entries: {},
          geometriesCount: 0,
          verticesCount: 0,
        });
    }
    addFeatures(t) {
      for (let e = 0; e < t.length; e++) this.addFeature(t[e]);
    }
    addFeature(t) {
      const e = t.getGeometry();
      e && this.addGeometry_(e, t);
    }
    clearFeatureEntryInPointBatch_(t) {
      const e = this.pointBatch.entries[j(t)];
      e &&
        ((this.pointBatch.geometriesCount -= e.flatCoordss.length),
        delete this.pointBatch.entries[j(t)]);
    }
    clearFeatureEntryInLineStringBatch_(t) {
      const e = this.lineStringBatch.entries[j(t)];
      e &&
        ((this.lineStringBatch.verticesCount -= e.verticesCount),
        (this.lineStringBatch.geometriesCount -= e.flatCoordss.length),
        delete this.lineStringBatch.entries[j(t)]);
    }
    clearFeatureEntryInPolygonBatch_(t) {
      const e = this.polygonBatch.entries[j(t)];
      e &&
        ((this.polygonBatch.verticesCount -= e.verticesCount),
        (this.polygonBatch.ringsCount -= e.ringsCount),
        (this.polygonBatch.geometriesCount -= e.flatCoordss.length),
        delete this.polygonBatch.entries[j(t)]);
    }
    addGeometry_(t, e) {
      const i = t.getType();
      switch (i) {
        case "GeometryCollection":
          const n = t.getGeometriesArray();
          for (const t of n) this.addGeometry_(t, e);
          break;
        case "MultiPolygon":
          const r = t;
          this.addCoordinates_(
            i,
            r.getFlatCoordinates(),
            r.getEndss(),
            e,
            j(e),
            r.getStride()
          );
          break;
        case "MultiLineString":
          const s = t;
          this.addCoordinates_(
            i,
            s.getFlatCoordinates(),
            s.getEnds(),
            e,
            j(e),
            s.getStride()
          );
          break;
        case "MultiPoint":
          const o = t;
          this.addCoordinates_(
            i,
            o.getFlatCoordinates(),
            null,
            e,
            j(e),
            o.getStride()
          );
          break;
        case "Polygon":
          const a = t;
          this.addCoordinates_(
            i,
            a.getFlatCoordinates(),
            a.getEnds(),
            e,
            j(e),
            a.getStride()
          );
          break;
        case "Point":
          const l = t;
          this.addCoordinates_(
            i,
            l.getFlatCoordinates(),
            null,
            e,
            j(e),
            l.getStride()
          );
          break;
        case "LineString":
        case "LinearRing":
          const h = t;
          this.addCoordinates_(
            i,
            h.getFlatCoordinates(),
            null,
            e,
            j(e),
            h.getStride()
          );
      }
    }
    addCoordinates_(t, e, i, n, r, s) {
      let o;
      switch (t) {
        case "MultiPolygon":
          const t = i;
          for (let i = 0, o = t.length; i < o; i++) {
            let o = t[i];
            const a = i > 0 ? t[i - 1] : null,
              l = a ? a[a.length - 1] : 0,
              h = o[o.length - 1];
            (o = l > 0 ? o.map((t) => t - l) : o),
              this.addCoordinates_("Polygon", e.slice(l, h), o, n, r, s);
          }
          break;
        case "MultiLineString":
          const a = i;
          for (let t = 0, i = a.length; t < i; t++) {
            const i = t > 0 ? a[t - 1] : 0;
            this.addCoordinates_("LinearRing", e.slice(i, a[t]), null, n, r, s);
          }
          break;
        case "MultiPoint":
          for (let t = 0, i = e.length; t < i; t += s)
            this.addCoordinates_("Point", e.slice(t, t + 2), null, n, r, null);
          break;
        case "Polygon":
          const l = i;
          for (let t = 1, i = l.length; t < i; t++) {
            const i = l[t - 1];
            if (t > 0 && vr(e, i, l[t], s))
              return (
                this.addCoordinates_(
                  "Polygon",
                  e.slice(0, i),
                  l.slice(0, t),
                  n,
                  r,
                  s
                ),
                void this.addCoordinates_(
                  "Polygon",
                  e.slice(i),
                  l.slice(t).map((e) => e - l[t - 1]),
                  n,
                  r,
                  s
                )
              );
          }
          this.polygonBatch.entries[r] ||
            (this.polygonBatch.entries[r] = {
              feature: n,
              flatCoordss: [],
              verticesCount: 0,
              ringsCount: 0,
              ringsVerticesCounts: [],
            }),
            (o = e.length / s);
          const h = i.length,
            c = i.map((t, e, i) => (e > 0 ? (t - i[e - 1]) / s : t / s));
          (this.polygonBatch.verticesCount += o),
            (this.polygonBatch.ringsCount += h),
            this.polygonBatch.geometriesCount++,
            this.polygonBatch.entries[r].flatCoordss.push(ex(e, s)),
            this.polygonBatch.entries[r].ringsVerticesCounts.push(c),
            (this.polygonBatch.entries[r].verticesCount += o),
            (this.polygonBatch.entries[r].ringsCount += h);
          for (let t = 0, i = l.length; t < i; t++) {
            const i = t > 0 ? l[t - 1] : 0;
            this.addCoordinates_("LinearRing", e.slice(i, l[t]), null, n, r, s);
          }
          break;
        case "Point":
          this.pointBatch.entries[r] ||
            (this.pointBatch.entries[r] = { feature: n, flatCoordss: [] }),
            this.pointBatch.geometriesCount++,
            this.pointBatch.entries[r].flatCoordss.push(e);
          break;
        case "LineString":
        case "LinearRing":
          this.lineStringBatch.entries[r] ||
            (this.lineStringBatch.entries[r] = {
              feature: n,
              flatCoordss: [],
              verticesCount: 0,
            }),
            (o = e.length / s),
            (this.lineStringBatch.verticesCount += o),
            this.lineStringBatch.geometriesCount++,
            this.lineStringBatch.entries[r].flatCoordss.push(ex(e, s)),
            (this.lineStringBatch.entries[r].verticesCount += o);
      }
    }
    changeFeature(t) {
      this.clearFeatureEntryInPointBatch_(t),
        this.clearFeatureEntryInPolygonBatch_(t),
        this.clearFeatureEntryInLineStringBatch_(t);
      const e = t.getGeometry();
      e && this.addGeometry_(e, t);
    }
    removeFeature(t) {
      this.clearFeatureEntryInPointBatch_(t),
        this.clearFeatureEntryInPolygonBatch_(t),
        this.clearFeatureEntryInLineStringBatch_(t);
    }
    clear() {
      (this.polygonBatch.entries = {}),
        (this.polygonBatch.geometriesCount = 0),
        (this.polygonBatch.verticesCount = 0),
        (this.polygonBatch.ringsCount = 0),
        (this.lineStringBatch.entries = {}),
        (this.lineStringBatch.geometriesCount = 0),
        (this.lineStringBatch.verticesCount = 0),
        (this.pointBatch.entries = {}),
        (this.pointBatch.geometriesCount = 0);
    }
  };
  var nx = class extends wg {
    constructor(t, e) {
      super(t),
        (this.batch_ = new ix()),
        (this.styleRenderers_ = e),
        (this.buffers = []),
        this.setTile(t.tile);
    }
    uploadTile() {
      this.batch_.clear();
      const t = this.tile.getSourceTiles(),
        e = t.reduce((t, e) => t.concat(e.getFeatures()), []);
      this.batch_.addFeatures(e);
      const i = qt([1, 0, 0, 1, 0, 0], -t[0].extent[0], -t[0].extent[1]),
        n = this.styleRenderers_.map((t, e) =>
          t.generateBuffers(this.batch_, i).then((t) => {
            this.buffers[e] = t;
          })
        );
      Promise.all(n).then(() => {
        this.setReady();
      });
    }
  };
  var rx = class {
    constructor(t) {
      this.first_,
        this.last_,
        this.head_,
        (this.circular_ = void 0 === t || t),
        (this.length_ = 0);
    }
    insertItem(t) {
      const e = { prev: void 0, next: void 0, data: t },
        i = this.head_;
      if (i) {
        const t = i.next;
        (e.prev = i),
          (e.next = t),
          (i.next = e),
          t && (t.prev = e),
          i === this.last_ && (this.last_ = e);
      } else
        (this.first_ = e),
          (this.last_ = e),
          this.circular_ && ((e.next = e), (e.prev = e));
      (this.head_ = e), this.length_++;
    }
    removeItem() {
      const t = this.head_;
      if (t) {
        const e = t.next,
          i = t.prev;
        e && (e.prev = i),
          i && (i.next = e),
          (this.head_ = e || i),
          this.first_ === this.last_
            ? ((this.head_ = void 0),
              (this.first_ = void 0),
              (this.last_ = void 0))
            : this.first_ === t
            ? (this.first_ = this.head_)
            : this.last_ === t &&
              (this.last_ = i ? this.head_.prev : this.head_),
          this.length_--;
      }
    }
    firstItem() {
      if (((this.head_ = this.first_), this.head_)) return this.head_.data;
    }
    lastItem() {
      if (((this.head_ = this.last_), this.head_)) return this.head_.data;
    }
    nextItem() {
      if (this.head_ && this.head_.next)
        return (this.head_ = this.head_.next), this.head_.data;
    }
    getNextItem() {
      if (this.head_ && this.head_.next) return this.head_.next.data;
    }
    prevItem() {
      if (this.head_ && this.head_.prev)
        return (this.head_ = this.head_.prev), this.head_.data;
    }
    getPrevItem() {
      if (this.head_ && this.head_.prev) return this.head_.prev.data;
    }
    getCurrItem() {
      if (this.head_) return this.head_.data;
    }
    setFirstItem() {
      this.circular_ &&
        this.head_ &&
        ((this.first_ = this.head_), (this.last_ = this.head_.prev));
    }
    concat(t) {
      if (t.head_) {
        if (this.head_) {
          const e = this.head_.next;
          (this.head_.next = t.first_),
            (t.first_.prev = this.head_),
            (e.prev = t.last_),
            (t.last_.next = e),
            (this.length_ += t.length_);
        } else
          (this.head_ = t.head_),
            (this.first_ = t.first_),
            (this.last_ = t.last_),
            (this.length_ = t.length_);
        (t.head_ = void 0),
          (t.first_ = void 0),
          (t.last_ = void 0),
          (t.length_ = 0);
      }
    }
    getLength() {
      return this.length_;
    }
  };
  function sx(t, e, i, n) {
    let r = 0;
    for (const s in e) {
      const o = e[s],
        a = o.callback(i.feature);
      (t[n + r++] = a[0] || a),
        o.size &&
          1 !== o.size &&
          ((t[n + r++] = a[1]),
          o.size < 3 ||
            ((t[n + r++] = a[2]), o.size < 4 || (t[n + r++] = a[3])));
    }
    return r;
  }
  function ox(t) {
    return Object.keys(t).reduce((e, i) => e + (t[i].size || 1), 0);
  }
  function ax(t, e, i, n) {
    const r = (2 + ox(i)) * t.geometriesCount;
    (e && e.length === r) || (e = new Float32Array(r));
    const s = [];
    let o = 0;
    for (const r in t.entries) {
      const a = t.entries[r];
      for (let t = 0, r = a.flatCoordss.length; t < r; t++)
        (s[0] = a.flatCoordss[t][0]),
          (s[1] = a.flatCoordss[t][1]),
          Bt(n, s),
          (e[o++] = s[0]),
          (e[o++] = s[1]),
          (o += sx(e, i, a, o));
    }
    return e;
  }
  function lx(t, e, i, n) {
    const r = 2 * t.verticesCount + (1 + ox(i)) * t.geometriesCount;
    (e && e.length === r) || (e = new Float32Array(r));
    const s = [];
    let o = 0;
    for (const r in t.entries) {
      const a = t.entries[r];
      for (let t = 0, r = a.flatCoordss.length; t < r; t++) {
        (s.length = a.flatCoordss[t].length),
          Wn(a.flatCoordss[t], 0, s.length, 2, n, s),
          (o += sx(e, i, a, o)),
          (e[o++] = s.length / 2);
        for (let t = 0, i = s.length; t < i; t += 2)
          (e[o++] = s[t]), (e[o++] = s[t + 1]);
      }
    }
    return e;
  }
  function hx(t, e, i, n) {
    const r =
      2 * t.verticesCount + (1 + ox(i)) * t.geometriesCount + t.ringsCount;
    (e && e.length === r) || (e = new Float32Array(r));
    const s = [];
    let o = 0;
    for (const r in t.entries) {
      const a = t.entries[r];
      for (let t = 0, r = a.flatCoordss.length; t < r; t++) {
        (s.length = a.flatCoordss[t].length),
          Wn(a.flatCoordss[t], 0, s.length, 2, n, s),
          (o += sx(e, i, a, o)),
          (e[o++] = a.ringsVerticesCounts[t].length);
        for (let i = 0, n = a.ringsVerticesCounts[t].length; i < n; i++)
          e[o++] = a.ringsVerticesCounts[t][i];
        for (let t = 0, i = s.length; t < i; t += 2)
          (e[o++] = s[t]), (e[o++] = s[t + 1]);
      }
    }
    return e;
  }
  const cx = hg();
  let ux = 0;
  const dx = "a_position",
    gx = "a_index",
    fx = "a_segmentStart",
    px = "a_segmentEnd",
    mx = "a_parameters",
    _x = "a_joinAngles",
    yx = "a_distance";
  var xx = class {
    constructor(t, e) {
      this.helper_ = e;
      let i = t;
      if (
        !(
          "fill" in t ||
          "stroke" in t ||
          ("symbol" in t && "vertex" in t.symbol)
        )
      ) {
        const e = ip(t);
        i = {
          fill: {
            vertex: e.builder.getFillVertexShader(),
            fragment: e.builder.getFillFragmentShader(),
          },
          stroke: {
            vertex: e.builder.getStrokeVertexShader(),
            fragment: e.builder.getStrokeFragmentShader(),
          },
          symbol: {
            vertex: e.builder.getSymbolVertexShader(),
            fragment: e.builder.getSymbolFragmentShader(),
          },
          attributes: e.attributes,
          uniforms: e.uniforms,
        };
      }
      (this.hasFill_ = !!i.fill?.vertex),
        this.hasFill_ &&
          ((this.fillVertexShader_ = i.fill.vertex),
          (this.fillFragmentShader_ = i.fill.fragment),
          (this.fillProgram_ = this.helper_.getProgram(
            this.fillFragmentShader_,
            this.fillVertexShader_
          ))),
        (this.hasStroke_ = !!i.stroke?.vertex),
        this.hasStroke_ &&
          ((this.strokeVertexShader_ = i.stroke && i.stroke.vertex),
          (this.strokeFragmentShader_ = i.stroke && i.stroke.fragment),
          (this.strokeProgram_ = this.helper_.getProgram(
            this.strokeFragmentShader_,
            this.strokeVertexShader_
          ))),
        (this.hasSymbol_ = !!i.symbol?.vertex),
        this.hasSymbol_ &&
          ((this.symbolVertexShader_ = i.symbol && i.symbol.vertex),
          (this.symbolFragmentShader_ = i.symbol && i.symbol.fragment),
          (this.symbolProgram_ = this.helper_.getProgram(
            this.symbolFragmentShader_,
            this.symbolVertexShader_
          ))),
        (this.customAttributes_ = i.attributes),
        (this.uniforms_ = i.uniforms);
      const n = Object.keys(this.customAttributes_).map((t) => ({
        name: `a_${t}`,
        size: this.customAttributes_[t].size || 1,
        type: pd.FLOAT,
      }));
      (this.polygonAttributesDesc_ = [
        { name: dx, size: 2, type: pd.FLOAT },
        ...n,
      ]),
        (this.lineStringAttributesDesc_ = [
          { name: fx, size: 2, type: pd.FLOAT },
          { name: px, size: 2, type: pd.FLOAT },
          { name: _x, size: 2, type: pd.FLOAT },
          { name: yx, size: 1, type: pd.FLOAT },
          { name: mx, size: 1, type: pd.FLOAT },
          ...n,
        ]),
        (this.pointAttributesDesc_ = [
          { name: dx, size: 2, type: pd.FLOAT },
          { name: gx, size: 1, type: pd.FLOAT },
          ...n,
        ]),
        i.uniforms && this.helper_.addUniforms(i.uniforms);
    }
    async generateBuffers(t, e) {
      const i = this.generateRenderInstructions_(t, e),
        [n, r, s] = await Promise.all([
          this.generateBuffersForType_(i.polygonInstructions, "Polygon", e),
          this.generateBuffersForType_(
            i.lineStringInstructions,
            "LineString",
            e
          ),
          this.generateBuffersForType_(i.pointInstructions, "Point", e),
        ]);
      return {
        polygonBuffers: n,
        lineStringBuffers: r,
        pointBuffers: s,
        invertVerticesTransform: Xt([1, 0, 0, 1, 0, 0], e),
      };
    }
    generateRenderInstructions_(t, e) {
      return {
        polygonInstructions: this.hasFill_
          ? hx(t.polygonBatch, new Float32Array(0), this.customAttributes_, e)
          : null,
        lineStringInstructions: this.hasStroke_
          ? lx(
              t.lineStringBatch,
              new Float32Array(0),
              this.customAttributes_,
              e
            )
          : null,
        pointInstructions: this.hasSymbol_
          ? ax(t.pointBatch, new Float32Array(0), this.customAttributes_, e)
          : null,
      };
    }
    generateBuffersForType_(t, e, i) {
      if (null === t) return null;
      const n = ux++;
      let r;
      switch (e) {
        case "Polygon":
          r = Rd;
          break;
        case "LineString":
          r = Pd;
          break;
        case "Point":
          r = Td;
      }
      const s = {
        id: n,
        type: r,
        renderInstructions: t.buffer,
        renderInstructionsTransform: i,
        customAttributesSize: ox(this.customAttributes_),
      };
      return (
        cx.postMessage(s, [t.buffer]),
        (t = null),
        new Promise((t) => {
          const e = (i) => {
            const r = i.data;
            if (r.id !== n) return;
            if ((cx.removeEventListener("message", e), !this.helper_.getGL()))
              return;
            const s = new ld($u, ed).fromArrayBuffer(r.vertexBuffer),
              o = new ld(Ju, ed).fromArrayBuffer(r.indexBuffer);
            this.helper_.flushBufferData(s),
              this.helper_.flushBufferData(o),
              t([o, s]);
          };
          cx.addEventListener("message", e);
        })
      );
    }
    render(t, e, i) {
      this.hasFill_ &&
        this.renderInternal_(
          t.polygonBuffers[0],
          t.polygonBuffers[1],
          this.fillProgram_,
          this.polygonAttributesDesc_,
          e,
          i
        ),
        this.hasStroke_ &&
          this.renderInternal_(
            t.lineStringBuffers[0],
            t.lineStringBuffers[1],
            this.strokeProgram_,
            this.lineStringAttributesDesc_,
            e,
            i
          ),
        this.hasSymbol_ &&
          this.renderInternal_(
            t.pointBuffers[0],
            t.pointBuffers[1],
            this.symbolProgram_,
            this.pointAttributesDesc_,
            e,
            i
          );
    }
    renderInternal_(t, e, i, n, r, s) {
      this.helper_.useProgram(i, r),
        this.helper_.bindBuffer(e),
        this.helper_.bindBuffer(t),
        this.helper_.enableAttributes(n),
        s();
      const o = t.getSize();
      this.helper_.drawElements(0, o);
    }
  };
  const vx = {
    ...fd,
    RENDER_EXTENT: "u_renderExtent",
    GLOBAL_ALPHA: "u_globalAlpha",
  };
  var Sx = class extends wd {
    constructor(t, e) {
      super(t, {
        uniforms: { [vx.RENDER_EXTENT]: [0, 0, 0, 0], [vx.GLOBAL_ALPHA]: 1 },
        postProcesses: e.postProcesses,
      }),
        (this.sourceRevision_ = -1),
        (this.previousExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
        (this.currentTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.tmpTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.tmpMat4_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        (this.currentFrameStateTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.styles_ = []),
        (this.styleRenderers_ = []),
        (this.buffers_ = []),
        this.applyOptions_(e),
        (this.batch_ = new ix());
      const i = this.getLayer().getSource();
      this.batch_.addFeatures(i.getFeatures()),
        (this.sourceListenKeys_ = [
          M(i, Lu, this.handleSourceFeatureAdded_, this),
          M(i, Mu, this.handleSourceFeatureChanged_, this),
          M(i, ku, this.handleSourceFeatureDelete_, this),
          M(i, Ou, this.handleSourceFeatureClear_, this),
        ]);
    }
    applyOptions_(t) {
      this.styles_ = Array.isArray(t.style) ? t.style : [t.style];
    }
    createRenderers_() {
      (this.buffers_ = []),
        (this.styleRenderers_ = this.styles_.map(
          (t) => new xx(t, this.helper)
        ));
    }
    reset(t) {
      this.applyOptions_(t),
        this.helper && this.createRenderers_(),
        super.reset(t);
    }
    afterHelperCreated() {
      this.createRenderers_();
    }
    handleSourceFeatureAdded_(t) {
      const e = t.feature;
      this.batch_.addFeature(e);
    }
    handleSourceFeatureChanged_(t) {
      const e = t.feature;
      this.batch_.changeFeature(e);
    }
    handleSourceFeatureDelete_(t) {
      const e = t.feature;
      this.batch_.removeFeature(e);
    }
    handleSourceFeatureClear_() {
      this.batch_.clear();
    }
    applyUniforms_(t) {
      Gt(this.tmpTransform_, this.currentFrameStateTransform_),
        Nt(this.tmpTransform_, t),
        this.helper.setUniformMatrixValue(
          vx.PROJECTION_MATRIX,
          gd(this.tmpMat4_, this.tmpTransform_)
        ),
        Xt(this.tmpTransform_, this.tmpTransform_),
        this.helper.setUniformMatrixValue(
          vx.SCREEN_TO_WORLD_MATRIX,
          gd(this.tmpMat4_, this.tmpTransform_)
        );
    }
    renderFrame(t) {
      const e = this.helper.getGL();
      this.preRender(e, t),
        this.helper.prepareDraw(t),
        (this.currentFrameStateTransform_ = this.helper.makeProjectionTransform(
          t,
          this.currentFrameStateTransform_
        ));
      const i = this.getLayer().getSource(),
        n = t.viewState.projection,
        r = i.getWrapX() && n.canWrapX(),
        s = n.getExtent(),
        o = t.extent,
        a = r ? Fe(s) : null,
        l = r ? Math.ceil((o[2] - s[2]) / a) + 1 : 1;
      let h = r ? Math.floor((o[0] - s[0]) / a) : 0;
      qt(this.currentFrameStateTransform_, h * a, 0);
      do {
        for (let e = 0, i = this.styleRenderers_.length; e < i; e++) {
          const i = this.styleRenderers_[e],
            n = this.buffers_[e];
          n &&
            i.render(n, t, () => {
              this.applyUniforms_(n.invertVerticesTransform);
            });
        }
        qt(this.currentFrameStateTransform_, a, 0);
      } while (++h < l);
      this.helper.finalizeDraw(t);
      const c = this.helper.getCanvas(),
        u = t.layerStatesArray[t.layerIndex].opacity;
      return (
        u !== parseFloat(c.style.opacity) && (c.style.opacity = String(u)),
        this.postRender(e, t),
        c
      );
    }
    prepareFrameInternal(t) {
      const e = this.getLayer(),
        i = e.getSource(),
        n = t.viewState,
        r = !t.viewHints[Ms] && !t.viewHints[Os],
        s = !ce(this.previousExtent_, t.extent),
        o = this.sourceRevision_ < i.getRevision();
      if ((o && (this.sourceRevision_ = i.getRevision()), r && (s || o))) {
        const r = n.projection,
          s = n.resolution,
          o = e instanceof Cc ? e.getRenderBuffer() : 0,
          a = $t(t.extent, o * s);
        i.loadFeatures(a, s, r), (this.ready = !1);
        const l = this.helper.makeProjectionTransform(t, [1, 0, 0, 1, 0, 0]),
          h = this.styleRenderers_.map((t, e) =>
            t.generateBuffers(this.batch_, l).then((t) => {
              this.buffers_[e] = t;
            })
          );
        Promise.all(h).then(() => {
          (this.ready = !0), this.getLayer().changed();
        }),
          (this.previousExtent_ = t.extent.slice());
      }
      return !0;
    }
    forEachFeatureAtCoordinate(t, e, i, n, r) {}
    disposeInternal() {
      this.sourceListenKeys_.forEach(function (t) {
        k(t);
      }),
        (this.sourceListenKeys_ = null),
        super.disposeInternal();
    }
  };
  var Cx = class extends Xg {
    constructor(t, e) {
      super(t, e),
        (this.styles_ = []),
        (this.styleRenderers_ = []),
        (this.currentFrameStateTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.tmpTransform_ = [1, 0, 0, 1, 0, 0]),
        (this.tmpMat4_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        this.applyOptions_(e);
    }
    reset(t) {
      super.reset(t),
        this.applyOptions_(t),
        this.helper && this.createRenderers_();
    }
    applyOptions_(t) {
      this.styles_ = Array.isArray(t.style) ? t.style : [t.style];
    }
    createRenderers_() {
      this.styleRenderers_ = this.styles_.map((t) => new xx(t, this.helper));
    }
    afterHelperCreated() {
      this.createRenderers_();
    }
    createTileRepresentation(t) {
      const e = new nx(t, this.styleRenderers_),
        i = () => {
          e.ready && (this.getLayer().changed(), e.removeEventListener(v, i));
        };
      return e.addEventListener(v, i), e;
    }
    beforeTilesRender(t, e) {
      super.beforeTilesRender(t, !0),
        this.helper.makeProjectionTransform(
          t,
          this.currentFrameStateTransform_
        );
    }
    applyUniforms_(t, e, i) {
      Gt(this.tmpTransform_, this.currentFrameStateTransform_),
        Nt(this.tmpTransform_, i),
        this.helper.setUniformMatrixValue(
          Gg.PROJECTION_MATRIX,
          gd(this.tmpMat4_, this.tmpTransform_)
        ),
        Xt(this.tmpTransform_, this.currentFrameStateTransform_),
        this.helper.setUniformMatrixValue(
          Gg.SCREEN_TO_WORLD_MATRIX,
          gd(this.tmpMat4_, this.tmpTransform_)
        ),
        this.helper.setUniformFloatValue(Gg.GLOBAL_ALPHA, t),
        this.helper.setUniformFloatVec4(Gg.RENDER_EXTENT, e);
    }
    renderTile(t, e, i, n, r, s, o, a, l, h, c) {
      const u = Te(a, n, a);
      for (let e = 0, n = this.styleRenderers_.length; e < n; e++) {
        const n = this.styleRenderers_[e],
          r = t.buffers[e];
        r &&
          n.render(r, i, () => {
            this.applyUniforms_(c, u, r.invertVerticesTransform);
          });
      }
    }
    renderDeclutter(t) {}
    disposeInternal() {
      super.disposeInternal();
    }
  };
  class wx extends Ln {
    constructor(t, e, i) {
      super(),
        void 0 !== i && void 0 === e
          ? this.setFlatCoordinates(i, t)
          : ((e = e || 0), this.setCenterAndRadius(t, e, i));
    }
    clone() {
      const t = new wx(this.flatCoordinates.slice(), void 0, this.layout);
      return t.applyProperties(this), t;
    }
    closestPointXY(t, e, i, n) {
      const r = this.flatCoordinates,
        s = t - r[0],
        o = e - r[1],
        a = s * s + o * o;
      if (a < n) {
        if (0 === a) for (let t = 0; t < this.stride; ++t) i[t] = r[t];
        else {
          const t = this.getRadius() / Math.sqrt(a);
          (i[0] = r[0] + t * s), (i[1] = r[1] + t * o);
          for (let t = 2; t < this.stride; ++t) i[t] = r[t];
        }
        return (i.length = this.stride), a;
      }
      return n;
    }
    containsXY(t, e) {
      const i = this.flatCoordinates,
        n = t - i[0],
        r = e - i[1];
      return n * n + r * r <= this.getRadiusSquared_();
    }
    getCenter() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    computeExtent(t) {
      const e = this.flatCoordinates,
        i = e[this.stride] - e[0];
      return oe(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t);
    }
    getRadius() {
      return Math.sqrt(this.getRadiusSquared_());
    }
    getRadiusSquared_() {
      const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0],
        e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
      return t * t + e * e;
    }
    getType() {
      return "Circle";
    }
    intersectsExtent(t) {
      if (Ie(t, this.getExtent())) {
        const e = this.getCenter();
        return (
          (t[0] <= e[0] && t[2] >= e[0]) ||
          (t[1] <= e[1] && t[3] >= e[1]) ||
          ye(t, this.intersectsCoordinate.bind(this))
        );
      }
      return !1;
    }
    setCenter(t) {
      const e = this.stride,
        i = this.flatCoordinates[e] - this.flatCoordinates[0],
        n = t.slice();
      n[e] = n[0] + i;
      for (let i = 1; i < e; ++i) n[e + i] = t[i];
      this.setFlatCoordinates(this.layout, n), this.changed();
    }
    setCenterAndRadius(t, e, i) {
      this.setLayout(i, t, 0),
        this.flatCoordinates || (this.flatCoordinates = []);
      const n = this.flatCoordinates;
      let r = Bn(n, 0, t, this.stride);
      n[r++] = n[0] + e;
      for (let t = 1, e = this.stride; t < e; ++t) n[r++] = n[t];
      (n.length = r), this.changed();
    }
    getCoordinates() {
      return null;
    }
    setCoordinates(t, e) {}
    setRadius(t) {
      (this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t),
        this.changed();
    }
    rotate(t, e) {
      const i = this.getCenter(),
        n = this.getStride();
      this.setCenter(En(i, 0, i.length, n, t, e, i)), this.changed();
    }
  }
  wx.prototype.transform;
  var Wx = wx;
  class Ex extends bn {
    constructor(t) {
      super(),
        (this.geometries_ = t || null),
        (this.changeEventsKeys_ = []),
        this.listenGeometriesChange_();
    }
    unlistenGeometriesChange_() {
      this.changeEventsKeys_.forEach(k), (this.changeEventsKeys_.length = 0);
    }
    listenGeometriesChange_() {
      if (this.geometries_)
        for (let t = 0, e = this.geometries_.length; t < e; ++t)
          this.changeEventsKeys_.push(
            M(this.geometries_[t], v, this.changed, this)
          );
    }
    clone() {
      const t = new Ex(null);
      return t.setGeometries(this.geometries_), t.applyProperties(this), t;
    }
    closestPointXY(t, e, i, n) {
      if (n < te(this.getExtent(), t, e)) return n;
      const r = this.geometries_;
      for (let s = 0, o = r.length; s < o; ++s)
        n = r[s].closestPointXY(t, e, i, n);
      return n;
    }
    containsXY(t, e) {
      const i = this.geometries_;
      for (let n = 0, r = i.length; n < r; ++n)
        if (i[n].containsXY(t, e)) return !0;
      return !1;
    }
    computeExtent(t) {
      ae(t);
      const e = this.geometries_;
      for (let i = 0, n = e.length; i < n; ++i) de(t, e[i].getExtent());
      return t;
    }
    getGeometries() {
      return Rx(this.geometries_);
    }
    getGeometriesArray() {
      return this.geometries_;
    }
    getGeometriesArrayRecursive() {
      let t = [];
      const e = this.geometries_;
      for (let i = 0, n = e.length; i < n; ++i)
        e[i].getType() === this.getType()
          ? (t = t.concat(e[i].getGeometriesArrayRecursive()))
          : t.push(e[i]);
      return t;
    }
    getSimplifiedGeometry(t) {
      if (
        (this.simplifiedGeometryRevision !== this.getRevision() &&
          ((this.simplifiedGeometryMaxMinSquaredTolerance = 0),
          (this.simplifiedGeometryRevision = this.getRevision())),
        t < 0 ||
          (0 !== this.simplifiedGeometryMaxMinSquaredTolerance &&
            t < this.simplifiedGeometryMaxMinSquaredTolerance))
      )
        return this;
      const e = [],
        i = this.geometries_;
      let n = !1;
      for (let r = 0, s = i.length; r < s; ++r) {
        const s = i[r],
          o = s.getSimplifiedGeometry(t);
        e.push(o), o !== s && (n = !0);
      }
      if (n) {
        const t = new Ex(null);
        return t.setGeometriesArray(e), t;
      }
      return (this.simplifiedGeometryMaxMinSquaredTolerance = t), this;
    }
    getType() {
      return "GeometryCollection";
    }
    intersectsExtent(t) {
      const e = this.geometries_;
      for (let i = 0, n = e.length; i < n; ++i)
        if (e[i].intersectsExtent(t)) return !0;
      return !1;
    }
    isEmpty() {
      return 0 === this.geometries_.length;
    }
    rotate(t, e) {
      const i = this.geometries_;
      for (let n = 0, r = i.length; n < r; ++n) i[n].rotate(t, e);
      this.changed();
    }
    scale(t, e, i) {
      i || (i = Ce(this.getExtent()));
      const n = this.geometries_;
      for (let r = 0, s = n.length; r < s; ++r) n[r].scale(t, e, i);
      this.changed();
    }
    setGeometries(t) {
      this.setGeometriesArray(Rx(t));
    }
    setGeometriesArray(t) {
      this.unlistenGeometriesChange_(),
        (this.geometries_ = t),
        this.listenGeometriesChange_(),
        this.changed();
    }
    applyTransform(t) {
      const e = this.geometries_;
      for (let i = 0, n = e.length; i < n; ++i) e[i].applyTransform(t);
      this.changed();
    }
    translate(t, e) {
      const i = this.geometries_;
      for (let n = 0, r = i.length; n < r; ++n) i[n].translate(t, e);
      this.changed();
    }
    disposeInternal() {
      this.unlistenGeometriesChange_(), super.disposeInternal();
    }
  }
  function Rx(t) {
    const e = [];
    for (let i = 0, n = t.length; i < n; ++i) e.push(t[i].clone());
    return e;
  }
  var Tx = Ex;
  class Px extends Ln {
    constructor(t, e, i) {
      if (
        (super(),
        (this.ends_ = []),
        (this.maxDelta_ = -1),
        (this.maxDeltaRevision_ = -1),
        Array.isArray(t[0]))
      )
        this.setCoordinates(t, e);
      else if (void 0 !== e && i)
        this.setFlatCoordinates(e, t), (this.ends_ = i);
      else {
        let e = this.getLayout();
        const i = t,
          n = [],
          r = [];
        for (let t = 0, s = i.length; t < s; ++t) {
          const s = i[t];
          0 === t && (e = s.getLayout()),
            h(n, s.getFlatCoordinates()),
            r.push(n.length);
        }
        this.setFlatCoordinates(e, n), (this.ends_ = r);
      }
    }
    appendLineString(t) {
      this.flatCoordinates
        ? h(this.flatCoordinates, t.getFlatCoordinates().slice())
        : (this.flatCoordinates = t.getFlatCoordinates().slice()),
        this.ends_.push(this.flatCoordinates.length),
        this.changed();
    }
    clone() {
      const t = new Px(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return t.applyProperties(this), t;
    }
    closestPointXY(t, e, i, n) {
      return n < te(this.getExtent(), t, e)
        ? n
        : (this.maxDeltaRevision_ != this.getRevision() &&
            ((this.maxDelta_ = Math.sqrt(
              kn(this.flatCoordinates, 0, this.ends_, this.stride, 0)
            )),
            (this.maxDeltaRevision_ = this.getRevision())),
          Dn(
            this.flatCoordinates,
            0,
            this.ends_,
            this.stride,
            this.maxDelta_,
            !1,
            t,
            e,
            i,
            n
          ));
    }
    getCoordinateAtM(t, e, i) {
      return ("XYM" != this.layout && "XYZM" != this.layout) ||
        0 === this.flatCoordinates.length
        ? null
        : ((e = void 0 !== e && e),
          (i = void 0 !== i && i),
          Nl(this.flatCoordinates, 0, this.ends_, this.stride, t, e, i));
    }
    getCoordinates() {
      return $n(this.flatCoordinates, 0, this.ends_, this.stride);
    }
    getEnds() {
      return this.ends_;
    }
    getLineString(t) {
      return t < 0 || this.ends_.length <= t
        ? null
        : new Bl(
            this.flatCoordinates.slice(
              0 === t ? 0 : this.ends_[t - 1],
              this.ends_[t]
            ),
            this.layout
          );
    }
    getLineStrings() {
      const t = this.flatCoordinates,
        e = this.ends_,
        i = this.layout,
        n = [];
      let r = 0;
      for (let s = 0, o = e.length; s < o; ++s) {
        const o = e[s],
          a = new Bl(t.slice(r, o), i);
        n.push(a), (r = o);
      }
      return n;
    }
    getFlatMidpoints() {
      const t = [],
        e = this.flatCoordinates;
      let i = 0;
      const n = this.ends_,
        r = this.stride;
      for (let s = 0, o = n.length; s < o; ++s) {
        const o = n[s];
        h(t, kl(e, i, o, r, 0.5)), (i = o);
      }
      return t;
    }
    getSimplifiedGeometryInternal(t) {
      const e = [],
        i = [];
      return (
        (e.length = Vn(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          t,
          e,
          0,
          i
        )),
        new Px(e, "XY", i)
      );
    }
    getType() {
      return "MultiLineString";
    }
    intersectsExtent(t) {
      return pr(this.flatCoordinates, 0, this.ends_, this.stride, t);
    }
    setCoordinates(t, e) {
      this.setLayout(e, t, 2),
        this.flatCoordinates || (this.flatCoordinates = []);
      const i = zn(this.flatCoordinates, 0, t, this.stride, this.ends_);
      (this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1]),
        this.changed();
    }
  }
  var bx = Px;
  class Fx extends Ln {
    constructor(t, e) {
      super(),
        e && !Array.isArray(t[0])
          ? this.setFlatCoordinates(e, t)
          : this.setCoordinates(t, e);
    }
    appendPoint(t) {
      this.flatCoordinates
        ? h(this.flatCoordinates, t.getFlatCoordinates())
        : (this.flatCoordinates = t.getFlatCoordinates().slice()),
        this.changed();
    }
    clone() {
      const t = new Fx(this.flatCoordinates.slice(), this.layout);
      return t.applyProperties(this), t;
    }
    closestPointXY(t, e, i, n) {
      if (n < te(this.getExtent(), t, e)) return n;
      const r = this.flatCoordinates,
        s = this.stride;
      for (let o = 0, a = r.length; o < a; o += s) {
        const a = gi(t, e, r[o], r[o + 1]);
        if (a < n) {
          n = a;
          for (let t = 0; t < s; ++t) i[t] = r[o + t];
          i.length = s;
        }
      }
      return n;
    }
    getCoordinates() {
      return Qn(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    getPoint(t) {
      const e = this.flatCoordinates
        ? this.flatCoordinates.length / this.stride
        : 0;
      return t < 0 || e <= t
        ? null
        : new or(
            this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride),
            this.layout
          );
    }
    getPoints() {
      const t = this.flatCoordinates,
        e = this.layout,
        i = this.stride,
        n = [];
      for (let r = 0, s = t.length; r < s; r += i) {
        const s = new or(t.slice(r, r + i), e);
        n.push(s);
      }
      return n;
    }
    getType() {
      return "MultiPoint";
    }
    intersectsExtent(t) {
      const e = this.flatCoordinates,
        i = this.stride;
      for (let n = 0, r = e.length; n < r; n += i) {
        if (ne(t, e[n], e[n + 1])) return !0;
      }
      return !1;
    }
    setCoordinates(t, e) {
      this.setLayout(e, t, 1),
        this.flatCoordinates || (this.flatCoordinates = []),
        (this.flatCoordinates.length = jn(
          this.flatCoordinates,
          0,
          t,
          this.stride
        )),
        this.changed();
    }
  }
  var Ix = Fx;
  function Lx(t, e, i, n) {
    const r = [];
    let s = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    for (let o = 0, a = i.length; o < a; ++o) {
      const a = i[o];
      (s = he(t, e, a[0], n)),
        r.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2),
        (e = a[a.length - 1]);
    }
    return r;
  }
  class Mx extends Ln {
    constructor(t, e, i) {
      if (
        (super(),
        (this.endss_ = []),
        (this.flatInteriorPointsRevision_ = -1),
        (this.flatInteriorPoints_ = null),
        (this.maxDelta_ = -1),
        (this.maxDeltaRevision_ = -1),
        (this.orientedRevision_ = -1),
        (this.orientedFlatCoordinates_ = null),
        !i && !Array.isArray(t[0]))
      ) {
        let n = this.getLayout();
        const r = t,
          s = [],
          o = [];
        for (let t = 0, e = r.length; t < e; ++t) {
          const e = r[t];
          0 === t && (n = e.getLayout());
          const i = s.length,
            a = e.getEnds();
          for (let t = 0, e = a.length; t < e; ++t) a[t] += i;
          h(s, e.getFlatCoordinates()), o.push(a);
        }
        (e = n), (t = s), (i = o);
      }
      void 0 !== e && i
        ? (this.setFlatCoordinates(e, t), (this.endss_ = i))
        : this.setCoordinates(t, e);
    }
    appendPolygon(t) {
      let e;
      if (this.flatCoordinates) {
        const i = this.flatCoordinates.length;
        h(this.flatCoordinates, t.getFlatCoordinates()),
          (e = t.getEnds().slice());
        for (let t = 0, n = e.length; t < n; ++t) e[t] += i;
      } else
        (this.flatCoordinates = t.getFlatCoordinates().slice()),
          (e = t.getEnds().slice()),
          this.endss_.push();
      this.endss_.push(e), this.changed();
    }
    clone() {
      const t = this.endss_.length,
        e = new Array(t);
      for (let i = 0; i < t; ++i) e[i] = this.endss_[i].slice();
      const i = new Mx(this.flatCoordinates.slice(), this.layout, e);
      return i.applyProperties(this), i;
    }
    closestPointXY(t, e, i, n) {
      return n < te(this.getExtent(), t, e)
        ? n
        : (this.maxDeltaRevision_ != this.getRevision() &&
            ((this.maxDelta_ = Math.sqrt(
              An(this.flatCoordinates, 0, this.endss_, this.stride, 0)
            )),
            (this.maxDeltaRevision_ = this.getRevision())),
          Gn(
            this.getOrientedFlatCoordinates(),
            0,
            this.endss_,
            this.stride,
            this.maxDelta_,
            !0,
            t,
            e,
            i,
            n
          ));
    }
    containsXY(t, e) {
      return cr(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t,
        e
      );
    }
    getArea() {
      return ir(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    }
    getCoordinates(t) {
      let e;
      return (
        void 0 !== t
          ? ((e = this.getOrientedFlatCoordinates().slice()),
            Wr(e, 0, this.endss_, this.stride, t))
          : (e = this.flatCoordinates),
        Jn(e, 0, this.endss_, this.stride)
      );
    }
    getEndss() {
      return this.endss_;
    }
    getFlatInteriorPoints() {
      if (this.flatInteriorPointsRevision_ != this.getRevision()) {
        const t = Lx(this.flatCoordinates, 0, this.endss_, this.stride);
        (this.flatInteriorPoints_ = dr(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          t
        )),
          (this.flatInteriorPointsRevision_ = this.getRevision());
      }
      return this.flatInteriorPoints_;
    }
    getInteriorPoints() {
      return new Ix(this.getFlatInteriorPoints().slice(), "XYM");
    }
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const t = this.flatCoordinates;
        Cr(t, 0, this.endss_, this.stride)
          ? (this.orientedFlatCoordinates_ = t)
          : ((this.orientedFlatCoordinates_ = t.slice()),
            (this.orientedFlatCoordinates_.length = Wr(
              this.orientedFlatCoordinates_,
              0,
              this.endss_,
              this.stride
            ))),
          (this.orientedRevision_ = this.getRevision());
      }
      return this.orientedFlatCoordinates_;
    }
    getSimplifiedGeometryInternal(t) {
      const e = [],
        i = [];
      return (
        (e.length = Yn(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          Math.sqrt(t),
          e,
          0,
          i
        )),
        new Mx(e, "XY", i)
      );
    }
    getPolygon(t) {
      if (t < 0 || this.endss_.length <= t) return null;
      let e;
      if (0 === t) e = 0;
      else {
        const i = this.endss_[t - 1];
        e = i[i.length - 1];
      }
      const i = this.endss_[t].slice(),
        n = i[i.length - 1];
      if (0 !== e) for (let t = 0, n = i.length; t < n; ++t) i[t] -= e;
      return new Tr(this.flatCoordinates.slice(e, n), this.layout, i);
    }
    getPolygons() {
      const t = this.layout,
        e = this.flatCoordinates,
        i = this.endss_,
        n = [];
      let r = 0;
      for (let s = 0, o = i.length; s < o; ++s) {
        const o = i[s].slice(),
          a = o[o.length - 1];
        if (0 !== r) for (let t = 0, e = o.length; t < e; ++t) o[t] -= r;
        const l = new Tr(e.slice(r, a), t, o);
        n.push(l), (r = a);
      }
      return n;
    }
    getType() {
      return "MultiPolygon";
    }
    intersectsExtent(t) {
      return yr(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        t
      );
    }
    setCoordinates(t, e) {
      this.setLayout(e, t, 3),
        this.flatCoordinates || (this.flatCoordinates = []);
      const i = Un(this.flatCoordinates, 0, t, this.stride, this.endss_);
      if (0 === i.length) this.flatCoordinates.length = 0;
      else {
        const t = i[i.length - 1];
        this.flatCoordinates.length = 0 === t.length ? 0 : t[t.length - 1];
      }
      this.changed();
    }
  }
  var Ox = Mx;
  const kx = [1, 0, 0, 1, 0, 0];
  class Ax {
    constructor(t, e, i, n, r) {
      this.styleFunction,
        this.extent_,
        (this.id_ = r),
        (this.type_ = t),
        (this.flatCoordinates_ = e),
        (this.flatInteriorPoints_ = null),
        (this.flatMidpoints_ = null),
        (this.ends_ = i),
        (this.properties_ = n);
    }
    get(t) {
      return this.properties_[t];
    }
    getExtent() {
      return (
        this.extent_ ||
          (this.extent_ =
            "Point" === this.type_
              ? le(this.flatCoordinates_)
              : he(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2)),
        this.extent_
      );
    }
    getFlatInteriorPoint() {
      if (!this.flatInteriorPoints_) {
        const t = Ce(this.getExtent());
        this.flatInteriorPoints_ = ur(
          this.flatCoordinates_,
          0,
          this.ends_,
          2,
          t,
          0
        );
      }
      return this.flatInteriorPoints_;
    }
    getFlatInteriorPoints() {
      if (!this.flatInteriorPoints_) {
        const t = Lx(this.flatCoordinates_, 0, this.ends_, 2);
        this.flatInteriorPoints_ = dr(
          this.flatCoordinates_,
          0,
          this.ends_,
          2,
          t
        );
      }
      return this.flatInteriorPoints_;
    }
    getFlatMidpoint() {
      return (
        this.flatMidpoints_ ||
          (this.flatMidpoints_ = kl(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            0.5
          )),
        this.flatMidpoints_
      );
    }
    getFlatMidpoints() {
      if (!this.flatMidpoints_) {
        this.flatMidpoints_ = [];
        const t = this.flatCoordinates_;
        let e = 0;
        const i = this.ends_;
        for (let n = 0, r = i.length; n < r; ++n) {
          const r = i[n],
            s = kl(t, e, r, 2, 0.5);
          h(this.flatMidpoints_, s), (e = r);
        }
      }
      return this.flatMidpoints_;
    }
    getId() {
      return this.id_;
    }
    getOrientedFlatCoordinates() {
      return this.flatCoordinates_;
    }
    getGeometry() {
      return this;
    }
    getSimplifiedGeometry(t) {
      return this;
    }
    simplifyTransformed(t, e) {
      return this;
    }
    getProperties() {
      return this.properties_;
    }
    getPropertiesInternal() {
      return this.properties_;
    }
    getStride() {
      return 2;
    }
    getStyleFunction() {
      return this.styleFunction;
    }
    getType() {
      return this.type_;
    }
    transform(t) {
      const e = (t = tn(t)).getExtent(),
        i = t.getWorldExtent();
      if (e && i) {
        const t = Re(i) / Re(e);
        Vt(kx, i[0], i[3], t, -t, 0, 0, 0),
          Wn(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            kx,
            this.flatCoordinates_
          );
      }
    }
    getEnds() {
      return this.ends_;
    }
  }
  function Nx(t) {
    const e = t.getType();
    switch (e) {
      case "Point":
        return new or(t.getFlatCoordinates());
      case "MultiPoint":
        return new Ix(t.getFlatCoordinates(), "XY");
      case "LineString":
        return new Bl(t.getFlatCoordinates(), "XY");
      case "MultiLineString":
        return new bx(t.getFlatCoordinates(), "XY", t.getEnds());
      case "Polygon":
        const i = t.getFlatCoordinates(),
          n = t.getEnds(),
          r = Er(i, n);
        return r.length > 1 ? new Ox(i, "XY", r) : new Tr(i, "XY", n);
      default:
        throw new Error("Invalid geometry type:" + e);
    }
  }
  (Ax.prototype.getEndss = Ax.prototype.getEnds),
    (Ax.prototype.getFlatCoordinates = Ax.prototype.getOrientedFlatCoordinates);
  var Dx = Ax;
  let Gx = null;
  function Bx(t) {
    Gx = t;
    const e = Object.keys(t.defs),
      i = e.length;
    let n, r;
    for (n = 0; n < i; ++n) {
      const i = e[n];
      if (!tn(i)) {
        const e = t.defs(i);
        let n = e.units;
        n || "longlat" !== e.projName || (n = "degrees"),
          $i(
            new ze({
              code: i,
              axisOrientation: e.axis,
              metersPerUnit: e.to_meter,
              units: n,
            })
          );
      }
    }
    for (n = 0; n < i; ++n) {
      const s = e[n],
        o = tn(s);
      for (r = 0; r < i; ++r) {
        const i = e[r],
          n = tn(i);
        if (!ci(s, i))
          if (t.defs[s] === t.defs[i]) nn([o, n]);
          else {
            const e = t(s, i);
            an(o, n, Cn(o, n, e.forward), Cn(n, o, e.inverse));
          }
      }
    }
  }
  let jx = async function (t) {
    const e = await fetch(`https://epsg.io/${t}.proj4`);
    if (!e.ok) throw new Error(`Unexpected response from epsg.io: ${e.status}`);
    return e.text();
  };
  var zx = class extends ya {
    constructor(t) {
      const e = t || {};
      super(e),
        e.stopDown && (this.stopDown = e.stopDown),
        (this.scaleDeltaByPixel_ = e.delta ? e.delta : 0.01),
        (this.duration_ = void 0 !== e.duration ? e.duration : 250),
        (this.handlingDownUpSequence_ = !1),
        (this.handlingDoubleDownSequence_ = !1),
        (this.doubleTapTimeoutId_ = void 0),
        (this.trackedPointers_ = {}),
        (this.targetPointers = []);
    }
    handleEvent(t) {
      if (!t.originalEvent) return !0;
      let e = !1;
      if ((this.updateTrackedPointers_(t), this.handlingDownUpSequence_)) {
        if (t.type == Vo.POINTERDRAG)
          this.handleDragEvent(t), t.originalEvent.preventDefault();
        else if (t.type == Vo.POINTERUP) {
          const e = this.handleUpEvent(t);
          this.handlingDownUpSequence_ = e;
        }
      } else if (t.type == Vo.POINTERDOWN)
        if (this.handlingDoubleDownSequence_) {
          this.handlingDoubleDownSequence_ = !1;
          const i = this.handleDownEvent(t);
          (this.handlingDownUpSequence_ = i), (e = this.stopDown(i));
        } else (e = this.stopDown(!1)), this.waitForDblTap_();
      return !e;
    }
    handleDragEvent(t) {
      let e = 1;
      const i = this.targetPointers[0],
        n = this.down_.originalEvent,
        r = i.clientY - n.clientY;
      void 0 !== this.lastDistance_ &&
        (e = 1 - (this.lastDistance_ - r) * this.scaleDeltaByPixel_),
        (this.lastDistance_ = r),
        1 != e && (this.lastScaleDelta_ = e);
      const s = t.map,
        o = s.getView();
      s.render(), o.adjustResolutionInternal(e);
    }
    handleDownEvent(t) {
      if (1 == this.targetPointers.length) {
        const e = t.map;
        return (
          (this.anchor_ = null),
          (this.lastDistance_ = void 0),
          (this.lastScaleDelta_ = 1),
          (this.down_ = t),
          this.handlingDownUpSequence_ || e.getView().beginInteraction(),
          !0
        );
      }
      return !1;
    }
    handleUpEvent(t) {
      if (0 == this.targetPointers.length) {
        const e = t.map.getView(),
          i = this.lastScaleDelta_ > 1 ? 1 : -1;
        return (
          e.endInteraction(this.duration_, i),
          (this.handlingDownUpSequence_ = !1),
          (this.handlingDoubleDownSequence_ = !1),
          !1
        );
      }
      return !0;
    }
    stopDown(t) {
      return t;
    }
    updateTrackedPointers_(t) {
      if (
        (function (t) {
          const e = t.type;
          return (
            e === Vo.POINTERDOWN || e === Vo.POINTERDRAG || e === Vo.POINTERUP
          );
        })(t)
      ) {
        const e = t.originalEvent,
          i = e.pointerId.toString();
        t.type == Vo.POINTERUP
          ? delete this.trackedPointers_[i]
          : (t.type == Vo.POINTERDOWN || i in this.trackedPointers_) &&
            (this.trackedPointers_[i] = e),
          (this.targetPointers = Object.values(this.trackedPointers_));
      }
    }
    waitForDblTap_() {
      void 0 !== this.doubleTapTimeoutId_
        ? (clearTimeout(this.doubleTapTimeoutId_),
          (this.doubleTapTimeoutId_ = void 0))
        : ((this.handlingDoubleDownSequence_ = !0),
          (this.doubleTapTimeoutId_ = setTimeout(
            this.endInteraction_.bind(this),
            250
          )));
    }
    endInteraction_() {
      (this.handlingDoubleDownSequence_ = !1),
        (this.doubleTapTimeoutId_ = void 0);
    }
  };
  const Ux = "addfeatures";
  class qx extends e {
    constructor(t, e, i, n) {
      super(t), (this.features = i), (this.file = e), (this.projection = n);
    }
  }
  var Vx = class extends ya {
    constructor(t) {
      (t = t || {}),
        super({ handleEvent: d }),
        this.on,
        this.once,
        this.un,
        (this.readAsBuffer_ = !1),
        (this.formats_ = []);
      const e = t.formatConstructors ? t.formatConstructors : [];
      for (let t = 0, i = e.length; t < i; ++t) {
        let i = e[t];
        "function" == typeof i && (i = new i()),
          this.formats_.push(i),
          (this.readAsBuffer_ =
            this.readAsBuffer_ || "arraybuffer" === i.getType());
      }
      (this.projection_ = t.projection ? tn(t.projection) : null),
        (this.dropListenKeys_ = null),
        (this.source_ = t.source || null),
        (this.target = t.target ? t.target : null);
    }
    handleResult_(t, e) {
      const i = e.target.result,
        n = this.getMap();
      let r,
        s = this.projection_;
      if (!s && ((s = pn()), !s)) {
        s = n.getView().getProjection();
      }
      const o = this.formats_;
      for (let e = 0, n = o.length; e < n; ++e) {
        const n = o[e];
        let a = i;
        this.readAsBuffer_ &&
          "arraybuffer" !== n.getType() &&
          (void 0 === r && (r = new TextDecoder().decode(i)), (a = r));
        const l = this.tryReadFeatures_(n, a, { featureProjection: s });
        if (l && l.length > 0) {
          this.source_ && (this.source_.clear(), this.source_.addFeatures(l)),
            this.dispatchEvent(new qx(Ux, t, l, s));
          break;
        }
      }
    }
    registerListeners_() {
      const t = this.getMap();
      if (t) {
        const e = this.target ? this.target : t.getViewport();
        this.dropListenKeys_ = [
          M(e, T, this.handleDrop, this),
          M(e, E, this.handleStop, this),
          M(e, R, this.handleStop, this),
          M(e, T, this.handleStop, this),
        ];
      }
    }
    setActive(t) {
      !this.getActive() && t && this.registerListeners_(),
        this.getActive() && !t && this.unregisterListeners_(),
        super.setActive(t);
    }
    setMap(t) {
      this.unregisterListeners_(),
        super.setMap(t),
        this.getActive() && this.registerListeners_();
    }
    tryReadFeatures_(t, e, i) {
      try {
        return t.readFeatures(e, i);
      } catch (t) {
        return null;
      }
    }
    unregisterListeners_() {
      this.dropListenKeys_ &&
        (this.dropListenKeys_.forEach(k), (this.dropListenKeys_ = null));
    }
    handleDrop(t) {
      const e = t.dataTransfer.files;
      for (let t = 0, i = e.length; t < i; ++t) {
        const i = e.item(t),
          n = new FileReader();
        n.addEventListener(F, this.handleResult_.bind(this, i)),
          this.readAsBuffer_ ? n.readAsArrayBuffer(i) : n.readAsText(i);
      }
    }
    handleStop(t) {
      t.stopPropagation(),
        t.preventDefault(),
        (t.dataTransfer.dropEffect = "copy");
    }
  };
  var Xx = class extends Sa {
    constructor(t) {
      super((t = t || {})),
        (this.condition_ = t.condition ? t.condition : Ma),
        (this.lastAngle_ = void 0),
        (this.lastMagnitude_ = void 0),
        (this.lastScaleDelta_ = 0),
        (this.duration_ = void 0 !== t.duration ? t.duration : 400);
    }
    handleDragEvent(t) {
      if (!ka(t)) return;
      const e = t.map,
        i = e.getSize(),
        n = t.pixel,
        r = n[0] - i[0] / 2,
        s = i[1] / 2 - n[1],
        o = Math.atan2(s, r),
        a = Math.sqrt(r * r + s * s),
        l = e.getView();
      if (void 0 !== this.lastAngle_) {
        const t = this.lastAngle_ - o;
        l.adjustRotationInternal(t);
      }
      (this.lastAngle_ = o),
        void 0 !== this.lastMagnitude_ &&
          l.adjustResolutionInternal(this.lastMagnitude_ / a),
        void 0 !== this.lastMagnitude_ &&
          (this.lastScaleDelta_ = this.lastMagnitude_ / a),
        (this.lastMagnitude_ = a);
    }
    handleUpEvent(t) {
      if (!ka(t)) return !0;
      const e = t.map.getView(),
        i = this.lastScaleDelta_ > 1 ? 1 : -1;
      return (
        e.endInteraction(this.duration_, i), (this.lastScaleDelta_ = 0), !1
      );
    }
    handleDownEvent(t) {
      return (
        !!ka(t) &&
        !!this.condition_(t) &&
        (t.map.getView().beginInteraction(),
        (this.lastAngle_ = void 0),
        (this.lastMagnitude_ = void 0),
        !0)
      );
    }
  };
  const Zx = "drawstart",
    Kx = "drawend",
    Hx = "drawabort";
  class Yx extends e {
    constructor(t, e) {
      super(t), (this.feature = e);
    }
  }
  function Qx(t, e) {
    return gi(t[0], t[1], e[0], e[1]);
  }
  function $x(t, e) {
    const i = t.length;
    return e < 0 ? t[e + i] : e >= i ? t[e - i] : t[e];
  }
  function Jx(t, e, i) {
    let n, r;
    e < i ? ((n = e), (r = i)) : ((n = i), (r = e));
    const s = Math.ceil(n),
      o = Math.floor(r);
    if (s > o) {
      return Qx(sv(t, n), sv(t, r));
    }
    let a = 0;
    if (n < s) {
      a += Qx(sv(t, n), $x(t, s));
    }
    if (o < r) {
      a += Qx($x(t, o), sv(t, r));
    }
    for (let e = s; e < o - 1; ++e) {
      a += Qx($x(t, e), $x(t, e + 1));
    }
    return a;
  }
  function tv(t, e, i) {
    if (e instanceof Bl) iv(t, e.getCoordinates(), !1, i);
    else if (e instanceof bx) {
      const n = e.getCoordinates();
      for (let e = 0, r = n.length; e < r; ++e) iv(t, n[e], !1, i);
    } else if (e instanceof Tr) {
      const n = e.getCoordinates();
      for (let e = 0, r = n.length; e < r; ++e) iv(t, n[e], !0, i);
    } else if (e instanceof Ox) {
      const n = e.getCoordinates();
      for (let e = 0, r = n.length; e < r; ++e) {
        const r = n[e];
        for (let e = 0, n = r.length; e < n; ++e) iv(t, r[e], !0, i);
      }
    } else if (e instanceof Tx) {
      const n = e.getGeometries();
      for (let e = 0; e < n.length; ++e) tv(t, n[e], i);
    } else;
  }
  const ev = { index: -1, endIndex: NaN };
  function iv(t, e, i, n) {
    const r = t[0],
      s = t[1];
    for (let t = 0, o = e.length - 1; t < o; ++t) {
      const o = rv(r, s, e[t], e[t + 1]);
      if (0 === o.squaredDistance) {
        const r = t + o.along;
        return void n.push({
          coordinates: e,
          ring: i,
          startIndex: r,
          endIndex: r,
        });
      }
    }
  }
  const nv = { along: 0, squaredDistance: 0 };
  function rv(t, e, i, n) {
    const r = i[0],
      s = i[1],
      o = n[0] - r,
      a = n[1] - s;
    let l = 0,
      h = r,
      c = s;
    return (
      (0 === o && 0 === a) ||
        ((l = ui(((t - r) * o + (e - s) * a) / (o * o + a * a), 0, 1)),
        (h += o * l),
        (c += a * l)),
      (nv.along = l),
      (nv.squaredDistance = xi(gi(t, e, h, c), 10)),
      nv
    );
  }
  function sv(t, e) {
    const i = t.length;
    let n = Math.floor(e);
    const r = e - n;
    n >= i ? (n -= i) : n < 0 && (n += i);
    let s = n + 1;
    s >= i && (s -= i);
    const o = t[n],
      a = o[0],
      l = o[1],
      h = t[s];
    return [a + (h[0] - a) * r, l + (h[1] - l) * r];
  }
  function ov() {
    const t = th();
    return function (e, i) {
      return t[e.getGeometry().getType()];
    };
  }
  var av = class extends Sa {
    constructor(t) {
      const e = t;
      e.stopDown || (e.stopDown = g),
        super(e),
        this.on,
        this.once,
        this.un,
        (this.shouldHandle_ = !1),
        (this.downPx_ = null),
        this.downTimeout_,
        this.lastDragTime_,
        this.pointerType_,
        (this.freehand_ = !1),
        (this.source_ = t.source ? t.source : null),
        (this.features_ = t.features ? t.features : null),
        (this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12),
        (this.type_ = t.type),
        (this.mode_ = (function (t) {
          switch (t) {
            case "Point":
            case "MultiPoint":
              return "Point";
            case "LineString":
            case "MultiLineString":
              return "LineString";
            case "Polygon":
            case "MultiPolygon":
              return "Polygon";
            case "Circle":
              return "Circle";
            default:
              throw new Error("Invalid type: " + t);
          }
        })(this.type_)),
        (this.stopClick_ = !!t.stopClick),
        (this.minPoints_ = t.minPoints
          ? t.minPoints
          : "Polygon" === this.mode_
          ? 3
          : 2),
        (this.maxPoints_ =
          "Circle" === this.mode_ ? 2 : t.maxPoints ? t.maxPoints : 1 / 0),
        (this.finishCondition_ = t.finishCondition ? t.finishCondition : d),
        (this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY");
      let i = t.geometryFunction;
      if (!i) {
        const t = this.mode_;
        if ("Circle" === t)
          i = function (t, e, i) {
            const n = e || new Wx([NaN, NaN]),
              r = _n(t[0], i),
              s = Mi(r, _n(t[t.length - 1], i));
            n.setCenterAndRadius(r, Math.sqrt(s), this.geometryLayout_);
            const o = pn();
            return o && n.transform(i, o), n;
          };
        else {
          let e;
          "Point" === t
            ? (e = or)
            : "LineString" === t
            ? (e = Bl)
            : "Polygon" === t && (e = Tr),
            (i = function (i, n, r) {
              return (
                n
                  ? "Polygon" === t
                    ? i[0].length
                      ? n.setCoordinates(
                          [i[0].concat([i[0][0]])],
                          this.geometryLayout_
                        )
                      : n.setCoordinates([], this.geometryLayout_)
                    : n.setCoordinates(i, this.geometryLayout_)
                  : (n = new e(i, this.geometryLayout_)),
                n
              );
            });
        }
      }
      (this.geometryFunction_ = i),
        (this.dragVertexDelay_ =
          void 0 !== t.dragVertexDelay ? t.dragVertexDelay : 500),
        (this.finishCoordinate_ = null),
        (this.sketchFeature_ = null),
        (this.sketchPoint_ = null),
        (this.sketchCoords_ = null),
        (this.sketchLine_ = null),
        (this.sketchLineCoords_ = null),
        (this.squaredClickTolerance_ = t.clickTolerance
          ? t.clickTolerance * t.clickTolerance
          : 36),
        (this.overlay_ = new Pu({
          source: new qu({ useSpatialIndex: !1, wrapX: !!t.wrapX && t.wrapX }),
          style: t.style ? t.style : ov(),
          updateWhileInteracting: !0,
        })),
        (this.geometryName_ = t.geometryName),
        (this.condition_ = t.condition ? t.condition : Ia),
        this.freehandCondition_,
        t.freehand
          ? (this.freehandCondition_ = Ta)
          : (this.freehandCondition_ = t.freehandCondition
              ? t.freehandCondition
              : Ma),
        this.traceCondition_,
        this.setTrace(t.trace || !1),
        (this.traceState_ = { active: !1 }),
        (this.traceSource_ = t.traceSource || t.source || null),
        this.addChangeListener(pa, this.updateState_);
    }
    setTrace(t) {
      let e;
      (e = t ? (!0 === t ? Ta : t) : ba), (this.traceCondition_ = e);
    }
    setMap(t) {
      super.setMap(t), this.updateState_();
    }
    getOverlay() {
      return this.overlay_;
    }
    handleEvent(t) {
      t.originalEvent.type === C && t.originalEvent.preventDefault(),
        (this.freehand_ = "Point" !== this.mode_ && this.freehandCondition_(t));
      let e = t.type === Vo.POINTERMOVE,
        i = !0;
      if (!this.freehand_ && this.lastDragTime_ && t.type === Vo.POINTERDRAG) {
        Date.now() - this.lastDragTime_ >= this.dragVertexDelay_
          ? ((this.downPx_ = t.pixel),
            (this.shouldHandle_ = !this.freehand_),
            (e = !0))
          : (this.lastDragTime_ = void 0),
          this.shouldHandle_ &&
            void 0 !== this.downTimeout_ &&
            (clearTimeout(this.downTimeout_), (this.downTimeout_ = void 0));
      }
      return (
        this.freehand_ &&
        t.type === Vo.POINTERDRAG &&
        null !== this.sketchFeature_
          ? (this.addToDrawing_(t.coordinate), (i = !1))
          : this.freehand_ && t.type === Vo.POINTERDOWN
          ? (i = !1)
          : e && this.getPointerCount() < 2
          ? ((i = t.type === Vo.POINTERMOVE),
            i && this.freehand_
              ? (this.handlePointerMove_(t),
                this.shouldHandle_ && t.originalEvent.preventDefault())
              : ("mouse" === t.originalEvent.pointerType ||
                  (t.type === Vo.POINTERDRAG &&
                    void 0 === this.downTimeout_)) &&
                this.handlePointerMove_(t))
          : t.type === Vo.DBLCLICK && (i = !1),
        super.handleEvent(t) && i
      );
    }
    handleDownEvent(t) {
      return (
        (this.shouldHandle_ = !this.freehand_),
        this.freehand_
          ? ((this.downPx_ = t.pixel),
            this.finishCoordinate_ || this.startDrawing_(t.coordinate),
            !0)
          : this.condition_(t)
          ? ((this.lastDragTime_ = Date.now()),
            (this.downTimeout_ = setTimeout(() => {
              this.handlePointerMove_(
                new qo(Vo.POINTERMOVE, t.map, t.originalEvent, !1, t.frameState)
              );
            }, this.dragVertexDelay_)),
            (this.downPx_ = t.pixel),
            !0)
          : ((this.lastDragTime_ = void 0), !1)
      );
    }
    deactivateTrace_() {
      this.traceState_ = { active: !1 };
    }
    toggleTraceState_(t) {
      if (!this.traceSource_ || !this.traceCondition_(t)) return;
      if (this.traceState_.active) return void this.deactivateTrace_();
      const e = this.getMap(),
        i = Qt([
          e.getCoordinateFromPixel([
            t.pixel[0] - this.snapTolerance_,
            t.pixel[1] + this.snapTolerance_,
          ]),
          e.getCoordinateFromPixel([
            t.pixel[0] + this.snapTolerance_,
            t.pixel[1] - this.snapTolerance_,
          ]),
        ]),
        n = this.traceSource_.getFeaturesInExtent(i);
      if (0 === n.length) return;
      const r = (function (t, e) {
        const i = [];
        for (let n = 0; n < e.length; ++n) tv(t, e[n].getGeometry(), i);
        return i;
      })(t.coordinate, n);
      r.length &&
        (this.traceState_ = {
          active: !0,
          startPx: t.pixel.slice(),
          targets: r,
          targetIndex: -1,
        });
    }
    addOrRemoveTracedCoordinates_(t, e) {
      const i = t.startIndex <= t.endIndex;
      i === t.startIndex <= e
        ? (i && e > t.endIndex) || (!i && e < t.endIndex)
          ? this.addTracedCoordinates_(t, t.endIndex, e)
          : ((i && e < t.endIndex) || (!i && e > t.endIndex)) &&
            this.removeTracedCoordinates_(e, t.endIndex)
        : (this.removeTracedCoordinates_(t.startIndex, t.endIndex),
          this.addTracedCoordinates_(t, t.startIndex, e));
    }
    removeTracedCoordinates_(t, e) {
      if (t === e) return;
      let i = 0;
      if (t < e) {
        const n = Math.ceil(t);
        let r = Math.floor(e);
        r === e && (r -= 1), (i = r - n + 1);
      } else {
        const n = Math.floor(t);
        let r = Math.ceil(e);
        r === e && (r += 1), (i = n - r + 1);
      }
      i > 0 && this.removeLastPoints_(i);
    }
    addTracedCoordinates_(t, e, i) {
      if (e === i) return;
      const n = [];
      if (e < i) {
        const r = Math.ceil(e);
        let s = Math.floor(i);
        s === i && (s -= 1);
        for (let e = r; e <= s; ++e) n.push($x(t.coordinates, e));
      } else {
        const r = Math.floor(e);
        let s = Math.ceil(i);
        s === i && (s += 1);
        for (let e = r; e >= s; --e) n.push($x(t.coordinates, e));
      }
      n.length && this.appendCoordinates(n);
    }
    updateTrace_(t) {
      const e = this.traceState_;
      if (!e.active) return;
      if (-1 === e.targetIndex && Oi(e.startPx, t.pixel) < this.snapTolerance_)
        return;
      const i = (function (t, e, i, n) {
        const r = t[0],
          s = t[1];
        let o = 1 / 0,
          a = -1,
          l = NaN;
        for (let t = 0; t < e.targets.length; ++t) {
          const i = e.targets[t],
            n = i.coordinates;
          let h,
            c = 1 / 0;
          for (let t = 0; t < n.length - 1; ++t) {
            const e = rv(r, s, n[t], n[t + 1]);
            e.squaredDistance < c &&
              ((c = e.squaredDistance), (h = t + e.along));
          }
          c < o &&
            ((o = c),
            i.ring &&
              e.targetIndex === t &&
              (i.endIndex > i.startIndex
                ? h < i.startIndex && (h += n.length)
                : i.endIndex < i.startIndex &&
                  h > i.startIndex &&
                  (h -= n.length)),
            (l = h),
            (a = t));
        }
        const h = e.targets[a];
        let c = h.ring;
        if (e.targetIndex === a && c) {
          const t = sv(h.coordinates, l);
          Oi(i.getPixelFromCoordinate(t), e.startPx) > n && (c = !1);
        }
        if (c) {
          const t = h.coordinates,
            e = t.length,
            i = h.startIndex,
            n = l;
          if (i < n) {
            const r = Jx(t, i, n);
            Jx(t, i, n - e) < r && (l -= e);
          } else {
            const r = Jx(t, i, n);
            Jx(t, i, n + e) < r && (l += e);
          }
        }
        return (ev.index = a), (ev.endIndex = l), ev;
      })(t.coordinate, e, this.getMap(), this.snapTolerance_);
      if (e.targetIndex !== i.index) {
        if (-1 !== e.targetIndex) {
          const t = e.targets[e.targetIndex];
          this.removeTracedCoordinates_(t.startIndex, t.endIndex);
        }
        const t = e.targets[i.index];
        this.addTracedCoordinates_(t, t.startIndex, i.endIndex);
      } else {
        const t = e.targets[e.targetIndex];
        this.addOrRemoveTracedCoordinates_(t, i.endIndex);
      }
      e.targetIndex = i.index;
      const n = e.targets[e.targetIndex];
      n.endIndex = i.endIndex;
      const r = sv(n.coordinates, n.endIndex),
        s = this.getMap().getPixelFromCoordinate(r);
      (t.coordinate = r), (t.pixel = [Math.round(s[0]), Math.round(s[1])]);
    }
    handleUpEvent(t) {
      let e = !0;
      if (0 === this.getPointerCount()) {
        this.downTimeout_ &&
          (clearTimeout(this.downTimeout_), (this.downTimeout_ = void 0)),
          this.handlePointerMove_(t);
        const i = this.traceState_.active;
        if ((this.toggleTraceState_(t), this.shouldHandle_)) {
          const n = !this.finishCoordinate_;
          n && this.startDrawing_(t.coordinate),
            !n && this.freehand_
              ? this.finishDrawing()
              : this.freehand_ ||
                (n && "Point" !== this.mode_) ||
                (this.atFinish_(t.pixel, i)
                  ? this.finishCondition_(t) && this.finishDrawing()
                  : this.addToDrawing_(t.coordinate)),
            (e = !1);
        } else this.freehand_ && this.abortDrawing();
      }
      return !e && this.stopClick_ && t.preventDefault(), e;
    }
    handlePointerMove_(t) {
      if (
        ((this.pointerType_ = t.originalEvent.pointerType),
        this.downPx_ &&
          ((!this.freehand_ && this.shouldHandle_) ||
            (this.freehand_ && !this.shouldHandle_)))
      ) {
        const e = this.downPx_,
          i = t.pixel,
          n = e[0] - i[0],
          r = e[1] - i[1],
          s = n * n + r * r;
        if (
          ((this.shouldHandle_ = this.freehand_
            ? s > this.squaredClickTolerance_
            : s <= this.squaredClickTolerance_),
          !this.shouldHandle_)
        )
          return;
      }
      this.finishCoordinate_
        ? (this.updateTrace_(t), this.modifyDrawing_(t.coordinate))
        : this.createOrUpdateSketchPoint_(t.coordinate.slice());
    }
    atFinish_(t, e) {
      let i = !1;
      if (this.sketchFeature_) {
        let n = !1,
          r = [this.finishCoordinate_];
        const s = this.mode_;
        if ("Point" === s) i = !0;
        else if ("Circle" === s) i = 2 === this.sketchCoords_.length;
        else if ("LineString" === s)
          n = !e && this.sketchCoords_.length > this.minPoints_;
        else if ("Polygon" === s) {
          const t = this.sketchCoords_;
          (n = t[0].length > this.minPoints_),
            (r = [t[0][0], t[0][t[0].length - 2]]),
            (r = e ? [t[0][0]] : [t[0][0], t[0][t[0].length - 2]]);
        }
        if (n) {
          const e = this.getMap();
          for (let n = 0, s = r.length; n < s; n++) {
            const s = r[n],
              o = e.getPixelFromCoordinate(s),
              a = t[0] - o[0],
              l = t[1] - o[1],
              h = this.freehand_ ? 1 : this.snapTolerance_;
            if (((i = Math.sqrt(a * a + l * l) <= h), i)) {
              this.finishCoordinate_ = s;
              break;
            }
          }
        }
      }
      return i;
    }
    createOrUpdateSketchPoint_(t) {
      if (this.sketchPoint_) {
        this.sketchPoint_.getGeometry().setCoordinates(t);
      } else
        (this.sketchPoint_ = new Mt(new or(t))), this.updateSketchFeatures_();
    }
    createOrUpdateCustomSketchLine_(t) {
      this.sketchLine_ || (this.sketchLine_ = new Mt());
      const e = t.getLinearRing(0);
      let i = this.sketchLine_.getGeometry();
      i
        ? (i.setFlatCoordinates(e.getLayout(), e.getFlatCoordinates()),
          i.changed())
        : ((i = new Bl(e.getFlatCoordinates(), e.getLayout())),
          this.sketchLine_.setGeometry(i));
    }
    startDrawing_(t) {
      const e = this.getMap().getView().getProjection(),
        i = Fn(this.geometryLayout_);
      for (; t.length < i; ) t.push(0);
      (this.finishCoordinate_ = t),
        "Point" === this.mode_
          ? (this.sketchCoords_ = t.slice())
          : "Polygon" === this.mode_
          ? ((this.sketchCoords_ = [[t.slice(), t.slice()]]),
            (this.sketchLineCoords_ = this.sketchCoords_[0]))
          : (this.sketchCoords_ = [t.slice(), t.slice()]),
        this.sketchLineCoords_ &&
          (this.sketchLine_ = new Mt(new Bl(this.sketchLineCoords_)));
      const n = this.geometryFunction_(this.sketchCoords_, void 0, e);
      (this.sketchFeature_ = new Mt()),
        this.geometryName_ &&
          this.sketchFeature_.setGeometryName(this.geometryName_),
        this.sketchFeature_.setGeometry(n),
        this.updateSketchFeatures_(),
        this.dispatchEvent(new Yx(Zx, this.sketchFeature_));
    }
    modifyDrawing_(t) {
      const e = this.getMap(),
        i = this.sketchFeature_.getGeometry(),
        n = e.getView().getProjection(),
        r = Fn(this.geometryLayout_);
      let s, o;
      for (; t.length < r; ) t.push(0);
      if (
        ("Point" === this.mode_
          ? (o = this.sketchCoords_)
          : "Polygon" === this.mode_
          ? ((s = this.sketchCoords_[0]),
            (o = s[s.length - 1]),
            this.atFinish_(e.getPixelFromCoordinate(t)) &&
              (t = this.finishCoordinate_.slice()))
          : ((s = this.sketchCoords_), (o = s[s.length - 1])),
        (o[0] = t[0]),
        (o[1] = t[1]),
        this.geometryFunction_(this.sketchCoords_, i, n),
        this.sketchPoint_)
      ) {
        this.sketchPoint_.getGeometry().setCoordinates(t);
      }
      if ("Polygon" === i.getType() && "Polygon" !== this.mode_)
        this.createOrUpdateCustomSketchLine_(i);
      else if (this.sketchLineCoords_) {
        this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_);
      }
      this.updateSketchFeatures_();
    }
    addToDrawing_(t) {
      const e = this.sketchFeature_.getGeometry(),
        i = this.getMap().getView().getProjection();
      let n, r;
      const s = this.mode_;
      "LineString" === s || "Circle" === s
        ? ((this.finishCoordinate_ = t.slice()),
          (r = this.sketchCoords_),
          r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : (n = !0)),
          r.push(t.slice()),
          this.geometryFunction_(r, e, i))
        : "Polygon" === s &&
          ((r = this.sketchCoords_[0]),
          r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : (n = !0)),
          r.push(t.slice()),
          n && (this.finishCoordinate_ = r[0]),
          this.geometryFunction_(this.sketchCoords_, e, i)),
        this.createOrUpdateSketchPoint_(t.slice()),
        this.updateSketchFeatures_(),
        n && this.finishDrawing();
    }
    removeLastPoints_(t) {
      if (!this.sketchFeature_) return;
      const e = this.sketchFeature_.getGeometry(),
        i = this.getMap().getView().getProjection(),
        n = this.mode_;
      for (let r = 0; r < t; ++r) {
        let t;
        if ("LineString" === n || "Circle" === n) {
          if (((t = this.sketchCoords_), t.splice(-2, 1), t.length >= 2)) {
            this.finishCoordinate_ = t[t.length - 2].slice();
            const e = this.finishCoordinate_.slice();
            (t[t.length - 1] = e), this.createOrUpdateSketchPoint_(e);
          }
          this.geometryFunction_(t, e, i),
            "Polygon" === e.getType() &&
              this.sketchLine_ &&
              this.createOrUpdateCustomSketchLine_(e);
        } else if ("Polygon" === n) {
          (t = this.sketchCoords_[0]), t.splice(-2, 1);
          const n = this.sketchLine_.getGeometry();
          if (t.length >= 2) {
            const e = t[t.length - 2].slice();
            (t[t.length - 1] = e), this.createOrUpdateSketchPoint_(e);
          }
          n.setCoordinates(t), this.geometryFunction_(this.sketchCoords_, e, i);
        }
        if (1 === t.length) {
          this.abortDrawing();
          break;
        }
      }
      this.updateSketchFeatures_();
    }
    removeLastPoint() {
      this.removeLastPoints_(1);
    }
    finishDrawing() {
      const t = this.abortDrawing_();
      if (!t) return;
      let e = this.sketchCoords_;
      const i = t.getGeometry(),
        n = this.getMap().getView().getProjection();
      "LineString" === this.mode_
        ? (e.pop(), this.geometryFunction_(e, i, n))
        : "Polygon" === this.mode_ &&
          (e[0].pop(),
          this.geometryFunction_(e, i, n),
          (e = i.getCoordinates())),
        "MultiPoint" === this.type_
          ? t.setGeometry(new Ix([e]))
          : "MultiLineString" === this.type_
          ? t.setGeometry(new bx([e]))
          : "MultiPolygon" === this.type_ && t.setGeometry(new Ox([e])),
        this.dispatchEvent(new Yx(Kx, t)),
        this.features_ && this.features_.push(t),
        this.source_ && this.source_.addFeature(t);
    }
    abortDrawing_() {
      this.finishCoordinate_ = null;
      const t = this.sketchFeature_;
      return (
        (this.sketchFeature_ = null),
        (this.sketchPoint_ = null),
        (this.sketchLine_ = null),
        this.overlay_.getSource().clear(!0),
        this.deactivateTrace_(),
        t
      );
    }
    abortDrawing() {
      const t = this.abortDrawing_();
      t && this.dispatchEvent(new Yx(Hx, t));
    }
    appendCoordinates(t) {
      const e = this.mode_,
        i = !this.sketchFeature_;
      let n;
      if ((i && this.startDrawing_(t[0]), "LineString" === e || "Circle" === e))
        n = this.sketchCoords_;
      else {
        if ("Polygon" !== e) return;
        n =
          this.sketchCoords_ && this.sketchCoords_.length
            ? this.sketchCoords_[0]
            : [];
      }
      i && n.shift(), n.pop();
      for (let e = 0; e < t.length; e++) this.addToDrawing_(t[e]);
      const r = t[t.length - 1];
      this.addToDrawing_(r), this.modifyDrawing_(r);
    }
    extend(t) {
      const e = t.getGeometry();
      (this.sketchFeature_ = t), (this.sketchCoords_ = e.getCoordinates());
      const i = this.sketchCoords_[this.sketchCoords_.length - 1];
      (this.finishCoordinate_ = i.slice()),
        this.sketchCoords_.push(i.slice()),
        (this.sketchPoint_ = new Mt(new or(i))),
        this.updateSketchFeatures_(),
        this.dispatchEvent(new Yx(Zx, this.sketchFeature_));
    }
    updateSketchFeatures_() {
      const t = [];
      this.sketchFeature_ && t.push(this.sketchFeature_),
        this.sketchLine_ && t.push(this.sketchLine_),
        this.sketchPoint_ && t.push(this.sketchPoint_);
      const e = this.overlay_.getSource();
      e.clear(!0), e.addFeatures(t);
    }
    updateState_() {
      const t = this.getMap(),
        e = this.getActive();
      (t && e) || this.abortDrawing(), this.overlay_.setMap(e ? t : null);
    }
  };
  const lv = "extentchanged";
  class hv extends e {
    constructor(t) {
      super(lv), (this.extent = t);
    }
  }
  function cv() {
    const t = th();
    return function (e, i) {
      return t.Polygon;
    };
  }
  function uv() {
    const t = th();
    return function (e, i) {
      return t.Point;
    };
  }
  function dv(t) {
    return function (e) {
      return Qt([t, e]);
    };
  }
  function gv(t, e) {
    return t[0] == e[0]
      ? function (i) {
          return Qt([t, [i[0], e[1]]]);
        }
      : t[1] == e[1]
      ? function (i) {
          return Qt([t, [e[0], i[1]]]);
        }
      : null;
  }
  var fv = class extends Sa {
    constructor(t) {
      super((t = t || {})),
        this.on,
        this.once,
        this.un,
        (this.condition_ = t.condition ? t.condition : Ta),
        (this.extent_ = null),
        (this.pointerHandler_ = null),
        (this.pixelTolerance_ =
          void 0 !== t.pixelTolerance ? t.pixelTolerance : 10),
        (this.snappedToVertex_ = !1),
        (this.extentFeature_ = null),
        (this.vertexFeature_ = null),
        t || (t = {}),
        (this.extentOverlay_ = new Pu({
          source: new qu({ useSpatialIndex: !1, wrapX: !!t.wrapX }),
          style: t.boxStyle ? t.boxStyle : cv(),
          updateWhileAnimating: !0,
          updateWhileInteracting: !0,
        })),
        (this.vertexOverlay_ = new Pu({
          source: new qu({ useSpatialIndex: !1, wrapX: !!t.wrapX }),
          style: t.pointerStyle ? t.pointerStyle : uv(),
          updateWhileAnimating: !0,
          updateWhileInteracting: !0,
        })),
        t.extent && this.setExtent(t.extent);
    }
    snapToVertex_(t, e) {
      const i = e.getCoordinateFromPixelInternal(t),
        n = function (t, e) {
          return ki(i, t) - ki(i, e);
        },
        r = this.getExtentInternal();
      if (r) {
        const s = (function (t) {
          return [
            [
              [t[0], t[1]],
              [t[0], t[3]],
            ],
            [
              [t[0], t[3]],
              [t[2], t[3]],
            ],
            [
              [t[2], t[3]],
              [t[2], t[1]],
            ],
            [
              [t[2], t[1]],
              [t[0], t[1]],
            ],
          ];
        })(r);
        s.sort(n);
        const o = s[0];
        let a = Ti(i, o);
        const l = e.getPixelFromCoordinateInternal(a);
        if (Oi(t, l) <= this.pixelTolerance_) {
          const t = e.getPixelFromCoordinateInternal(o[0]),
            i = e.getPixelFromCoordinateInternal(o[1]),
            n = Mi(l, t),
            r = Mi(l, i),
            s = Math.sqrt(Math.min(n, r));
          return (
            (this.snappedToVertex_ = s <= this.pixelTolerance_),
            this.snappedToVertex_ && (a = n > r ? o[1] : o[0]),
            a
          );
        }
      }
      return null;
    }
    handlePointerMove_(t) {
      const e = t.pixel,
        i = t.map;
      let n = this.snapToVertex_(e, i);
      n || (n = i.getCoordinateFromPixelInternal(e)),
        this.createOrUpdatePointerFeature_(n);
    }
    createOrUpdateExtentFeature_(t) {
      let e = this.extentFeature_;
      return (
        e
          ? t
            ? e.setGeometry(br(t))
            : e.setGeometry(void 0)
          : ((e = new Mt(t ? br(t) : {})),
            (this.extentFeature_ = e),
            this.extentOverlay_.getSource().addFeature(e)),
        e
      );
    }
    createOrUpdatePointerFeature_(t) {
      let e = this.vertexFeature_;
      if (e) {
        e.getGeometry().setCoordinates(t);
      } else
        (e = new Mt(new or(t))),
          (this.vertexFeature_ = e),
          this.vertexOverlay_.getSource().addFeature(e);
      return e;
    }
    handleEvent(t) {
      return (
        !t.originalEvent ||
        !this.condition_(t) ||
        (t.type != Vo.POINTERMOVE ||
          this.handlingDownUpSequence ||
          this.handlePointerMove_(t),
        super.handleEvent(t),
        !1)
      );
    }
    handleDownEvent(t) {
      const e = t.pixel,
        i = t.map,
        n = this.getExtentInternal();
      let r = this.snapToVertex_(e, i);
      const s = function (t) {
        let e = null,
          i = null;
        return (
          t[0] == n[0] ? (e = n[2]) : t[0] == n[2] && (e = n[0]),
          t[1] == n[1] ? (i = n[3]) : t[1] == n[3] && (i = n[1]),
          null !== e && null !== i ? [e, i] : null
        );
      };
      if (r && n) {
        const t = r[0] == n[0] || r[0] == n[2] ? r[0] : null,
          e = r[1] == n[1] || r[1] == n[3] ? r[1] : null;
        null !== t && null !== e
          ? (this.pointerHandler_ = dv(s(r)))
          : null !== t
          ? (this.pointerHandler_ = gv(s([t, n[1]]), s([t, n[3]])))
          : null !== e &&
            (this.pointerHandler_ = gv(s([n[0], e]), s([n[2], e])));
      } else
        (r = i.getCoordinateFromPixelInternal(e)),
          this.setExtent([r[0], r[1], r[0], r[1]]),
          (this.pointerHandler_ = dv(r));
      return !0;
    }
    handleDragEvent(t) {
      if (this.pointerHandler_) {
        const e = t.coordinate;
        this.setExtent(this.pointerHandler_(e)),
          this.createOrUpdatePointerFeature_(e);
      }
    }
    handleUpEvent(t) {
      this.pointerHandler_ = null;
      const e = this.getExtentInternal();
      return (e && 0 !== xe(e)) || this.setExtent(null), !1;
    }
    setMap(t) {
      this.extentOverlay_.setMap(t),
        this.vertexOverlay_.setMap(t),
        super.setMap(t);
    }
    getExtent() {
      return yn(
        this.getExtentInternal(),
        this.getMap().getView().getProjection()
      );
    }
    getExtentInternal() {
      return this.extent_;
    }
    setExtent(t) {
      (this.extent_ = t || null),
        this.createOrUpdateExtentFeature_(t),
        this.dispatchEvent(new hv(this.extent_));
    }
  };
  function pv(t) {
    return parseFloat(t);
  }
  function mv(t) {
    return (function (t) {
      return xi(t, 5);
    })(t).toString();
  }
  function _v(t, e) {
    return !isNaN(t) && t !== pv(mv(e));
  }
  var yv = class extends ya {
    constructor(t) {
      let e;
      super(),
        (e =
          !0 ===
          (t = Object.assign(
            {
              animate: !0,
              params: ["x", "y", "z", "r", "l"],
              replace: !1,
              prefix: "",
            },
            t || {}
          )).animate
            ? { duration: 250 }
            : t.animate
            ? t.animate
            : null),
        (this.animationOptions_ = e),
        (this.params_ = t.params.reduce((t, e) => ((t[e] = !0), t), {})),
        (this.replace_ = t.replace),
        (this.prefix_ = t.prefix),
        (this.listenerKeys_ = []),
        (this.initial_ = !0),
        (this.updateState_ = this.updateState_.bind(this));
    }
    getParamName_(t) {
      return this.prefix_ ? this.prefix_ + t : t;
    }
    get_(t, e) {
      return t.get(this.getParamName_(e));
    }
    set_(t, e, i) {
      e in this.params_ && t.set(this.getParamName_(e), i);
    }
    delete_(t, e) {
      e in this.params_ && t.delete(this.getParamName_(e));
    }
    setMap(t) {
      const e = this.getMap();
      super.setMap(t),
        t !== e &&
          (e && this.unregisterListeners_(e),
          t &&
            ((this.initial_ = !0),
            this.updateState_(),
            this.registerListeners_(t)));
    }
    registerListeners_(t) {
      this.listenerKeys_.push(
        M(t, Jo, this.updateUrl_, this),
        M(t.getLayerGroup(), v, this.updateUrl_, this),
        M(t, "change:layergroup", this.handleChangeLayerGroup_, this)
      ),
        this.replace_ || addEventListener("popstate", this.updateState_);
    }
    unregisterListeners_(t) {
      for (let t = 0, e = this.listenerKeys_.length; t < e; ++t)
        k(this.listenerKeys_[t]);
      (this.listenerKeys_.length = 0),
        this.replace_ || removeEventListener("popstate", this.updateState_);
      const e = new URL(window.location.href),
        i = e.searchParams;
      this.delete_(i, "x"),
        this.delete_(i, "y"),
        this.delete_(i, "z"),
        this.delete_(i, "r"),
        this.delete_(i, "l"),
        window.history.replaceState(null, "", e);
    }
    handleChangeLayerGroup_() {
      const t = this.getMap();
      t &&
        (this.unregisterListeners_(t),
        this.registerListeners_(t),
        (this.initial_ = !0),
        this.updateUrl_());
    }
    updateState_() {
      const t = this.getMap();
      if (!t) return;
      const e = t.getView();
      if (!e) return;
      const i = new URL(window.location.href).searchParams;
      let n = !1;
      const r = {},
        s = pv(this.get_(i, "z"));
      "z" in this.params_ && _v(s, e.getZoom()) && ((n = !0), (r.zoom = s));
      const o = pv(this.get_(i, "r"));
      "r" in this.params_ &&
        _v(o, e.getRotation()) &&
        ((n = !0), (r.rotation = o));
      const a = [pv(this.get_(i, "x")), pv(this.get_(i, "y"))];
      var l, h;
      ("x" in this.params_ || "y" in this.params_) &&
        ((l = a), (h = e.getCenter()), _v(l[0], h[0]) || _v(l[1], h[1])) &&
        ((n = !0), (r.center = a)),
        n &&
          (!this.initial_ && this.animationOptions_
            ? e.animate(Object.assign(r, this.animationOptions_))
            : (r.center && e.setCenter(r.center),
              "zoom" in r && e.setZoom(r.zoom),
              "rotation" in r && e.setRotation(r.rotation)));
      const c = t.getAllLayers(),
        u = this.get_(i, "l");
      if ("l" in this.params_ && u && u.length === c.length)
        for (let t = 0, e = c.length; t < e; ++t) {
          const e = parseInt(u[t]);
          if (!isNaN(e)) {
            const i = Boolean(e),
              n = c[t];
            n.getVisible() !== i && n.setVisible(i);
          }
        }
    }
    updateUrl_() {
      const t = this.getMap();
      if (!t) return;
      const e = t.getView();
      if (!e) return;
      const i = this.initial_;
      this.initial_ = !1;
      const n = e.getCenter(),
        r = e.getZoom(),
        s = e.getRotation(),
        o = t.getAllLayers(),
        a = new Array(o.length);
      for (let t = 0, e = o.length; t < e; ++t)
        a[t] = o[t].getVisible() ? "1" : "0";
      const l = new URL(window.location.href),
        h = l.searchParams;
      this.set_(h, "x", mv(n[0])),
        this.set_(h, "y", mv(n[1])),
        this.set_(h, "z", mv(r)),
        this.set_(h, "r", mv(s)),
        this.set_(h, "l", a.join("")),
        l.href !== window.location.href &&
          (i || this.replace_
            ? window.history.replaceState(history.state, "", l)
            : window.history.pushState(null, "", l));
    }
  };
  const xv = [0, 0, 0, 0],
    vv = [],
    Sv = "modifystart",
    Cv = "modifyend";
  class wv extends e {
    constructor(t, e, i) {
      super(t), (this.features = e), (this.mapBrowserEvent = i);
    }
  }
  function Wv(t, e) {
    return t.index - e.index;
  }
  function Ev(t, e, i) {
    const n = e.geometry;
    if ("Circle" === n.getType()) {
      let r = n;
      if (1 === e.index) {
        const e = pn();
        e && (r = r.clone().transform(e, i));
        const n = Mi(r.getCenter(), _n(t, i)),
          s = Math.sqrt(n) - r.getRadius();
        return s * s;
      }
    }
    const r = _n(t, i);
    return (
      (vv[0] = _n(e.segment[0], i)), (vv[1] = _n(e.segment[1], i)), ki(r, vv)
    );
  }
  function Rv(t, e, i) {
    const n = e.geometry;
    if ("Circle" === n.getType() && 1 === e.index) {
      let e = n;
      const r = pn();
      return (
        r && (e = e.clone().transform(r, i)), mn(e.getClosestPoint(_n(t, i)), i)
      );
    }
    const r = _n(t, i);
    return (
      (vv[0] = _n(e.segment[0], i)),
      (vv[1] = _n(e.segment[1], i)),
      mn(Ti(r, vv), i)
    );
  }
  function Tv() {
    const t = th();
    return function (e, i) {
      return t.Point;
    };
  }
  var Pv = class extends Sa {
    constructor(t) {
      let e;
      if (
        (super(t),
        this.on,
        this.once,
        this.un,
        (this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this)),
        (this.condition_ = t.condition ? t.condition : Aa),
        (this.defaultDeleteCondition_ = function (t) {
          return wa(t) && Fa(t);
        }),
        (this.deleteCondition_ = t.deleteCondition
          ? t.deleteCondition
          : this.defaultDeleteCondition_),
        (this.insertVertexCondition_ = t.insertVertexCondition
          ? t.insertVertexCondition
          : Ta),
        (this.vertexFeature_ = null),
        (this.vertexSegments_ = null),
        (this.lastPixel_ = [0, 0]),
        (this.ignoreNextSingleClick_ = !1),
        (this.featuresBeingModified_ = null),
        (this.rBush_ = new bu()),
        (this.pixelTolerance_ =
          void 0 !== t.pixelTolerance ? t.pixelTolerance : 10),
        (this.snappedToVertex_ = !1),
        (this.changingFeature_ = !1),
        (this.dragSegments_ = []),
        (this.overlay_ = new Pu({
          source: new qu({ useSpatialIndex: !1, wrapX: !!t.wrapX }),
          style: t.style ? t.style : Tv(),
          updateWhileAnimating: !0,
          updateWhileInteracting: !0,
        })),
        (this.SEGMENT_WRITERS_ = {
          Point: this.writePointGeometry_.bind(this),
          LineString: this.writeLineStringGeometry_.bind(this),
          LinearRing: this.writeLineStringGeometry_.bind(this),
          Polygon: this.writePolygonGeometry_.bind(this),
          MultiPoint: this.writeMultiPointGeometry_.bind(this),
          MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
          MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
          Circle: this.writeCircleGeometry_.bind(this),
          GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this),
        }),
        (this.source_ = null),
        (this.hitDetection_ = null),
        t.features
          ? (e = t.features)
          : t.source &&
            ((this.source_ = t.source),
            (e = new K(this.source_.getFeatures())),
            this.source_.addEventListener(Lu, this.handleSourceAdd_.bind(this)),
            this.source_.addEventListener(
              ku,
              this.handleSourceRemove_.bind(this)
            )),
        !e)
      )
        throw new Error(
          "The modify interaction requires features, a source or a layer"
        );
      t.hitDetection && (this.hitDetection_ = t.hitDetection),
        (this.features_ = e),
        this.features_.forEach(this.addFeature_.bind(this)),
        this.features_.addEventListener(q, this.handleFeatureAdd_.bind(this)),
        this.features_.addEventListener(
          V,
          this.handleFeatureRemove_.bind(this)
        ),
        (this.lastPointerEvent_ = null),
        (this.delta_ = [0, 0]),
        (this.snapToPointer_ =
          void 0 === t.snapToPointer ? !this.hitDetection_ : t.snapToPointer);
    }
    addFeature_(t) {
      const e = t.getGeometry();
      if (e) {
        const i = this.SEGMENT_WRITERS_[e.getType()];
        i && i(t, e);
      }
      const i = this.getMap();
      i &&
        i.isRendered() &&
        this.getActive() &&
        this.handlePointerAtPixel_(this.lastPixel_, i),
        t.addEventListener(v, this.boundHandleFeatureChange_);
    }
    willModifyFeatures_(t, e) {
      if (!this.featuresBeingModified_) {
        this.featuresBeingModified_ = new K();
        const i = this.featuresBeingModified_.getArray();
        for (let t = 0, n = e.length; t < n; ++t) {
          const n = e[t];
          for (let t = 0, e = n.length; t < e; ++t) {
            const e = n[t].feature;
            e && !i.includes(e) && this.featuresBeingModified_.push(e);
          }
        }
        0 === this.featuresBeingModified_.getLength()
          ? (this.featuresBeingModified_ = null)
          : this.dispatchEvent(new wv(Sv, this.featuresBeingModified_, t));
      }
    }
    removeFeature_(t) {
      this.removeFeatureSegmentData_(t),
        this.vertexFeature_ &&
          0 === this.features_.getLength() &&
          (this.overlay_.getSource().removeFeature(this.vertexFeature_),
          (this.vertexFeature_ = null)),
        t.removeEventListener(v, this.boundHandleFeatureChange_);
    }
    removeFeatureSegmentData_(t) {
      const e = this.rBush_,
        i = [];
      e.forEach(function (e) {
        t === e.feature && i.push(e);
      });
      for (let t = i.length - 1; t >= 0; --t) {
        const n = i[t];
        for (let t = this.dragSegments_.length - 1; t >= 0; --t)
          this.dragSegments_[t][0] === n && this.dragSegments_.splice(t, 1);
        e.remove(n);
      }
    }
    setActive(t) {
      this.vertexFeature_ &&
        !t &&
        (this.overlay_.getSource().removeFeature(this.vertexFeature_),
        (this.vertexFeature_ = null)),
        super.setActive(t);
    }
    setMap(t) {
      this.overlay_.setMap(t), super.setMap(t);
    }
    getOverlay() {
      return this.overlay_;
    }
    handleSourceAdd_(t) {
      t.feature && this.features_.push(t.feature);
    }
    handleSourceRemove_(t) {
      t.feature && this.features_.remove(t.feature);
    }
    handleFeatureAdd_(t) {
      this.addFeature_(t.element);
    }
    handleFeatureChange_(t) {
      if (!this.changingFeature_) {
        const e = t.target;
        this.removeFeature_(e), this.addFeature_(e);
      }
    }
    handleFeatureRemove_(t) {
      this.removeFeature_(t.element);
    }
    writePointGeometry_(t, e) {
      const i = e.getCoordinates(),
        n = { feature: t, geometry: e, segment: [i, i] };
      this.rBush_.insert(e.getExtent(), n);
    }
    writeMultiPointGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let n = 0, r = i.length; n < r; ++n) {
        const r = i[n],
          s = {
            feature: t,
            geometry: e,
            depth: [n],
            index: n,
            segment: [r, r],
          };
        this.rBush_.insert(e.getExtent(), s);
      }
    }
    writeLineStringGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let n = 0, r = i.length - 1; n < r; ++n) {
        const r = i.slice(n, n + 2),
          s = { feature: t, geometry: e, index: n, segment: r };
        this.rBush_.insert(Qt(r), s);
      }
    }
    writeMultiLineStringGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let n = 0, r = i.length; n < r; ++n) {
        const r = i[n];
        for (let i = 0, s = r.length - 1; i < s; ++i) {
          const s = r.slice(i, i + 2),
            o = { feature: t, geometry: e, depth: [n], index: i, segment: s };
          this.rBush_.insert(Qt(s), o);
        }
      }
    }
    writePolygonGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let n = 0, r = i.length; n < r; ++n) {
        const r = i[n];
        for (let i = 0, s = r.length - 1; i < s; ++i) {
          const s = r.slice(i, i + 2),
            o = { feature: t, geometry: e, depth: [n], index: i, segment: s };
          this.rBush_.insert(Qt(s), o);
        }
      }
    }
    writeMultiPolygonGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let n = 0, r = i.length; n < r; ++n) {
        const r = i[n];
        for (let i = 0, s = r.length; i < s; ++i) {
          const s = r[i];
          for (let r = 0, o = s.length - 1; r < o; ++r) {
            const o = s.slice(r, r + 2),
              a = {
                feature: t,
                geometry: e,
                depth: [i, n],
                index: r,
                segment: o,
              };
            this.rBush_.insert(Qt(o), a);
          }
        }
      }
    }
    writeCircleGeometry_(t, e) {
      const i = e.getCenter(),
        n = { feature: t, geometry: e, index: 0, segment: [i, i] },
        r = { feature: t, geometry: e, index: 1, segment: [i, i] },
        s = [n, r];
      (n.featureSegments = s),
        (r.featureSegments = s),
        this.rBush_.insert(le(i), n);
      let o = e;
      const a = pn();
      if (a && this.getMap()) {
        const t = this.getMap().getView().getProjection();
        (o = o.clone().transform(a, t)), (o = Fr(o).transform(t, a));
      }
      this.rBush_.insert(o.getExtent(), r);
    }
    writeGeometryCollectionGeometry_(t, e) {
      const i = e.getGeometriesArray();
      for (let e = 0; e < i.length; ++e) {
        const n = i[e];
        (0, this.SEGMENT_WRITERS_[n.getType()])(t, n);
      }
    }
    createOrUpdateVertexFeature_(t, e, i) {
      let n = this.vertexFeature_;
      if (n) {
        n.getGeometry().setCoordinates(t);
      } else
        (n = new Mt(new or(t))),
          (this.vertexFeature_ = n),
          this.overlay_.getSource().addFeature(n);
      return n.set("features", e), n.set("geometries", i), n;
    }
    handleEvent(t) {
      if (!t.originalEvent) return !0;
      let e;
      return (
        (this.lastPointerEvent_ = t),
        t.map.getView().getInteracting() ||
          t.type != Vo.POINTERMOVE ||
          this.handlingDownUpSequence ||
          this.handlePointerMove_(t),
        this.vertexFeature_ &&
          this.deleteCondition_(t) &&
          (e =
            !(t.type != Vo.SINGLECLICK || !this.ignoreNextSingleClick_) ||
            this.removePoint()),
        t.type == Vo.SINGLECLICK && (this.ignoreNextSingleClick_ = !1),
        super.handleEvent(t) && !e
      );
    }
    handleDragEvent(t) {
      (this.ignoreNextSingleClick_ = !1),
        this.willModifyFeatures_(t, this.dragSegments_);
      const e = [
          t.coordinate[0] + this.delta_[0],
          t.coordinate[1] + this.delta_[1],
        ],
        i = [],
        n = [];
      for (let r = 0, s = this.dragSegments_.length; r < s; ++r) {
        const s = this.dragSegments_[r],
          o = s[0],
          a = o.feature;
        i.includes(a) || i.push(a);
        const l = o.geometry;
        n.includes(l) || n.push(l);
        const h = o.depth;
        let c;
        const u = o.segment,
          d = s[1];
        for (; e.length < l.getStride(); ) e.push(u[d][e.length]);
        switch (l.getType()) {
          case "Point":
            (c = e), (u[0] = e), (u[1] = e);
            break;
          case "MultiPoint":
            (c = l.getCoordinates()), (c[o.index] = e), (u[0] = e), (u[1] = e);
            break;
          case "LineString":
            (c = l.getCoordinates()), (c[o.index + d] = e), (u[d] = e);
            break;
          case "MultiLineString":
          case "Polygon":
            (c = l.getCoordinates()), (c[h[0]][o.index + d] = e), (u[d] = e);
            break;
          case "MultiPolygon":
            (c = l.getCoordinates()),
              (c[h[1]][h[0]][o.index + d] = e),
              (u[d] = e);
            break;
          case "Circle":
            if (((u[0] = e), (u[1] = e), 0 === o.index))
              (this.changingFeature_ = !0),
                l.setCenter(e),
                (this.changingFeature_ = !1);
            else {
              this.changingFeature_ = !0;
              const i = t.map.getView().getProjection();
              let n = Oi(_n(l.getCenter(), i), _n(e, i));
              const r = pn();
              if (r) {
                const t = l.clone().transform(r, i);
                t.setRadius(n), (n = t.transform(i, r).getRadius());
              }
              l.setRadius(n), (this.changingFeature_ = !1);
            }
        }
        c && this.setGeometryCoordinates_(l, c);
      }
      this.createOrUpdateVertexFeature_(e, i, n);
    }
    handleDownEvent(t) {
      if (!this.condition_(t)) return !1;
      const e = t.coordinate;
      this.handlePointerAtPixel_(t.pixel, t.map, e),
        (this.dragSegments_.length = 0),
        (this.featuresBeingModified_ = null);
      const i = this.vertexFeature_;
      if (i) {
        const n = t.map.getView().getProjection(),
          r = [],
          s = i.getGeometry().getCoordinates(),
          o = Qt([s]),
          a = this.rBush_.getInExtent(o),
          l = {};
        a.sort(Wv);
        for (let i = 0, o = a.length; i < o; ++i) {
          const o = a[i],
            h = o.segment;
          let c = j(o.geometry);
          const u = o.depth;
          if (
            (u && (c += "-" + u.join("-")),
            l[c] || (l[c] = new Array(2)),
            "Circle" !== o.geometry.getType() || 1 !== o.index)
          )
            if (!Fi(h[0], s) || l[c][0])
              if (!Fi(h[1], s) || l[c][1])
                j(h) in this.vertexSegments_ &&
                  !l[c][0] &&
                  !l[c][1] &&
                  this.insertVertexCondition_(t) &&
                  r.push(o);
              else {
                if (l[c][0] && 0 === l[c][0].index) {
                  let t = o.geometry.getCoordinates();
                  switch (o.geometry.getType()) {
                    case "LineString":
                    case "MultiLineString":
                      continue;
                    case "MultiPolygon":
                      t = t[u[1]];
                    case "Polygon":
                      if (o.index !== t[u[0]].length - 2) continue;
                  }
                }
                this.dragSegments_.push([o, 1]), (l[c][1] = o);
              }
            else this.dragSegments_.push([o, 0]), (l[c][0] = o);
          else {
            Fi(Rv(e, o, n), s) &&
              !l[c][0] &&
              (this.dragSegments_.push([o, 0]), (l[c][0] = o));
          }
        }
        r.length && this.willModifyFeatures_(t, [r]);
        for (let t = r.length - 1; t >= 0; --t) this.insertVertex_(r[t], s);
      }
      return !!this.vertexFeature_;
    }
    handleUpEvent(t) {
      for (let e = this.dragSegments_.length - 1; e >= 0; --e) {
        const i = this.dragSegments_[e][0],
          n = i.geometry;
        if ("Circle" === n.getType()) {
          const e = n.getCenter(),
            r = i.featureSegments[0],
            s = i.featureSegments[1];
          (r.segment[0] = e),
            (r.segment[1] = e),
            (s.segment[0] = e),
            (s.segment[1] = e),
            this.rBush_.update(le(e), r);
          let o = n;
          const a = pn();
          if (a) {
            const e = t.map.getView().getProjection();
            (o = o.clone().transform(a, e)), (o = Fr(o).transform(e, a));
          }
          this.rBush_.update(o.getExtent(), s);
        } else this.rBush_.update(Qt(i.segment), i);
      }
      return (
        this.featuresBeingModified_ &&
          (this.dispatchEvent(new wv(Cv, this.featuresBeingModified_, t)),
          (this.featuresBeingModified_ = null)),
        !1
      );
    }
    handlePointerMove_(t) {
      (this.lastPixel_ = t.pixel),
        this.handlePointerAtPixel_(t.pixel, t.map, t.coordinate);
    }
    handlePointerAtPixel_(t, e, i) {
      const n = i || e.getCoordinateFromPixel(t),
        r = e.getView().getProjection(),
        s = function (t, e) {
          return Ev(n, t, r) - Ev(n, e, r);
        };
      let o, a;
      if (this.hitDetection_) {
        const i =
          "object" == typeof this.hitDetection_
            ? (t) => t === this.hitDetection_
            : void 0;
        e.forEachFeatureAtPixel(
          t,
          (t, e, i) => {
            i && (i = new or(mn(i.getCoordinates(), r)));
            const n = i || t.getGeometry();
            if (
              "Point" === n.getType() &&
              t instanceof Mt &&
              this.features_.getArray().includes(t)
            ) {
              a = n;
              const e = t.getGeometry().getFlatCoordinates().slice(0, 2);
              o = [{ feature: t, geometry: a, segment: [e, e] }];
            }
            return !0;
          },
          { layerFilter: i }
        );
      }
      if (!o) {
        const t = yn(
          $t(
            xn(le(n, xv), r),
            e.getView().getResolution() * this.pixelTolerance_,
            xv
          ),
          r
        );
        o = this.rBush_.getInExtent(t);
      }
      if (o && o.length > 0) {
        const i = o.sort(s)[0],
          l = i.segment;
        let h = Rv(n, i, r);
        const c = e.getPixelFromCoordinate(h);
        let u = Oi(t, c);
        if (a || u <= this.pixelTolerance_) {
          const t = {};
          if (
            ((t[j(l)] = !0),
            this.snapToPointer_ ||
              ((this.delta_[0] = h[0] - n[0]), (this.delta_[1] = h[1] - n[1])),
            "Circle" === i.geometry.getType() && 1 === i.index)
          )
            (this.snappedToVertex_ = !0),
              this.createOrUpdateVertexFeature_(h, [i.feature], [i.geometry]);
          else {
            const n = e.getPixelFromCoordinate(l[0]),
              r = e.getPixelFromCoordinate(l[1]),
              s = Mi(c, n),
              a = Mi(c, r);
            (u = Math.sqrt(Math.min(s, a))),
              (this.snappedToVertex_ = u <= this.pixelTolerance_),
              this.snappedToVertex_ && (h = s > a ? l[1] : l[0]),
              this.createOrUpdateVertexFeature_(h, [i.feature], [i.geometry]);
            const d = {};
            d[j(i.geometry)] = !0;
            for (let e = 1, i = o.length; e < i; ++e) {
              const i = o[e].segment;
              if (
                !(
                  (Fi(l[0], i[0]) && Fi(l[1], i[1])) ||
                  (Fi(l[0], i[1]) && Fi(l[1], i[0]))
                )
              )
                break;
              {
                const n = j(o[e].geometry);
                n in d || ((d[n] = !0), (t[j(i)] = !0));
              }
            }
          }
          return void (this.vertexSegments_ = t);
        }
      }
      this.vertexFeature_ &&
        (this.overlay_.getSource().removeFeature(this.vertexFeature_),
        (this.vertexFeature_ = null));
    }
    insertVertex_(t, e) {
      const i = t.segment,
        n = t.feature,
        r = t.geometry,
        s = t.depth,
        o = t.index;
      let a;
      for (; e.length < r.getStride(); ) e.push(0);
      switch (r.getType()) {
        case "MultiLineString":
        case "Polygon":
          (a = r.getCoordinates()), a[s[0]].splice(o + 1, 0, e);
          break;
        case "MultiPolygon":
          (a = r.getCoordinates()), a[s[1]][s[0]].splice(o + 1, 0, e);
          break;
        case "LineString":
          (a = r.getCoordinates()), a.splice(o + 1, 0, e);
          break;
        default:
          return;
      }
      this.setGeometryCoordinates_(r, a);
      const l = this.rBush_;
      l.remove(t), this.updateSegmentIndices_(r, o, s, 1);
      const h = {
        segment: [i[0], e],
        feature: n,
        geometry: r,
        depth: s,
        index: o,
      };
      l.insert(Qt(h.segment), h), this.dragSegments_.push([h, 1]);
      const c = {
        segment: [e, i[1]],
        feature: n,
        geometry: r,
        depth: s,
        index: o + 1,
      };
      l.insert(Qt(c.segment), c),
        this.dragSegments_.push([c, 0]),
        (this.ignoreNextSingleClick_ = !0);
    }
    removePoint() {
      if (
        this.lastPointerEvent_ &&
        this.lastPointerEvent_.type != Vo.POINTERDRAG
      ) {
        const t = this.lastPointerEvent_;
        this.willModifyFeatures_(t, this.dragSegments_);
        const e = this.removeVertex_();
        return (
          this.featuresBeingModified_ &&
            this.dispatchEvent(new wv(Cv, this.featuresBeingModified_, t)),
          (this.featuresBeingModified_ = null),
          e
        );
      }
      return !1;
    }
    removeVertex_() {
      const t = this.dragSegments_,
        e = {};
      let i,
        n,
        r,
        s,
        o,
        a,
        l,
        h,
        c,
        u,
        d,
        g = !1;
      for (o = t.length - 1; o >= 0; --o)
        (r = t[o]),
          (u = r[0]),
          (d = j(u.feature)),
          u.depth && (d += "-" + u.depth.join("-")),
          d in e || (e[d] = {}),
          0 === r[1]
            ? ((e[d].right = u), (e[d].index = u.index))
            : 1 == r[1] && ((e[d].left = u), (e[d].index = u.index + 1));
      for (d in e) {
        switch (
          ((c = e[d].right),
          (l = e[d].left),
          (a = e[d].index),
          (h = a - 1),
          (u = void 0 !== l ? l : c),
          h < 0 && (h = 0),
          (s = u.geometry),
          (n = s.getCoordinates()),
          (i = n),
          (g = !1),
          s.getType())
        ) {
          case "MultiLineString":
            n[u.depth[0]].length > 2 && (n[u.depth[0]].splice(a, 1), (g = !0));
            break;
          case "LineString":
            n.length > 2 && (n.splice(a, 1), (g = !0));
            break;
          case "MultiPolygon":
            i = i[u.depth[1]];
          case "Polygon":
            (i = i[u.depth[0]]),
              i.length > 4 &&
                (a == i.length - 1 && (a = 0),
                i.splice(a, 1),
                (g = !0),
                0 === a && (i.pop(), i.push(i[0]), (h = i.length - 1)));
        }
        if (g) {
          this.setGeometryCoordinates_(s, n);
          const e = [];
          if (
            (void 0 !== l && (this.rBush_.remove(l), e.push(l.segment[0])),
            void 0 !== c && (this.rBush_.remove(c), e.push(c.segment[1])),
            void 0 !== l && void 0 !== c)
          ) {
            const t = {
              depth: u.depth,
              feature: u.feature,
              geometry: u.geometry,
              index: h,
              segment: e,
            };
            this.rBush_.insert(Qt(t.segment), t);
          }
          this.updateSegmentIndices_(s, a, u.depth, -1),
            this.vertexFeature_ &&
              (this.overlay_.getSource().removeFeature(this.vertexFeature_),
              (this.vertexFeature_ = null)),
            (t.length = 0);
        }
      }
      return g;
    }
    setGeometryCoordinates_(t, e) {
      (this.changingFeature_ = !0),
        t.setCoordinates(e),
        (this.changingFeature_ = !1);
    }
    updateSegmentIndices_(t, e, i, n) {
      this.rBush_.forEachInExtent(t.getExtent(), function (r) {
        r.geometry === t &&
          (void 0 === i || void 0 === r.depth || c(r.depth, i)) &&
          r.index > e &&
          (r.index += n);
      });
    }
  };
  const bv = "select";
  class Fv extends e {
    constructor(t, e, i, n) {
      super(t),
        (this.selected = e),
        (this.deselected = i),
        (this.mapBrowserEvent = n);
    }
  }
  const Iv = {};
  class Lv extends ya {
    constructor(t) {
      let e;
      if (
        (super(),
        this.on,
        this.once,
        this.un,
        (t = t || {}),
        (this.boundAddFeature_ = this.addFeature_.bind(this)),
        (this.boundRemoveFeature_ = this.removeFeature_.bind(this)),
        (this.condition_ = t.condition ? t.condition : Fa),
        (this.addCondition_ = t.addCondition ? t.addCondition : ba),
        (this.removeCondition_ = t.removeCondition ? t.removeCondition : ba),
        (this.toggleCondition_ = t.toggleCondition ? t.toggleCondition : Ma),
        (this.multi_ = !!t.multi && t.multi),
        (this.filter_ = t.filter ? t.filter : d),
        (this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0),
        (this.style_ =
          void 0 !== t.style
            ? t.style
            : (function () {
                const t = th();
                return (
                  h(t.Polygon, t.LineString),
                  h(t.GeometryCollection, t.LineString),
                  function (e) {
                    return e.getGeometry()
                      ? t[e.getGeometry().getType()]
                      : null;
                  }
                );
              })()),
        (this.features_ = t.features || new K()),
        t.layers)
      )
        if ("function" == typeof t.layers) e = t.layers;
        else {
          const i = t.layers;
          e = function (t) {
            return i.includes(t);
          };
        }
      else e = d;
      (this.layerFilter_ = e), (this.featureLayerAssociation_ = {});
    }
    addFeatureLayerAssociation_(t, e) {
      this.featureLayerAssociation_[j(t)] = e;
    }
    getFeatures() {
      return this.features_;
    }
    getHitTolerance() {
      return this.hitTolerance_;
    }
    getLayer(t) {
      return this.featureLayerAssociation_[j(t)];
    }
    setHitTolerance(t) {
      this.hitTolerance_ = t;
    }
    setMap(t) {
      this.getMap() &&
        this.style_ &&
        this.features_.forEach(this.restorePreviousStyle_.bind(this)),
        super.setMap(t),
        t
          ? (this.features_.addEventListener(q, this.boundAddFeature_),
            this.features_.addEventListener(V, this.boundRemoveFeature_),
            this.style_ &&
              this.features_.forEach(this.applySelectedStyle_.bind(this)))
          : (this.features_.removeEventListener(q, this.boundAddFeature_),
            this.features_.removeEventListener(V, this.boundRemoveFeature_));
    }
    addFeature_(t) {
      const e = t.element;
      if ((this.style_ && this.applySelectedStyle_(e), !this.getLayer(e))) {
        const t = this.getMap()
          .getAllLayers()
          .find(function (t) {
            if (t instanceof Pu && t.getSource() && t.getSource().hasFeature(e))
              return t;
          });
        t && this.addFeatureLayerAssociation_(e, t);
      }
    }
    removeFeature_(t) {
      this.style_ && this.restorePreviousStyle_(t.element);
    }
    getStyle() {
      return this.style_;
    }
    applySelectedStyle_(t) {
      const e = j(t);
      e in Iv || (Iv[e] = t.getStyle()), t.setStyle(this.style_);
    }
    restorePreviousStyle_(t) {
      const e = this.getMap().getInteractions().getArray();
      for (let i = e.length - 1; i >= 0; --i) {
        const n = e[i];
        if (
          n !== this &&
          n instanceof Lv &&
          n.getStyle() &&
          -1 !== n.getFeatures().getArray().lastIndexOf(t)
        )
          return void t.setStyle(n.getStyle());
      }
      const i = j(t);
      t.setStyle(Iv[i]), delete Iv[i];
    }
    removeFeatureLayerAssociation_(t) {
      delete this.featureLayerAssociation_[j(t)];
    }
    handleEvent(t) {
      if (!this.condition_(t)) return !0;
      const e = this.addCondition_(t),
        i = this.removeCondition_(t),
        n = this.toggleCondition_(t),
        r = !e && !i && !n,
        s = t.map,
        o = this.getFeatures(),
        a = [],
        l = [];
      if (r) {
        _(this.featureLayerAssociation_),
          s.forEachFeatureAtPixel(
            t.pixel,
            (t, e) => {
              if (t instanceof Mt && this.filter_(t, e))
                return (
                  this.addFeatureLayerAssociation_(t, e),
                  l.push(t),
                  !this.multi_
                );
            },
            { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }
          );
        for (let t = o.getLength() - 1; t >= 0; --t) {
          const e = o.item(t),
            i = l.indexOf(e);
          i > -1 ? l.splice(i, 1) : (o.remove(e), a.push(e));
        }
        0 !== l.length && o.extend(l);
      } else {
        s.forEachFeatureAtPixel(
          t.pixel,
          (t, r) => {
            if (t instanceof Mt && this.filter_(t, r))
              return (
                (!e && !n) || o.getArray().includes(t)
                  ? (i || n) &&
                    o.getArray().includes(t) &&
                    (a.push(t), this.removeFeatureLayerAssociation_(t))
                  : (this.addFeatureLayerAssociation_(t, r), l.push(t)),
                !this.multi_
              );
          },
          { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }
        );
        for (let t = a.length - 1; t >= 0; --t) o.remove(a[t]);
        o.extend(l);
      }
      return (
        (l.length > 0 || a.length > 0) &&
          this.dispatchEvent(new Fv(bv, l, a, t)),
        !0
      );
    }
  }
  var Mv = Lv;
  const Ov = "snap";
  class kv extends e {
    constructor(t, e) {
      super(t),
        (this.vertex = e.vertex),
        (this.vertexPixel = e.vertexPixel),
        (this.feature = e.feature);
    }
  }
  function Av(t) {
    return t.feature ? t.feature : t.element ? t.element : null;
  }
  const Nv = [];
  var Dv = class extends Sa {
    constructor(t) {
      const e = (t = t || {});
      e.handleDownEvent || (e.handleDownEvent = d),
        e.stopDown || (e.stopDown = g),
        super(e),
        this.on,
        this.once,
        this.un,
        (this.source_ = t.source ? t.source : null),
        (this.vertex_ = void 0 === t.vertex || t.vertex),
        (this.edge_ = void 0 === t.edge || t.edge),
        (this.features_ = t.features ? t.features : null),
        (this.featuresListenerKeys_ = []),
        (this.featureChangeListenerKeys_ = {}),
        (this.indexedFeaturesExtents_ = {}),
        (this.pendingFeatures_ = {}),
        (this.pixelTolerance_ =
          void 0 !== t.pixelTolerance ? t.pixelTolerance : 10),
        (this.rBush_ = new bu()),
        (this.GEOMETRY_SEGMENTERS_ = {
          Point: this.segmentPointGeometry_.bind(this),
          LineString: this.segmentLineStringGeometry_.bind(this),
          LinearRing: this.segmentLineStringGeometry_.bind(this),
          Polygon: this.segmentPolygonGeometry_.bind(this),
          MultiPoint: this.segmentMultiPointGeometry_.bind(this),
          MultiLineString: this.segmentMultiLineStringGeometry_.bind(this),
          MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this),
          GeometryCollection:
            this.segmentGeometryCollectionGeometry_.bind(this),
          Circle: this.segmentCircleGeometry_.bind(this),
        });
    }
    addFeature(t, e) {
      e = void 0 === e || e;
      const i = j(t),
        n = t.getGeometry();
      if (n) {
        const e = this.GEOMETRY_SEGMENTERS_[n.getType()];
        if (e) {
          this.indexedFeaturesExtents_[i] = n.getExtent([
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0,
          ]);
          const r = [];
          if ((e(r, n), 1 === r.length))
            this.rBush_.insert(Qt(r[0]), { feature: t, segment: r[0] });
          else if (r.length > 1) {
            const e = r.map((t) => Qt(t)),
              i = r.map((e) => ({ feature: t, segment: e }));
            this.rBush_.load(e, i);
          }
        }
      }
      e &&
        (this.featureChangeListenerKeys_[i] = M(
          t,
          v,
          this.handleFeatureChange_,
          this
        ));
    }
    getFeatures_() {
      let t;
      return (
        this.features_
          ? (t = this.features_)
          : this.source_ && (t = this.source_.getFeatures()),
        t
      );
    }
    handleEvent(t) {
      const e = this.snapTo(t.pixel, t.coordinate, t.map);
      return (
        e &&
          ((t.coordinate = e.vertex.slice(0, 2)),
          (t.pixel = e.vertexPixel),
          this.dispatchEvent(
            new kv(Ov, {
              vertex: t.coordinate,
              vertexPixel: t.pixel,
              feature: e.feature,
            })
          )),
        super.handleEvent(t)
      );
    }
    handleFeatureAdd_(t) {
      const e = Av(t);
      e && this.addFeature(e);
    }
    handleFeatureRemove_(t) {
      const e = Av(t);
      e && this.removeFeature(e);
    }
    handleFeatureChange_(t) {
      const e = t.target;
      if (this.handlingDownUpSequence) {
        const t = j(e);
        t in this.pendingFeatures_ || (this.pendingFeatures_[t] = e);
      } else this.updateFeature_(e);
    }
    handleUpEvent(t) {
      const e = Object.values(this.pendingFeatures_);
      return (
        e.length &&
          (e.forEach(this.updateFeature_.bind(this)),
          (this.pendingFeatures_ = {})),
        !1
      );
    }
    removeFeature(t, e) {
      const i = void 0 === e || e,
        n = j(t),
        r = this.indexedFeaturesExtents_[n];
      if (r) {
        const e = this.rBush_,
          i = [];
        e.forEachInExtent(r, function (e) {
          t === e.feature && i.push(e);
        });
        for (let t = i.length - 1; t >= 0; --t) e.remove(i[t]);
      }
      i &&
        (k(this.featureChangeListenerKeys_[n]),
        delete this.featureChangeListenerKeys_[n]);
    }
    setMap(t) {
      const e = this.getMap(),
        i = this.featuresListenerKeys_,
        n = this.getFeatures_();
      e &&
        (i.forEach(k),
        (i.length = 0),
        this.rBush_.clear(),
        Object.values(this.featureChangeListenerKeys_).forEach(k),
        (this.featureChangeListenerKeys_ = {})),
        super.setMap(t),
        t &&
          (this.features_
            ? i.push(
                M(this.features_, q, this.handleFeatureAdd_, this),
                M(this.features_, V, this.handleFeatureRemove_, this)
              )
            : this.source_ &&
              i.push(
                M(this.source_, Lu, this.handleFeatureAdd_, this),
                M(this.source_, ku, this.handleFeatureRemove_, this)
              ),
          n.forEach((t) => this.addFeature(t)));
    }
    snapTo(t, e, i) {
      const n = i.getView().getProjection(),
        r = _n(e, n),
        s = yn(
          $t(Qt([r]), i.getView().getResolution() * this.pixelTolerance_),
          n
        ),
        o = this.rBush_.getInExtent(s),
        a = o.length;
      if (0 === a) return null;
      let l,
        h,
        c = 1 / 0;
      const u = this.pixelTolerance_ * this.pixelTolerance_,
        d = () => {
          if (l) {
            const e = i.getPixelFromCoordinate(l);
            if (Mi(t, e) <= u)
              return {
                vertex: l,
                vertexPixel: [Math.round(e[0]), Math.round(e[1])],
                feature: h,
              };
          }
          return null;
        };
      if (this.vertex_) {
        for (let t = 0; t < a; ++t) {
          const e = o[t];
          "Circle" !== e.feature.getGeometry().getType() &&
            e.segment.forEach((t) => {
              const i = _n(t, n),
                s = Mi(r, i);
              s < c && ((l = t), (c = s), (h = e.feature));
            });
        }
        const t = d();
        if (t) return t;
      }
      if (this.edge_) {
        for (let t = 0; t < a; ++t) {
          let e = null;
          const i = o[t];
          if ("Circle" === i.feature.getGeometry().getType()) {
            let t = i.feature.getGeometry();
            const s = pn();
            s && (t = t.clone().transform(s, n)), (e = Ri(r, t));
          } else {
            const [t, s] = i.segment;
            s && ((Nv[0] = _n(t, n)), (Nv[1] = _n(s, n)), (e = Ti(r, Nv)));
          }
          if (e) {
            const t = Mi(r, e);
            t < c && ((l = mn(e, n)), (c = t));
          }
        }
        const t = d();
        if (t) return t;
      }
      return null;
    }
    updateFeature_(t) {
      this.removeFeature(t, !1), this.addFeature(t, !1);
    }
    segmentCircleGeometry_(t, e) {
      const i = this.getMap().getView().getProjection();
      let n = e;
      const r = pn();
      r && (n = n.clone().transform(r, i));
      const s = Fr(n);
      r && s.transform(i, r);
      const o = s.getCoordinates()[0];
      for (let e = 0, i = o.length - 1; e < i; ++e) t.push(o.slice(e, e + 2));
    }
    segmentGeometryCollectionGeometry_(t, e) {
      const i = e.getGeometriesArray();
      for (let e = 0; e < i.length; ++e) {
        const n = this.GEOMETRY_SEGMENTERS_[i[e].getType()];
        n && n(t, i[e]);
      }
    }
    segmentLineStringGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let e = 0, n = i.length - 1; e < n; ++e) t.push(i.slice(e, e + 2));
    }
    segmentMultiLineStringGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let e = 0, n = i.length; e < n; ++e) {
        const n = i[e];
        for (let e = 0, i = n.length - 1; e < i; ++e) t.push(n.slice(e, e + 2));
      }
    }
    segmentMultiPointGeometry_(t, e) {
      e.getCoordinates().forEach((e) => {
        t.push([e]);
      });
    }
    segmentMultiPolygonGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let e = 0, n = i.length; e < n; ++e) {
        const n = i[e];
        for (let e = 0, i = n.length; e < i; ++e) {
          const i = n[e];
          for (let e = 0, n = i.length - 1; e < n; ++e)
            t.push(i.slice(e, e + 2));
        }
      }
    }
    segmentPointGeometry_(t, e) {
      t.push([e.getCoordinates()]);
    }
    segmentPolygonGeometry_(t, e) {
      const i = e.getCoordinates();
      for (let e = 0, n = i.length; e < n; ++e) {
        const n = i[e];
        for (let e = 0, i = n.length - 1; e < i; ++e) t.push(n.slice(e, e + 2));
      }
    }
  };
  const Gv = "translatestart",
    Bv = "translating",
    jv = "translateend";
  class zv extends e {
    constructor(t, e, i, n, r) {
      super(t),
        (this.features = e),
        (this.coordinate = i),
        (this.startCoordinate = n),
        (this.mapBrowserEvent = r);
    }
  }
  var Uv = class extends Sa {
    constructor(t) {
      let e;
      if (
        (super((t = t || {})),
        this.on,
        this.once,
        this.un,
        (this.lastCoordinate_ = null),
        (this.startCoordinate_ = null),
        (this.features_ = void 0 !== t.features ? t.features : null),
        t.layers && !this.features_)
      )
        if ("function" == typeof t.layers) e = t.layers;
        else {
          const i = t.layers;
          e = function (t) {
            return i.includes(t);
          };
        }
      else e = d;
      (this.layerFilter_ = e),
        (this.filter_ = t.filter && !this.features_ ? t.filter : d),
        (this.hitTolerance_ = t.hitTolerance ? t.hitTolerance : 0),
        (this.condition_ = t.condition ? t.condition : Ta),
        (this.lastFeature_ = null),
        this.addChangeListener(pa, this.handleActiveChanged_);
    }
    handleDownEvent(t) {
      if (!t.originalEvent || !this.condition_(t)) return !1;
      if (
        ((this.lastFeature_ = this.featuresAtPixel_(t.pixel, t.map)),
        !this.lastCoordinate_ && this.lastFeature_)
      ) {
        (this.startCoordinate_ = t.coordinate),
          (this.lastCoordinate_ = t.coordinate),
          this.handleMoveEvent(t);
        const e = this.features_ || new K([this.lastFeature_]);
        return (
          this.dispatchEvent(
            new zv(Gv, e, t.coordinate, this.startCoordinate_, t)
          ),
          !0
        );
      }
      return !1;
    }
    handleUpEvent(t) {
      if (this.lastCoordinate_) {
        (this.lastCoordinate_ = null), this.handleMoveEvent(t);
        const e = this.features_ || new K([this.lastFeature_]);
        return (
          this.dispatchEvent(
            new zv(jv, e, t.coordinate, this.startCoordinate_, t)
          ),
          (this.startCoordinate_ = null),
          !0
        );
      }
      return !1;
    }
    handleDragEvent(t) {
      if (this.lastCoordinate_) {
        const e = t.coordinate,
          i = t.map.getView().getProjection(),
          n = _n(e, i),
          r = _n(this.lastCoordinate_, i),
          s = n[0] - r[0],
          o = n[1] - r[1],
          a = this.features_ || new K([this.lastFeature_]),
          l = pn();
        a.forEach(function (t) {
          const e = t.getGeometry();
          l
            ? (e.transform(l, i), e.translate(s, o), e.transform(i, l))
            : e.translate(s, o),
            t.setGeometry(e);
        }),
          (this.lastCoordinate_ = e),
          this.dispatchEvent(new zv(Bv, a, e, this.startCoordinate_, t));
      }
    }
    handleMoveEvent(t) {
      const e = t.map.getViewport();
      this.featuresAtPixel_(t.pixel, t.map)
        ? (e.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing"),
          e.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab"))
        : e.classList.remove("ol-grab", "ol-grabbing");
    }
    featuresAtPixel_(t, e) {
      return e.forEachFeatureAtPixel(
        t,
        (t, e) => {
          if (
            t instanceof Mt &&
            this.filter_(t, e) &&
            (!this.features_ || this.features_.getArray().includes(t))
          )
            return t;
        },
        { layerFilter: this.layerFilter_, hitTolerance: this.hitTolerance_ }
      );
    }
    getHitTolerance() {
      return this.hitTolerance_;
    }
    setHitTolerance(t) {
      this.hitTolerance_ = t;
    }
    setMap(t) {
      const e = this.getMap();
      super.setMap(t), this.updateState_(e);
    }
    handleActiveChanged_() {
      this.updateState_(null);
    }
    updateState_(t) {
      let e = this.getMap();
      const i = this.getActive();
      if ((!e || !i) && ((e = e || t), e)) {
        e.getViewport().classList.remove("ol-grab", "ol-grabbing");
      }
    }
  };
  function qv(t, e, i, n, r, s) {
    void 0 !== r ? (s = void 0 !== s ? s : 0) : ((r = []), (s = 0));
    let o = e;
    for (; o < i; ) {
      const e = t[o++];
      (r[s++] = t[o++]), (r[s++] = e);
      for (let e = 2; e < n; ++e) r[s++] = t[o++];
    }
    return (r.length = s), r;
  }
  var Vv = class {
    constructor() {
      (this.dataProjection = void 0),
        (this.defaultFeatureProjection = void 0),
        (this.supportedMediaTypes = null);
    }
    getReadOptions(t, e) {
      if (e) {
        let i = e.dataProjection
          ? tn(e.dataProjection)
          : this.readProjection(t);
        e.extent &&
          i &&
          "tile-pixels" === i.getUnits() &&
          ((i = tn(i)), i.setWorldExtent(e.extent)),
          (e = { dataProjection: i, featureProjection: e.featureProjection });
      }
      return this.adaptOptions(e);
    }
    adaptOptions(t) {
      return Object.assign(
        {
          dataProjection: this.dataProjection,
          featureProjection: this.defaultFeatureProjection,
        },
        t
      );
    }
    getType() {
      return G();
    }
    readFeature(t, e) {
      return G();
    }
    readFeatures(t, e) {
      return G();
    }
    readGeometry(t, e) {
      return G();
    }
    readProjection(t) {
      return G();
    }
    writeFeature(t, e) {
      return G();
    }
    writeFeatures(t, e) {
      return G();
    }
    writeGeometry(t, e) {
      return G();
    }
  };
  function Xv(t, e, i) {
    const n = i ? tn(i.featureProjection) : null,
      r = i ? tn(i.dataProjection) : null;
    let s;
    if (
      ((s =
        n && r && !ln(n, r)
          ? (e ? t.clone() : t).transform(e ? n : r, e ? r : n)
          : t),
      e && i && void 0 !== i.decimals)
    ) {
      const e = Math.pow(10, i.decimals),
        n = function (t) {
          for (let i = 0, n = t.length; i < n; ++i)
            t[i] = Math.round(t[i] * e) / e;
          return t;
        };
      s === t && (s = t.clone()), s.applyTransform(n);
    }
    return s;
  }
  function Zv(t, e) {
    const i = e ? tn(e.featureProjection) : null,
      n = e ? tn(e.dataProjection) : null;
    return i && n && !ln(i, n) ? dn(t, n, i) : t;
  }
  function Kv(t) {
    if ("string" == typeof t) {
      const e = JSON.parse(t);
      return e || null;
    }
    return null !== t ? t : null;
  }
  var Hv = class extends Vv {
    constructor() {
      super();
    }
    getType() {
      return "json";
    }
    readFeature(t, e) {
      return this.readFeatureFromObject(Kv(t), this.getReadOptions(t, e));
    }
    readFeatures(t, e) {
      return this.readFeaturesFromObject(Kv(t), this.getReadOptions(t, e));
    }
    readFeatureFromObject(t, e) {
      return G();
    }
    readFeaturesFromObject(t, e) {
      return G();
    }
    readGeometry(t, e) {
      return this.readGeometryFromObject(Kv(t), this.getReadOptions(t, e));
    }
    readGeometryFromObject(t, e) {
      return G();
    }
    readProjection(t) {
      return this.readProjectionFromObject(Kv(t));
    }
    readProjectionFromObject(t) {
      return G();
    }
    writeFeature(t, e) {
      return JSON.stringify(this.writeFeatureObject(t, e));
    }
    writeFeatureObject(t, e) {
      return G();
    }
    writeFeatures(t, e) {
      return JSON.stringify(this.writeFeaturesObject(t, e));
    }
    writeFeaturesObject(t, e) {
      return G();
    }
    writeGeometry(t, e) {
      return JSON.stringify(this.writeGeometryObject(t, e));
    }
    writeGeometryObject(t, e) {
      return G();
    }
  };
  const Yv = {
      Point: function (t) {
        let e;
        e =
          void 0 !== t.m && void 0 !== t.z
            ? new or([t.x, t.y, t.z, t.m], "XYZM")
            : void 0 !== t.z
            ? new or([t.x, t.y, t.z], "XYZ")
            : void 0 !== t.m
            ? new or([t.x, t.y, t.m], "XYM")
            : new or([t.x, t.y]);
        return e;
      },
      LineString: function (t) {
        const e = Jv(t);
        return new Bl(t.paths[0], e);
      },
      Polygon: function (t) {
        const e = Jv(t);
        return new Tr(t.rings, e);
      },
      MultiPoint: function (t) {
        const e = Jv(t);
        return new Ix(t.points, e);
      },
      MultiLineString: function (t) {
        const e = Jv(t);
        return new bx(t.paths, e);
      },
      MultiPolygon: function (t) {
        const e = Jv(t);
        return new Ox(t.rings, e);
      },
    },
    Qv = {
      Point: function (t, e) {
        const i = t.getCoordinates();
        let n;
        const r = t.getLayout();
        if ("XYZ" === r) n = { x: i[0], y: i[1], z: i[2] };
        else if ("XYM" === r) n = { x: i[0], y: i[1], m: i[2] };
        else if ("XYZM" === r) n = { x: i[0], y: i[1], z: i[2], m: i[3] };
        else {
          if ("XY" !== r) throw new Error("Invalid geometry layout");
          n = { x: i[0], y: i[1] };
        }
        return n;
      },
      LineString: function (t, e) {
        const i = tS(t);
        return { hasZ: i.hasZ, hasM: i.hasM, paths: [t.getCoordinates()] };
      },
      Polygon: function (t, e) {
        const i = tS(t);
        return { hasZ: i.hasZ, hasM: i.hasM, rings: t.getCoordinates(!1) };
      },
      MultiPoint: function (t, e) {
        const i = tS(t);
        return { hasZ: i.hasZ, hasM: i.hasM, points: t.getCoordinates() };
      },
      MultiLineString: function (t, e) {
        const i = tS(t);
        return { hasZ: i.hasZ, hasM: i.hasM, paths: t.getCoordinates() };
      },
      MultiPolygon: function (t, e) {
        const i = tS(t),
          n = t.getCoordinates(!1),
          r = [];
        for (let t = 0; t < n.length; t++)
          for (let e = n[t].length - 1; e >= 0; e--) r.push(n[t][e]);
        return { hasZ: i.hasZ, hasM: i.hasM, rings: r };
      },
    };
  function $v(t, e) {
    if (!t) return null;
    let i;
    if ("number" == typeof t.x && "number" == typeof t.y) i = "Point";
    else if (t.points) i = "MultiPoint";
    else if (t.paths) {
      i = 1 === t.paths.length ? "LineString" : "MultiLineString";
    } else if (t.rings) {
      const e = t,
        n = Jv(e),
        r = (function (t, e) {
          const i = [],
            n = [],
            r = [];
          let s, o;
          for (s = 0, o = t.length; s < o; ++s) {
            (i.length = 0), jn(i, 0, t[s], e.length);
            vr(i, 0, i.length, e.length) ? n.push([t[s]]) : r.push(t[s]);
          }
          for (; r.length; ) {
            const t = r.shift();
            let e = !1;
            for (s = n.length - 1; s >= 0; s--) {
              const i = n[s][0];
              if (ie(new rr(i).getExtent(), new rr(t).getExtent())) {
                n[s].push(t), (e = !0);
                break;
              }
            }
            e || n.push([t.reverse()]);
          }
          return n;
        })(e.rings, n);
      1 === r.length
        ? ((i = "Polygon"), (t = Object.assign({}, t, { rings: r[0] })))
        : ((i = "MultiPolygon"), (t = Object.assign({}, t, { rings: r })));
    }
    return Xv((0, Yv[i])(t), !1, e);
  }
  function Jv(t) {
    let e = "XY";
    return (
      !0 === t.hasZ && !0 === t.hasM
        ? (e = "XYZM")
        : !0 === t.hasZ
        ? (e = "XYZ")
        : !0 === t.hasM && (e = "XYM"),
      e
    );
  }
  function tS(t) {
    const e = t.getLayout();
    return {
      hasZ: "XYZ" === e || "XYZM" === e,
      hasM: "XYM" === e || "XYZM" === e,
    };
  }
  function eS(t, e) {
    return (0, Qv[t.getType()])(Xv(t, !0, e), e);
  }
  var iS = class extends Hv {
    constructor(t) {
      (t = t || {}), super(), (this.geometryName_ = t.geometryName);
    }
    readFeatureFromObject(t, e, i) {
      const n = t,
        r = $v(n.geometry, e),
        s = new Mt();
      if (
        (this.geometryName_ && s.setGeometryName(this.geometryName_),
        s.setGeometry(r),
        n.attributes)
      ) {
        s.setProperties(n.attributes, !0);
        const t = n.attributes[i];
        void 0 !== t && s.setId(t);
      }
      return s;
    }
    readFeaturesFromObject(t, e) {
      if (((e = e || {}), t.features)) {
        const i = [],
          n = t.features;
        for (let r = 0, s = n.length; r < s; ++r)
          i.push(this.readFeatureFromObject(n[r], e, t.objectIdFieldName));
        return i;
      }
      return [this.readFeatureFromObject(t, e)];
    }
    readGeometryFromObject(t, e) {
      return $v(t, e);
    }
    readProjectionFromObject(t) {
      if (t.spatialReference && void 0 !== t.spatialReference.wkid) {
        return tn("EPSG:" + t.spatialReference.wkid);
      }
      return null;
    }
    writeGeometryObject(t, e) {
      return eS(t, this.adaptOptions(e));
    }
    writeFeatureObject(t, e) {
      e = this.adaptOptions(e);
      const i = {};
      if (!t.hasProperties()) return (i.attributes = {}), i;
      const n = t.getProperties(),
        r = t.getGeometry();
      if (r) {
        i.geometry = eS(r, e);
        const s = e && (e.dataProjection || e.featureProjection);
        s &&
          (i.geometry.spatialReference = {
            wkid: Number(tn(s).getCode().split(":").pop()),
          }),
          delete n[t.getGeometryName()];
      }
      return y(n) ? (i.attributes = {}) : (i.attributes = n), i;
    }
    writeFeaturesObject(t, e) {
      e = this.adaptOptions(e);
      const i = [];
      for (let n = 0, r = t.length; n < r; ++n)
        i.push(this.writeFeatureObject(t[n], e));
      return { features: i };
    }
  };
  var nS = class extends Vv {
    constructor() {
      super(), (this.xmlSerializer_ = Jy());
    }
    getType() {
      return "xml";
    }
    readFeature(t, e) {
      if (!t) return null;
      if ("string" == typeof t) {
        const i = ky(t);
        return this.readFeatureFromDocument(i, e);
      }
      return My(t)
        ? this.readFeatureFromDocument(t, e)
        : this.readFeatureFromNode(t, e);
    }
    readFeatureFromDocument(t, e) {
      const i = this.readFeaturesFromDocument(t, e);
      return i.length > 0 ? i[0] : null;
    }
    readFeatureFromNode(t, e) {
      return null;
    }
    readFeatures(t, e) {
      if (!t) return [];
      if ("string" == typeof t) {
        const i = ky(t);
        return this.readFeaturesFromDocument(i, e);
      }
      return My(t)
        ? this.readFeaturesFromDocument(t, e)
        : this.readFeaturesFromNode(t, e);
    }
    readFeaturesFromDocument(t, e) {
      const i = [];
      for (let n = t.firstChild; n; n = n.nextSibling)
        n.nodeType == Node.ELEMENT_NODE &&
          h(i, this.readFeaturesFromNode(n, e));
      return i;
    }
    readFeaturesFromNode(t, e) {
      return G();
    }
    readGeometry(t, e) {
      if (!t) return null;
      if ("string" == typeof t) {
        const i = ky(t);
        return this.readGeometryFromDocument(i, e);
      }
      return My(t)
        ? this.readGeometryFromDocument(t, e)
        : this.readGeometryFromNode(t, e);
    }
    readGeometryFromDocument(t, e) {
      return null;
    }
    readGeometryFromNode(t, e) {
      return null;
    }
    readProjection(t) {
      if (!t) return null;
      if ("string" == typeof t) {
        const e = ky(t);
        return this.readProjectionFromDocument(e);
      }
      return My(t)
        ? this.readProjectionFromDocument(t)
        : this.readProjectionFromNode(t);
    }
    readProjectionFromDocument(t) {
      return this.dataProjection;
    }
    readProjectionFromNode(t) {
      return this.dataProjection;
    }
    writeFeature(t, e) {
      const i = this.writeFeatureNode(t, e);
      return this.xmlSerializer_.serializeToString(i);
    }
    writeFeatureNode(t, e) {
      return null;
    }
    writeFeatures(t, e) {
      const i = this.writeFeaturesNode(t, e);
      return this.xmlSerializer_.serializeToString(i);
    }
    writeFeaturesNode(t, e) {
      return null;
    }
    writeGeometry(t, e) {
      const i = this.writeGeometryNode(t, e);
      return this.xmlSerializer_.serializeToString(i);
    }
    writeGeometryNode(t, e) {
      return null;
    }
  };
  const rS = "http://www.opengis.net/gml",
    sS = /^\s*$/;
  class oS extends nS {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.featureType = t.featureType),
        (this.featureNS = t.featureNS),
        (this.srsName = t.srsName),
        (this.schemaLocation = ""),
        (this.FEATURE_COLLECTION_PARSERS = {}),
        (this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
          featureMember: Ny(this.readFeaturesInternal),
          featureMembers: Dy(this.readFeaturesInternal),
        }),
        (this.supportedMediaTypes = ["application/gml+xml"]);
    }
    readFeaturesInternal(t, e) {
      const i = t.localName;
      let n = null;
      if ("FeatureCollection" == i)
        n = Ky([], this.FEATURE_COLLECTION_PARSERS, t, e, this);
      else if ("featureMembers" == i || "featureMember" == i || "member" == i) {
        const r = e[0];
        let s = r.featureType,
          o = r.featureNS;
        const a = "p",
          l = "p0";
        if (!s && t.childNodes) {
          (s = []), (o = {});
          for (let e = 0, i = t.childNodes.length; e < i; ++e) {
            const i = t.childNodes[e];
            if (1 === i.nodeType) {
              const t = i.nodeName.split(":").pop();
              if (!s.includes(t)) {
                let e = "",
                  n = 0;
                const r = i.namespaceURI;
                for (const t in o) {
                  if (o[t] === r) {
                    e = t;
                    break;
                  }
                  ++n;
                }
                e || ((e = a + n), (o[e] = r)), s.push(e + ":" + t);
              }
            }
          }
          "featureMember" != i && ((r.featureType = s), (r.featureNS = o));
        }
        if ("string" == typeof o) {
          const t = o;
          (o = {}), (o[l] = t);
        }
        const h = {},
          c = Array.isArray(s) ? s : [s];
        for (const t in o) {
          const e = {};
          for (let n = 0, r = c.length; n < r; ++n) {
            (c[n].includes(":") ? c[n].split(":")[0] : l) === t &&
              (e[c[n].split(":").pop()] =
                "featureMembers" == i
                  ? Ny(this.readFeatureElement, this)
                  : Dy(this.readFeatureElement, this));
          }
          h[o[t]] = e;
        }
        n = Ky("featureMember" == i || "member" == i ? void 0 : [], h, t, e);
      }
      return null === n && (n = []), n;
    }
    readGeometryOrExtent(t, e) {
      const i = e[0];
      return (
        (i.srsName = t.firstElementChild.getAttribute("srsName")),
        (i.srsDimension = t.firstElementChild.getAttribute("srsDimension")),
        Ky(null, this.GEOMETRY_PARSERS, t, e, this)
      );
    }
    readExtentElement(t, e) {
      const i = e[0],
        n = this.readGeometryOrExtent(t, e);
      return n ? Zv(n, i) : void 0;
    }
    readGeometryElement(t, e) {
      const i = e[0],
        n = this.readGeometryOrExtent(t, e);
      return n ? Xv(n, !1, i) : void 0;
    }
    readFeatureElementInternal(t, e, i) {
      let n;
      const r = {};
      for (let s = t.firstElementChild; s; s = s.nextElementSibling) {
        let t;
        const o = s.localName;
        0 === s.childNodes.length ||
        (1 === s.childNodes.length &&
          (3 === s.firstChild.nodeType || 4 === s.firstChild.nodeType))
          ? ((t = Iy(s, !1)), sS.test(t) && (t = void 0))
          : (i &&
              (t =
                "boundedBy" === o
                  ? this.readExtentElement(s, e)
                  : this.readGeometryElement(s, e)),
            t
              ? "boundedBy" !== o && (n = o)
              : (t = this.readFeatureElementInternal(s, e, !1)));
        const a = s.attributes.length;
        if (a > 0 && !(t instanceof bn)) {
          t = { _content_: t };
          for (let e = 0; e < a; e++) {
            t[s.attributes[e].name] = s.attributes[e].value;
          }
        }
        r[o]
          ? (r[o] instanceof Array || (r[o] = [r[o]]), r[o].push(t))
          : (r[o] = t);
      }
      if (!i) return r;
      const s = new Mt(r);
      n && s.setGeometryName(n);
      const o = t.getAttribute("fid") || Oy(t, this.namespace, "id");
      return o && s.setId(o), s;
    }
    readFeatureElement(t, e) {
      return this.readFeatureElementInternal(t, e, !0);
    }
    readPoint(t, e) {
      const i = this.readFlatCoordinatesFromNode(t, e);
      if (i) return new or(i, "XYZ");
    }
    readMultiPoint(t, e) {
      const i = Ky([], this.MULTIPOINT_PARSERS, t, e, this);
      if (i) return new Ix(i);
    }
    readMultiLineString(t, e) {
      const i = Ky([], this.MULTILINESTRING_PARSERS, t, e, this);
      if (i) return new bx(i);
    }
    readMultiPolygon(t, e) {
      const i = Ky([], this.MULTIPOLYGON_PARSERS, t, e, this);
      if (i) return new Ox(i);
    }
    pointMemberParser(t, e) {
      Zy(this.POINTMEMBER_PARSERS, t, e, this);
    }
    lineStringMemberParser(t, e) {
      Zy(this.LINESTRINGMEMBER_PARSERS, t, e, this);
    }
    polygonMemberParser(t, e) {
      Zy(this.POLYGONMEMBER_PARSERS, t, e, this);
    }
    readLineString(t, e) {
      const i = this.readFlatCoordinatesFromNode(t, e);
      if (i) {
        return new Bl(i, "XYZ");
      }
    }
    readFlatLinearRing(t, e) {
      const i = Ky(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
      if (i) return i;
    }
    readLinearRing(t, e) {
      const i = this.readFlatCoordinatesFromNode(t, e);
      if (i) return new rr(i, "XYZ");
    }
    readPolygon(t, e) {
      const i = Ky([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this);
      if (i && i[0]) {
        const t = i[0],
          e = [t.length];
        let n, r;
        for (n = 1, r = i.length; n < r; ++n) h(t, i[n]), e.push(t.length);
        return new Tr(t, "XYZ", e);
      }
    }
    readFlatCoordinatesFromNode(t, e) {
      return Ky(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
    }
    readGeometryFromNode(t, e) {
      const i = this.readGeometryElement(t, [this.getReadOptions(t, e || {})]);
      return i || null;
    }
    readFeaturesFromNode(t, e) {
      const i = { featureType: this.featureType, featureNS: this.featureNS };
      i && Object.assign(i, this.getReadOptions(t, e));
      return this.readFeaturesInternal(t, [i]) || [];
    }
    readProjectionFromNode(t) {
      return tn(
        this.srsName
          ? this.srsName
          : t.firstElementChild.getAttribute("srsName")
      );
    }
  }
  (oS.prototype.namespace = rS),
    (oS.prototype.FLAT_LINEAR_RINGS_PARSERS = {
      "http://www.opengis.net/gml": {},
    }),
    (oS.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
      "http://www.opengis.net/gml": {},
    }),
    (oS.prototype.GEOMETRY_PARSERS = { "http://www.opengis.net/gml": {} }),
    (oS.prototype.MULTIPOINT_PARSERS = {
      "http://www.opengis.net/gml": {
        pointMember: Ny(oS.prototype.pointMemberParser),
        pointMembers: Ny(oS.prototype.pointMemberParser),
      },
    }),
    (oS.prototype.MULTILINESTRING_PARSERS = {
      "http://www.opengis.net/gml": {
        lineStringMember: Ny(oS.prototype.lineStringMemberParser),
        lineStringMembers: Ny(oS.prototype.lineStringMemberParser),
      },
    }),
    (oS.prototype.MULTIPOLYGON_PARSERS = {
      "http://www.opengis.net/gml": {
        polygonMember: Ny(oS.prototype.polygonMemberParser),
        polygonMembers: Ny(oS.prototype.polygonMemberParser),
      },
    }),
    (oS.prototype.POINTMEMBER_PARSERS = {
      "http://www.opengis.net/gml": {
        Point: Ny(oS.prototype.readFlatCoordinatesFromNode),
      },
    }),
    (oS.prototype.LINESTRINGMEMBER_PARSERS = {
      "http://www.opengis.net/gml": {
        LineString: Ny(oS.prototype.readLineString),
      },
    }),
    (oS.prototype.POLYGONMEMBER_PARSERS = {
      "http://www.opengis.net/gml": { Polygon: Ny(oS.prototype.readPolygon) },
    }),
    (oS.prototype.RING_PARSERS = {
      "http://www.opengis.net/gml": {
        LinearRing: Dy(oS.prototype.readFlatLinearRing),
      },
    });
  var aS = oS;
  function lS(t) {
    return hS(Iy(t, !1));
  }
  function hS(t) {
    const e = /^\s*(true|1)|(false|0)\s*$/.exec(t);
    if (e) return void 0 !== e[1] || !1;
  }
  function cS(t) {
    const e = Iy(t, !1),
      i = Date.parse(e);
    return isNaN(i) ? void 0 : i / 1e3;
  }
  function uS(t) {
    return dS(Iy(t, !1));
  }
  function dS(t) {
    const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t);
    if (e) return parseFloat(e[1]);
  }
  function gS(t) {
    return fS(Iy(t, !1));
  }
  function fS(t) {
    const e = /^\s*(\d+)\s*$/.exec(t);
    if (e) return parseInt(e[1], 10);
  }
  function pS(t) {
    return Iy(t, !1).trim();
  }
  function mS(t, e) {
    SS(t, e ? "1" : "0");
  }
  function _S(t, e) {
    t.appendChild(tx().createCDATASection(e));
  }
  function yS(t, e) {
    const i = new Date(1e3 * e),
      n =
        i.getUTCFullYear() +
        "-" +
        wi(i.getUTCMonth() + 1, 2) +
        "-" +
        wi(i.getUTCDate(), 2) +
        "T" +
        wi(i.getUTCHours(), 2) +
        ":" +
        wi(i.getUTCMinutes(), 2) +
        ":" +
        wi(i.getUTCSeconds(), 2) +
        "Z";
    t.appendChild(tx().createTextNode(n));
  }
  function xS(t, e) {
    const i = e.toPrecision();
    t.appendChild(tx().createTextNode(i));
  }
  function vS(t, e) {
    const i = e.toString();
    t.appendChild(tx().createTextNode(i));
  }
  function SS(t, e) {
    t.appendChild(tx().createTextNode(e));
  }
  const CS = rS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd",
    wS = {
      MultiLineString: "lineStringMember",
      MultiCurve: "curveMember",
      MultiPolygon: "polygonMember",
      MultiSurface: "surfaceMember",
    };
  class WS extends aS {
    constructor(t) {
      super((t = t || {})),
        (this.FEATURE_COLLECTION_PARSERS[rS].featureMember = Ny(
          this.readFeaturesInternal
        )),
        (this.schemaLocation = t.schemaLocation ? t.schemaLocation : CS);
    }
    readFlatCoordinates(t, e) {
      const i = Iy(t, !1).replace(/^\s*|\s*$/g, ""),
        n = e[0].srsName;
      let r = "enu";
      if (n) {
        const t = tn(n);
        t && (r = t.getAxisOrientation());
      }
      const s = i.trim().split(/\s+/),
        o = [];
      for (let t = 0, e = s.length; t < e; t++) {
        const e = s[t].split(/,+/),
          i = parseFloat(e[0]),
          n = parseFloat(e[1]),
          a = 3 === e.length ? parseFloat(e[2]) : 0;
        "en" === r.substr(0, 2) ? o.push(i, n, a) : o.push(n, i, a);
      }
      return o;
    }
    readBox(t, e) {
      const i = Ky([null], this.BOX_PARSERS_, t, e, this);
      return oe(i[1][0], i[1][1], i[1][3], i[1][4]);
    }
    innerBoundaryIsParser(t, e) {
      const i = Ky(void 0, this.RING_PARSERS, t, e, this);
      if (i) {
        e[e.length - 1].push(i);
      }
    }
    outerBoundaryIsParser(t, e) {
      const i = Ky(void 0, this.RING_PARSERS, t, e, this);
      if (i) {
        e[e.length - 1][0] = i;
      }
    }
    GEOMETRY_NODE_FACTORY_(t, e, i) {
      const n = e[e.length - 1],
        r = n.multiSurface,
        s = n.surface,
        o = n.multiCurve;
      return (
        Array.isArray(t)
          ? (i = "Envelope")
          : "MultiPolygon" === (i = t.getType()) && !0 === r
          ? (i = "MultiSurface")
          : "Polygon" === i && !0 === s
          ? (i = "Surface")
          : "MultiLineString" === i && !0 === o && (i = "MultiCurve"),
        Fy("http://www.opengis.net/gml", i)
      );
    }
    writeFeatureElement(t, e, i) {
      const n = e.getId();
      n && t.setAttribute("fid", n);
      const r = i[i.length - 1],
        s = r.featureNS,
        o = e.getGeometryName();
      r.serializers || ((r.serializers = {}), (r.serializers[s] = {}));
      const a = [],
        l = [];
      if (e.hasProperties()) {
        const t = e.getProperties();
        for (const e in t) {
          const i = t[e];
          null !== i &&
            (a.push(e),
            l.push(i),
            e == o || "function" == typeof i.getSimplifiedGeometry
              ? e in r.serializers[s] ||
                (r.serializers[s][e] = jy(this.writeGeometryElement, this))
              : e in r.serializers[s] || (r.serializers[s][e] = jy(SS)));
        }
      }
      const h = Object.assign({}, r);
      (h.node = t), Yy(h, r.serializers, Uy(void 0, s), l, i, a);
    }
    writeCurveOrLineString(t, e, i) {
      const n = i[i.length - 1].srsName;
      if (
        ("LineStringSegment" !== t.nodeName &&
          n &&
          t.setAttribute("srsName", n),
        "LineString" === t.nodeName || "LineStringSegment" === t.nodeName)
      ) {
        const n = this.createCoordinatesNode_(t.namespaceURI);
        t.appendChild(n), this.writeCoordinates_(n, e, i);
      } else if ("Curve" === t.nodeName) {
        const n = Fy(t.namespaceURI, "segments");
        t.appendChild(n), this.writeCurveSegments_(n, e, i);
      }
    }
    writeLineStringOrCurveMember(t, e, i) {
      const n = this.GEOMETRY_NODE_FACTORY_(e, i);
      n && (t.appendChild(n), this.writeCurveOrLineString(n, e, i));
    }
    writeMultiCurveOrLineString(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName,
        o = n.curve;
      s && t.setAttribute("srsName", s);
      const a = e.getLineStrings();
      Yy(
        { node: t, hasZ: r, srsName: s, curve: o },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        a,
        i,
        void 0,
        this
      );
    }
    writeGeometryElement(t, e, i) {
      const n = i[i.length - 1],
        r = Object.assign({}, n);
      let s;
      (r.node = t),
        (s = Array.isArray(e) ? Zv(e, n) : Xv(e, !0, n)),
        Yy(
          r,
          this.GEOMETRY_SERIALIZERS,
          this.GEOMETRY_NODE_FACTORY_,
          [s],
          i,
          void 0,
          this
        );
    }
    createCoordinatesNode_(t) {
      const e = Fy(t, "coordinates");
      return (
        e.setAttribute("decimal", "."),
        e.setAttribute("cs", ","),
        e.setAttribute("ts", " "),
        e
      );
    }
    writeCoordinates_(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName,
        o = e.getCoordinates(),
        a = o.length,
        l = new Array(a);
      for (let t = 0; t < a; ++t) {
        const e = o[t];
        l[t] = this.getCoords_(e, s, r);
      }
      SS(t, l.join(" "));
    }
    writeCurveSegments_(t, e, i) {
      const n = Fy(t.namespaceURI, "LineStringSegment");
      t.appendChild(n), this.writeCurveOrLineString(n, e, i);
    }
    writeSurfaceOrPolygon(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName;
      if (
        ("PolygonPatch" !== t.nodeName && s && t.setAttribute("srsName", s),
        "Polygon" === t.nodeName || "PolygonPatch" === t.nodeName)
      ) {
        const n = e.getLinearRings();
        Yy(
          { node: t, hasZ: r, srsName: s },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          n,
          i,
          void 0,
          this
        );
      } else if ("Surface" === t.nodeName) {
        const n = Fy(t.namespaceURI, "patches");
        t.appendChild(n), this.writeSurfacePatches_(n, e, i);
      }
    }
    RING_NODE_FACTORY_(t, e, i) {
      const n = e[e.length - 1],
        r = n.node,
        s = n.exteriorWritten;
      return (
        void 0 === s && (n.exteriorWritten = !0),
        Fy(r.namespaceURI, void 0 !== s ? "innerBoundaryIs" : "outerBoundaryIs")
      );
    }
    writeSurfacePatches_(t, e, i) {
      const n = Fy(t.namespaceURI, "PolygonPatch");
      t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i);
    }
    writeRing(t, e, i) {
      const n = Fy(t.namespaceURI, "LinearRing");
      t.appendChild(n), this.writeLinearRing(n, e, i);
    }
    getCoords_(t, e, i) {
      let n = "enu";
      e && (n = tn(e).getAxisOrientation());
      let r = "en" === n.substr(0, 2) ? t[0] + "," + t[1] : t[1] + "," + t[0];
      if (i) {
        r += "," + (t[2] || 0);
      }
      return r;
    }
    writePoint(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName;
      s && t.setAttribute("srsName", s);
      const o = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(o);
      const a = e.getCoordinates();
      SS(o, this.getCoords_(a, s, r));
    }
    writeMultiPoint(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName;
      s && t.setAttribute("srsName", s);
      const o = e.getPoints();
      Yy(
        { node: t, hasZ: r, srsName: s },
        this.POINTMEMBER_SERIALIZERS,
        Uy("pointMember"),
        o,
        i,
        void 0,
        this
      );
    }
    writePointMember(t, e, i) {
      const n = Fy(t.namespaceURI, "Point");
      t.appendChild(n), this.writePoint(n, e, i);
    }
    writeLinearRing(t, e, i) {
      const n = i[i.length - 1].srsName;
      n && t.setAttribute("srsName", n);
      const r = this.createCoordinatesNode_(t.namespaceURI);
      t.appendChild(r), this.writeCoordinates_(r, e, i);
    }
    writeMultiSurfaceOrPolygon(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName,
        o = n.surface;
      s && t.setAttribute("srsName", s);
      const a = e.getPolygons();
      Yy(
        { node: t, hasZ: r, srsName: s, surface: o },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        a,
        i,
        void 0,
        this
      );
    }
    writeSurfaceOrPolygonMember(t, e, i) {
      const n = this.GEOMETRY_NODE_FACTORY_(e, i);
      n && (t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i));
    }
    writeEnvelope(t, e, i) {
      const n = i[i.length - 1].srsName;
      n && t.setAttribute("srsName", n);
      const r = [e[0] + " " + e[1], e[2] + " " + e[3]];
      Yy(
        { node: t },
        this.ENVELOPE_SERIALIZERS,
        qy,
        r,
        i,
        ["lowerCorner", "upperCorner"],
        this
      );
    }
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) {
      const n = e[e.length - 1].node;
      return Fy("http://www.opengis.net/gml", wS[n.nodeName]);
    }
  }
  (WS.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      coordinates: Dy(WS.prototype.readFlatCoordinates),
    },
  }),
    (WS.prototype.FLAT_LINEAR_RINGS_PARSERS = {
      "http://www.opengis.net/gml": {
        innerBoundaryIs: WS.prototype.innerBoundaryIsParser,
        outerBoundaryIs: WS.prototype.outerBoundaryIsParser,
      },
    }),
    (WS.prototype.BOX_PARSERS_ = {
      "http://www.opengis.net/gml": {
        coordinates: Ny(WS.prototype.readFlatCoordinates),
      },
    }),
    (WS.prototype.GEOMETRY_PARSERS = {
      "http://www.opengis.net/gml": {
        Point: Dy(aS.prototype.readPoint),
        MultiPoint: Dy(aS.prototype.readMultiPoint),
        LineString: Dy(aS.prototype.readLineString),
        MultiLineString: Dy(aS.prototype.readMultiLineString),
        LinearRing: Dy(aS.prototype.readLinearRing),
        Polygon: Dy(aS.prototype.readPolygon),
        MultiPolygon: Dy(aS.prototype.readMultiPolygon),
        Box: Dy(WS.prototype.readBox),
      },
    }),
    (WS.prototype.GEOMETRY_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        Curve: jy(WS.prototype.writeCurveOrLineString),
        MultiCurve: jy(WS.prototype.writeMultiCurveOrLineString),
        Point: jy(WS.prototype.writePoint),
        MultiPoint: jy(WS.prototype.writeMultiPoint),
        LineString: jy(WS.prototype.writeCurveOrLineString),
        MultiLineString: jy(WS.prototype.writeMultiCurveOrLineString),
        LinearRing: jy(WS.prototype.writeLinearRing),
        Polygon: jy(WS.prototype.writeSurfaceOrPolygon),
        MultiPolygon: jy(WS.prototype.writeMultiSurfaceOrPolygon),
        Surface: jy(WS.prototype.writeSurfaceOrPolygon),
        MultiSurface: jy(WS.prototype.writeMultiSurfaceOrPolygon),
        Envelope: jy(WS.prototype.writeEnvelope),
      },
    }),
    (WS.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        lineStringMember: jy(WS.prototype.writeLineStringOrCurveMember),
        curveMember: jy(WS.prototype.writeLineStringOrCurveMember),
      },
    }),
    (WS.prototype.RING_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        outerBoundaryIs: jy(WS.prototype.writeRing),
        innerBoundaryIs: jy(WS.prototype.writeRing),
      },
    }),
    (WS.prototype.POINTMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        pointMember: jy(WS.prototype.writePointMember),
      },
    }),
    (WS.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        surfaceMember: jy(WS.prototype.writeSurfaceOrPolygonMember),
        polygonMember: jy(WS.prototype.writeSurfaceOrPolygonMember),
      },
    }),
    (WS.prototype.ENVELOPE_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        lowerCorner: jy(SS),
        upperCorner: jy(SS),
      },
    });
  var ES = WS;
  const RS =
      rS +
      " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",
    TS = {
      MultiLineString: "lineStringMember",
      MultiCurve: "curveMember",
      MultiPolygon: "polygonMember",
      MultiSurface: "surfaceMember",
    };
  class PS extends aS {
    constructor(t) {
      super((t = t || {})),
        (this.surface_ = void 0 !== t.surface && t.surface),
        (this.curve_ = void 0 !== t.curve && t.curve),
        (this.multiCurve_ = void 0 === t.multiCurve || t.multiCurve),
        (this.multiSurface_ = void 0 === t.multiSurface || t.multiSurface),
        (this.schemaLocation = t.schemaLocation ? t.schemaLocation : RS),
        (this.hasZ = void 0 !== t.hasZ && t.hasZ);
    }
    readMultiCurve(t, e) {
      const i = Ky([], this.MULTICURVE_PARSERS, t, e, this);
      if (i) {
        return new bx(i);
      }
    }
    readFlatCurveRing(t, e) {
      const i = Ky([], this.MULTICURVE_PARSERS, t, e, this),
        n = [];
      for (let t = 0, e = i.length; t < e; ++t) h(n, i[t].getFlatCoordinates());
      return n;
    }
    readMultiSurface(t, e) {
      const i = Ky([], this.MULTISURFACE_PARSERS, t, e, this);
      if (i) return new Ox(i);
    }
    curveMemberParser(t, e) {
      Zy(this.CURVEMEMBER_PARSERS, t, e, this);
    }
    surfaceMemberParser(t, e) {
      Zy(this.SURFACEMEMBER_PARSERS, t, e, this);
    }
    readPatch(t, e) {
      return Ky([null], this.PATCHES_PARSERS, t, e, this);
    }
    readSegment(t, e) {
      return Ky([], this.SEGMENTS_PARSERS, t, e, this);
    }
    readPolygonPatch(t, e) {
      return Ky([null], this.FLAT_LINEAR_RINGS_PARSERS, t, e, this);
    }
    readLineStringSegment(t, e) {
      return Ky([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, t, e, this);
    }
    interiorParser(t, e) {
      const i = Ky(void 0, this.RING_PARSERS, t, e, this);
      if (i) {
        e[e.length - 1].push(i);
      }
    }
    exteriorParser(t, e) {
      const i = Ky(void 0, this.RING_PARSERS, t, e, this);
      if (i) {
        e[e.length - 1][0] = i;
      }
    }
    readSurface(t, e) {
      const i = Ky([null], this.SURFACE_PARSERS, t, e, this);
      if (i && i[0]) {
        const t = i[0],
          e = [t.length];
        let n, r;
        for (n = 1, r = i.length; n < r; ++n) h(t, i[n]), e.push(t.length);
        return new Tr(t, "XYZ", e);
      }
    }
    readCurve(t, e) {
      const i = Ky([null], this.CURVE_PARSERS, t, e, this);
      if (i) {
        return new Bl(i, "XYZ");
      }
    }
    readEnvelope(t, e) {
      const i = Ky([null], this.ENVELOPE_PARSERS, t, e, this);
      return oe(i[1][0], i[1][1], i[2][0], i[2][1]);
    }
    readFlatPos(t, e) {
      let i = Iy(t, !1);
      const n = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/,
        r = [];
      let s;
      for (; (s = n.exec(i)); )
        r.push(parseFloat(s[1])), (i = i.substr(s[0].length));
      if ("" !== i) return;
      const o = e[0].srsName;
      let a = "enu";
      if (o) {
        a = tn(o).getAxisOrientation();
      }
      if ("neu" === a) {
        let t, e;
        for (t = 0, e = r.length; t < e; t += 3) {
          const e = r[t],
            i = r[t + 1];
          (r[t] = i), (r[t + 1] = e);
        }
      }
      const l = r.length;
      return 2 == l && r.push(0), 0 !== l ? r : void 0;
    }
    readFlatPosList(t, e) {
      const i = Iy(t, !1).replace(/^\s*|\s*$/g, ""),
        n = e[0],
        r = n.srsName,
        s = n.srsDimension;
      let o = "enu";
      if (r) {
        o = tn(r).getAxisOrientation();
      }
      const a = i.split(/\s+/);
      let l,
        h,
        c,
        u = 2;
      t.getAttribute("srsDimension")
        ? (u = fS(t.getAttribute("srsDimension")))
        : t.getAttribute("dimension")
        ? (u = fS(t.getAttribute("dimension")))
        : t.parentNode.getAttribute("srsDimension")
        ? (u = fS(t.parentNode.getAttribute("srsDimension")))
        : s && (u = fS(s));
      const d = [];
      for (let t = 0, e = a.length; t < e; t += u)
        (l = parseFloat(a[t])),
          (h = parseFloat(a[t + 1])),
          (c = 3 === u ? parseFloat(a[t + 2]) : 0),
          "en" === o.substr(0, 2) ? d.push(l, h, c) : d.push(h, l, c);
      return d;
    }
    writePos_(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = r ? "3" : "2";
      t.setAttribute("srsDimension", s);
      const o = n.srsName;
      let a = "enu";
      o && (a = tn(o).getAxisOrientation());
      const l = e.getCoordinates();
      let h;
      if (
        ((h = "en" === a.substr(0, 2) ? l[0] + " " + l[1] : l[1] + " " + l[0]),
        r)
      ) {
        h += " " + (l[2] || 0);
      }
      SS(t, h);
    }
    getCoords_(t, e, i) {
      let n = "enu";
      e && (n = tn(e).getAxisOrientation());
      let r = "en" === n.substr(0, 2) ? t[0] + " " + t[1] : t[1] + " " + t[0];
      if (i) {
        r += " " + (t[2] || 0);
      }
      return r;
    }
    writePosList_(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = r ? "3" : "2";
      t.setAttribute("srsDimension", s);
      const o = n.srsName,
        a = e.getCoordinates(),
        l = a.length,
        h = new Array(l);
      let c;
      for (let t = 0; t < l; ++t) (c = a[t]), (h[t] = this.getCoords_(c, o, r));
      SS(t, h.join(" "));
    }
    writePoint(t, e, i) {
      const n = i[i.length - 1].srsName;
      n && t.setAttribute("srsName", n);
      const r = Fy(t.namespaceURI, "pos");
      t.appendChild(r), this.writePos_(r, e, i);
    }
    writeEnvelope(t, e, i) {
      const n = i[i.length - 1].srsName;
      n && t.setAttribute("srsName", n);
      const r = [e[0] + " " + e[1], e[2] + " " + e[3]];
      Yy(
        { node: t },
        this.ENVELOPE_SERIALIZERS,
        qy,
        r,
        i,
        ["lowerCorner", "upperCorner"],
        this
      );
    }
    writeLinearRing(t, e, i) {
      const n = i[i.length - 1].srsName;
      n && t.setAttribute("srsName", n);
      const r = Fy(t.namespaceURI, "posList");
      t.appendChild(r), this.writePosList_(r, e, i);
    }
    RING_NODE_FACTORY_(t, e, i) {
      const n = e[e.length - 1],
        r = n.node,
        s = n.exteriorWritten;
      return (
        void 0 === s && (n.exteriorWritten = !0),
        Fy(r.namespaceURI, void 0 !== s ? "interior" : "exterior")
      );
    }
    writeSurfaceOrPolygon(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName;
      if (
        ("PolygonPatch" !== t.nodeName && s && t.setAttribute("srsName", s),
        "Polygon" === t.nodeName || "PolygonPatch" === t.nodeName)
      ) {
        const n = e.getLinearRings();
        Yy(
          { node: t, hasZ: r, srsName: s },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          n,
          i,
          void 0,
          this
        );
      } else if ("Surface" === t.nodeName) {
        const n = Fy(t.namespaceURI, "patches");
        t.appendChild(n), this.writeSurfacePatches_(n, e, i);
      }
    }
    writeCurveOrLineString(t, e, i) {
      const n = i[i.length - 1].srsName;
      if (
        ("LineStringSegment" !== t.nodeName &&
          n &&
          t.setAttribute("srsName", n),
        "LineString" === t.nodeName || "LineStringSegment" === t.nodeName)
      ) {
        const n = Fy(t.namespaceURI, "posList");
        t.appendChild(n), this.writePosList_(n, e, i);
      } else if ("Curve" === t.nodeName) {
        const n = Fy(t.namespaceURI, "segments");
        t.appendChild(n), this.writeCurveSegments_(n, e, i);
      }
    }
    writeMultiSurfaceOrPolygon(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName,
        o = n.surface;
      s && t.setAttribute("srsName", s);
      const a = e.getPolygons();
      Yy(
        { node: t, hasZ: r, srsName: s, surface: o },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        a,
        i,
        void 0,
        this
      );
    }
    writeMultiPoint(t, e, i) {
      const n = i[i.length - 1],
        r = n.srsName,
        s = n.hasZ;
      r && t.setAttribute("srsName", r);
      const o = e.getPoints();
      Yy(
        { node: t, hasZ: s, srsName: r },
        this.POINTMEMBER_SERIALIZERS,
        Uy("pointMember"),
        o,
        i,
        void 0,
        this
      );
    }
    writeMultiCurveOrLineString(t, e, i) {
      const n = i[i.length - 1],
        r = n.hasZ,
        s = n.srsName,
        o = n.curve;
      s && t.setAttribute("srsName", s);
      const a = e.getLineStrings();
      Yy(
        { node: t, hasZ: r, srsName: s, curve: o },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        a,
        i,
        void 0,
        this
      );
    }
    writeRing(t, e, i) {
      const n = Fy(t.namespaceURI, "LinearRing");
      t.appendChild(n), this.writeLinearRing(n, e, i);
    }
    writeSurfaceOrPolygonMember(t, e, i) {
      const n = this.GEOMETRY_NODE_FACTORY_(e, i);
      n && (t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i));
    }
    writePointMember(t, e, i) {
      const n = Fy(t.namespaceURI, "Point");
      t.appendChild(n), this.writePoint(n, e, i);
    }
    writeLineStringOrCurveMember(t, e, i) {
      const n = this.GEOMETRY_NODE_FACTORY_(e, i);
      n && (t.appendChild(n), this.writeCurveOrLineString(n, e, i));
    }
    writeSurfacePatches_(t, e, i) {
      const n = Fy(t.namespaceURI, "PolygonPatch");
      t.appendChild(n), this.writeSurfaceOrPolygon(n, e, i);
    }
    writeCurveSegments_(t, e, i) {
      const n = Fy(t.namespaceURI, "LineStringSegment");
      t.appendChild(n), this.writeCurveOrLineString(n, e, i);
    }
    writeGeometryElement(t, e, i) {
      const n = i[i.length - 1],
        r = Object.assign({}, n);
      let s;
      (r.node = t),
        (s = Array.isArray(e) ? Zv(e, n) : Xv(e, !0, n)),
        Yy(
          r,
          this.GEOMETRY_SERIALIZERS,
          this.GEOMETRY_NODE_FACTORY_,
          [s],
          i,
          void 0,
          this
        );
    }
    writeFeatureElement(t, e, i) {
      const n = e.getId();
      n && t.setAttribute("fid", n);
      const r = i[i.length - 1],
        s = r.featureNS,
        o = e.getGeometryName();
      r.serializers || ((r.serializers = {}), (r.serializers[s] = {}));
      const a = [],
        l = [];
      if (e.hasProperties()) {
        const t = e.getProperties();
        for (const e in t) {
          const i = t[e];
          null !== i &&
            (a.push(e),
            l.push(i),
            e == o || "function" == typeof i.getSimplifiedGeometry
              ? e in r.serializers[s] ||
                (r.serializers[s][e] = jy(this.writeGeometryElement, this))
              : e in r.serializers[s] || (r.serializers[s][e] = jy(SS)));
        }
      }
      const h = Object.assign({}, r);
      (h.node = t), Yy(h, r.serializers, Uy(void 0, s), l, i, a);
    }
    writeFeatureMembers_(t, e, i) {
      const n = i[i.length - 1],
        r = n.featureType,
        s = n.featureNS,
        o = {};
      (o[s] = {}), (o[s][r] = jy(this.writeFeatureElement, this));
      const a = Object.assign({}, n);
      (a.node = t), Yy(a, o, Uy(r, s), e, i);
    }
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(t, e, i) {
      const n = e[e.length - 1].node;
      return Fy(this.namespace, TS[n.nodeName]);
    }
    GEOMETRY_NODE_FACTORY_(t, e, i) {
      const n = e[e.length - 1],
        r = n.multiSurface,
        s = n.surface,
        o = n.curve,
        a = n.multiCurve;
      return (
        Array.isArray(t)
          ? (i = "Envelope")
          : "MultiPolygon" === (i = t.getType()) && !0 === r
          ? (i = "MultiSurface")
          : "Polygon" === i && !0 === s
          ? (i = "Surface")
          : "LineString" === i && !0 === o
          ? (i = "Curve")
          : "MultiLineString" === i && !0 === a && (i = "MultiCurve"),
        Fy(this.namespace, i)
      );
    }
    writeGeometryNode(t, e) {
      e = this.adaptOptions(e);
      const i = Fy(this.namespace, "geom"),
        n = {
          node: i,
          hasZ: this.hasZ,
          srsName: this.srsName,
          curve: this.curve_,
          surface: this.surface_,
          multiSurface: this.multiSurface_,
          multiCurve: this.multiCurve_,
        };
      return e && Object.assign(n, e), this.writeGeometryElement(i, t, [n]), i;
    }
    writeFeaturesNode(t, e) {
      e = this.adaptOptions(e);
      const i = Fy(this.namespace, "featureMembers");
      i.setAttributeNS(by, "xsi:schemaLocation", this.schemaLocation);
      const n = {
        srsName: this.srsName,
        hasZ: this.hasZ,
        curve: this.curve_,
        surface: this.surface_,
        multiSurface: this.multiSurface_,
        multiCurve: this.multiCurve_,
        featureNS: this.featureNS,
        featureType: this.featureType,
      };
      return e && Object.assign(n, e), this.writeFeatureMembers_(i, t, [n]), i;
    }
  }
  (PS.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      pos: Dy(PS.prototype.readFlatPos),
      posList: Dy(PS.prototype.readFlatPosList),
      coordinates: Dy(ES.prototype.readFlatCoordinates),
    },
  }),
    (PS.prototype.FLAT_LINEAR_RINGS_PARSERS = {
      "http://www.opengis.net/gml": {
        interior: PS.prototype.interiorParser,
        exterior: PS.prototype.exteriorParser,
      },
    }),
    (PS.prototype.GEOMETRY_PARSERS = {
      "http://www.opengis.net/gml": {
        Point: Dy(aS.prototype.readPoint),
        MultiPoint: Dy(aS.prototype.readMultiPoint),
        LineString: Dy(aS.prototype.readLineString),
        MultiLineString: Dy(aS.prototype.readMultiLineString),
        LinearRing: Dy(aS.prototype.readLinearRing),
        Polygon: Dy(aS.prototype.readPolygon),
        MultiPolygon: Dy(aS.prototype.readMultiPolygon),
        Surface: Dy(PS.prototype.readSurface),
        MultiSurface: Dy(PS.prototype.readMultiSurface),
        Curve: Dy(PS.prototype.readCurve),
        MultiCurve: Dy(PS.prototype.readMultiCurve),
        Envelope: Dy(PS.prototype.readEnvelope),
      },
    }),
    (PS.prototype.MULTICURVE_PARSERS = {
      "http://www.opengis.net/gml": {
        curveMember: Ny(PS.prototype.curveMemberParser),
        curveMembers: Ny(PS.prototype.curveMemberParser),
      },
    }),
    (PS.prototype.MULTISURFACE_PARSERS = {
      "http://www.opengis.net/gml": {
        surfaceMember: Ny(PS.prototype.surfaceMemberParser),
        surfaceMembers: Ny(PS.prototype.surfaceMemberParser),
      },
    }),
    (PS.prototype.CURVEMEMBER_PARSERS = {
      "http://www.opengis.net/gml": {
        LineString: Ny(aS.prototype.readLineString),
        Curve: Ny(PS.prototype.readCurve),
      },
    }),
    (PS.prototype.SURFACEMEMBER_PARSERS = {
      "http://www.opengis.net/gml": {
        Polygon: Ny(aS.prototype.readPolygon),
        Surface: Ny(PS.prototype.readSurface),
      },
    }),
    (PS.prototype.SURFACE_PARSERS = {
      "http://www.opengis.net/gml": { patches: Dy(PS.prototype.readPatch) },
    }),
    (PS.prototype.CURVE_PARSERS = {
      "http://www.opengis.net/gml": { segments: Dy(PS.prototype.readSegment) },
    }),
    (PS.prototype.ENVELOPE_PARSERS = {
      "http://www.opengis.net/gml": {
        lowerCorner: Ny(PS.prototype.readFlatPosList),
        upperCorner: Ny(PS.prototype.readFlatPosList),
      },
    }),
    (PS.prototype.PATCHES_PARSERS = {
      "http://www.opengis.net/gml": {
        PolygonPatch: Dy(PS.prototype.readPolygonPatch),
      },
    }),
    (PS.prototype.SEGMENTS_PARSERS = {
      "http://www.opengis.net/gml": {
        LineStringSegment: Ay(PS.prototype.readLineStringSegment),
      },
    }),
    (aS.prototype.RING_PARSERS = {
      "http://www.opengis.net/gml": {
        LinearRing: Dy(aS.prototype.readFlatLinearRing),
        Ring: Dy(PS.prototype.readFlatCurveRing),
      },
    }),
    PS.prototype.writeFeatures,
    (PS.prototype.RING_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        exterior: jy(PS.prototype.writeRing),
        interior: jy(PS.prototype.writeRing),
      },
    }),
    (PS.prototype.ENVELOPE_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        lowerCorner: jy(SS),
        upperCorner: jy(SS),
      },
    }),
    (PS.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        surfaceMember: jy(PS.prototype.writeSurfaceOrPolygonMember),
        polygonMember: jy(PS.prototype.writeSurfaceOrPolygonMember),
      },
    }),
    (PS.prototype.POINTMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        pointMember: jy(PS.prototype.writePointMember),
      },
    }),
    (PS.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        lineStringMember: jy(PS.prototype.writeLineStringOrCurveMember),
        curveMember: jy(PS.prototype.writeLineStringOrCurveMember),
      },
    }),
    (PS.prototype.GEOMETRY_SERIALIZERS = {
      "http://www.opengis.net/gml": {
        Curve: jy(PS.prototype.writeCurveOrLineString),
        MultiCurve: jy(PS.prototype.writeMultiCurveOrLineString),
        Point: jy(PS.prototype.writePoint),
        MultiPoint: jy(PS.prototype.writeMultiPoint),
        LineString: jy(PS.prototype.writeCurveOrLineString),
        MultiLineString: jy(PS.prototype.writeMultiCurveOrLineString),
        LinearRing: jy(PS.prototype.writeLinearRing),
        Polygon: jy(PS.prototype.writeSurfaceOrPolygon),
        MultiPolygon: jy(PS.prototype.writeMultiSurfaceOrPolygon),
        Surface: jy(PS.prototype.writeSurfaceOrPolygon),
        MultiSurface: jy(PS.prototype.writeMultiSurfaceOrPolygon),
        Envelope: jy(PS.prototype.writeEnvelope),
      },
    });
  var bS = PS;
  const FS = bS;
  FS.prototype.writeFeatures, FS.prototype.writeFeaturesNode;
  var IS = FS;
  class LS extends bS {
    constructor(t) {
      super((t = t || {})),
        (this.schemaLocation = t.schemaLocation
          ? t.schemaLocation
          : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd");
    }
    writeGeometryElement(t, e, i) {
      const n = i[i.length - 1];
      (i[i.length - 1] = Object.assign(
        { multiCurve: !0, multiSurface: !0 },
        n
      )),
        super.writeGeometryElement(t, e, i);
    }
  }
  (LS.prototype.namespace = "http://www.opengis.net/gml/3.2"),
    (LS.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        pos: Dy(bS.prototype.readFlatPos),
        posList: Dy(bS.prototype.readFlatPosList),
        coordinates: Dy(ES.prototype.readFlatCoordinates),
      },
    }),
    (LS.prototype.FLAT_LINEAR_RINGS_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        interior: bS.prototype.interiorParser,
        exterior: bS.prototype.exteriorParser,
      },
    }),
    (LS.prototype.GEOMETRY_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        Point: Dy(aS.prototype.readPoint),
        MultiPoint: Dy(aS.prototype.readMultiPoint),
        LineString: Dy(aS.prototype.readLineString),
        MultiLineString: Dy(aS.prototype.readMultiLineString),
        LinearRing: Dy(aS.prototype.readLinearRing),
        Polygon: Dy(aS.prototype.readPolygon),
        MultiPolygon: Dy(aS.prototype.readMultiPolygon),
        Surface: Dy(LS.prototype.readSurface),
        MultiSurface: Dy(bS.prototype.readMultiSurface),
        Curve: Dy(LS.prototype.readCurve),
        MultiCurve: Dy(bS.prototype.readMultiCurve),
        Envelope: Dy(LS.prototype.readEnvelope),
      },
    }),
    (LS.prototype.MULTICURVE_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        curveMember: Ny(bS.prototype.curveMemberParser),
        curveMembers: Ny(bS.prototype.curveMemberParser),
      },
    }),
    (LS.prototype.MULTISURFACE_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        surfaceMember: Ny(bS.prototype.surfaceMemberParser),
        surfaceMembers: Ny(bS.prototype.surfaceMemberParser),
      },
    }),
    (LS.prototype.CURVEMEMBER_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        LineString: Ny(aS.prototype.readLineString),
        Curve: Ny(bS.prototype.readCurve),
      },
    }),
    (LS.prototype.SURFACEMEMBER_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        Polygon: Ny(aS.prototype.readPolygon),
        Surface: Ny(bS.prototype.readSurface),
      },
    }),
    (LS.prototype.SURFACE_PARSERS = {
      "http://www.opengis.net/gml/3.2": { patches: Dy(bS.prototype.readPatch) },
    }),
    (LS.prototype.CURVE_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        segments: Dy(bS.prototype.readSegment),
      },
    }),
    (LS.prototype.ENVELOPE_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        lowerCorner: Ny(bS.prototype.readFlatPosList),
        upperCorner: Ny(bS.prototype.readFlatPosList),
      },
    }),
    (LS.prototype.PATCHES_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        PolygonPatch: Dy(bS.prototype.readPolygonPatch),
      },
    }),
    (LS.prototype.SEGMENTS_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        LineStringSegment: Ay(bS.prototype.readLineStringSegment),
      },
    }),
    (LS.prototype.MULTIPOINT_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        pointMember: Ny(aS.prototype.pointMemberParser),
        pointMembers: Ny(aS.prototype.pointMemberParser),
      },
    }),
    (LS.prototype.MULTILINESTRING_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        lineStringMember: Ny(aS.prototype.lineStringMemberParser),
        lineStringMembers: Ny(aS.prototype.lineStringMemberParser),
      },
    }),
    (LS.prototype.MULTIPOLYGON_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        polygonMember: Ny(aS.prototype.polygonMemberParser),
        polygonMembers: Ny(aS.prototype.polygonMemberParser),
      },
    }),
    (LS.prototype.POINTMEMBER_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        Point: Ny(aS.prototype.readFlatCoordinatesFromNode),
      },
    }),
    (LS.prototype.LINESTRINGMEMBER_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        LineString: Ny(aS.prototype.readLineString),
      },
    }),
    (LS.prototype.POLYGONMEMBER_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        Polygon: Ny(aS.prototype.readPolygon),
      },
    }),
    (LS.prototype.RING_PARSERS = {
      "http://www.opengis.net/gml/3.2": {
        LinearRing: Dy(aS.prototype.readFlatLinearRing),
        Ring: Dy(LS.prototype.readFlatCurveRing),
      },
    }),
    (LS.prototype.RING_SERIALIZERS = {
      "http://www.opengis.net/gml/3.2": {
        exterior: jy(bS.prototype.writeRing),
        interior: jy(bS.prototype.writeRing),
      },
    }),
    (LS.prototype.ENVELOPE_SERIALIZERS = {
      "http://www.opengis.net/gml/3.2": {
        lowerCorner: jy(SS),
        upperCorner: jy(SS),
      },
    }),
    (LS.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml/3.2": {
        surfaceMember: jy(bS.prototype.writeSurfaceOrPolygonMember),
        polygonMember: jy(bS.prototype.writeSurfaceOrPolygonMember),
      },
    }),
    (LS.prototype.POINTMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml/3.2": {
        pointMember: jy(bS.prototype.writePointMember),
      },
    }),
    (LS.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
      "http://www.opengis.net/gml/3.2": {
        lineStringMember: jy(bS.prototype.writeLineStringOrCurveMember),
        curveMember: jy(bS.prototype.writeLineStringOrCurveMember),
      },
    }),
    (LS.prototype.GEOMETRY_SERIALIZERS = {
      "http://www.opengis.net/gml/3.2": {
        Curve: jy(bS.prototype.writeCurveOrLineString),
        MultiCurve: jy(bS.prototype.writeMultiCurveOrLineString),
        Point: jy(LS.prototype.writePoint),
        MultiPoint: jy(bS.prototype.writeMultiPoint),
        LineString: jy(bS.prototype.writeCurveOrLineString),
        MultiLineString: jy(bS.prototype.writeMultiCurveOrLineString),
        LinearRing: jy(bS.prototype.writeLinearRing),
        Polygon: jy(bS.prototype.writeSurfaceOrPolygon),
        MultiPolygon: jy(bS.prototype.writeMultiSurfaceOrPolygon),
        Surface: jy(bS.prototype.writeSurfaceOrPolygon),
        MultiSurface: jy(bS.prototype.writeMultiSurfaceOrPolygon),
        Envelope: jy(bS.prototype.writeEnvelope),
      },
    });
  var MS = LS;
  const OS = [
      null,
      "http://www.topografix.com/GPX/1/0",
      "http://www.topografix.com/GPX/1/1",
    ],
    kS = { rte: lC, trk: hC, wpt: cC },
    AS = Xy(OS, { rte: Ny(lC), trk: Ny(hC), wpt: Ny(cC) }),
    NS = Xy(OS, { text: By(pS, "linkText"), type: By(pS, "linkType") }),
    DS = Xy(OS, {
      rte: jy(function (t, e, i) {
        const n = i[0],
          r = e.getProperties(),
          s = { node: t };
        s.properties = r;
        const o = e.getGeometry();
        if ("LineString" == o.getType()) {
          const t = Xv(o, !0, n);
          (s.geometryLayout = t.getLayout()), (r.rtept = t.getCoordinates());
        }
        const a = i[i.length - 1].node,
          l = ZS[a.namespaceURI],
          h = Vy(r, l);
        Yy(s, KS, qy, h, i, l);
      }),
      trk: jy(function (t, e, i) {
        const n = i[0],
          r = e.getProperties(),
          s = { node: t };
        s.properties = r;
        const o = e.getGeometry();
        if ("MultiLineString" == o.getType()) {
          const t = Xv(o, !0, n);
          r.trkseg = t.getLineStrings();
        }
        const a = i[i.length - 1].node,
          l = YS[a.namespaceURI],
          h = Vy(r, l);
        Yy(s, QS, qy, h, i, l);
      }),
      wpt: jy(function (t, e, i) {
        const n = i[0],
          r = i[i.length - 1];
        r.properties = e.getProperties();
        const s = e.getGeometry();
        if ("Point" == s.getType()) {
          const e = Xv(s, !0, n);
          (r.geometryLayout = e.getLayout()), dC(t, e.getCoordinates(), i);
        }
      }),
    });
  const GS = Xy(OS, {
      name: By(pS),
      cmt: By(pS),
      desc: By(pS),
      src: By(pS),
      link: oC,
      number: By(gS),
      extensions: aC,
      type: By(pS),
      rtept: function (t, e) {
        const i = Ky({}, BS, t, e);
        if (i) {
          const n = e[e.length - 1];
          rC(n.flatCoordinates, n.layoutOptions, t, i);
        }
      },
    }),
    BS = Xy(OS, { ele: By(uS), time: By(cS) }),
    jS = Xy(OS, {
      name: By(pS),
      cmt: By(pS),
      desc: By(pS),
      src: By(pS),
      link: oC,
      number: By(gS),
      type: By(pS),
      extensions: aC,
      trkseg: function (t, e) {
        const i = e[e.length - 1];
        Zy(zS, t, e);
        const n = i.flatCoordinates;
        i.ends.push(n.length);
      },
    }),
    zS = Xy(OS, {
      trkpt: function (t, e) {
        const i = Ky({}, US, t, e);
        if (i) {
          const n = e[e.length - 1];
          rC(n.flatCoordinates, n.layoutOptions, t, i);
        }
      },
    }),
    US = Xy(OS, { ele: By(uS), time: By(cS) }),
    qS = Xy(OS, {
      ele: By(uS),
      time: By(cS),
      magvar: By(uS),
      geoidheight: By(uS),
      name: By(pS),
      cmt: By(pS),
      desc: By(pS),
      src: By(pS),
      link: oC,
      sym: By(pS),
      type: By(pS),
      fix: By(pS),
      sat: By(gS),
      hdop: By(uS),
      vdop: By(uS),
      pdop: By(uS),
      ageofdgpsdata: By(uS),
      dgpsid: By(gS),
      extensions: aC,
    }),
    VS = ["text", "type"],
    XS = Xy(OS, { text: jy(SS), type: jy(SS) }),
    ZS = Xy(OS, [
      "name",
      "cmt",
      "desc",
      "src",
      "link",
      "number",
      "type",
      "rtept",
    ]),
    KS = Xy(OS, {
      name: jy(SS),
      cmt: jy(SS),
      desc: jy(SS),
      src: jy(SS),
      link: jy(uC),
      number: jy(vS),
      type: jy(SS),
      rtept: zy(jy(dC)),
    }),
    HS = Xy(OS, ["ele", "time"]),
    YS = Xy(OS, [
      "name",
      "cmt",
      "desc",
      "src",
      "link",
      "number",
      "type",
      "trkseg",
    ]),
    QS = Xy(OS, {
      name: jy(SS),
      cmt: jy(SS),
      desc: jy(SS),
      src: jy(SS),
      link: jy(uC),
      number: jy(vS),
      type: jy(SS),
      trkseg: zy(
        jy(function (t, e, i) {
          const n = { node: t };
          (n.geometryLayout = e.getLayout()),
            (n.properties = {}),
            Yy(n, JS, $S, e.getCoordinates(), i);
        })
      ),
    }),
    $S = Uy("trkpt"),
    JS = Xy(OS, { trkpt: jy(dC) }),
    tC = Xy(OS, [
      "ele",
      "time",
      "magvar",
      "geoidheight",
      "name",
      "cmt",
      "desc",
      "src",
      "link",
      "sym",
      "type",
      "fix",
      "sat",
      "hdop",
      "vdop",
      "pdop",
      "ageofdgpsdata",
      "dgpsid",
    ]),
    eC = Xy(OS, {
      ele: jy(xS),
      time: jy(yS),
      magvar: jy(xS),
      geoidheight: jy(xS),
      name: jy(SS),
      cmt: jy(SS),
      desc: jy(SS),
      src: jy(SS),
      link: jy(uC),
      sym: jy(SS),
      type: jy(SS),
      fix: jy(SS),
      sat: jy(vS),
      hdop: jy(xS),
      vdop: jy(xS),
      pdop: jy(xS),
      ageofdgpsdata: jy(xS),
      dgpsid: jy(vS),
    }),
    iC = { Point: "wpt", LineString: "rte", MultiLineString: "trk" };
  function nC(t, e, i) {
    const n = t.getGeometry();
    if (n) {
      const t = iC[n.getType()];
      if (t) {
        return Fy(e[e.length - 1].node.namespaceURI, t);
      }
    }
  }
  function rC(t, e, i, n) {
    return (
      t.push(
        parseFloat(i.getAttribute("lon")),
        parseFloat(i.getAttribute("lat"))
      ),
      "ele" in n ? (t.push(n.ele), delete n.ele, (e.hasZ = !0)) : t.push(0),
      "time" in n ? (t.push(n.time), delete n.time, (e.hasM = !0)) : t.push(0),
      t
    );
  }
  function sC(t, e, i) {
    let n = "XY",
      r = 2;
    if (
      (t.hasZ && t.hasM
        ? ((n = "XYZM"), (r = 4))
        : t.hasZ
        ? ((n = "XYZ"), (r = 3))
        : t.hasM && ((n = "XYM"), (r = 3)),
      4 !== r)
    ) {
      for (let i = 0, n = e.length / 4; i < n; i++)
        (e[i * r] = e[4 * i]),
          (e[i * r + 1] = e[4 * i + 1]),
          t.hasZ && (e[i * r + 2] = e[4 * i + 2]),
          t.hasM && (e[i * r + 2] = e[4 * i + 3]);
      if (((e.length = (e.length / 4) * r), i))
        for (let t = 0, e = i.length; t < e; t++) i[t] = (i[t] / 4) * r;
    }
    return n;
  }
  function oC(t, e) {
    const i = e[e.length - 1],
      n = t.getAttribute("href");
    null !== n && (i.link = n), Zy(NS, t, e);
  }
  function aC(t, e) {
    e[e.length - 1].extensionsNode_ = t;
  }
  function lC(t, e) {
    const i = e[0],
      n = Ky({ flatCoordinates: [], layoutOptions: {} }, GS, t, e);
    if (!n) return;
    const r = n.flatCoordinates;
    delete n.flatCoordinates;
    const s = n.layoutOptions;
    delete n.layoutOptions;
    const o = sC(s, r),
      a = new Bl(r, o);
    Xv(a, !1, i);
    const l = new Mt(a);
    return l.setProperties(n, !0), l;
  }
  function hC(t, e) {
    const i = e[0],
      n = Ky({ flatCoordinates: [], ends: [], layoutOptions: {} }, jS, t, e);
    if (!n) return;
    const r = n.flatCoordinates;
    delete n.flatCoordinates;
    const s = n.ends;
    delete n.ends;
    const o = n.layoutOptions;
    delete n.layoutOptions;
    const a = sC(o, r, s),
      l = new bx(r, a, s);
    Xv(l, !1, i);
    const h = new Mt(l);
    return h.setProperties(n, !0), h;
  }
  function cC(t, e) {
    const i = e[0],
      n = Ky({}, qS, t, e);
    if (!n) return;
    const r = {},
      s = rC([], r, t, n),
      o = sC(r, s),
      a = new or(s, o);
    Xv(a, !1, i);
    const l = new Mt(a);
    return l.setProperties(n, !0), l;
  }
  function uC(t, e, i) {
    t.setAttribute("href", e);
    const n = i[i.length - 1].properties,
      r = [n.linkText, n.linkType];
    Yy({ node: t }, XS, qy, r, i, VS);
  }
  function dC(t, e, i) {
    const n = i[i.length - 1],
      r = n.node.namespaceURI,
      s = n.properties;
    t.setAttributeNS(null, "lat", String(e[1])),
      t.setAttributeNS(null, "lon", String(e[0]));
    switch (n.geometryLayout) {
      case "XYZM":
        0 !== e[3] && (s.time = e[3]);
      case "XYZ":
        0 !== e[2] && (s.ele = e[2]);
        break;
      case "XYM":
        0 !== e[2] && (s.time = e[2]);
    }
    const o = "rtept" == t.nodeName ? HS[r] : tC[r],
      a = Vy(s, o);
    Yy({ node: t, properties: s }, eC, qy, a, i, o);
  }
  var gC = class extends nS {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.dataProjection = tn("EPSG:4326")),
        (this.readExtensions_ = t.readExtensions);
    }
    handleReadExtensions_(t) {
      t || (t = []);
      for (let e = 0, i = t.length; e < i; ++e) {
        const i = t[e];
        if (this.readExtensions_) {
          const t = i.get("extensionsNode_") || null;
          this.readExtensions_(i, t);
        }
        i.set("extensionsNode_", void 0);
      }
    }
    readFeatureFromNode(t, e) {
      if (!OS.includes(t.namespaceURI)) return null;
      const i = kS[t.localName];
      if (!i) return null;
      const n = i(t, [this.getReadOptions(t, e)]);
      return n ? (this.handleReadExtensions_([n]), n) : null;
    }
    readFeaturesFromNode(t, e) {
      if (!OS.includes(t.namespaceURI)) return [];
      if ("gpx" == t.localName) {
        const i = Ky([], AS, t, [this.getReadOptions(t, e)]);
        return i ? (this.handleReadExtensions_(i), i) : [];
      }
      return [];
    }
    writeFeaturesNode(t, e) {
      e = this.adaptOptions(e);
      const i = Fy("http://www.topografix.com/GPX/1/1", "gpx");
      return (
        i.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xsi", by),
        i.setAttributeNS(
          by,
          "xsi:schemaLocation",
          "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"
        ),
        i.setAttribute("version", "1.1"),
        i.setAttribute("creator", "OpenLayers"),
        Yy({ node: i }, DS, nC, t, [e]),
        i
      );
    }
  };
  function fC(t, e) {
    if (!t) return null;
    let i;
    switch (t.type) {
      case "Point":
        i = (function (t) {
          return new or(t.coordinates);
        })(t);
        break;
      case "LineString":
        i = (function (t) {
          return new Bl(t.coordinates);
        })(t);
        break;
      case "Polygon":
        i = (function (t) {
          return new Tr(t.coordinates);
        })(t);
        break;
      case "MultiPoint":
        i = (function (t) {
          return new Ix(t.coordinates);
        })(t);
        break;
      case "MultiLineString":
        i = (function (t) {
          return new bx(t.coordinates);
        })(t);
        break;
      case "MultiPolygon":
        i = (function (t) {
          return new Ox(t.coordinates);
        })(t);
        break;
      case "GeometryCollection":
        i = (function (t, e) {
          const i = t.geometries.map(function (t) {
            return fC(t, e);
          });
          return new Tx(i);
        })(t);
        break;
      default:
        throw new Error("Unsupported GeoJSON type: " + t.type);
    }
    return Xv(i, !1, e);
  }
  function pC(t, e) {
    const i = (t = Xv(t, !0, e)).getType();
    let n;
    switch (i) {
      case "Point":
        n = (function (t, e) {
          return { type: "Point", coordinates: t.getCoordinates() };
        })(t);
        break;
      case "LineString":
        n = (function (t, e) {
          return { type: "LineString", coordinates: t.getCoordinates() };
        })(t);
        break;
      case "Polygon":
        n = (function (t, e) {
          let i;
          e && (i = e.rightHanded);
          return { type: "Polygon", coordinates: t.getCoordinates(i) };
        })(t, e);
        break;
      case "MultiPoint":
        n = (function (t, e) {
          return { type: "MultiPoint", coordinates: t.getCoordinates() };
        })(t);
        break;
      case "MultiLineString":
        n = (function (t, e) {
          return { type: "MultiLineString", coordinates: t.getCoordinates() };
        })(t);
        break;
      case "MultiPolygon":
        n = (function (t, e) {
          let i;
          e && (i = e.rightHanded);
          return { type: "MultiPolygon", coordinates: t.getCoordinates(i) };
        })(t, e);
        break;
      case "GeometryCollection":
        n = (function (t, e) {
          (e = Object.assign({}, e)), delete e.featureProjection;
          const i = t.getGeometriesArray().map(function (t) {
            return pC(t, e);
          });
          return { type: "GeometryCollection", geometries: i };
        })(t, e);
        break;
      case "Circle":
        n = { type: "GeometryCollection", geometries: [] };
        break;
      default:
        throw new Error("Unsupported geometry type: " + i);
    }
    return n;
  }
  var mC = class extends Hv {
    constructor(t) {
      (t = t || {}),
        super(),
        (this.dataProjection = tn(
          t.dataProjection ? t.dataProjection : "EPSG:4326"
        )),
        t.featureProjection &&
          (this.defaultFeatureProjection = tn(t.featureProjection)),
        (this.geometryName_ = t.geometryName),
        (this.extractGeometryName_ = t.extractGeometryName),
        (this.supportedMediaTypes = [
          "application/geo+json",
          "application/vnd.geo+json",
        ]);
    }
    readFeatureFromObject(t, e) {
      let i = null;
      i =
        "Feature" === t.type
          ? t
          : { type: "Feature", geometry: t, properties: null };
      const n = fC(i.geometry, e),
        r = new Mt();
      return (
        this.geometryName_
          ? r.setGeometryName(this.geometryName_)
          : this.extractGeometryName_ &&
            "geometry_name" in i !== void 0 &&
            r.setGeometryName(i.geometry_name),
        r.setGeometry(n),
        "id" in i && r.setId(i.id),
        i.properties && r.setProperties(i.properties, !0),
        r
      );
    }
    readFeaturesFromObject(t, e) {
      let i = null;
      if ("FeatureCollection" === t.type) {
        i = [];
        const n = t.features;
        for (let t = 0, r = n.length; t < r; ++t)
          i.push(this.readFeatureFromObject(n[t], e));
      } else i = [this.readFeatureFromObject(t, e)];
      return i;
    }
    readGeometryFromObject(t, e) {
      return fC(t, e);
    }
    readProjectionFromObject(t) {
      const e = t.crs;
      let i;
      if (e)
        if ("name" == e.type) i = tn(e.properties.name);
        else {
          if ("EPSG" !== e.type) throw new Error("Unknown SRS type");
          i = tn("EPSG:" + e.properties.code);
        }
      else i = this.dataProjection;
      return i;
    }
    writeFeatureObject(t, e) {
      e = this.adaptOptions(e);
      const i = { type: "Feature", geometry: null, properties: null },
        n = t.getId();
      if ((void 0 !== n && (i.id = n), !t.hasProperties())) return i;
      const r = t.getProperties(),
        s = t.getGeometry();
      return (
        s && ((i.geometry = pC(s, e)), delete r[t.getGeometryName()]),
        y(r) || (i.properties = r),
        i
      );
    }
    writeFeaturesObject(t, e) {
      e = this.adaptOptions(e);
      const i = [];
      for (let n = 0, r = t.length; n < r; ++n)
        i.push(this.writeFeatureObject(t[n], e));
      return { type: "FeatureCollection", features: i };
    }
    writeGeometryObject(t, e) {
      return pC(t, this.adaptOptions(e));
    }
  };
  function _C(t) {
    return "string" == typeof t ? t : "";
  }
  var yC = class extends Vv {
    constructor() {
      super();
    }
    getType() {
      return "text";
    }
    readFeature(t, e) {
      return this.readFeatureFromText(_C(t), this.adaptOptions(e));
    }
    readFeatureFromText(t, e) {
      return G();
    }
    readFeatures(t, e) {
      return this.readFeaturesFromText(_C(t), this.adaptOptions(e));
    }
    readFeaturesFromText(t, e) {
      return G();
    }
    readGeometry(t, e) {
      return this.readGeometryFromText(_C(t), this.adaptOptions(e));
    }
    readGeometryFromText(t, e) {
      return G();
    }
    readProjection(t) {
      return this.readProjectionFromText(_C(t));
    }
    readProjectionFromText(t) {
      return this.dataProjection;
    }
    writeFeature(t, e) {
      return this.writeFeatureText(t, this.adaptOptions(e));
    }
    writeFeatureText(t, e) {
      return G();
    }
    writeFeatures(t, e) {
      return this.writeFeaturesText(t, this.adaptOptions(e));
    }
    writeFeaturesText(t, e) {
      return G();
    }
    writeGeometry(t, e) {
      return this.writeGeometryText(t, this.adaptOptions(e));
    }
    writeGeometryText(t, e) {
      return G();
    }
  };
  const xC =
      /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/,
    vC = /^H.([A-Z]{3}).*?:(.*)/,
    SC = /^HFDTE(\d{2})(\d{2})(\d{2})/,
    CC = /\r\n|\r|\n/;
  var wC = class extends yC {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.dataProjection = tn("EPSG:4326")),
        (this.altitudeMode_ = t.altitudeMode ? t.altitudeMode : "none");
    }
    readFeatureFromText(t, e) {
      const i = this.altitudeMode_,
        n = t.split(CC),
        r = {},
        s = [];
      let o,
        a,
        l = 2e3,
        h = 0,
        c = 1,
        u = -1;
      for (o = 0, a = n.length; o < a; ++o) {
        const t = n[o];
        let e;
        if ("B" == t.charAt(0)) {
          if (((e = xC.exec(t)), e)) {
            const t = parseInt(e[1], 10),
              n = parseInt(e[2], 10),
              r = parseInt(e[3], 10);
            let o = parseInt(e[4], 10) + parseInt(e[5], 10) / 6e4;
            "S" == e[6] && (o = -o);
            let a = parseInt(e[7], 10) + parseInt(e[8], 10) / 6e4;
            if (("W" == e[9] && (a = -a), s.push(a, o), "none" != i)) {
              let t;
              (t =
                "gps" == i
                  ? parseInt(e[11], 10)
                  : "barometric" == i
                  ? parseInt(e[12], 10)
                  : 0),
                s.push(t);
            }
            let d = Date.UTC(l, h, c, t, n, r);
            d < u && (d = Date.UTC(l, h, c + 1, t, n, r)),
              s.push(d / 1e3),
              (u = d);
          }
        } else
          "H" == t.charAt(0) &&
            ((e = SC.exec(t)),
            e
              ? ((c = parseInt(e[1], 10)),
                (h = parseInt(e[2], 10) - 1),
                (l = 2e3 + parseInt(e[3], 10)))
              : ((e = vC.exec(t)), e && (r[e[1]] = e[2].trim())));
      }
      if (0 === s.length) return null;
      const d = new Bl(s, "none" == i ? "XYM" : "XYZM"),
        g = new Mt(Xv(d, !1, e));
      return g.setProperties(r, !0), g;
    }
    readFeaturesFromText(t, e) {
      const i = this.readFeatureFromText(t, e);
      return i ? [i] : [];
    }
  };
  const WC = ["http://www.google.com/kml/ext/2.2"],
    EC = [
      null,
      "http://earth.google.com/kml/2.0",
      "http://earth.google.com/kml/2.1",
      "http://earth.google.com/kml/2.2",
      "http://www.opengis.net/kml/2.2",
    ],
    RC = { fraction: "fraction", pixels: "pixels", insetPixels: "pixels" },
    TC = Xy(
      EC,
      {
        ExtendedData: Fw,
        Region: Iw,
        MultiGeometry: By(Sw, "geometry"),
        LineString: By(yw, "geometry"),
        LinearRing: By(xw, "geometry"),
        Point: By(Cw, "geometry"),
        Polygon: By(Ww, "geometry"),
        Style: By(Rw),
        StyleMap: function (t, e) {
          const i = rw.call(this, t, e);
          if (!i) return;
          const n = e[e.length - 1];
          if (Array.isArray(i)) n.Style = i;
          else {
            if ("string" != typeof i)
              throw new Error("`styleMapValue` has an unknown type");
            n.styleUrl = i;
          }
        },
        address: By(pS),
        description: By(pS),
        name: By(pS),
        open: By(lS),
        phoneNumber: By(pS),
        styleUrl: By(ew),
        visibility: By(lS),
      },
      Xy(WC, {
        MultiTrack: By(function (t, e) {
          const i = Ky([], uw, t, e);
          if (!i) return;
          return new bx(i);
        }, "geometry"),
        Track: By(gw, "geometry"),
      })
    ),
    PC = Xy(EC, {
      ExtendedData: Fw,
      Region: Iw,
      Link: function (t, e) {
        Zy(bC, t, e);
      },
      address: By(pS),
      description: By(pS),
      name: By(pS),
      open: By(lS),
      phoneNumber: By(pS),
      visibility: By(lS),
    }),
    bC = Xy(EC, { href: By(tw) }),
    FC = Xy(EC, {
      Altitude: By(uS),
      Longitude: By(uS),
      Latitude: By(uS),
      Tilt: By(uS),
      AltitudeMode: By(pS),
      Heading: By(uS),
      Roll: By(uS),
    }),
    IC = Xy(EC, {
      LatLonAltBox: function (t, e) {
        const i = Ky({}, Ow, t, e);
        if (!i) return;
        const n = e[e.length - 1],
          r = [
            parseFloat(i.west),
            parseFloat(i.south),
            parseFloat(i.east),
            parseFloat(i.north),
          ];
        (n.extent = r),
          (n.altitudeMode = i.altitudeMode),
          (n.minAltitude = parseFloat(i.minAltitude)),
          (n.maxAltitude = parseFloat(i.maxAltitude));
      },
      Lod: function (t, e) {
        const i = Ky({}, kw, t, e);
        if (!i) return;
        const n = e[e.length - 1];
        (n.minLodPixels = parseFloat(i.minLodPixels)),
          (n.maxLodPixels = parseFloat(i.maxLodPixels)),
          (n.minFadeExtent = parseFloat(i.minFadeExtent)),
          (n.maxFadeExtent = parseFloat(i.maxFadeExtent));
      },
    }),
    LC = Xy(EC, ["Document", "Placemark"]),
    MC = Xy(EC, {
      Document: jy(function (t, e, i) {
        const n = { node: t };
        Yy(n, Bw, jw, e, i, void 0, this);
      }),
      Placemark: jy(uW),
    });
  let OC,
    kC,
    AC,
    NC,
    DC,
    GC,
    BC = null;
  let jC,
    zC = null;
  let UC,
    qC = null;
  let VC = null;
  let XC = null;
  let ZC,
    KC = null;
  function HC(t) {
    return 32 / Math.min(t[0], t[1]);
  }
  function YC(t) {
    return t;
  }
  function QC(t, e, i) {
    return Array.isArray(t) ? t : "string" == typeof t ? QC(i[t], e, i) : e;
  }
  function $C(t) {
    const e = Iy(t, !1),
      i = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e);
    if (i) {
      const t = i[1];
      return [
        parseInt(t.substr(6, 2), 16),
        parseInt(t.substr(4, 2), 16),
        parseInt(t.substr(2, 2), 16),
        parseInt(t.substr(0, 2), 16) / 255,
      ];
    }
  }
  function JC(t) {
    let e = Iy(t, !1);
    const i = [];
    e = e.replace(/\s*,\s*/g, ",");
    const n =
      /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
    let r;
    for (; (r = n.exec(e)); ) {
      const t = parseFloat(r[1]),
        n = parseFloat(r[2]),
        s = r[3] ? parseFloat(r[3]) : 0;
      i.push(t, n, s), (e = e.substr(r[0].length));
    }
    if ("" === e) return i;
  }
  function tw(t) {
    const e = Iy(t, !1).trim();
    let i = t.baseURI;
    if (((i && "about:blank" != i) || (i = window.location.href), i)) {
      return new URL(e, i).href;
    }
    return e;
  }
  function ew(t) {
    const e = Iy(t, !1)
      .trim()
      .replace(/^(?!.*#)/, "#");
    let i = t.baseURI;
    if (((i && "about:blank" != i) || (i = window.location.href), i)) {
      return new URL(e, i).href;
    }
    return e;
  }
  function iw(t) {
    return uS(t);
  }
  const nw = Xy(EC, {
    Pair: function (t, e) {
      const i = Ky({}, Lw, t, e, this);
      if (!i) return;
      const n = i.key;
      if (n && "normal" == n) {
        const t = i.styleUrl;
        t && (e[e.length - 1] = t);
        const n = i.Style;
        n && (e[e.length - 1] = n);
      }
    },
  });
  function rw(t, e) {
    return Ky(void 0, nw, t, e, this);
  }
  const sw = Xy(EC, {
    Icon: By(function (t, e) {
      const i = Ky({}, fw, t, e);
      if (i) return i;
      return null;
    }),
    color: By($C),
    heading: By(uS),
    hotSpot: By(function (t) {
      const e = t.getAttribute("xunits"),
        i = t.getAttribute("yunits");
      let n;
      return (
        (n =
          "insetPixels" !== e
            ? "insetPixels" !== i
              ? "bottom-left"
              : "top-left"
            : "insetPixels" !== i
            ? "bottom-right"
            : "top-right"),
        {
          x: parseFloat(t.getAttribute("x")),
          xunits: RC[e],
          y: parseFloat(t.getAttribute("y")),
          yunits: RC[i],
          origin: n,
        }
      );
    }),
    scale: By(iw),
  });
  const ow = Xy(EC, { color: By($C), scale: By(iw) });
  const aw = Xy(EC, { color: By($C), width: By(uS) });
  const lw = Xy(EC, { color: By($C), fill: By(lS), outline: By(lS) });
  const hw = Xy(EC, { coordinates: Dy(JC) });
  function cw(t, e) {
    return Ky(null, hw, t, e);
  }
  const uw = Xy(WC, { Track: Ny(gw) });
  const dw = Xy(
    EC,
    {
      when: function (t, e) {
        const i = e[e.length - 1].whens,
          n = Iy(t, !1),
          r = Date.parse(n);
        i.push(isNaN(r) ? 0 : r);
      },
    },
    Xy(WC, {
      coord: function (t, e) {
        const i = e[e.length - 1].coordinates,
          n = Iy(t, !1),
          r =
            /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(
              n
            );
        if (r) {
          const t = parseFloat(r[1]),
            e = parseFloat(r[2]),
            n = parseFloat(r[3]);
          i.push([t, e, n]);
        } else i.push([]);
      },
    })
  );
  function gw(t, e) {
    const i = Ky({ coordinates: [], whens: [] }, dw, t, e);
    if (!i) return;
    const n = [],
      r = i.coordinates,
      s = i.whens;
    for (let t = 0, e = Math.min(r.length, s.length); t < e; ++t)
      3 == r[t].length && n.push(r[t][0], r[t][1], r[t][2], s[t]);
    return new Bl(n, "XYZM");
  }
  const fw = Xy(
    EC,
    { href: By(tw) },
    Xy(WC, { x: By(uS), y: By(uS), w: By(uS), h: By(uS) })
  );
  const pw = Xy(EC, { coordinates: Dy(JC) });
  function mw(t, e) {
    return Ky(null, pw, t, e);
  }
  const _w = Xy(EC, {
    extrude: By(lS),
    tessellate: By(lS),
    altitudeMode: By(pS),
  });
  function yw(t, e) {
    const i = Ky({}, _w, t, e),
      n = mw(t, e);
    if (n) {
      const t = new Bl(n, "XYZ");
      return t.setProperties(i, !0), t;
    }
  }
  function xw(t, e) {
    const i = Ky({}, _w, t, e),
      n = mw(t, e);
    if (n) {
      const t = new Tr(n, "XYZ", [n.length]);
      return t.setProperties(i, !0), t;
    }
  }
  const vw = Xy(EC, {
    LineString: Ny(yw),
    LinearRing: Ny(xw),
    MultiGeometry: Ny(Sw),
    Point: Ny(Cw),
    Polygon: Ny(Ww),
  });
  function Sw(t, e) {
    const i = Ky([], vw, t, e);
    if (!i) return null;
    if (0 === i.length) return new Tx(i);
    let n,
      r = !0;
    const s = i[0].getType();
    let o;
    for (let t = 1, e = i.length; t < e; ++t)
      if (((o = i[t]), o.getType() != s)) {
        r = !1;
        break;
      }
    if (r) {
      let t, e;
      if ("Point" == s) {
        const r = i[0];
        (t = r.getLayout()), (e = r.getFlatCoordinates());
        for (let t = 1, n = i.length; t < n; ++t)
          (o = i[t]), h(e, o.getFlatCoordinates());
        (n = new Ix(e, t)), Tw(n, i);
      } else if ("LineString" == s) (n = new bx(i)), Tw(n, i);
      else if ("Polygon" == s) (n = new Ox(i)), Tw(n, i);
      else {
        if ("GeometryCollection" != s)
          throw new Error("Unknown geometry type found");
        n = new Tx(i);
      }
    } else n = new Tx(i);
    return n;
  }
  function Cw(t, e) {
    const i = Ky({}, _w, t, e),
      n = mw(t, e);
    if (n) {
      const t = new or(n, "XYZ");
      return t.setProperties(i, !0), t;
    }
  }
  const ww = Xy(EC, {
    innerBoundaryIs: function (t, e) {
      const i = Ky([], Aw, t, e);
      if (i.length > 0) {
        e[e.length - 1].push(...i);
      }
    },
    outerBoundaryIs: function (t, e) {
      const i = Ky(void 0, Nw, t, e);
      if (i) {
        e[e.length - 1][0] = i;
      }
    },
  });
  function Ww(t, e) {
    const i = Ky({}, _w, t, e),
      n = Ky([null], ww, t, e);
    if (n && n[0]) {
      const t = n[0],
        e = [t.length];
      for (let i = 1, r = n.length; i < r; ++i) h(t, n[i]), e.push(t.length);
      const r = new Tr(t, "XYZ", e);
      return r.setProperties(i, !0), r;
    }
  }
  const Ew = Xy(EC, {
    IconStyle: function (t, e) {
      const i = Ky({}, sw, t, e);
      if (!i) return;
      const n = e[e.length - 1],
        r = "Icon" in i ? i.Icon : {},
        s = !("Icon" in i) || Object.keys(r).length > 0;
      let o;
      const a = r.href;
      let l, h, c;
      a ? (o = a) : s && (o = GC);
      let u = "bottom-left";
      const d = i.hotSpot;
      let g;
      d
        ? ((l = [d.x, d.y]), (h = d.xunits), (c = d.yunits), (u = d.origin))
        : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) &&
          (o.includes("pushpin")
            ? ((l = kC), (h = AC), (c = NC))
            : o.includes("arrow-reverse")
            ? ((l = [54, 42]), (h = AC), (c = NC))
            : o.includes("paddle") && ((l = [32, 1]), (h = AC), (c = NC)));
      const f = r.x,
        p = r.y;
      let m;
      void 0 !== f && void 0 !== p && (g = [f, p]);
      const _ = r.w,
        y = r.h;
      let x;
      void 0 !== _ && void 0 !== y && (m = [_, y]);
      const v = i.heading;
      void 0 !== v && (x = mi(v));
      const S = i.scale,
        C = i.color;
      if (s) {
        o == GC && (m = DC);
        const t = new bh({
            anchor: l,
            anchorOrigin: u,
            anchorXUnits: h,
            anchorYUnits: c,
            crossOrigin: this.crossOrigin_,
            offset: g,
            offsetOrigin: "bottom-left",
            rotation: x,
            scale: S,
            size: m,
            src: this.iconUrlFunction_(o),
            color: C,
          }),
          e = t.getScaleArray()[0],
          i = t.getSize();
        if (null === i) {
          const i = t.getImageState();
          if (i === Vr || i === Xr) {
            const n = function () {
              const i = t.getImageState();
              if (i !== Vr && i !== Xr) {
                const i = t.getSize();
                if (i && 2 == i.length) {
                  const n = HC(i);
                  t.setScale(e * n);
                }
                t.unlistenImageChange(n);
              }
            };
            t.listenImageChange(n), i === Vr && t.load();
          }
        } else if (2 == i.length) {
          const n = HC(i);
          t.setScale(e * n);
        }
        n.imageStyle = t;
      } else n.imageStyle = jC;
    },
    LabelStyle: function (t, e) {
      const i = Ky({}, ow, t, e);
      if (!i) return;
      const n = e[e.length - 1],
        r = new rh({
          fill: new Ol({ color: "color" in i ? i.color : OC }),
          scale: i.scale,
        });
      n.textStyle = r;
    },
    LineStyle: function (t, e) {
      const i = Ky({}, aw, t, e);
      if (!i) return;
      const n = e[e.length - 1],
        r = new zl({
          color: "color" in i ? i.color : OC,
          width: "width" in i ? i.width : 1,
        });
      n.strokeStyle = r;
    },
    PolyStyle: function (t, e) {
      const i = Ky({}, lw, t, e);
      if (!i) return;
      const n = e[e.length - 1],
        r = new Ol({ color: "color" in i ? i.color : OC });
      n.fillStyle = r;
      const s = i.fill;
      void 0 !== s && (n.fill = s);
      const o = i.outline;
      void 0 !== o && (n.outline = o);
    },
  });
  function Rw(t, e) {
    const i = Ky({}, Ew, t, e, this);
    if (!i) return null;
    let n = "fillStyle" in i ? i.fillStyle : BC;
    const r = i.fill;
    let s;
    void 0 === r || r || (n = null),
      "imageStyle" in i ? i.imageStyle != jC && (s = i.imageStyle) : (s = zC);
    const o = "textStyle" in i ? i.textStyle : VC,
      a = "strokeStyle" in i ? i.strokeStyle : qC,
      l = i.outline;
    return void 0 === l || l
      ? [new ih({ fill: n, image: s, stroke: a, text: o, zIndex: void 0 })]
      : [
          new ih({
            geometry: function (t) {
              const e = t.getGeometry(),
                i = e.getType();
              if ("GeometryCollection" === i) {
                return new Tx(
                  e.getGeometriesArrayRecursive().filter(function (t) {
                    const e = t.getType();
                    return "Polygon" !== e && "MultiPolygon" !== e;
                  })
                );
              }
              if ("Polygon" !== i && "MultiPolygon" !== i) return e;
            },
            fill: n,
            image: s,
            stroke: a,
            text: o,
            zIndex: void 0,
          }),
          new ih({
            geometry: function (t) {
              const e = t.getGeometry(),
                i = e.getType();
              if ("GeometryCollection" === i) {
                return new Tx(
                  e.getGeometriesArrayRecursive().filter(function (t) {
                    const e = t.getType();
                    return "Polygon" === e || "MultiPolygon" === e;
                  })
                );
              }
              if ("Polygon" === i || "MultiPolygon" === i) return e;
            },
            fill: n,
            stroke: null,
            zIndex: void 0,
          }),
        ];
  }
  function Tw(t, e) {
    const i = e.length,
      n = new Array(e.length),
      r = new Array(e.length),
      s = new Array(e.length);
    let o, a, l;
    (o = !1), (a = !1), (l = !1);
    for (let t = 0; t < i; ++t) {
      const i = e[t];
      (n[t] = i.get("extrude")),
        (r[t] = i.get("tessellate")),
        (s[t] = i.get("altitudeMode")),
        (o = o || void 0 !== n[t]),
        (a = a || void 0 !== r[t]),
        (l = l || s[t]);
    }
    o && t.set("extrude", n),
      a && t.set("tessellate", r),
      l && t.set("altitudeMode", s);
  }
  const Pw = Xy(EC, { displayName: By(pS), value: By(pS) });
  const bw = Xy(EC, {
    Data: function (t, e) {
      const i = t.getAttribute("name");
      Zy(Pw, t, e);
      const n = e[e.length - 1];
      i && n.displayName
        ? (n[i] = {
            value: n.value,
            displayName: n.displayName,
            toString: function () {
              return n.value;
            },
          })
        : null !== i
        ? (n[i] = n.value)
        : null !== n.displayName && (n[n.displayName] = n.value),
        delete n.value;
    },
    SchemaData: function (t, e) {
      Zy(Mw, t, e);
    },
  });
  function Fw(t, e) {
    Zy(bw, t, e);
  }
  function Iw(t, e) {
    Zy(IC, t, e);
  }
  const Lw = Xy(EC, { Style: By(Rw), key: By(pS), styleUrl: By(ew) });
  const Mw = Xy(EC, {
    SimpleData: function (t, e) {
      const i = t.getAttribute("name");
      if (null !== i) {
        const n = pS(t);
        e[e.length - 1][i] = n;
      }
    },
  });
  const Ow = Xy(EC, {
    altitudeMode: By(pS),
    minAltitude: By(uS),
    maxAltitude: By(uS),
    north: By(uS),
    south: By(uS),
    east: By(uS),
    west: By(uS),
  });
  const kw = Xy(EC, {
    minLodPixels: By(uS),
    maxLodPixels: By(uS),
    minFadeExtent: By(uS),
    maxFadeExtent: By(uS),
  });
  const Aw = Xy(EC, { LinearRing: Ny(cw) });
  const Nw = Xy(EC, { LinearRing: Dy(cw) });
  function Dw(t, e) {
    const i = hs(e),
      n = [255 * (4 == i.length ? i[3] : 1), i[2], i[1], i[0]];
    for (let t = 0; t < 4; ++t) {
      const e = Math.floor(n[t]).toString(16);
      n[t] = 1 == e.length ? "0" + e : e;
    }
    SS(t, n.join(""));
  }
  const Gw = Xy(EC, {
    Data: jy(function (t, e, i) {
      t.setAttribute("name", e.name);
      const n = { node: t },
        r = e.value;
      "object" == typeof r
        ? (null !== r &&
            r.displayName &&
            Yy(n, Gw, qy, [r.displayName], i, ["displayName"]),
          null !== r && r.value && Yy(n, Gw, qy, [r.value], i, ["value"]))
        : Yy(n, Gw, qy, [r], i, ["value"]);
    }),
    value: jy(function (t, e) {
      SS(t, e);
    }),
    displayName: jy(function (t, e) {
      _S(t, e);
    }),
  });
  const Bw = Xy(EC, { Placemark: jy(uW) }),
    jw = function (t, e, i) {
      return Fy(e[e.length - 1].node.namespaceURI, "Placemark");
    };
  const zw = Uy("Data");
  const Uw = Xy(EC, ["href"], Xy(WC, ["x", "y", "w", "h"])),
    qw = Xy(
      EC,
      { href: jy(SS) },
      Xy(WC, { x: jy(xS), y: jy(xS), w: jy(xS), h: jy(xS) })
    ),
    Vw = function (t, e, i) {
      return Fy(WC[0], "gx:" + i);
    };
  const Xw = Xy(EC, ["scale", "heading", "Icon", "color", "hotSpot"]),
    Zw = Xy(EC, {
      Icon: jy(function (t, e, i) {
        const n = { node: t },
          r = i[i.length - 1].node;
        let s = Uw[r.namespaceURI],
          o = Vy(e, s);
        Yy(n, qw, qy, o, i, s),
          (s = Uw[WC[0]]),
          (o = Vy(e, s)),
          Yy(n, qw, Vw, o, i, s);
      }),
      color: jy(Dw),
      heading: jy(xS),
      hotSpot: jy(function (t, e) {
        t.setAttribute("x", String(e.x)),
          t.setAttribute("y", String(e.y)),
          t.setAttribute("xunits", e.xunits),
          t.setAttribute("yunits", e.yunits);
      }),
      scale: jy(SW),
    });
  const Kw = Xy(EC, ["color", "scale"]),
    Hw = Xy(EC, { color: jy(Dw), scale: jy(SW) });
  const Yw = Xy(EC, ["color", "width"]),
    Qw = Xy(EC, { color: jy(Dw), width: jy(xS) });
  const $w = {
      Point: "Point",
      LineString: "LineString",
      LinearRing: "LinearRing",
      Polygon: "Polygon",
      MultiPoint: "MultiGeometry",
      MultiLineString: "MultiGeometry",
      MultiPolygon: "MultiGeometry",
      GeometryCollection: "MultiGeometry",
    },
    Jw = function (t, e, i) {
      if (t) {
        return Fy(e[e.length - 1].node.namespaceURI, $w[t.getType()]);
      }
    },
    tW = Uy("Point"),
    eW = Uy("LineString"),
    iW = Uy("LinearRing"),
    nW = Uy("Polygon"),
    rW = Xy(EC, {
      LineString: jy(fW),
      Point: jy(fW),
      Polygon: jy(xW),
      GeometryCollection: jy(sW),
    });
  function sW(t, e, i) {
    const n = { node: t },
      r = e.getType();
    let s,
      o = [];
    if ("GeometryCollection" === r)
      e.getGeometriesArrayRecursive().forEach(function (t) {
        const e = t.getType();
        if ("MultiPoint" === e) o = o.concat(t.getPoints());
        else if ("MultiLineString" === e) o = o.concat(t.getLineStrings());
        else if ("MultiPolygon" === e) o = o.concat(t.getPolygons());
        else {
          if ("Point" !== e && "LineString" !== e && "Polygon" !== e)
            throw new Error("Unknown geometry type");
          o.push(t);
        }
      }),
        (s = Jw);
    else if ("MultiPoint" === r) (o = e.getPoints()), (s = tW);
    else if ("MultiLineString" === r) (o = e.getLineStrings()), (s = eW);
    else {
      if ("MultiPolygon" !== r) throw new Error("Unknown geometry type");
      (o = e.getPolygons()), (s = nW);
    }
    Yy(n, rW, s, o, i);
  }
  const oW = Xy(EC, { LinearRing: jy(fW) });
  function aW(t, e, i) {
    Yy({ node: t }, oW, iW, [e], i);
  }
  const lW = Xy(EC, {
      ExtendedData: jy(function (t, e, i) {
        const n = { node: t },
          r = e.names,
          s = e.values,
          o = r.length;
        for (let t = 0; t < o; t++)
          Yy(n, Gw, zw, [{ name: r[t], value: s[t] }], i);
      }),
      MultiGeometry: jy(sW),
      LineString: jy(fW),
      LinearRing: jy(fW),
      Point: jy(fW),
      Polygon: jy(xW),
      Style: jy(function (t, e, i) {
        const n = { node: t },
          r = {};
        if (e.pointStyles.length) {
          const t = e.pointStyles[0].getText();
          t && (r.LabelStyle = t);
          const i = e.pointStyles[0].getImage();
          i && "function" == typeof i.getSrc && (r.IconStyle = i);
        }
        if (e.lineStyles.length) {
          const t = e.lineStyles[0].getStroke();
          t && (r.LineStyle = t);
        }
        if (e.polyStyles.length) {
          const t = e.polyStyles[0].getStroke();
          t && !r.LineStyle && (r.LineStyle = t),
            (r.PolyStyle = e.polyStyles[0]);
        }
        const s = i[i.length - 1].node,
          o = CW[s.namespaceURI],
          a = Vy(r, o);
        Yy(n, wW, qy, a, i, o);
      }),
      address: jy(SS),
      description: jy(SS),
      name: jy(SS),
      open: jy(mS),
      phoneNumber: jy(SS),
      styleUrl: jy(SS),
      visibility: jy(mS),
    }),
    hW = Xy(EC, [
      "name",
      "open",
      "visibility",
      "address",
      "phoneNumber",
      "description",
      "styleUrl",
      "Style",
    ]),
    cW = Uy("ExtendedData");
  function uW(t, e, i) {
    const n = { node: t };
    e.getId() && t.setAttribute("id", e.getId());
    const r = e.getProperties(),
      s = {
        address: 1,
        description: 1,
        name: 1,
        open: 1,
        phoneNumber: 1,
        styleUrl: 1,
        visibility: 1,
      };
    s[e.getGeometryName()] = 1;
    const o = Object.keys(r || {})
        .sort()
        .filter(function (t) {
          return !s[t];
        }),
      a = e.getStyleFunction();
    if (a) {
      const t = a(e, 0);
      if (t) {
        const i = Array.isArray(t) ? t : [t];
        let n = i;
        if (
          (e.getGeometry() &&
            (n = i.filter(function (t) {
              const i = t.getGeometryFunction()(e);
              if (i) {
                const t = i.getType();
                return "GeometryCollection" === t
                  ? i.getGeometriesArrayRecursive().filter(function (t) {
                      const e = t.getType();
                      return "Point" === e || "MultiPoint" === e;
                    }).length
                  : "Point" === t || "MultiPoint" === t;
              }
            })),
          this.writeStyles_)
        ) {
          let t = i,
            s = i;
          e.getGeometry() &&
            ((t = i.filter(function (t) {
              const i = t.getGeometryFunction()(e);
              if (i) {
                const t = i.getType();
                return "GeometryCollection" === t
                  ? i.getGeometriesArrayRecursive().filter(function (t) {
                      const e = t.getType();
                      return "LineString" === e || "MultiLineString" === e;
                    }).length
                  : "LineString" === t || "MultiLineString" === t;
              }
            })),
            (s = i.filter(function (t) {
              const i = t.getGeometryFunction()(e);
              if (i) {
                const t = i.getType();
                return "GeometryCollection" === t
                  ? i.getGeometriesArrayRecursive().filter(function (t) {
                      const e = t.getType();
                      return "Polygon" === e || "MultiPolygon" === e;
                    }).length
                  : "Polygon" === t || "MultiPolygon" === t;
              }
            }))),
            (r.Style = { pointStyles: n, lineStyles: t, polyStyles: s });
        }
        if (n.length && void 0 === r.name) {
          const t = n[0].getText();
          t && (r.name = t.getText());
        }
      }
    }
    const l = i[i.length - 1].node,
      h = hW[l.namespaceURI],
      c = Vy(r, h);
    if ((Yy(n, lW, qy, c, i, h), o.length > 0)) {
      const t = Vy(r, o);
      Yy(n, lW, cW, [{ names: o, values: t }], i);
    }
    const u = i[0];
    let d = e.getGeometry();
    d && (d = Xv(d, !0, u)), Yy(n, lW, Jw, [d], i);
  }
  const dW = Xy(EC, ["extrude", "tessellate", "altitudeMode", "coordinates"]),
    gW = Xy(EC, {
      extrude: jy(mS),
      tessellate: jy(mS),
      altitudeMode: jy(SS),
      coordinates: jy(function (t, e, i) {
        const n = i[i.length - 1],
          r = n.layout,
          s = n.stride;
        let o;
        if ("XY" == r || "XYM" == r) o = 2;
        else {
          if ("XYZ" != r && "XYZM" != r)
            throw new Error("Invalid geometry layout");
          o = 3;
        }
        const a = e.length;
        let l = "";
        if (a > 0) {
          l += e[0];
          for (let t = 1; t < o; ++t) l += "," + e[t];
          for (let t = s; t < a; t += s) {
            l += " " + e[t];
            for (let i = 1; i < o; ++i) l += "," + e[t + i];
          }
        }
        SS(t, l);
      }),
    });
  function fW(t, e, i) {
    const n = e.getFlatCoordinates(),
      r = { node: t };
    (r.layout = e.getLayout()), (r.stride = e.getStride());
    const s = e.getProperties();
    s.coordinates = n;
    const o = i[i.length - 1].node,
      a = dW[o.namespaceURI],
      l = Vy(s, a);
    Yy(r, gW, qy, l, i, a);
  }
  const pW = Xy(EC, ["color", "fill", "outline"]),
    mW = Xy(EC, { outerBoundaryIs: jy(aW), innerBoundaryIs: jy(aW) }),
    _W = Uy("innerBoundaryIs"),
    yW = Uy("outerBoundaryIs");
  function xW(t, e, i) {
    const n = e.getLinearRings(),
      r = n.shift(),
      s = { node: t };
    Yy(s, mW, _W, n, i), Yy(s, mW, yW, [r], i);
  }
  const vW = Xy(EC, { color: jy(Dw), fill: jy(mS), outline: jy(mS) });
  function SW(t, e) {
    xS(t, Math.round(1e6 * e) / 1e6);
  }
  const CW = Xy(EC, ["IconStyle", "LabelStyle", "LineStyle", "PolyStyle"]),
    wW = Xy(EC, {
      IconStyle: jy(function (t, e, i) {
        const n = { node: t },
          r = {},
          s = e.getSrc(),
          o = e.getSize(),
          a = e.getImageSize(),
          l = { href: s };
        if (o) {
          (l.w = o[0]), (l.h = o[1]);
          const t = e.getAnchor(),
            i = e.getOrigin();
          if (
            (i &&
              a &&
              0 !== i[0] &&
              i[1] !== o[1] &&
              ((l.x = i[0]), (l.y = a[1] - (i[1] + o[1]))),
            t && (t[0] !== o[0] / 2 || t[1] !== o[1] / 2))
          ) {
            const e = {
              x: t[0],
              xunits: "pixels",
              y: o[1] - t[1],
              yunits: "pixels",
            };
            r.hotSpot = e;
          }
        }
        r.Icon = l;
        let h = e.getScaleArray()[0],
          c = o;
        if ((null === c && (c = DC), 2 == c.length)) {
          h /= HC(c);
        }
        1 !== h && (r.scale = h);
        const u = e.getRotation();
        0 !== u && (r.heading = u);
        const d = e.getColor();
        d && (r.color = d);
        const g = i[i.length - 1].node,
          f = Xw[g.namespaceURI],
          p = Vy(r, f);
        Yy(n, Zw, qy, p, i, f);
      }),
      LabelStyle: jy(function (t, e, i) {
        const n = { node: t },
          r = {},
          s = e.getFill();
        s && (r.color = s.getColor());
        const o = e.getScale();
        o && 1 !== o && (r.scale = o);
        const a = i[i.length - 1].node,
          l = Kw[a.namespaceURI],
          h = Vy(r, l);
        Yy(n, Hw, qy, h, i, l);
      }),
      LineStyle: jy(function (t, e, i) {
        const n = { node: t },
          r = { color: e.getColor(), width: Number(e.getWidth()) || 1 },
          s = i[i.length - 1].node,
          o = Yw[s.namespaceURI],
          a = Vy(r, o);
        Yy(n, Qw, qy, a, i, o);
      }),
      PolyStyle: jy(function (t, e, i) {
        const n = { node: t },
          r = e.getFill(),
          s = e.getStroke(),
          o = {
            color: r ? r.getColor() : void 0,
            fill: !!r && void 0,
            outline: !!s && void 0,
          },
          a = i[i.length - 1].node,
          l = pW[a.namespaceURI],
          h = Vy(o, l);
        Yy(n, vW, qy, h, i, l);
      }),
    });
  var WW = class extends nS {
      constructor(t) {
        super(),
          (t = t || {}),
          KC ||
            ((OC = [255, 255, 255, 1]),
            (BC = new Ol({ color: OC })),
            (kC = [20, 2]),
            (AC = "pixels"),
            (NC = "pixels"),
            (DC = [64, 64]),
            (GC =
              "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png"),
            (zC = new bh({
              anchor: kC,
              anchorOrigin: "bottom-left",
              anchorXUnits: AC,
              anchorYUnits: NC,
              crossOrigin: "anonymous",
              rotation: 0,
              scale: HC(DC),
              size: DC,
              src: GC,
            })),
            (jC = "NO_IMAGE"),
            (qC = new zl({ color: OC, width: 1 })),
            (UC = new zl({ color: [51, 51, 51, 1], width: 2 })),
            (VC = new rh({
              font: "bold 16px Helvetica",
              fill: BC,
              stroke: UC,
              scale: 0.8,
            })),
            (XC = new ih({
              fill: BC,
              image: zC,
              text: VC,
              stroke: qC,
              zIndex: 0,
            })),
            (KC = [XC])),
          (this.dataProjection = tn("EPSG:4326")),
          (this.defaultStyle_ = t.defaultStyle ? t.defaultStyle : KC),
          (this.extractStyles_ = void 0 === t.extractStyles || t.extractStyles),
          (this.writeStyles_ = void 0 === t.writeStyles || t.writeStyles),
          (this.sharedStyles_ = {}),
          (this.showPointNames_ =
            void 0 === t.showPointNames || t.showPointNames),
          (this.crossOrigin_ =
            void 0 !== t.crossOrigin ? t.crossOrigin : "anonymous"),
          (this.iconUrlFunction_ = t.iconUrlFunction ? t.iconUrlFunction : YC),
          (this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"]);
      }
      readDocumentOrFolder_(t, e) {
        const i = Ky(
          [],
          Xy(EC, {
            Document: Ay(this.readDocumentOrFolder_, this),
            Folder: Ay(this.readDocumentOrFolder_, this),
            Placemark: Ny(this.readPlacemark_, this),
            Style: this.readSharedStyle_.bind(this),
            StyleMap: this.readSharedStyleMap_.bind(this),
          }),
          t,
          e,
          this
        );
        if (i) return i;
      }
      readPlacemark_(t, e) {
        const i = Ky({ geometry: null }, TC, t, e, this);
        if (!i) return;
        const n = new Mt(),
          r = t.getAttribute("id");
        null !== r && n.setId(r);
        const s = e[0],
          o = i.geometry;
        if (
          (o && Xv(o, !1, s),
          n.setGeometry(o),
          delete i.geometry,
          this.extractStyles_)
        ) {
          const t = (function (t, e, i, n, r) {
            return function (s, o) {
              let a = r,
                l = "",
                h = [];
              if (a) {
                const t = s.getGeometry();
                if (t)
                  if (t instanceof Tx)
                    (h = t.getGeometriesArrayRecursive().filter(function (t) {
                      const e = t.getType();
                      return "Point" === e || "MultiPoint" === e;
                    })),
                      (a = h.length > 0);
                  else {
                    const e = t.getType();
                    a = "Point" === e || "MultiPoint" === e;
                  }
              }
              a &&
                ((l = s.get("name")),
                (a = a && !!l),
                a &&
                  /&[^&]+;/.test(l) &&
                  (ZC || (ZC = document.createElement("textarea")),
                  (ZC.innerHTML = l),
                  (l = ZC.value)));
              let c = i;
              if ((t ? (c = t) : e && (c = QC(e, i, n)), a)) {
                const t = (function (t, e) {
                  const i = [0, 0];
                  let n = "start";
                  const r = t.getImage();
                  if (r) {
                    const t = r.getSize();
                    if (t && 2 == t.length) {
                      const e = r.getScaleArray(),
                        s = r.getAnchor();
                      (i[0] = e[0] * (t[0] - s[0])),
                        (i[1] = e[1] * (t[1] / 2 - s[1])),
                        (n = "left");
                    }
                  }
                  let s = t.getText();
                  s
                    ? ((s = s.clone()),
                      s.setFont(s.getFont() || VC.getFont()),
                      s.setScale(s.getScale() || VC.getScale()),
                      s.setFill(s.getFill() || VC.getFill()),
                      s.setStroke(s.getStroke() || UC))
                    : (s = VC.clone());
                  s.setText(e),
                    s.setOffsetX(i[0]),
                    s.setOffsetY(i[1]),
                    s.setTextAlign(n);
                  const o = new ih({ image: r, text: s });
                  return o;
                })(c[0], l);
                if (h.length > 0) {
                  t.setGeometry(new Tx(h));
                  return [
                    t,
                    new ih({
                      geometry: c[0].getGeometry(),
                      image: null,
                      fill: c[0].getFill(),
                      stroke: c[0].getStroke(),
                      text: null,
                    }),
                  ].concat(c.slice(1));
                }
                return t;
              }
              return c;
            };
          })(
            i.Style,
            i.styleUrl,
            this.defaultStyle_,
            this.sharedStyles_,
            this.showPointNames_
          );
          n.setStyle(t);
        }
        return delete i.Style, n.setProperties(i, !0), n;
      }
      readSharedStyle_(t, e) {
        const i = t.getAttribute("id");
        if (null !== i) {
          const n = Rw.call(this, t, e);
          if (n) {
            let e,
              r = t.baseURI;
            if (((r && "about:blank" != r) || (r = window.location.href), r)) {
              e = new URL("#" + i, r).href;
            } else e = "#" + i;
            this.sharedStyles_[e] = n;
          }
        }
      }
      readSharedStyleMap_(t, e) {
        const i = t.getAttribute("id");
        if (null === i) return;
        const n = rw.call(this, t, e);
        if (!n) return;
        let r,
          s = t.baseURI;
        if (((s && "about:blank" != s) || (s = window.location.href), s)) {
          r = new URL("#" + i, s).href;
        } else r = "#" + i;
        this.sharedStyles_[r] = n;
      }
      readFeatureFromNode(t, e) {
        if (!EC.includes(t.namespaceURI)) return null;
        const i = this.readPlacemark_(t, [this.getReadOptions(t, e)]);
        return i || null;
      }
      readFeaturesFromNode(t, e) {
        if (!EC.includes(t.namespaceURI)) return [];
        let i;
        const n = t.localName;
        if ("Document" == n || "Folder" == n)
          return (
            (i = this.readDocumentOrFolder_(t, [this.getReadOptions(t, e)])),
            i || []
          );
        if ("Placemark" == n) {
          const i = this.readPlacemark_(t, [this.getReadOptions(t, e)]);
          return i ? [i] : [];
        }
        if ("kml" == n) {
          i = [];
          for (let n = t.firstElementChild; n; n = n.nextElementSibling) {
            const t = this.readFeaturesFromNode(n, e);
            t && h(i, t);
          }
          return i;
        }
        return [];
      }
      readName(t) {
        if (t) {
          if ("string" == typeof t) {
            const e = ky(t);
            return this.readNameFromDocument(e);
          }
          return My(t)
            ? this.readNameFromDocument(t)
            : this.readNameFromNode(t);
        }
      }
      readNameFromDocument(t) {
        for (let e = t.firstChild; e; e = e.nextSibling)
          if (e.nodeType == Node.ELEMENT_NODE) {
            const t = this.readNameFromNode(e);
            if (t) return t;
          }
      }
      readNameFromNode(t) {
        for (let e = t.firstElementChild; e; e = e.nextElementSibling)
          if (EC.includes(e.namespaceURI) && "name" == e.localName)
            return pS(e);
        for (let e = t.firstElementChild; e; e = e.nextElementSibling) {
          const t = e.localName;
          if (
            EC.includes(e.namespaceURI) &&
            ("Document" == t || "Folder" == t || "Placemark" == t || "kml" == t)
          ) {
            const t = this.readNameFromNode(e);
            if (t) return t;
          }
        }
      }
      readNetworkLinks(t) {
        const e = [];
        if ("string" == typeof t) {
          const i = ky(t);
          h(e, this.readNetworkLinksFromDocument(i));
        } else
          My(t)
            ? h(e, this.readNetworkLinksFromDocument(t))
            : h(e, this.readNetworkLinksFromNode(t));
        return e;
      }
      readNetworkLinksFromDocument(t) {
        const e = [];
        for (let i = t.firstChild; i; i = i.nextSibling)
          i.nodeType == Node.ELEMENT_NODE &&
            h(e, this.readNetworkLinksFromNode(i));
        return e;
      }
      readNetworkLinksFromNode(t) {
        const e = [];
        for (let i = t.firstElementChild; i; i = i.nextElementSibling)
          if (EC.includes(i.namespaceURI) && "NetworkLink" == i.localName) {
            const t = Ky({}, PC, i, []);
            e.push(t);
          }
        for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
          const t = i.localName;
          !EC.includes(i.namespaceURI) ||
            ("Document" != t && "Folder" != t && "kml" != t) ||
            h(e, this.readNetworkLinksFromNode(i));
        }
        return e;
      }
      readRegion(t) {
        const e = [];
        if ("string" == typeof t) {
          const i = ky(t);
          h(e, this.readRegionFromDocument(i));
        } else
          My(t)
            ? h(e, this.readRegionFromDocument(t))
            : h(e, this.readRegionFromNode(t));
        return e;
      }
      readRegionFromDocument(t) {
        const e = [];
        for (let i = t.firstChild; i; i = i.nextSibling)
          i.nodeType == Node.ELEMENT_NODE && h(e, this.readRegionFromNode(i));
        return e;
      }
      readRegionFromNode(t) {
        const e = [];
        for (let i = t.firstElementChild; i; i = i.nextElementSibling)
          if (EC.includes(i.namespaceURI) && "Region" == i.localName) {
            const t = Ky({}, IC, i, []);
            e.push(t);
          }
        for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
          const t = i.localName;
          !EC.includes(i.namespaceURI) ||
            ("Document" != t && "Folder" != t && "kml" != t) ||
            h(e, this.readRegionFromNode(i));
        }
        return e;
      }
      readCamera(t) {
        const e = [];
        if ("string" == typeof t) {
          const i = ky(t);
          h(e, this.readCameraFromDocument(i));
        } else
          My(t)
            ? h(e, this.readCameraFromDocument(t))
            : h(e, this.readCameraFromNode(t));
        return e;
      }
      readCameraFromDocument(t) {
        const e = [];
        for (let i = t.firstChild; i; i = i.nextSibling)
          i.nodeType === Node.ELEMENT_NODE && h(e, this.readCameraFromNode(i));
        return e;
      }
      readCameraFromNode(t) {
        const e = [];
        for (let i = t.firstElementChild; i; i = i.nextElementSibling)
          if (EC.includes(i.namespaceURI) && "Camera" === i.localName) {
            const t = Ky({}, FC, i, []);
            e.push(t);
          }
        for (let i = t.firstElementChild; i; i = i.nextElementSibling) {
          const t = i.localName;
          !EC.includes(i.namespaceURI) ||
            ("Document" !== t &&
              "Folder" !== t &&
              "Placemark" !== t &&
              "kml" !== t) ||
            h(e, this.readCameraFromNode(i));
        }
        return e;
      }
      writeFeaturesNode(t, e) {
        e = this.adaptOptions(e);
        const i = Fy(EC[4], "kml"),
          n = "http://www.w3.org/2000/xmlns/";
        i.setAttributeNS(n, "xmlns:gx", WC[0]),
          i.setAttributeNS(n, "xmlns:xsi", by),
          i.setAttributeNS(
            by,
            "xsi:schemaLocation",
            "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd"
          );
        const r = { node: i },
          s = {};
        t.length > 1 ? (s.Document = t) : 1 == t.length && (s.Placemark = t[0]);
        const o = LC[i.namespaceURI],
          a = Vy(s, o);
        return Yy(r, MC, qy, a, [e], o, this), i;
      }
    },
    EW = {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      read: function (t, e, i, n, r) {
        var s,
          o,
          a = 8 * r - n - 1,
          l = (1 << a) - 1,
          h = l >> 1,
          c = -7,
          u = i ? r - 1 : 0,
          d = i ? -1 : 1,
          g = t[e + u];
        for (
          u += d, s = g & ((1 << -c) - 1), g >>= -c, c += a;
          c > 0;
          s = 256 * s + t[e + u], u += d, c -= 8
        );
        for (
          o = s & ((1 << -c) - 1), s >>= -c, c += n;
          c > 0;
          o = 256 * o + t[e + u], u += d, c -= 8
        );
        if (0 === s) s = 1 - h;
        else {
          if (s === l) return o ? NaN : (1 / 0) * (g ? -1 : 1);
          (o += Math.pow(2, n)), (s -= h);
        }
        return (g ? -1 : 1) * o * Math.pow(2, s - n);
      },
      write: function (t, e, i, n, r, s) {
        var o,
          a,
          l,
          h = 8 * s - r - 1,
          c = (1 << h) - 1,
          u = c >> 1,
          d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          g = n ? 0 : s - 1,
          f = n ? 1 : -1,
          p = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
        for (
          e = Math.abs(e),
            isNaN(e) || e === 1 / 0
              ? ((a = isNaN(e) ? 1 : 0), (o = c))
              : ((o = Math.floor(Math.log(e) / Math.LN2)),
                e * (l = Math.pow(2, -o)) < 1 && (o--, (l *= 2)),
                (e += o + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 &&
                  (o++, (l /= 2)),
                o + u >= c
                  ? ((a = 0), (o = c))
                  : o + u >= 1
                  ? ((a = (e * l - 1) * Math.pow(2, r)), (o += u))
                  : ((a = e * Math.pow(2, u - 1) * Math.pow(2, r)), (o = 0)));
          r >= 8;
          t[i + g] = 255 & a, g += f, a /= 256, r -= 8
        );
        for (
          o = (o << r) | a, h += r;
          h > 0;
          t[i + g] = 255 & o, g += f, o /= 256, h -= 8
        );
        t[i + g - f] |= 128 * p;
      },
    },
    RW = PW,
    TW = EW;
  function PW(t) {
    (this.buf =
      ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0)),
      (this.pos = 0),
      (this.type = 0),
      (this.length = this.buf.length);
  }
  (PW.Varint = 0), (PW.Fixed64 = 1), (PW.Bytes = 2), (PW.Fixed32 = 5);
  var bW = 4294967296,
    FW = 1 / bW,
    IW = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
  function LW(t) {
    return t.type === PW.Bytes ? t.readVarint() + t.pos : t.pos + 1;
  }
  function MW(t, e, i) {
    return i ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);
  }
  function OW(t, e, i) {
    var n =
      e <= 16383
        ? 1
        : e <= 2097151
        ? 2
        : e <= 268435455
        ? 3
        : Math.floor(Math.log(e) / (7 * Math.LN2));
    i.realloc(n);
    for (var r = i.pos - 1; r >= t; r--) i.buf[r + n] = i.buf[r];
  }
  function kW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeVarint(t[i]);
  }
  function AW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeSVarint(t[i]);
  }
  function NW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeFloat(t[i]);
  }
  function DW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeDouble(t[i]);
  }
  function GW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeBoolean(t[i]);
  }
  function BW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeFixed32(t[i]);
  }
  function jW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeSFixed32(t[i]);
  }
  function zW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeFixed64(t[i]);
  }
  function UW(t, e) {
    for (var i = 0; i < t.length; i++) e.writeSFixed64(t[i]);
  }
  function qW(t, e) {
    return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + 16777216 * t[e + 3];
  }
  function VW(t, e, i) {
    (t[i] = e),
      (t[i + 1] = e >>> 8),
      (t[i + 2] = e >>> 16),
      (t[i + 3] = e >>> 24);
  }
  function XW(t, e) {
    return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16)) + (t[e + 3] << 24);
  }
  PW.prototype = {
    destroy: function () {
      this.buf = null;
    },
    readFields: function (t, e, i) {
      for (i = i || this.length; this.pos < i; ) {
        var n = this.readVarint(),
          r = n >> 3,
          s = this.pos;
        (this.type = 7 & n), t(r, e, this), this.pos === s && this.skip(n);
      }
      return e;
    },
    readMessage: function (t, e) {
      return this.readFields(t, e, this.readVarint() + this.pos);
    },
    readFixed32: function () {
      var t = qW(this.buf, this.pos);
      return (this.pos += 4), t;
    },
    readSFixed32: function () {
      var t = XW(this.buf, this.pos);
      return (this.pos += 4), t;
    },
    readFixed64: function () {
      var t = qW(this.buf, this.pos) + qW(this.buf, this.pos + 4) * bW;
      return (this.pos += 8), t;
    },
    readSFixed64: function () {
      var t = qW(this.buf, this.pos) + XW(this.buf, this.pos + 4) * bW;
      return (this.pos += 8), t;
    },
    readFloat: function () {
      var t = TW.read(this.buf, this.pos, !0, 23, 4);
      return (this.pos += 4), t;
    },
    readDouble: function () {
      var t = TW.read(this.buf, this.pos, !0, 52, 8);
      return (this.pos += 8), t;
    },
    readVarint: function (t) {
      var e,
        i,
        n = this.buf;
      return (
        (e = 127 & (i = n[this.pos++])),
        i < 128
          ? e
          : ((e |= (127 & (i = n[this.pos++])) << 7),
            i < 128
              ? e
              : ((e |= (127 & (i = n[this.pos++])) << 14),
                i < 128
                  ? e
                  : ((e |= (127 & (i = n[this.pos++])) << 21),
                    i < 128
                      ? e
                      : (function (t, e, i) {
                          var n,
                            r,
                            s = i.buf;
                          if (((r = s[i.pos++]), (n = (112 & r) >> 4), r < 128))
                            return MW(t, n, e);
                          if (
                            ((r = s[i.pos++]), (n |= (127 & r) << 3), r < 128)
                          )
                            return MW(t, n, e);
                          if (
                            ((r = s[i.pos++]), (n |= (127 & r) << 10), r < 128)
                          )
                            return MW(t, n, e);
                          if (
                            ((r = s[i.pos++]), (n |= (127 & r) << 17), r < 128)
                          )
                            return MW(t, n, e);
                          if (
                            ((r = s[i.pos++]), (n |= (127 & r) << 24), r < 128)
                          )
                            return MW(t, n, e);
                          if (((r = s[i.pos++]), (n |= (1 & r) << 31), r < 128))
                            return MW(t, n, e);
                          throw new Error(
                            "Expected varint not more than 10 bytes"
                          );
                        })((e |= (15 & (i = n[this.pos])) << 28), t, this))))
      );
    },
    readVarint64: function () {
      return this.readVarint(!0);
    },
    readSVarint: function () {
      var t = this.readVarint();
      return t % 2 == 1 ? (t + 1) / -2 : t / 2;
    },
    readBoolean: function () {
      return Boolean(this.readVarint());
    },
    readString: function () {
      var t = this.readVarint() + this.pos,
        e = this.pos;
      return (
        (this.pos = t),
        t - e >= 12 && IW
          ? (function (t, e, i) {
              return IW.decode(t.subarray(e, i));
            })(this.buf, e, t)
          : (function (t, e, i) {
              var n = "",
                r = e;
              for (; r < i; ) {
                var s,
                  o,
                  a,
                  l = t[r],
                  h = null,
                  c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                if (r + c > i) break;
                1 === c
                  ? l < 128 && (h = l)
                  : 2 === c
                  ? 128 == (192 & (s = t[r + 1])) &&
                    (h = ((31 & l) << 6) | (63 & s)) <= 127 &&
                    (h = null)
                  : 3 === c
                  ? ((s = t[r + 1]),
                    (o = t[r + 2]),
                    128 == (192 & s) &&
                      128 == (192 & o) &&
                      ((h = ((15 & l) << 12) | ((63 & s) << 6) | (63 & o)) <=
                        2047 ||
                        (h >= 55296 && h <= 57343)) &&
                      (h = null))
                  : 4 === c &&
                    ((s = t[r + 1]),
                    (o = t[r + 2]),
                    (a = t[r + 3]),
                    128 == (192 & s) &&
                      128 == (192 & o) &&
                      128 == (192 & a) &&
                      ((h =
                        ((15 & l) << 18) |
                        ((63 & s) << 12) |
                        ((63 & o) << 6) |
                        (63 & a)) <= 65535 ||
                        h >= 1114112) &&
                      (h = null)),
                  null === h
                    ? ((h = 65533), (c = 1))
                    : h > 65535 &&
                      ((h -= 65536),
                      (n += String.fromCharCode(((h >>> 10) & 1023) | 55296)),
                      (h = 56320 | (1023 & h))),
                  (n += String.fromCharCode(h)),
                  (r += c);
              }
              return n;
            })(this.buf, e, t)
      );
    },
    readBytes: function () {
      var t = this.readVarint() + this.pos,
        e = this.buf.subarray(this.pos, t);
      return (this.pos = t), e;
    },
    readPackedVarint: function (t, e) {
      if (this.type !== PW.Bytes) return t.push(this.readVarint(e));
      var i = LW(this);
      for (t = t || []; this.pos < i; ) t.push(this.readVarint(e));
      return t;
    },
    readPackedSVarint: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readSVarint());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readSVarint());
      return t;
    },
    readPackedBoolean: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readBoolean());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readBoolean());
      return t;
    },
    readPackedFloat: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readFloat());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readFloat());
      return t;
    },
    readPackedDouble: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readDouble());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readDouble());
      return t;
    },
    readPackedFixed32: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readFixed32());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readFixed32());
      return t;
    },
    readPackedSFixed32: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readSFixed32());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readSFixed32());
      return t;
    },
    readPackedFixed64: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readFixed64());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readFixed64());
      return t;
    },
    readPackedSFixed64: function (t) {
      if (this.type !== PW.Bytes) return t.push(this.readSFixed64());
      var e = LW(this);
      for (t = t || []; this.pos < e; ) t.push(this.readSFixed64());
      return t;
    },
    skip: function (t) {
      var e = 7 & t;
      if (e === PW.Varint) for (; this.buf[this.pos++] > 127; );
      else if (e === PW.Bytes) this.pos = this.readVarint() + this.pos;
      else if (e === PW.Fixed32) this.pos += 4;
      else {
        if (e !== PW.Fixed64) throw new Error("Unimplemented type: " + e);
        this.pos += 8;
      }
    },
    writeTag: function (t, e) {
      this.writeVarint((t << 3) | e);
    },
    realloc: function (t) {
      for (var e = this.length || 16; e < this.pos + t; ) e *= 2;
      if (e !== this.length) {
        var i = new Uint8Array(e);
        i.set(this.buf), (this.buf = i), (this.length = e);
      }
    },
    finish: function () {
      return (
        (this.length = this.pos),
        (this.pos = 0),
        this.buf.subarray(0, this.length)
      );
    },
    writeFixed32: function (t) {
      this.realloc(4), VW(this.buf, t, this.pos), (this.pos += 4);
    },
    writeSFixed32: function (t) {
      this.realloc(4), VW(this.buf, t, this.pos), (this.pos += 4);
    },
    writeFixed64: function (t) {
      this.realloc(8),
        VW(this.buf, -1 & t, this.pos),
        VW(this.buf, Math.floor(t * FW), this.pos + 4),
        (this.pos += 8);
    },
    writeSFixed64: function (t) {
      this.realloc(8),
        VW(this.buf, -1 & t, this.pos),
        VW(this.buf, Math.floor(t * FW), this.pos + 4),
        (this.pos += 8);
    },
    writeVarint: function (t) {
      (t = +t || 0) > 268435455 || t < 0
        ? (function (t, e) {
            var i, n;
            t >= 0
              ? ((i = t % 4294967296 | 0), (n = (t / 4294967296) | 0))
              : ((n = ~(-t / 4294967296)),
                4294967295 ^ (i = ~(-t % 4294967296))
                  ? (i = (i + 1) | 0)
                  : ((i = 0), (n = (n + 1) | 0)));
            if (t >= 0x10000000000000000 || t < -0x10000000000000000)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e.realloc(10),
              (function (t, e, i) {
                (i.buf[i.pos++] = (127 & t) | 128),
                  (t >>>= 7),
                  (i.buf[i.pos++] = (127 & t) | 128),
                  (t >>>= 7),
                  (i.buf[i.pos++] = (127 & t) | 128),
                  (t >>>= 7),
                  (i.buf[i.pos++] = (127 & t) | 128),
                  (t >>>= 7),
                  (i.buf[i.pos] = 127 & t);
              })(i, 0, e),
              (function (t, e) {
                var i = (7 & t) << 4;
                if (((e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0)), !t))
                  return;
                if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                  return;
                if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                  return;
                if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                  return;
                if (((e.buf[e.pos++] = (127 & t) | ((t >>>= 7) ? 128 : 0)), !t))
                  return;
                e.buf[e.pos++] = 127 & t;
              })(n, e);
          })(t, this)
        : (this.realloc(4),
          (this.buf[this.pos++] = (127 & t) | (t > 127 ? 128 : 0)),
          t <= 127 ||
            ((this.buf[this.pos++] = (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
            t <= 127 ||
              ((this.buf[this.pos++] =
                (127 & (t >>>= 7)) | (t > 127 ? 128 : 0)),
              t <= 127 || (this.buf[this.pos++] = (t >>> 7) & 127))));
    },
    writeSVarint: function (t) {
      this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
    },
    writeBoolean: function (t) {
      this.writeVarint(Boolean(t));
    },
    writeString: function (t) {
      (t = String(t)), this.realloc(4 * t.length), this.pos++;
      var e = this.pos;
      this.pos = (function (t, e, i) {
        for (var n, r, s = 0; s < e.length; s++) {
          if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
            if (!r) {
              n > 56319 || s + 1 === e.length
                ? ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189))
                : (r = n);
              continue;
            }
            if (n < 56320) {
              (t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (r = n);
              continue;
            }
            (n = ((r - 55296) << 10) | (n - 56320) | 65536), (r = null);
          } else
            r && ((t[i++] = 239), (t[i++] = 191), (t[i++] = 189), (r = null));
          n < 128
            ? (t[i++] = n)
            : (n < 2048
                ? (t[i++] = (n >> 6) | 192)
                : (n < 65536
                    ? (t[i++] = (n >> 12) | 224)
                    : ((t[i++] = (n >> 18) | 240),
                      (t[i++] = ((n >> 12) & 63) | 128)),
                  (t[i++] = ((n >> 6) & 63) | 128)),
              (t[i++] = (63 & n) | 128));
        }
        return i;
      })(this.buf, t, this.pos);
      var i = this.pos - e;
      i >= 128 && OW(e, i, this),
        (this.pos = e - 1),
        this.writeVarint(i),
        (this.pos += i);
    },
    writeFloat: function (t) {
      this.realloc(4),
        TW.write(this.buf, t, this.pos, !0, 23, 4),
        (this.pos += 4);
    },
    writeDouble: function (t) {
      this.realloc(8),
        TW.write(this.buf, t, this.pos, !0, 52, 8),
        (this.pos += 8);
    },
    writeBytes: function (t) {
      var e = t.length;
      this.writeVarint(e), this.realloc(e);
      for (var i = 0; i < e; i++) this.buf[this.pos++] = t[i];
    },
    writeRawMessage: function (t, e) {
      this.pos++;
      var i = this.pos;
      t(e, this);
      var n = this.pos - i;
      n >= 128 && OW(i, n, this),
        (this.pos = i - 1),
        this.writeVarint(n),
        (this.pos += n);
    },
    writeMessage: function (t, e, i) {
      this.writeTag(t, PW.Bytes), this.writeRawMessage(e, i);
    },
    writePackedVarint: function (t, e) {
      e.length && this.writeMessage(t, kW, e);
    },
    writePackedSVarint: function (t, e) {
      e.length && this.writeMessage(t, AW, e);
    },
    writePackedBoolean: function (t, e) {
      e.length && this.writeMessage(t, GW, e);
    },
    writePackedFloat: function (t, e) {
      e.length && this.writeMessage(t, NW, e);
    },
    writePackedDouble: function (t, e) {
      e.length && this.writeMessage(t, DW, e);
    },
    writePackedFixed32: function (t, e) {
      e.length && this.writeMessage(t, BW, e);
    },
    writePackedSFixed32: function (t, e) {
      e.length && this.writeMessage(t, jW, e);
    },
    writePackedFixed64: function (t, e) {
      e.length && this.writeMessage(t, zW, e);
    },
    writePackedSFixed64: function (t, e) {
      e.length && this.writeMessage(t, UW, e);
    },
    writeBytesField: function (t, e) {
      this.writeTag(t, PW.Bytes), this.writeBytes(e);
    },
    writeFixed32Field: function (t, e) {
      this.writeTag(t, PW.Fixed32), this.writeFixed32(e);
    },
    writeSFixed32Field: function (t, e) {
      this.writeTag(t, PW.Fixed32), this.writeSFixed32(e);
    },
    writeFixed64Field: function (t, e) {
      this.writeTag(t, PW.Fixed64), this.writeFixed64(e);
    },
    writeSFixed64Field: function (t, e) {
      this.writeTag(t, PW.Fixed64), this.writeSFixed64(e);
    },
    writeVarintField: function (t, e) {
      this.writeTag(t, PW.Varint), this.writeVarint(e);
    },
    writeSVarintField: function (t, e) {
      this.writeTag(t, PW.Varint), this.writeSVarint(e);
    },
    writeStringField: function (t, e) {
      this.writeTag(t, PW.Bytes), this.writeString(e);
    },
    writeFloatField: function (t, e) {
      this.writeTag(t, PW.Fixed32), this.writeFloat(e);
    },
    writeDoubleField: function (t, e) {
      this.writeTag(t, PW.Fixed64), this.writeDouble(e);
    },
    writeBooleanField: function (t, e) {
      this.writeVarintField(t, Boolean(e));
    },
  };
  var ZW = bd(RW);
  function KW(t, e, i) {
    if (3 === t) {
      const t = { keys: [], values: [], features: [] },
        n = i.readVarint() + i.pos;
      i.readFields(HW, t, n),
        (t.length = t.features.length),
        t.length && (e[t.name] = t);
    }
  }
  function HW(t, e, i) {
    if (15 === t) e.version = i.readVarint();
    else if (1 === t) e.name = i.readString();
    else if (5 === t) e.extent = i.readVarint();
    else if (2 === t) e.features.push(i.pos);
    else if (3 === t) e.keys.push(i.readString());
    else if (4 === t) {
      let n = null;
      const r = i.readVarint() + i.pos;
      for (; i.pos < r; )
        n =
          1 === (t = i.readVarint() >> 3)
            ? i.readString()
            : 2 === t
            ? i.readFloat()
            : 3 === t
            ? i.readDouble()
            : 4 === t
            ? i.readVarint64()
            : 5 === t
            ? i.readVarint()
            : 6 === t
            ? i.readSVarint()
            : 7 === t
            ? i.readBoolean()
            : null;
      e.values.push(n);
    }
  }
  function YW(t, e, i) {
    if (1 == t) e.id = i.readVarint();
    else if (2 == t) {
      const t = i.readVarint() + i.pos;
      for (; i.pos < t; ) {
        const t = e.layer.keys[i.readVarint()],
          n = e.layer.values[i.readVarint()];
        e.properties[t] = n;
      }
    } else 3 == t ? (e.type = i.readVarint()) : 4 == t && (e.geometry = i.pos);
  }
  function QW(t, e, i) {
    t.pos = e.features[i];
    const n = t.readVarint() + t.pos,
      r = { layer: e, type: 0, properties: {} };
    return t.readFields(YW, r, n), r;
  }
  var $W = class extends Vv {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.dataProjection = new ze({ code: "", units: "tile-pixels" })),
        (this.featureClass_ = t.featureClass ? t.featureClass : Dx),
        (this.geometryName_ = t.geometryName),
        (this.layerName_ = t.layerName ? t.layerName : "layer"),
        (this.layers_ = t.layers ? t.layers : null),
        (this.idProperty_ = t.idProperty),
        (this.supportedMediaTypes = [
          "application/vnd.mapbox-vector-tile",
          "application/x-protobuf",
        ]);
    }
    readRawGeometry_(t, e, i, n) {
      t.pos = e.geometry;
      const r = t.readVarint() + t.pos;
      let s = 1,
        o = 0,
        a = 0,
        l = 0,
        h = 0,
        c = 0;
      for (; t.pos < r; ) {
        if (!o) {
          const e = t.readVarint();
          (s = 7 & e), (o = e >> 3);
        }
        if ((o--, 1 === s || 2 === s))
          (a += t.readSVarint()),
            (l += t.readSVarint()),
            1 === s && h > c && (n.push(h), (c = h)),
            i.push(a, l),
            (h += 2);
        else {
          if (7 !== s) throw new Error("Invalid command found in the PBF");
          h > c && (i.push(i[c], i[c + 1]), (h += 2));
        }
      }
      h > c && (n.push(h), (c = h));
    }
    createFeature_(t, e, i) {
      const n = e.type;
      if (0 === n) return null;
      let r;
      const s = e.properties;
      let o;
      this.idProperty_
        ? ((o = s[this.idProperty_]), delete s[this.idProperty_])
        : (o = e.id),
        (s[this.layerName_] = e.layer.name);
      const a = [],
        l = [];
      this.readRawGeometry_(t, e, a, l);
      const h = (function (t, e) {
        let i;
        1 === t
          ? (i = 1 === e ? "Point" : "MultiPoint")
          : 2 === t
          ? (i = 1 === e ? "LineString" : "MultiLineString")
          : 3 === t && (i = "Polygon");
        return i;
      })(n, l.length);
      if (this.featureClass_ === Dx)
        (r = new this.featureClass_(h, a, l, s, o)),
          r.transform(i.dataProjection);
      else {
        let t;
        if ("Polygon" == h) {
          const e = Er(a, l);
          t = e.length > 1 ? new Ox(a, "XY", e) : new Tr(a, "XY", l);
        } else
          t =
            "Point" === h
              ? new or(a, "XY")
              : "LineString" === h
              ? new Bl(a, "XY")
              : "MultiPoint" === h
              ? new Ix(a, "XY")
              : "MultiLineString" === h
              ? new bx(a, "XY", l)
              : null;
        (r = new (0, this.featureClass_)()),
          this.geometryName_ && r.setGeometryName(this.geometryName_);
        const e = Xv(t, !1, i);
        r.setGeometry(e), void 0 !== o && r.setId(o), r.setProperties(s, !0);
      }
      return r;
    }
    getType() {
      return "arraybuffer";
    }
    readFeatures(t, e) {
      const i = this.layers_,
        n = tn((e = this.adaptOptions(e)).dataProjection);
      n.setWorldExtent(e.extent), (e.dataProjection = n);
      const r = new ZW(t),
        s = r.readFields(KW, {}),
        o = [];
      for (const t in s) {
        if (i && !i.includes(t)) continue;
        const a = s[t],
          l = a ? [0, 0, a.extent, a.extent] : null;
        n.setExtent(l);
        for (let t = 0, i = a.length; t < i; ++t) {
          const i = QW(r, a, t),
            n = this.createFeature_(r, i, e);
          null !== n && o.push(n);
        }
      }
      return o;
    }
    readProjection(t) {
      return this.dataProjection;
    }
    setLayers(t) {
      this.layers_ = t;
    }
  };
  const JW = [null],
    tE = Xy(JW, {
      nd: function (t, e) {
        const i = e[e.length - 1];
        i.ndrefs.push(t.getAttribute("ref")),
          t.hasAttribute("lon") &&
            t.hasAttribute("lat") &&
            (i.flatCoordinates.push(parseFloat(t.getAttribute("lon"))),
            i.flatCoordinates.push(parseFloat(t.getAttribute("lat"))));
      },
      tag: nE,
    }),
    eE = Xy(JW, {
      node: function (t, e) {
        const i = e[0],
          n = e[e.length - 1],
          r = t.getAttribute("id"),
          s = [
            parseFloat(t.getAttribute("lon")),
            parseFloat(t.getAttribute("lat")),
          ];
        n.nodes[r] = s;
        const o = Ky({ tags: {} }, iE, t, e);
        if (!y(o.tags)) {
          const t = new or(s);
          Xv(t, !1, i);
          const e = new Mt(t);
          void 0 !== r && e.setId(r),
            e.setProperties(o.tags, !0),
            n.features.push(e);
        }
      },
      way: function (t, e) {
        const i = Ky(
          {
            id: t.getAttribute("id"),
            ndrefs: [],
            flatCoordinates: [],
            tags: {},
          },
          tE,
          t,
          e
        );
        e[e.length - 1].ways.push(i);
      },
    });
  const iE = Xy(JW, { tag: nE });
  function nE(t, e) {
    e[e.length - 1].tags[t.getAttribute("k")] = t.getAttribute("v");
  }
  var rE = class extends nS {
    constructor() {
      super(), (this.dataProjection = tn("EPSG:4326"));
    }
    readFeaturesFromNode(t, e) {
      if (((e = this.getReadOptions(t, e)), "osm" == t.localName)) {
        const i = Ky({ nodes: {}, ways: [], features: [] }, eE, t, [e]);
        for (let t = 0; t < i.ways.length; t++) {
          const n = i.ways[t],
            r = n.flatCoordinates;
          if (!r.length)
            for (let t = 0, e = n.ndrefs.length; t < e; t++) {
              h(r, i.nodes[n.ndrefs[t]]);
            }
          let s;
          (s =
            n.ndrefs[0] == n.ndrefs[n.ndrefs.length - 1]
              ? new Tr(r, "XY", [r.length])
              : new Bl(r, "XY")),
            Xv(s, !1, e);
          const o = new Mt(s);
          void 0 !== n.id && o.setId(n.id),
            o.setProperties(n.tags, !0),
            i.features.push(o);
        }
        if (i.features) return i.features;
      }
      return [];
    }
  };
  var sE = class {
    read(t) {
      if (!t) return null;
      if ("string" == typeof t) {
        const e = ky(t);
        return this.readFromDocument(e);
      }
      return My(t) ? this.readFromDocument(t) : this.readFromNode(t);
    }
    readFromDocument(t) {
      for (let e = t.firstChild; e; e = e.nextSibling)
        if (e.nodeType == Node.ELEMENT_NODE) return this.readFromNode(e);
      return null;
    }
    readFromNode(t) {}
  };
  const oE = "http://www.w3.org/1999/xlink";
  function aE(t) {
    return t.getAttributeNS(oE, "href");
  }
  const lE = [null, "http://www.opengis.net/ows/1.1"],
    hE = Xy(lE, {
      ServiceIdentification: By(function (t, e) {
        return Ky({}, SE, t, e);
      }),
      ServiceProvider: By(function (t, e) {
        return Ky({}, CE, t, e);
      }),
      OperationsMetadata: By(function (t, e) {
        return Ky({}, _E, t, e);
      }),
    });
  const cE = Xy(lE, {
      DeliveryPoint: By(pS),
      City: By(pS),
      AdministrativeArea: By(pS),
      PostalCode: By(pS),
      Country: By(pS),
      ElectronicMailAddress: By(pS),
    }),
    uE = Xy(lE, {
      Value: Gy(function (t, e) {
        return pS(t);
      }),
    }),
    dE = Xy(lE, {
      AllowedValues: By(function (t, e) {
        return Ky({}, uE, t, e);
      }),
    }),
    gE = Xy(lE, {
      Phone: By(function (t, e) {
        return Ky({}, yE, t, e);
      }),
      Address: By(function (t, e) {
        return Ky({}, cE, t, e);
      }),
    }),
    fE = Xy(lE, {
      HTTP: By(function (t, e) {
        return Ky({}, pE, t, e);
      }),
    }),
    pE = Xy(lE, {
      Get: Gy(function (t, e) {
        const i = aE(t);
        if (!i) return;
        return Ky({ href: i }, xE, t, e);
      }),
      Post: void 0,
    }),
    mE = Xy(lE, {
      DCP: By(function (t, e) {
        return Ky({}, fE, t, e);
      }),
    }),
    _E = Xy(lE, {
      Operation: function (t, e) {
        const i = t.getAttribute("name"),
          n = Ky({}, mE, t, e);
        if (!n) return;
        e[e.length - 1][i] = n;
      },
    }),
    yE = Xy(lE, { Voice: By(pS), Facsimile: By(pS) }),
    xE = Xy(lE, {
      Constraint: Gy(function (t, e) {
        const i = t.getAttribute("name");
        if (!i) return;
        return Ky({ name: i }, dE, t, e);
      }),
    }),
    vE = Xy(lE, {
      IndividualName: By(pS),
      PositionName: By(pS),
      ContactInfo: By(function (t, e) {
        return Ky({}, gE, t, e);
      }),
    }),
    SE = Xy(lE, {
      Abstract: By(pS),
      AccessConstraints: By(pS),
      Fees: By(pS),
      Title: By(pS),
      ServiceTypeVersion: By(pS),
      ServiceType: By(pS),
    }),
    CE = Xy(lE, {
      ProviderName: By(pS),
      ProviderSite: By(aE),
      ServiceContact: By(function (t, e) {
        return Ky({}, vE, t, e);
      }),
    });
  var wE = class extends sE {
    constructor() {
      super();
    }
    readFromNode(t) {
      const e = Ky({}, hE, t, []);
      return e || null;
    }
  };
  function WE(t, e, i) {
    let n;
    i = i || 1e5;
    const r = new Array(e);
    for (n = 0; n < e; ++n) r[n] = 0;
    for (let i = 0, s = t.length; i < s; )
      for (n = 0; n < e; ++n, ++i) {
        const e = t[i],
          s = e - r[n];
        (r[n] = e), (t[i] = s);
      }
    return RE(t, i);
  }
  function EE(t, e, i) {
    let n;
    i = i || 1e5;
    const r = new Array(e);
    for (n = 0; n < e; ++n) r[n] = 0;
    const s = TE(t, i);
    for (let t = 0, i = s.length; t < i; )
      for (n = 0; n < e; ++n, ++t) (r[n] += s[t]), (s[t] = r[n]);
    return s;
  }
  function RE(t, e) {
    e = e || 1e5;
    for (let i = 0, n = t.length; i < n; ++i) t[i] = Math.round(t[i] * e);
    return PE(t);
  }
  function TE(t, e) {
    e = e || 1e5;
    const i = bE(t);
    for (let t = 0, n = i.length; t < n; ++t) i[t] /= e;
    return i;
  }
  function PE(t) {
    for (let e = 0, i = t.length; e < i; ++e) {
      const i = t[e];
      t[e] = i < 0 ? ~(i << 1) : i << 1;
    }
    return FE(t);
  }
  function bE(t) {
    const e = IE(t);
    for (let t = 0, i = e.length; t < i; ++t) {
      const i = e[t];
      e[t] = 1 & i ? ~(i >> 1) : i >> 1;
    }
    return e;
  }
  function FE(t) {
    let e = "";
    for (let i = 0, n = t.length; i < n; ++i) e += LE(t[i]);
    return e;
  }
  function IE(t) {
    const e = [];
    let i = 0,
      n = 0;
    for (let r = 0, s = t.length; r < s; ++r) {
      const s = t.charCodeAt(r) - 63;
      (i |= (31 & s) << n), s < 32 ? (e.push(i), (i = 0), (n = 0)) : (n += 5);
    }
    return e;
  }
  function LE(t) {
    let e,
      i = "";
    for (; t >= 32; )
      (e = 63 + (32 | (31 & t))), (i += String.fromCharCode(e)), (t >>= 5);
    return (e = t + 63), (i += String.fromCharCode(e)), i;
  }
  var ME = class extends yC {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.dataProjection = tn("EPSG:4326")),
        (this.factor_ = t.factor ? t.factor : 1e5),
        (this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY");
    }
    readFeatureFromText(t, e) {
      const i = this.readGeometryFromText(t, e);
      return new Mt(i);
    }
    readFeaturesFromText(t, e) {
      return [this.readFeatureFromText(t, e)];
    }
    readGeometryFromText(t, e) {
      const i = Fn(this.geometryLayout_),
        n = EE(t, i, this.factor_);
      qv(n, 0, n.length, i, n);
      const r = Qn(n, 0, n.length, i);
      return Xv(new Bl(r, this.geometryLayout_), !1, this.adaptOptions(e));
    }
    writeFeatureText(t, e) {
      const i = t.getGeometry();
      if (i) return this.writeGeometryText(i, e);
      throw new Error("Expected `feature` to have a geometry");
    }
    writeFeaturesText(t, e) {
      return this.writeFeatureText(t[0], e);
    }
    writeGeometryText(t, e) {
      const i = (t = Xv(t, !0, this.adaptOptions(e))).getFlatCoordinates(),
        n = t.getStride();
      return qv(i, 0, i.length, n, i), WE(i, n, this.factor_);
    }
  };
  const OE = {
    Point: function (t, e, i) {
      const n = t.coordinates;
      e && i && GE(n, e, i);
      return new or(n);
    },
    LineString: function (t, e) {
      const i = kE(t.arcs, e);
      return new Bl(i);
    },
    Polygon: function (t, e) {
      const i = [];
      for (let n = 0, r = t.arcs.length; n < r; ++n) i[n] = kE(t.arcs[n], e);
      return new Tr(i);
    },
    MultiPoint: function (t, e, i) {
      const n = t.coordinates;
      if (e && i) for (let t = 0, r = n.length; t < r; ++t) GE(n[t], e, i);
      return new Ix(n);
    },
    MultiLineString: function (t, e) {
      const i = [];
      for (let n = 0, r = t.arcs.length; n < r; ++n) i[n] = kE(t.arcs[n], e);
      return new bx(i);
    },
    MultiPolygon: function (t, e) {
      const i = [];
      for (let n = 0, r = t.arcs.length; n < r; ++n) {
        const r = t.arcs[n],
          s = [];
        for (let t = 0, i = r.length; t < i; ++t) s[t] = kE(r[t], e);
        i[n] = s;
      }
      return new Ox(i);
    },
  };
  function kE(t, e) {
    const i = [];
    let n;
    for (let r = 0, s = t.length; r < s; ++r)
      if (((n = t[r]), r > 0 && i.pop(), n >= 0)) {
        const t = e[n];
        for (let e = 0, n = t.length; e < n; ++e) i.push(t[e].slice(0));
      } else {
        const t = e[~n];
        for (let e = t.length - 1; e >= 0; --e) i.push(t[e].slice(0));
      }
    return i;
  }
  function AE(t, e, i, n, r, s, o) {
    const a = t.geometries,
      l = [];
    for (let t = 0, h = a.length; t < h; ++t) l[t] = NE(a[t], e, i, n, r, s, o);
    return l;
  }
  function NE(t, e, i, n, r, s, o) {
    let a = null;
    const l = t.type;
    if (l) {
      const r = OE[l];
      (a = "Point" === l || "MultiPoint" === l ? r(t, i, n) : r(t, e)),
        (a = Xv(a, !1, o));
    }
    const h = new Mt({ geometry: a });
    void 0 !== t.id && h.setId(t.id);
    let c = t.properties;
    return r && (c || (c = {}), (c[r] = s)), c && h.setProperties(c, !0), h;
  }
  function DE(t, e, i) {
    let n = 0,
      r = 0;
    for (let s = 0, o = t.length; s < o; ++s) {
      const o = t[s];
      (n += o[0]), (r += o[1]), (o[0] = n), (o[1] = r), GE(o, e, i);
    }
  }
  function GE(t, e, i) {
    (t[0] = t[0] * e[0] + i[0]), (t[1] = t[1] * e[1] + i[1]);
  }
  var BE = class extends Hv {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.layerName_ = t.layerName),
        (this.layers_ = t.layers ? t.layers : null),
        (this.dataProjection = tn(
          t.dataProjection ? t.dataProjection : "EPSG:4326"
        ));
    }
    readFeaturesFromObject(t, e) {
      if ("Topology" == t.type) {
        const i = t;
        let n,
          r = null,
          s = null;
        i.transform && ((n = i.transform), (r = n.scale), (s = n.translate));
        const o = i.arcs;
        n &&
          (function (t, e, i) {
            for (let n = 0, r = t.length; n < r; ++n) DE(t[n], e, i);
          })(o, r, s);
        const a = [],
          l = i.objects,
          h = this.layerName_;
        let c;
        for (const t in l)
          (this.layers_ && !this.layers_.includes(t)) ||
            ("GeometryCollection" === l[t].type
              ? ((c = l[t]), a.push.apply(a, AE(c, o, r, s, h, t, e)))
              : ((c = l[t]), a.push(NE(c, o, r, s, h, t, e))));
        return a;
      }
      return [];
    }
    readProjectionFromObject(t) {
      return this.dataProjection;
    }
  };
  var jE = class {
    constructor(t) {
      this.tagName_ = t;
    }
    getTagName() {
      return this.tagName_;
    }
  };
  var zE = class extends jE {
    constructor(t, e) {
      super(t),
        (this.conditions = e),
        Ft(this.conditions.length >= 2, "At least 2 conditions are required");
    }
  };
  var UE = class extends zE {
    constructor(t) {
      super("And", Array.prototype.slice.call(arguments));
    }
  };
  var qE = class extends jE {
    constructor(t, e, i) {
      if (
        (super("BBOX"),
        (this.geometryName = t),
        (this.extent = e),
        4 !== e.length)
      )
        throw new Error(
          "Expected an extent with four values ([minX, minY, maxX, maxY])"
        );
      this.srsName = i;
    }
  };
  var VE = class extends jE {
    constructor(t, e, i, n) {
      super(t),
        (this.geometryName = e || "the_geom"),
        (this.geometry = i),
        (this.srsName = n);
    }
  };
  var XE = class extends VE {
    constructor(t, e, i) {
      super("Contains", t, e, i);
    }
  };
  var ZE = class extends VE {
    constructor(t, e, i, n, r) {
      super("DWithin", t, e, r), (this.distance = i), (this.unit = n);
    }
  };
  var KE = class extends VE {
    constructor(t, e, i) {
      super("Disjoint", t, e, i);
    }
  };
  var HE = class extends jE {
    constructor(t, e) {
      super(t), (this.propertyName = e);
    }
  };
  var YE = class extends HE {
    constructor(t, e, i) {
      super("During", t), (this.begin = e), (this.end = i);
    }
  };
  var QE = class extends HE {
    constructor(t, e, i, n) {
      super(t, e), (this.expression = i), (this.matchCase = n);
    }
  };
  var $E = class extends QE {
    constructor(t, e, i) {
      super("PropertyIsEqualTo", t, e, i);
    }
  };
  var JE = class extends QE {
    constructor(t, e) {
      super("PropertyIsGreaterThan", t, e);
    }
  };
  var tR = class extends QE {
    constructor(t, e) {
      super("PropertyIsGreaterThanOrEqualTo", t, e);
    }
  };
  var eR = class extends VE {
    constructor(t, e, i) {
      super("Intersects", t, e, i);
    }
  };
  var iR = class extends HE {
    constructor(t, e, i) {
      super("PropertyIsBetween", t),
        (this.lowerBoundary = e),
        (this.upperBoundary = i);
    }
  };
  var nR = class extends HE {
    constructor(t, e, i, n, r, s) {
      super("PropertyIsLike", t),
        (this.pattern = e),
        (this.wildCard = void 0 !== i ? i : "*"),
        (this.singleChar = void 0 !== n ? n : "."),
        (this.escapeChar = void 0 !== r ? r : "!"),
        (this.matchCase = s);
    }
  };
  var rR = class extends HE {
    constructor(t) {
      super("PropertyIsNull", t);
    }
  };
  var sR = class extends QE {
    constructor(t, e) {
      super("PropertyIsLessThan", t, e);
    }
  };
  var oR = class extends QE {
    constructor(t, e) {
      super("PropertyIsLessThanOrEqualTo", t, e);
    }
  };
  var aR = class extends jE {
    constructor(t) {
      super("Not"), (this.condition = t);
    }
  };
  var lR = class extends QE {
    constructor(t, e, i) {
      super("PropertyIsNotEqualTo", t, e, i);
    }
  };
  var hR = class extends zE {
    constructor(t) {
      super("Or", Array.prototype.slice.call(arguments));
    }
  };
  var cR = class extends jE {
    constructor(t) {
      super("ResourceId"), (this.rid = t);
    }
  };
  var uR = class extends VE {
    constructor(t, e, i) {
      super("Within", t, e, i);
    }
  };
  function dR(t) {
    const e = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(UE, e))();
  }
  function gR(t, e, i) {
    return new qE(t, e, i);
  }
  const fR = {
      "http://www.opengis.net/gml": {
        boundedBy: By(aS.prototype.readExtentElement, "bounds"),
      },
      "http://www.opengis.net/wfs/2.0": {
        member: Ny(aS.prototype.readFeaturesInternal),
      },
    },
    pR = {
      "http://www.opengis.net/wfs": {
        totalInserted: By(gS),
        totalUpdated: By(gS),
        totalDeleted: By(gS),
      },
      "http://www.opengis.net/wfs/2.0": {
        totalInserted: By(gS),
        totalUpdated: By(gS),
        totalDeleted: By(gS),
      },
    },
    mR = {
      "http://www.opengis.net/wfs": {
        TransactionSummary: By(TR, "transactionSummary"),
        InsertResults: By(IR, "insertIds"),
      },
      "http://www.opengis.net/wfs/2.0": {
        TransactionSummary: By(TR, "transactionSummary"),
        InsertResults: By(IR, "insertIds"),
      },
    },
    _R = {
      "http://www.opengis.net/wfs": { PropertyName: jy(SS) },
      "http://www.opengis.net/wfs/2.0": { PropertyName: jy(SS) },
    },
    yR = {
      "http://www.opengis.net/wfs": {
        Insert: jy(LR),
        Update: jy(AR),
        Delete: jy(kR),
        Property: jy(NR),
        Native: jy(DR),
      },
      "http://www.opengis.net/wfs/2.0": {
        Insert: jy(LR),
        Update: jy(AR),
        Delete: jy(kR),
        Property: jy(NR),
        Native: jy(DR),
      },
    },
    xR = "feature",
    vR = "http://www.w3.org/2000/xmlns/",
    SR = {
      "2.0.0": "http://www.opengis.net/ogc/1.1",
      "1.1.0": "http://www.opengis.net/ogc",
      "1.0.0": "http://www.opengis.net/ogc",
    },
    CR = {
      "2.0.0": "http://www.opengis.net/wfs/2.0",
      "1.1.0": "http://www.opengis.net/wfs",
      "1.0.0": "http://www.opengis.net/wfs",
    },
    wR = {
      "2.0.0": "http://www.opengis.net/fes/2.0",
      "1.1.0": "http://www.opengis.net/fes",
      "1.0.0": "http://www.opengis.net/fes",
    },
    WR = {
      "2.0.0":
        "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
      "1.1.0":
        "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
      "1.0.0":
        "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd",
    },
    ER = { "2.0.0": MS, "1.1.0": bS, "1.0.0": ES };
  function RR(t, e, i, n) {
    Yy(n, yR, Uy(t), e, i);
  }
  function TR(t, e) {
    return Ky({}, pR, t, e);
  }
  const PR = {
    "http://www.opengis.net/ogc": {
      FeatureId: Ny(function (t, e) {
        return t.getAttribute("fid");
      }),
    },
    "http://www.opengis.net/ogc/1.1": {
      FeatureId: Ny(function (t, e) {
        return t.getAttribute("fid");
      }),
    },
  };
  function bR(t, e) {
    Zy(PR, t, e);
  }
  const FR = {
    "http://www.opengis.net/wfs": { Feature: bR },
    "http://www.opengis.net/wfs/2.0": { Feature: bR },
  };
  function IR(t, e) {
    return Ky([], FR, t, e);
  }
  function LR(t, e, i) {
    const n = i[i.length - 1],
      r = n.featureType,
      s = n.featureNS,
      o = n.gmlVersion,
      a = Fy(s, r);
    t.appendChild(a),
      2 === o
        ? ES.prototype.writeFeatureElement(a, e, i)
        : 3 === o
        ? bS.prototype.writeFeatureElement(a, e, i)
        : MS.prototype.writeFeatureElement(a, e, i);
  }
  function MR(t, e, i) {
    const n = i[i.length - 1].version,
      r = SR[n],
      s = Fy(r, "Filter"),
      o = Fy(r, "FeatureId");
    s.appendChild(o), o.setAttribute("fid", e), t.appendChild(s);
  }
  function OR(t, e) {
    const i = (t = t || xR) + ":";
    return e.startsWith(i) ? e : i + e;
  }
  function kR(t, e, i) {
    const n = i[i.length - 1];
    Ft(void 0 !== e.getId(), "Features must have an id set");
    const r = n.featureType,
      s = n.featurePrefix,
      o = n.featureNS,
      a = OR(s, r);
    t.setAttribute("typeName", a), t.setAttributeNS(vR, "xmlns:" + s, o);
    const l = e.getId();
    void 0 !== l && MR(t, l, i);
  }
  function AR(t, e, i) {
    const n = i[i.length - 1];
    Ft(void 0 !== e.getId(), "Features must have an id set");
    const r = n.version,
      s = n.featureType,
      o = n.featurePrefix,
      a = n.featureNS,
      l = OR(o, s),
      h = e.getGeometryName();
    t.setAttribute("typeName", l), t.setAttributeNS(vR, "xmlns:" + o, a);
    const c = e.getId();
    if (void 0 !== c) {
      const s = e.getKeys(),
        o = [];
      for (let t = 0, i = s.length; t < i; t++) {
        const i = e.get(s[t]);
        if (void 0 !== i) {
          let e = s[t];
          i && "function" == typeof i.getSimplifiedGeometry && (e = h),
            o.push({ name: e, value: i });
        }
      }
      Yy(
        {
          version: r,
          gmlVersion: n.gmlVersion,
          node: t,
          hasZ: n.hasZ,
          srsName: n.srsName,
        },
        yR,
        Uy("Property"),
        o,
        i
      ),
        MR(t, c, i);
    }
  }
  function NR(t, e, i) {
    const n = i[i.length - 1],
      r = n.version,
      s = CR[r],
      o = Fy(s, "Name"),
      a = n.gmlVersion;
    if (
      (t.appendChild(o), SS(o, e.name), void 0 !== e.value && null !== e.value)
    ) {
      const n = Fy(s, "Value");
      t.appendChild(n),
        e.value && "function" == typeof e.value.getSimplifiedGeometry
          ? 2 === a
            ? ES.prototype.writeGeometryElement(n, e.value, i)
            : 3 === a
            ? bS.prototype.writeGeometryElement(n, e.value, i)
            : MS.prototype.writeGeometryElement(n, e.value, i)
          : SS(n, e.value);
    }
  }
  function DR(t, e, i) {
    e.vendorId && t.setAttribute("vendorId", e.vendorId),
      void 0 !== e.safeToIgnore &&
        t.setAttribute("safeToIgnore", String(e.safeToIgnore)),
      void 0 !== e.value && SS(t, e.value);
  }
  const GR = {
    "http://www.opengis.net/wfs": { Query: jy(BR) },
    "http://www.opengis.net/wfs/2.0": { Query: jy(BR) },
    "http://www.opengis.net/ogc": {
      During: jy(VR),
      And: jy(XR),
      Or: jy(XR),
      Not: jy(ZR),
      BBOX: jy(zR),
      Contains: jy(UR),
      Intersects: jy(UR),
      Within: jy(UR),
      DWithin: jy(qR),
      PropertyIsEqualTo: jy(KR),
      PropertyIsNotEqualTo: jy(KR),
      PropertyIsLessThan: jy(KR),
      PropertyIsLessThanOrEqualTo: jy(KR),
      PropertyIsGreaterThan: jy(KR),
      PropertyIsGreaterThanOrEqualTo: jy(KR),
      PropertyIsNull: jy(HR),
      PropertyIsBetween: jy(YR),
      PropertyIsLike: jy(QR),
    },
    "http://www.opengis.net/fes/2.0": {
      During: jy(VR),
      And: jy(XR),
      Or: jy(XR),
      Not: jy(ZR),
      BBOX: jy(zR),
      Contains: jy(UR),
      Disjoint: jy(UR),
      Intersects: jy(UR),
      ResourceId: jy(function (t, e, i) {
        t.setAttribute("rid", e.rid);
      }),
      Within: jy(UR),
      DWithin: jy(qR),
      PropertyIsEqualTo: jy(KR),
      PropertyIsNotEqualTo: jy(KR),
      PropertyIsLessThan: jy(KR),
      PropertyIsLessThanOrEqualTo: jy(KR),
      PropertyIsGreaterThan: jy(KR),
      PropertyIsGreaterThanOrEqualTo: jy(KR),
      PropertyIsNull: jy(HR),
      PropertyIsBetween: jy(YR),
      PropertyIsLike: jy(QR),
    },
  };
  function BR(t, e, i) {
    const n = i[i.length - 1],
      r = n.version,
      s = n.featurePrefix,
      o = n.featureNS,
      a = n.propertyNames,
      l = n.srsName;
    let h, c;
    (h = s ? OR(s, e) : e),
      (c = "2.0.0" === r ? "typeNames" : "typeName"),
      t.setAttribute(c, h),
      l && t.setAttribute("srsName", l),
      o && t.setAttributeNS(vR, "xmlns:" + s, o);
    const u = Object.assign({}, n);
    (u.node = t), Yy(u, _R, Uy("PropertyName"), a, i);
    const d = n.filter;
    if (d) {
      const e = Fy(nT(r), "Filter");
      t.appendChild(e), jR(e, d, i);
    }
  }
  function jR(t, e, i) {
    const n = i[i.length - 1],
      r = { node: t };
    Object.assign(r, { context: n }), Yy(r, GR, Uy(e.getTagName()), [e], i);
  }
  function zR(t, e, i) {
    const n = i[i.length - 1],
      r = n.context.version;
    n.srsName = e.srsName;
    const s = ER[r];
    tT(r, t, e.geometryName), s.prototype.writeGeometryElement(t, e.extent, i);
  }
  function UR(t, e, i) {
    const n = i[i.length - 1],
      r = n.context.version;
    n.srsName = e.srsName;
    const s = ER[r];
    tT(r, t, e.geometryName),
      s.prototype.writeGeometryElement(t, e.geometry, i);
  }
  function qR(t, e, i) {
    const n = i[i.length - 1].context.version;
    UR(t, e, i);
    const r = Fy(nT(n), "Distance");
    SS(r, e.distance.toString()),
      "2.0.0" === n
        ? r.setAttribute("uom", e.unit)
        : r.setAttribute("units", e.unit),
      t.appendChild(r);
  }
  function VR(t, e, i) {
    const n = i[i.length - 1].context.version;
    $R(wR[n], "ValueReference", t, e.propertyName);
    const r = Fy(rS, "TimePeriod");
    t.appendChild(r);
    const s = Fy(rS, "begin");
    r.appendChild(s), eT(s, e.begin);
    const o = Fy(rS, "end");
    r.appendChild(o), eT(o, e.end);
  }
  function XR(t, e, i) {
    const n = i[i.length - 1].context,
      r = { node: t };
    Object.assign(r, { context: n });
    const s = e.conditions;
    for (let t = 0, e = s.length; t < e; ++t) {
      const e = s[t];
      Yy(r, GR, Uy(e.getTagName()), [e], i);
    }
  }
  function ZR(t, e, i) {
    const n = i[i.length - 1].context,
      r = { node: t };
    Object.assign(r, { context: n });
    const s = e.condition;
    Yy(r, GR, Uy(s.getTagName()), [s], i);
  }
  function KR(t, e, i) {
    const n = i[i.length - 1].context.version;
    void 0 !== e.matchCase &&
      t.setAttribute("matchCase", e.matchCase.toString()),
      tT(n, t, e.propertyName),
      JR(n, t, "" + e.expression);
  }
  function HR(t, e, i) {
    tT(i[i.length - 1].context.version, t, e.propertyName);
  }
  function YR(t, e, i) {
    const n = i[i.length - 1].context.version,
      r = nT(n);
    tT(n, t, e.propertyName);
    const s = Fy(r, "LowerBoundary");
    t.appendChild(s), JR(n, s, "" + e.lowerBoundary);
    const o = Fy(r, "UpperBoundary");
    t.appendChild(o), JR(n, o, "" + e.upperBoundary);
  }
  function QR(t, e, i) {
    const n = i[i.length - 1].context.version;
    t.setAttribute("wildCard", e.wildCard),
      t.setAttribute("singleChar", e.singleChar),
      t.setAttribute("escapeChar", e.escapeChar),
      void 0 !== e.matchCase &&
        t.setAttribute("matchCase", e.matchCase.toString()),
      tT(n, t, e.propertyName),
      JR(n, t, "" + e.pattern);
  }
  function $R(t, e, i, n) {
    const r = Fy(t, e);
    SS(r, n), i.appendChild(r);
  }
  function JR(t, e, i) {
    $R(nT(t), "Literal", e, i);
  }
  function tT(t, e, i) {
    "2.0.0" === t
      ? $R(wR[t], "ValueReference", e, i)
      : $R(SR[t], "PropertyName", e, i);
  }
  function eT(t, e) {
    const i = Fy(rS, "TimeInstant");
    t.appendChild(i);
    const n = Fy(rS, "timePosition");
    i.appendChild(n), SS(n, e);
  }
  function iT(t, e, i) {
    const n = i[i.length - 1],
      r = Object.assign({}, n);
    (r.node = t), Yy(r, GR, Uy("Query"), e, i);
  }
  function nT(t) {
    let e;
    return (e = "2.0.0" === t ? wR[t] : SR[t]), e;
  }
  var rT = class extends nS {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.version_ = t.version ? t.version : "1.1.0"),
        (this.featureType_ = t.featureType),
        (this.featureNS_ = t.featureNS),
        (this.gmlFormat_ = t.gmlFormat ? t.gmlFormat : new ER[this.version_]()),
        (this.schemaLocation_ = t.schemaLocation
          ? t.schemaLocation
          : WR[this.version_]);
    }
    getFeatureType() {
      return this.featureType_;
    }
    setFeatureType(t) {
      this.featureType_ = t;
    }
    readFeaturesFromNode(t, e) {
      const i = { node: t };
      Object.assign(i, {
        featureType: this.featureType_,
        featureNS: this.featureNS_,
      }),
        Object.assign(i, this.getReadOptions(t, e || {}));
      const n = [i];
      let r;
      r =
        "2.0.0" === this.version_
          ? fR
          : this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
      let s = Ky([], r, t, n, this.gmlFormat_);
      return s || (s = []), s;
    }
    readTransactionResponse(t) {
      if (t) {
        if ("string" == typeof t) {
          const e = ky(t);
          return this.readTransactionResponseFromDocument(e);
        }
        return My(t)
          ? this.readTransactionResponseFromDocument(t)
          : this.readTransactionResponseFromNode(t);
      }
    }
    readFeatureCollectionMetadata(t) {
      if (t) {
        if ("string" == typeof t) {
          const e = ky(t);
          return this.readFeatureCollectionMetadataFromDocument(e);
        }
        return My(t)
          ? this.readFeatureCollectionMetadataFromDocument(t)
          : this.readFeatureCollectionMetadataFromNode(t);
      }
    }
    readFeatureCollectionMetadataFromDocument(t) {
      for (let e = t.firstChild; e; e = e.nextSibling)
        if (e.nodeType == Node.ELEMENT_NODE)
          return this.readFeatureCollectionMetadataFromNode(e);
    }
    readFeatureCollectionMetadataFromNode(t) {
      const e = {},
        i = fS(t.getAttribute("numberOfFeatures"));
      return (e.numberOfFeatures = i), Ky(e, fR, t, [], this.gmlFormat_);
    }
    readTransactionResponseFromDocument(t) {
      for (let e = t.firstChild; e; e = e.nextSibling)
        if (e.nodeType == Node.ELEMENT_NODE)
          return this.readTransactionResponseFromNode(e);
    }
    readTransactionResponseFromNode(t) {
      return Ky({}, mR, t, []);
    }
    writeGetFeature(t) {
      const e = Fy(CR[this.version_], "GetFeature");
      e.setAttribute("service", "WFS"),
        e.setAttribute("version", this.version_),
        t.handle && e.setAttribute("handle", t.handle),
        t.outputFormat && e.setAttribute("outputFormat", t.outputFormat),
        void 0 !== t.maxFeatures &&
          e.setAttribute("maxFeatures", String(t.maxFeatures)),
        t.resultType && e.setAttribute("resultType", t.resultType),
        void 0 !== t.startIndex &&
          e.setAttribute("startIndex", String(t.startIndex)),
        void 0 !== t.count && e.setAttribute("count", String(t.count)),
        void 0 !== t.viewParams && e.setAttribute("viewParams", t.viewParams),
        e.setAttributeNS(by, "xsi:schemaLocation", this.schemaLocation_);
      const i = { node: e };
      if (
        (Object.assign(i, {
          version: this.version_,
          srsName: t.srsName,
          featureNS: t.featureNS ? t.featureNS : this.featureNS_,
          featurePrefix: t.featurePrefix,
          propertyNames: t.propertyNames ? t.propertyNames : [],
        }),
        Ft(
          Array.isArray(t.featureTypes),
          "`options.featureTypes` must be an Array"
        ),
        "string" == typeof t.featureTypes[0])
      ) {
        let n = t.filter;
        t.bbox &&
          (Ft(
            t.geometryName,
            "`options.geometryName` must also be provided when `options.bbox` is set"
          ),
          (n = this.combineBboxAndFilter(
            t.geometryName,
            t.bbox,
            t.srsName,
            n
          ))),
          Object.assign(i, { geometryName: t.geometryName, filter: n }),
          iT(e, t.featureTypes, [i]);
      } else
        t.featureTypes.forEach((n) => {
          const r = this.combineBboxAndFilter(
            n.geometryName,
            n.bbox,
            t.srsName,
            t.filter
          );
          Object.assign(i, { geometryName: n.geometryName, filter: r }),
            iT(e, [n.name], [i]);
        });
      return e;
    }
    combineBboxAndFilter(t, e, i, n) {
      const r = gR(t, e, i);
      return n ? dR(n, r) : r;
    }
    writeTransaction(t, e, i, n) {
      const r = [],
        s = n.version ? n.version : this.version_,
        o = Fy(CR[s], "Transaction");
      let a;
      o.setAttribute("service", "WFS"),
        o.setAttribute("version", s),
        n &&
          ((a = n.gmlOptions ? n.gmlOptions : {}),
          n.handle && o.setAttribute("handle", n.handle)),
        o.setAttributeNS(by, "xsi:schemaLocation", WR[s]);
      const l = (function (t, e, i, n) {
        const r = n.featurePrefix ? n.featurePrefix : xR;
        let s;
        "1.0.0" === i
          ? (s = 2)
          : "1.1.0" === i
          ? (s = 3)
          : "2.0.0" === i && (s = 3.2);
        const o = Object.assign(
          { node: t },
          {
            version: i,
            featureNS: n.featureNS,
            featureType: n.featureType,
            featurePrefix: r,
            gmlVersion: s,
            hasZ: n.hasZ,
            srsName: n.srsName,
          },
          e
        );
        return o;
      })(o, a, s, n);
      return (
        t && RR("Insert", t, r, l),
        e && RR("Update", e, r, l),
        i && RR("Delete", i, r, l),
        n.nativeElements && RR("Native", n.nativeElements, r, l),
        o
      );
    }
    readProjectionFromDocument(t) {
      for (let e = t.firstChild; e; e = e.nextSibling)
        if (e.nodeType == Node.ELEMENT_NODE)
          return this.readProjectionFromNode(e);
      return null;
    }
    readProjectionFromNode(t) {
      if (t.firstElementChild && t.firstElementChild.firstElementChild)
        for (
          let e = (t = t.firstElementChild.firstElementChild).firstElementChild;
          e;
          e = e.nextElementSibling
        )
          if (
            0 !== e.childNodes.length &&
            (1 !== e.childNodes.length || 3 !== e.firstChild.nodeType)
          ) {
            const t = [{}];
            return (
              this.gmlFormat_.readGeometryElement(e, t), tn(t.pop().srsName)
            );
          }
      return null;
    }
  };
  const sT = 1,
    oT = 2,
    aT = 3,
    lT = 4,
    hT = 5,
    cT = 6,
    uT = 7,
    dT = 15,
    gT = 16,
    fT = 17;
  class pT {
    constructor(t) {
      (this.view_ = t),
        (this.pos_ = 0),
        (this.initialized_ = !1),
        (this.isLittleEndian_ = !1),
        (this.hasZ_ = !1),
        (this.hasM_ = !1),
        (this.srid_ = null),
        (this.layout_ = "XY");
    }
    readUint8() {
      return this.view_.getUint8(this.pos_++);
    }
    readUint32(t) {
      return this.view_.getUint32(
        (this.pos_ += 4) - 4,
        void 0 !== t ? t : this.isLittleEndian_
      );
    }
    readDouble(t) {
      return this.view_.getFloat64(
        (this.pos_ += 8) - 8,
        void 0 !== t ? t : this.isLittleEndian_
      );
    }
    readPoint() {
      const t = [];
      return (
        t.push(this.readDouble()),
        t.push(this.readDouble()),
        this.hasZ_ && t.push(this.readDouble()),
        this.hasM_ && t.push(this.readDouble()),
        t
      );
    }
    readLineString() {
      const t = this.readUint32(),
        e = [];
      for (let i = 0; i < t; i++) e.push(this.readPoint());
      return e;
    }
    readPolygon() {
      const t = this.readUint32(),
        e = [];
      for (let i = 0; i < t; i++) e.push(this.readLineString());
      return e;
    }
    readWkbHeader(t) {
      const e = this.readUint8() > 0,
        i = this.readUint32(e),
        n = Math.floor((268435455 & i) / 1e3),
        r = Boolean(2147483648 & i) || 1 === n || 3 === n,
        s = Boolean(1073741824 & i) || 2 === n || 3 === n,
        o = Boolean(536870912 & i),
        a = (268435455 & i) % 1e3,
        l = ["XY", r ? "Z" : "", s ? "M" : ""].join(""),
        h = o ? this.readUint32(e) : null;
      if (void 0 !== t && t !== a)
        throw new Error("Unexpected WKB geometry type " + a);
      if (this.initialized_) {
        if (this.isLittleEndian_ !== e) throw new Error("Inconsistent endian");
        if (this.layout_ !== l) throw new Error("Inconsistent geometry layout");
        if (h && this.srid_ !== h)
          throw new Error("Inconsistent coordinate system (SRID)");
      } else
        (this.isLittleEndian_ = e),
          (this.hasZ_ = r),
          (this.hasM_ = s),
          (this.layout_ = l),
          (this.srid_ = h),
          (this.initialized_ = !0);
      return a;
    }
    readWkbPayload(t) {
      switch (t) {
        case sT:
          return this.readPoint();
        case oT:
          return this.readLineString();
        case aT:
        case fT:
          return this.readPolygon();
        case lT:
          return this.readMultiPoint();
        case hT:
          return this.readMultiLineString();
        case cT:
        case dT:
        case gT:
          return this.readMultiPolygon();
        case uT:
          return this.readGeometryCollection();
        default:
          throw new Error("Unsupported WKB geometry type " + t + " is found");
      }
    }
    readWkbBlock(t) {
      return this.readWkbPayload(this.readWkbHeader(t));
    }
    readWkbCollection(t, e) {
      const i = this.readUint32(),
        n = [];
      for (let r = 0; r < i; r++) {
        const i = t.call(this, e);
        i && n.push(i);
      }
      return n;
    }
    readMultiPoint() {
      return this.readWkbCollection(this.readWkbBlock, sT);
    }
    readMultiLineString() {
      return this.readWkbCollection(this.readWkbBlock, oT);
    }
    readMultiPolygon() {
      return this.readWkbCollection(this.readWkbBlock, aT);
    }
    readGeometryCollection() {
      return this.readWkbCollection(this.readGeometry);
    }
    readGeometry() {
      const t = this.readWkbHeader(),
        e = this.readWkbPayload(t);
      switch (t) {
        case sT:
          return new or(e, this.layout_);
        case oT:
          return new Bl(e, this.layout_);
        case aT:
        case fT:
          return new Tr(e, this.layout_);
        case lT:
          return new Ix(e, this.layout_);
        case hT:
          return new bx(e, this.layout_);
        case cT:
        case dT:
        case gT:
          return new Ox(e, this.layout_);
        case uT:
          return new Tx(e);
        default:
          return null;
      }
    }
    getSrid() {
      return this.srid_;
    }
  }
  class mT {
    constructor(t) {
      (t = t || {}),
        (this.layout_ = t.layout),
        (this.isLittleEndian_ = !1 !== t.littleEndian),
        (this.isEWKB_ = !1 !== t.ewkb),
        (this.writeQueue_ = []),
        (this.nodata_ = Object.assign({ X: 0, Y: 0, Z: 0, M: 0 }, t.nodata));
    }
    writeUint8(t) {
      this.writeQueue_.push([1, t]);
    }
    writeUint32(t) {
      this.writeQueue_.push([4, t]);
    }
    writeDouble(t) {
      this.writeQueue_.push([8, t]);
    }
    writePoint(t, e) {
      const i = Object.assign.apply(
        null,
        e.split("").map((e, i) => ({ [e]: t[i] }))
      );
      for (const t of this.layout_)
        this.writeDouble(t in i ? i[t] : this.nodata_[t]);
    }
    writeLineString(t, e) {
      this.writeUint32(t.length);
      for (let i = 0; i < t.length; i++) this.writePoint(t[i], e);
    }
    writePolygon(t, e) {
      this.writeUint32(t.length);
      for (let i = 0; i < t.length; i++) this.writeLineString(t[i], e);
    }
    writeWkbHeader(t, e) {
      (t %= 1e3),
        this.layout_.includes("Z") && (t += this.isEWKB_ ? 2147483648 : 1e3),
        this.layout_.includes("M") && (t += this.isEWKB_ ? 1073741824 : 2e3),
        this.isEWKB_ && Number.isInteger(e) && (t |= 536870912),
        this.writeUint8(this.isLittleEndian_ ? 1 : 0),
        this.writeUint32(t),
        this.isEWKB_ && Number.isInteger(e) && this.writeUint32(e);
    }
    writeMultiPoint(t, e) {
      this.writeUint32(t.length);
      for (let i = 0; i < t.length; i++)
        this.writeWkbHeader(1), this.writePoint(t[i], e);
    }
    writeMultiLineString(t, e) {
      this.writeUint32(t.length);
      for (let i = 0; i < t.length; i++)
        this.writeWkbHeader(2), this.writeLineString(t[i], e);
    }
    writeMultiPolygon(t, e) {
      this.writeUint32(t.length);
      for (let i = 0; i < t.length; i++)
        this.writeWkbHeader(3), this.writePolygon(t[i], e);
    }
    writeGeometryCollection(t) {
      this.writeUint32(t.length);
      for (let e = 0; e < t.length; e++) this.writeGeometry(t[e]);
    }
    findMinimumLayout(t, e = "XYZM") {
      if (t instanceof Ln)
        return (i = t.getLayout()) === (n = e)
          ? i
          : "XYZM" === i
          ? n
          : "XYZM" === n
          ? i
          : "XY";
      var i, n;
      if (t instanceof Tx) {
        const i = t.getGeometriesArray();
        for (let t = 0; t < i.length && "XY" !== e; t++)
          e = this.findMinimumLayout(i[t], e);
      }
      return e;
    }
    writeGeometry(t, e) {
      const i = {
          Point: sT,
          LineString: oT,
          Polygon: aT,
          MultiPoint: lT,
          MultiLineString: hT,
          MultiPolygon: cT,
          GeometryCollection: uT,
        },
        n = t.getType(),
        r = i[n];
      if (!r) throw new Error("GeometryType " + n + " is not supported");
      if (
        (this.layout_ || (this.layout_ = this.findMinimumLayout(t)),
        this.writeWkbHeader(r, e),
        t instanceof Ln)
      ) {
        ({
          Point: this.writePoint,
          LineString: this.writeLineString,
          Polygon: this.writePolygon,
          MultiPoint: this.writeMultiPoint,
          MultiLineString: this.writeMultiLineString,
          MultiPolygon: this.writeMultiPolygon,
        })[n].call(this, t.getCoordinates(), t.getLayout());
      } else
        t instanceof Tx && this.writeGeometryCollection(t.getGeometriesArray());
    }
    getBuffer() {
      const t = this.writeQueue_.reduce((t, e) => t + e[0], 0),
        e = new ArrayBuffer(t),
        i = new DataView(e);
      let n = 0;
      return (
        this.writeQueue_.forEach((t) => {
          switch (t[0]) {
            case 1:
              i.setUint8(n, t[1]);
              break;
            case 4:
              i.setUint32(n, t[1], this.isLittleEndian_);
              break;
            case 8:
              i.setFloat64(n, t[1], this.isLittleEndian_);
          }
          n += t[0];
        }),
        e
      );
    }
  }
  function _T(t) {
    return "string" == typeof t
      ? (function (t) {
          const e = new Uint8Array(t.length / 2);
          for (let i = 0; i < t.length / 2; i++)
            e[i] = parseInt(t.substr(2 * i, 2), 16);
          return new DataView(e.buffer);
        })(t)
      : ArrayBuffer.isView(t)
      ? t instanceof DataView
        ? t
        : new DataView(t.buffer, t.byteOffset, t.byteLength)
      : t instanceof ArrayBuffer
      ? new DataView(t)
      : null;
  }
  var yT = class extends Vv {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.splitCollection = Boolean(t.splitCollection)),
        (this.viewCache_ = null),
        (this.hex_ = !1 !== t.hex),
        (this.littleEndian_ = !1 !== t.littleEndian),
        (this.ewkb_ = !1 !== t.ewkb),
        (this.layout_ = t.geometryLayout),
        (this.nodataZ_ = t.nodataZ || 0),
        (this.nodataM_ = t.nodataM || 0),
        (this.srid_ = t.srid);
    }
    getType() {
      return this.hex_ ? "text" : "arraybuffer";
    }
    readFeature(t, e) {
      return new Mt({ geometry: this.readGeometry(t, e) });
    }
    readFeatures(t, e) {
      let i = [];
      const n = this.readGeometry(t, e);
      return (
        (i =
          this.splitCollection && n instanceof Tx
            ? n.getGeometriesArray()
            : [n]),
        i.map((t) => new Mt({ geometry: t }))
      );
    }
    readGeometry(t, e) {
      const i = _T(t);
      if (!i) return null;
      const n = new pT(i).readGeometry();
      return (
        (this.viewCache_ = i),
        (e = this.getReadOptions(t, e)),
        (this.viewCache_ = null),
        Xv(n, !1, e)
      );
    }
    readProjection(t) {
      const e = this.viewCache_ || _T(t);
      if (!e) return;
      const i = new pT(e);
      return (
        i.readWkbHeader(), (i.getSrid() && tn("EPSG:" + i.getSrid())) || void 0
      );
    }
    writeFeature(t, e) {
      return this.writeGeometry(t.getGeometry(), e);
    }
    writeFeatures(t, e) {
      return this.writeGeometry(new Tx(t.map((t) => t.getGeometry())), e);
    }
    writeGeometry(t, e) {
      e = this.adaptOptions(e);
      const i = new mT({
        layout: this.layout_,
        littleEndian: this.littleEndian_,
        ewkb: this.ewkb_,
        nodata: { Z: this.nodataZ_, M: this.nodataM_ },
      });
      let n = Number.isInteger(this.srid_) ? Number(this.srid_) : null;
      if (!1 !== this.srid_ && !Number.isInteger(this.srid_)) {
        const t = e.dataProjection && tn(e.dataProjection);
        if (t) {
          const e = t.getCode();
          e.startsWith("EPSG:") && (n = Number(e.substring(5)));
        }
      }
      i.writeGeometry(Xv(t, !0, e), n);
      const r = i.getBuffer();
      return this.hex_
        ? (function (t) {
            const e = new Uint8Array(t);
            return Array.from(e.values())
              .map(
                (t) =>
                  (t < 16 ? "0" : "") + Number(t).toString(16).toUpperCase()
              )
              .join("");
          })(r)
        : r;
    }
  };
  const xT = {
      POINT: or,
      LINESTRING: Bl,
      POLYGON: Tr,
      MULTIPOINT: Ix,
      MULTILINESTRING: bx,
      MULTIPOLYGON: Ox,
    },
    vT = "EMPTY",
    ST = "Z",
    CT = "M",
    wT = 0,
    WT = 1,
    ET = 2,
    RT = 3,
    TT = 4,
    PT = 5,
    bT = 6,
    FT = {
      Point: "POINT",
      LineString: "LINESTRING",
      Polygon: "POLYGON",
      MultiPoint: "MULTIPOINT",
      MultiLineString: "MULTILINESTRING",
      MultiPolygon: "MULTIPOLYGON",
      GeometryCollection: "GEOMETRYCOLLECTION",
      Circle: "CIRCLE",
    };
  class IT {
    constructor(t) {
      (this.wkt = t), (this.index_ = -1);
    }
    isAlpha_(t) {
      return (t >= "a" && t <= "z") || (t >= "A" && t <= "Z");
    }
    isNumeric_(t, e) {
      return (
        (e = void 0 !== e && e), (t >= "0" && t <= "9") || ("." == t && !e)
      );
    }
    isWhiteSpace_(t) {
      return " " == t || "\t" == t || "\r" == t || "\n" == t;
    }
    nextChar_() {
      return this.wkt.charAt(++this.index_);
    }
    nextToken() {
      const t = this.nextChar_(),
        e = this.index_;
      let i,
        n = t;
      if ("(" == t) i = ET;
      else if ("," == t) i = PT;
      else if (")" == t) i = RT;
      else if (this.isNumeric_(t) || "-" == t)
        (i = TT), (n = this.readNumber_());
      else if (this.isAlpha_(t)) (i = WT), (n = this.readText_());
      else {
        if (this.isWhiteSpace_(t)) return this.nextToken();
        if ("" !== t) throw new Error("Unexpected character: " + t);
        i = bT;
      }
      return { position: e, value: n, type: i };
    }
    readNumber_() {
      let t;
      const e = this.index_;
      let i = !1,
        n = !1;
      do {
        "." == t ? (i = !0) : ("e" != t && "E" != t) || (n = !0),
          (t = this.nextChar_());
      } while (
        this.isNumeric_(t, i) ||
        (!n && ("e" == t || "E" == t)) ||
        (n && ("-" == t || "+" == t))
      );
      return parseFloat(this.wkt.substring(e, this.index_--));
    }
    readText_() {
      let t;
      const e = this.index_;
      do {
        t = this.nextChar_();
      } while (this.isAlpha_(t));
      return this.wkt.substring(e, this.index_--).toUpperCase();
    }
  }
  class LT {
    constructor(t) {
      (this.lexer_ = t),
        (this.token_ = { position: 0, type: wT }),
        (this.layout_ = "XY");
    }
    consume_() {
      this.token_ = this.lexer_.nextToken();
    }
    isTokenType(t) {
      return this.token_.type == t;
    }
    match(t) {
      const e = this.isTokenType(t);
      return e && this.consume_(), e;
    }
    parse() {
      return this.consume_(), this.parseGeometry_();
    }
    parseGeometryLayout_() {
      let t = "XY";
      const e = this.token_;
      if (this.isTokenType(WT)) {
        const i = e.value;
        i === ST
          ? (t = "XYZ")
          : i === CT
          ? (t = "XYM")
          : "ZM" === i && (t = "XYZM"),
          "XY" !== t && this.consume_();
      }
      return t;
    }
    parseGeometryCollectionText_() {
      if (this.match(ET)) {
        const t = [];
        do {
          t.push(this.parseGeometry_());
        } while (this.match(PT));
        if (this.match(RT)) return t;
      }
      throw new Error(this.formatErrorMessage_());
    }
    parsePointText_() {
      if (this.match(ET)) {
        const t = this.parsePoint_();
        if (this.match(RT)) return t;
      }
      throw new Error(this.formatErrorMessage_());
    }
    parseLineStringText_() {
      if (this.match(ET)) {
        const t = this.parsePointList_();
        if (this.match(RT)) return t;
      }
      throw new Error(this.formatErrorMessage_());
    }
    parsePolygonText_() {
      if (this.match(ET)) {
        const t = this.parseLineStringTextList_();
        if (this.match(RT)) return t;
      }
      throw new Error(this.formatErrorMessage_());
    }
    parseMultiPointText_() {
      if (this.match(ET)) {
        let t;
        if (
          ((t =
            this.token_.type == ET
              ? this.parsePointTextList_()
              : this.parsePointList_()),
          this.match(RT))
        )
          return t;
      }
      throw new Error(this.formatErrorMessage_());
    }
    parseMultiLineStringText_() {
      if (this.match(ET)) {
        const t = this.parseLineStringTextList_();
        if (this.match(RT)) return t;
      }
      throw new Error(this.formatErrorMessage_());
    }
    parseMultiPolygonText_() {
      if (this.match(ET)) {
        const t = this.parsePolygonTextList_();
        if (this.match(RT)) return t;
      }
      throw new Error(this.formatErrorMessage_());
    }
    parsePoint_() {
      const t = [],
        e = this.layout_.length;
      for (let i = 0; i < e; ++i) {
        const e = this.token_;
        if (!this.match(TT)) break;
        t.push(e.value);
      }
      if (t.length == e) return t;
      throw new Error(this.formatErrorMessage_());
    }
    parsePointList_() {
      const t = [this.parsePoint_()];
      for (; this.match(PT); ) t.push(this.parsePoint_());
      return t;
    }
    parsePointTextList_() {
      const t = [this.parsePointText_()];
      for (; this.match(PT); ) t.push(this.parsePointText_());
      return t;
    }
    parseLineStringTextList_() {
      const t = [this.parseLineStringText_()];
      for (; this.match(PT); ) t.push(this.parseLineStringText_());
      return t;
    }
    parsePolygonTextList_() {
      const t = [this.parsePolygonText_()];
      for (; this.match(PT); ) t.push(this.parsePolygonText_());
      return t;
    }
    isEmptyGeometry_() {
      const t = this.isTokenType(WT) && this.token_.value == vT;
      return t && this.consume_(), t;
    }
    formatErrorMessage_() {
      return (
        "Unexpected `" +
        this.token_.value +
        "` at position " +
        this.token_.position +
        " in `" +
        this.lexer_.wkt +
        "`"
      );
    }
    parseGeometry_() {
      const t = this.token_;
      if (this.match(WT)) {
        const e = t.value;
        this.layout_ = this.parseGeometryLayout_();
        const i = this.isEmptyGeometry_();
        if ("GEOMETRYCOLLECTION" == e) {
          if (i) return new Tx([]);
          const t = this.parseGeometryCollectionText_();
          return new Tx(t);
        }
        const n = xT[e];
        if (!n) throw new Error("Invalid geometry type: " + e);
        let r;
        if (i) r = "POINT" == e ? [NaN, NaN] : [];
        else
          switch (e) {
            case "POINT":
              r = this.parsePointText_();
              break;
            case "LINESTRING":
              r = this.parseLineStringText_();
              break;
            case "POLYGON":
              r = this.parsePolygonText_();
              break;
            case "MULTIPOINT":
              r = this.parseMultiPointText_();
              break;
            case "MULTILINESTRING":
              r = this.parseMultiLineStringText_();
              break;
            case "MULTIPOLYGON":
              r = this.parseMultiPolygonText_();
          }
        return new n(r, this.layout_);
      }
      throw new Error(this.formatErrorMessage_());
    }
  }
  function MT(t) {
    const e = t.getCoordinates();
    return 0 === e.length ? "" : e.join(" ");
  }
  function OT(t) {
    const e = t.getCoordinates(),
      i = [];
    for (let t = 0, n = e.length; t < n; ++t) i.push(e[t].join(" "));
    return i.join(",");
  }
  function kT(t) {
    const e = [],
      i = t.getLinearRings();
    for (let t = 0, n = i.length; t < n; ++t) e.push("(" + OT(i[t]) + ")");
    return e.join(",");
  }
  const AT = {
    Point: MT,
    LineString: OT,
    Polygon: kT,
    MultiPoint: function (t) {
      const e = [],
        i = t.getPoints();
      for (let t = 0, n = i.length; t < n; ++t) e.push("(" + MT(i[t]) + ")");
      return e.join(",");
    },
    MultiLineString: function (t) {
      const e = [],
        i = t.getLineStrings();
      for (let t = 0, n = i.length; t < n; ++t) e.push("(" + OT(i[t]) + ")");
      return e.join(",");
    },
    MultiPolygon: function (t) {
      const e = [],
        i = t.getPolygons();
      for (let t = 0, n = i.length; t < n; ++t) e.push("(" + kT(i[t]) + ")");
      return e.join(",");
    },
    GeometryCollection: function (t) {
      const e = [],
        i = t.getGeometries();
      for (let t = 0, n = i.length; t < n; ++t) e.push(NT(i[t]));
      return e.join(",");
    },
  };
  function NT(t) {
    const e = t.getType(),
      i = (0, AT[e])(t);
    let n = FT[e];
    if ("function" == typeof t.getFlatCoordinates) {
      const e = (function (t) {
        const e = t.getLayout();
        let i = "";
        return (
          ("XYZ" !== e && "XYZM" !== e) || (i += ST),
          ("XYM" !== e && "XYZM" !== e) || (i += CT),
          i
        );
      })(t);
      e.length > 0 && (n += " " + e);
    }
    return 0 === i.length ? n + " " + vT : n + "(" + i + ")";
  }
  var DT = class extends yC {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.splitCollection_ =
          void 0 !== t.splitCollection && t.splitCollection);
    }
    parse_(t) {
      const e = new IT(t);
      return new LT(e).parse();
    }
    readFeatureFromText(t, e) {
      const i = this.readGeometryFromText(t, e),
        n = new Mt();
      return n.setGeometry(i), n;
    }
    readFeaturesFromText(t, e) {
      let i = [];
      const n = this.readGeometryFromText(t, e);
      i =
        this.splitCollection_ && "GeometryCollection" == n.getType()
          ? n.getGeometriesArray()
          : [n];
      const r = [];
      for (let t = 0, e = i.length; t < e; ++t) {
        const e = new Mt();
        e.setGeometry(i[t]), r.push(e);
      }
      return r;
    }
    readGeometryFromText(t, e) {
      return Xv(this.parse_(t), !1, e);
    }
    writeFeatureText(t, e) {
      const i = t.getGeometry();
      return i ? this.writeGeometryText(i, e) : "";
    }
    writeFeaturesText(t, e) {
      if (1 == t.length) return this.writeFeatureText(t[0], e);
      const i = [];
      for (let e = 0, n = t.length; e < n; ++e) i.push(t[e].getGeometry());
      const n = new Tx(i);
      return this.writeGeometryText(n, e);
    }
    writeGeometryText(t, e) {
      return NT(Xv(t, !0, e));
    }
  };
  const GT = [null, "http://www.opengis.net/wms"],
    BT = Xy(GT, {
      Service: By(function (t, e) {
        return Ky({}, zT, t, e);
      }),
      Capability: By(function (t, e) {
        return Ky({}, jT, t, e);
      }),
    }),
    jT = Xy(GT, {
      Request: By(function (t, e) {
        return Ky({}, YT, t, e);
      }),
      Exception: By(function (t, e) {
        return Ky([], XT, t, e);
      }),
      Layer: By(function (t, e) {
        const i = Ky({}, ZT, t, e);
        if (void 0 === i.Layer) return Object.assign(i, nP(t, e));
        return i;
      }),
    });
  const zT = Xy(GT, {
      Name: By(pS),
      Title: By(pS),
      Abstract: By(pS),
      KeywordList: By(aP),
      OnlineResource: By(aE),
      ContactInformation: By(function (t, e) {
        return Ky({}, UT, t, e);
      }),
      Fees: By(pS),
      AccessConstraints: By(pS),
      LayerLimit: By(gS),
      MaxWidth: By(gS),
      MaxHeight: By(gS),
    }),
    UT = Xy(GT, {
      ContactPersonPrimary: By(function (t, e) {
        return Ky({}, qT, t, e);
      }),
      ContactPosition: By(pS),
      ContactAddress: By(function (t, e) {
        return Ky({}, VT, t, e);
      }),
      ContactVoiceTelephone: By(pS),
      ContactFacsimileTelephone: By(pS),
      ContactElectronicMailAddress: By(pS),
    }),
    qT = Xy(GT, { ContactPerson: By(pS), ContactOrganization: By(pS) }),
    VT = Xy(GT, {
      AddressType: By(pS),
      Address: By(pS),
      City: By(pS),
      StateOrProvince: By(pS),
      PostCode: By(pS),
      Country: By(pS),
    }),
    XT = Xy(GT, { Format: Ny(pS) }),
    ZT = Xy(GT, {
      Name: By(pS),
      Title: By(pS),
      Abstract: By(pS),
      KeywordList: By(aP),
      CRS: Gy(pS),
      EX_GeographicBoundingBox: By(function (t, e) {
        const i = Ky({}, HT, t, e);
        if (!i) return;
        const n = i.westBoundLongitude,
          r = i.southBoundLatitude,
          s = i.eastBoundLongitude,
          o = i.northBoundLatitude;
        if (void 0 === n || void 0 === r || void 0 === s || void 0 === o)
          return;
        return [n, r, s, o];
      }),
      BoundingBox: Gy(function (t, e) {
        const i = [
            dS(t.getAttribute("minx")),
            dS(t.getAttribute("miny")),
            dS(t.getAttribute("maxx")),
            dS(t.getAttribute("maxy")),
          ],
          n = [dS(t.getAttribute("resx")), dS(t.getAttribute("resy"))];
        return { crs: t.getAttribute("CRS"), extent: i, res: n };
      }),
      Dimension: Gy(function (t, e) {
        return {
          name: t.getAttribute("name"),
          units: t.getAttribute("units"),
          unitSymbol: t.getAttribute("unitSymbol"),
          default: t.getAttribute("default"),
          multipleValues: hS(t.getAttribute("multipleValues")),
          nearestValue: hS(t.getAttribute("nearestValue")),
          current: hS(t.getAttribute("current")),
          values: pS(t),
        };
      }),
      Attribution: By(function (t, e) {
        return Ky({}, KT, t, e);
      }),
      AuthorityURL: Gy(function (t, e) {
        const i = rP(t, e);
        if (i) return (i.name = t.getAttribute("name")), i;
        return;
      }),
      Identifier: Gy(pS),
      MetadataURL: Gy(function (t, e) {
        const i = rP(t, e);
        if (i) return (i.type = t.getAttribute("type")), i;
        return;
      }),
      DataURL: Gy(rP),
      FeatureListURL: Gy(rP),
      Style: Gy(function (t, e) {
        return Ky({}, tP, t, e);
      }),
      MinScaleDenominator: By(uS),
      MaxScaleDenominator: By(uS),
      Layer: Gy(nP),
    }),
    KT = Xy(GT, { Title: By(pS), OnlineResource: By(aE), LogoURL: By(oP) }),
    HT = Xy(GT, {
      westBoundLongitude: By(uS),
      eastBoundLongitude: By(uS),
      southBoundLatitude: By(uS),
      northBoundLatitude: By(uS),
    }),
    YT = Xy(GT, {
      GetCapabilities: By(sP),
      GetMap: By(sP),
      GetFeatureInfo: By(sP),
    }),
    QT = Xy(GT, {
      Format: Gy(pS),
      DCPType: Gy(function (t, e) {
        return Ky({}, $T, t, e);
      }),
    }),
    $T = Xy(GT, {
      HTTP: By(function (t, e) {
        return Ky({}, JT, t, e);
      }),
    }),
    JT = Xy(GT, { Get: By(rP), Post: By(rP) }),
    tP = Xy(GT, {
      Name: By(pS),
      Title: By(pS),
      Abstract: By(pS),
      LegendURL: Gy(oP),
      StyleSheetURL: By(rP),
      StyleURL: By(rP),
    }),
    eP = Xy(GT, { Format: By(pS), OnlineResource: By(aE) }),
    iP = Xy(GT, { Keyword: Ny(pS) });
  function nP(t, e) {
    const i = e[e.length - 1],
      n = Ky({}, ZT, t, e);
    if (!n) return;
    let r = hS(t.getAttribute("queryable"));
    void 0 === r && (r = i.queryable), (n.queryable = void 0 !== r && r);
    let s = fS(t.getAttribute("cascaded"));
    void 0 === s && (s = i.cascaded), (n.cascaded = s);
    let o = hS(t.getAttribute("opaque"));
    void 0 === o && (o = i.opaque), (n.opaque = void 0 !== o && o);
    let a = hS(t.getAttribute("noSubsets"));
    void 0 === a && (a = i.noSubsets), (n.noSubsets = void 0 !== a && a);
    let l = dS(t.getAttribute("fixedWidth"));
    l || (l = i.fixedWidth), (n.fixedWidth = l);
    let h = dS(t.getAttribute("fixedHeight"));
    h || (h = i.fixedHeight), (n.fixedHeight = h);
    ["Style", "CRS", "AuthorityURL"].forEach(function (t) {
      if (t in i) {
        const e = n[t] || [];
        n[t] = e.concat(i[t]);
      }
    });
    return (
      [
        "EX_GeographicBoundingBox",
        "BoundingBox",
        "Dimension",
        "Attribution",
        "MinScaleDenominator",
        "MaxScaleDenominator",
      ].forEach(function (t) {
        if (!(t in n)) {
          const e = i[t];
          n[t] = e;
        }
      }),
      n
    );
  }
  function rP(t, e) {
    return Ky({}, eP, t, e);
  }
  function sP(t, e) {
    return Ky({}, QT, t, e);
  }
  function oP(t, e) {
    const i = rP(t, e);
    if (i) {
      const e = [fS(t.getAttribute("width")), fS(t.getAttribute("height"))];
      return (i.size = e), i;
    }
  }
  function aP(t, e) {
    return Ky([], iP, t, e);
  }
  var lP = class extends sE {
    constructor() {
      super(), (this.version = void 0);
    }
    readFromNode(t) {
      this.version = t.getAttribute("version").trim();
      const e = Ky({ version: this.version }, BT, t, []);
      return e || null;
    }
  };
  var hP = class extends nS {
    constructor(t) {
      super(),
        (t = t || {}),
        (this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver"),
        (this.gmlFormat_ = new ES()),
        (this.layers_ = t.layers ? t.layers : null);
    }
    getLayers() {
      return this.layers_;
    }
    setLayers(t) {
      this.layers_ = t;
    }
    readFeatures_(t, e) {
      t.setAttribute("namespaceURI", this.featureNS_);
      const i = t.localName;
      let n = [];
      if (0 === t.childNodes.length) return n;
      if ("msGMLOutput" == i)
        for (let i = 0, r = t.childNodes.length; i < r; i++) {
          const r = t.childNodes[i];
          if (r.nodeType !== Node.ELEMENT_NODE) continue;
          const s = r,
            o = e[0],
            a = "_layer",
            l = s.localName.replace(a, "");
          if (this.layers_ && !this.layers_.includes(l)) continue;
          const c = l + "_feature";
          (o.featureType = c), (o.featureNS = this.featureNS_);
          const u = {};
          u[c] = Ny(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
          const d = Xy([o.featureNS, null], u);
          s.setAttribute("namespaceURI", this.featureNS_);
          const g = Ky([], d, s, e, this.gmlFormat_);
          g && h(n, g);
        }
      if ("FeatureCollection" == i) {
        const e = Ky(
          [],
          this.gmlFormat_.FEATURE_COLLECTION_PARSERS,
          t,
          [{}],
          this.gmlFormat_
        );
        e && (n = e);
      }
      return n;
    }
    readFeaturesFromNode(t, e) {
      const i = {};
      return (
        e && Object.assign(i, this.getReadOptions(t, e)),
        this.readFeatures_(t, [i])
      );
    }
  };
  const cP = [null, "http://www.opengis.net/wmts/1.0"],
    uP = [null, "http://www.opengis.net/ows/1.1"],
    dP = Xy(cP, {
      Contents: By(function (t, e) {
        return Ky({}, gP, t, e);
      }),
    });
  const gP = Xy(cP, {
      Layer: Gy(function (t, e) {
        return Ky({}, fP, t, e);
      }),
      TileMatrixSet: Gy(function (t, e) {
        return Ky({}, SP, t, e);
      }),
    }),
    fP = Xy(
      cP,
      {
        Style: Gy(function (t, e) {
          const i = Ky({}, pP, t, e);
          if (!i) return;
          const n = "true" === t.getAttribute("isDefault");
          return (i.isDefault = n), i;
        }),
        Format: Gy(pS),
        TileMatrixSetLink: Gy(function (t, e) {
          return Ky({}, mP, t, e);
        }),
        Dimension: Gy(function (t, e) {
          return Ky({}, xP, t, e);
        }),
        ResourceURL: Gy(function (t, e) {
          const i = t.getAttribute("format"),
            n = t.getAttribute("template"),
            r = t.getAttribute("resourceType"),
            s = {};
          i && (s.format = i);
          n && (s.template = n);
          r && (s.resourceType = r);
          return s;
        }),
      },
      Xy(uP, {
        Title: By(pS),
        Abstract: By(pS),
        WGS84BoundingBox: By(wP),
        Identifier: By(pS),
      })
    ),
    pP = Xy(
      cP,
      {
        LegendURL: Gy(function (t, e) {
          const i = {};
          return (i.format = t.getAttribute("format")), (i.href = aE(t)), i;
        }),
      },
      Xy(uP, { Title: By(pS), Identifier: By(pS) })
    ),
    mP = Xy(cP, {
      TileMatrixSet: By(pS),
      TileMatrixSetLimits: By(function (t, e) {
        return Ky([], _P, t, e);
      }),
    }),
    _P = Xy(cP, {
      TileMatrixLimits: Ny(function (t, e) {
        return Ky({}, yP, t, e);
      }),
    }),
    yP = Xy(cP, {
      TileMatrix: By(pS),
      MinTileRow: By(gS),
      MaxTileRow: By(gS),
      MinTileCol: By(gS),
      MaxTileCol: By(gS),
    }),
    xP = Xy(
      cP,
      { Default: By(pS), Value: Gy(pS) },
      Xy(uP, { Identifier: By(pS) })
    ),
    vP = Xy(uP, { LowerCorner: Ny(WP), UpperCorner: Ny(WP) }),
    SP = Xy(
      cP,
      {
        WellKnownScaleSet: By(pS),
        TileMatrix: Gy(function (t, e) {
          return Ky({}, CP, t, e);
        }),
      },
      Xy(uP, { SupportedCRS: By(pS), Identifier: By(pS), BoundingBox: By(wP) })
    ),
    CP = Xy(
      cP,
      {
        TopLeftCorner: By(WP),
        ScaleDenominator: By(uS),
        TileWidth: By(gS),
        TileHeight: By(gS),
        MatrixWidth: By(gS),
        MatrixHeight: By(gS),
      },
      Xy(uP, { Identifier: By(pS) })
    );
  function wP(t, e) {
    const i = Ky([], vP, t, e);
    if (2 == i.length) return Qt(i);
  }
  function WP(t, e) {
    const i = pS(t).split(/\s+/);
    if (!i || 2 != i.length) return;
    const n = +i[0],
      r = +i[1];
    return isNaN(n) || isNaN(r) ? void 0 : [n, r];
  }
  var EP = class extends sE {
      constructor() {
        super(), (this.owsParser_ = new wE());
      }
      readFromNode(t) {
        let e = t.getAttribute("version");
        e && (e = e.trim());
        let i = this.owsParser_.readFromNode(t);
        return i ? ((i.version = e), (i = Ky(i, dP, t, [])), i || null) : null;
      }
    },
    RP = {};
  return (
    (RP.Collection = K),
    (RP.Collection.CollectionEvent = Z),
    (RP.DataTile = bt),
    (RP.DataTile.asArrayLike = Et),
    (RP.DataTile.asImageLike = Wt),
    (RP.DataTile.toArray = Tt),
    (RP.Disposable = n),
    (RP.Feature = Mt),
    (RP.Feature.createStyleFunction = Lt),
    (RP.Geolocation = qr),
    (RP.Geolocation.GeolocationError = Ur),
    (RP.Image = ts),
    (RP.Image.decode = Jr),
    (RP.Image.decodeFallback = $r),
    (RP.Image.listenImage = Yr),
    (RP.Image.load = Qr),
    (RP.ImageCanvas = es),
    (RP.ImageTile = is),
    (RP.Kinetic = ns),
    (RP.Map = Py),
    (RP.MapBrowserEvent = qo),
    (RP.MapBrowserEventHandler = Yo),
    (RP.MapEvent = Uo),
    (RP.Object = U),
    (RP.Object.ObjectEvent = z),
    (RP.Observable = D),
    (RP.Observable.unByKey = N),
    (RP.Overlay = Sl),
    (RP.Tile = rt),
    (RP.TileCache = ap),
    (RP.TileQueue = la),
    (RP.TileQueue.getTilePriority = ha),
    (RP.TileRange = Ig),
    (RP.TileRange.createOrUpdate = Fg),
    (RP.VectorRenderTile = Qm),
    (RP.VectorTile = Hm),
    (RP.View = eo),
    (RP.View.createCenterConstraint = Ys),
    (RP.View.createResolutionConstraint = Qs),
    (RP.View.createRotationConstraint = $s),
    (RP.View.isNoopAnimation = Js),
    (RP.array = {}),
    (RP.array.ascending = s),
    (RP.array.binarySearch = r),
    (RP.array.descending = o),
    (RP.array.equals = c),
    (RP.array.extend = h),
    (RP.array.isSorted = u),
    (RP.array.linearFindNearest = a),
    (RP.array.remove = function (t, e) {
      const i = t.indexOf(e),
        n = i > -1;
      return n && t.splice(i, 1), n;
    }),
    (RP.array.reverseSubArray = l),
    (RP.array.stableSort = function (t, e) {
      const i = t.length,
        n = Array(t.length);
      let r;
      for (r = 0; r < i; r++) n[r] = { index: r, value: t[r] };
      for (
        n.sort(function (t, i) {
          return e(t.value, i.value) || t.index - i.index;
        }),
          r = 0;
        r < t.length;
        r++
      )
        t[r] = n[r].value;
    }),
    (RP.asserts = {}),
    (RP.asserts.assert = Ft),
    (RP.centerconstraint = {}),
    (RP.centerconstraint.createExtent = Ds),
    (RP.centerconstraint.none = Gs),
    (RP.color = {}),
    (RP.color.asArray = hs),
    (RP.color.asString = os),
    (RP.color.fromString = ls),
    (RP.color.isStringColor = ds),
    (RP.color.normalize = cs),
    (RP.color.toString = us),
    (RP.colorlike = {}),
    (RP.colorlike.asColorLike = Vl),
    (RP.console = {}),
    (RP.console.error = Zi),
    (RP.console.log = function (...t) {
      Vi > qi.info || console.log(...t);
    }),
    (RP.console.setLevel = function (t) {
      Vi = qi[t];
    }),
    (RP.console.warn = Xi),
    (RP.control = {}),
    (RP.control.Attribution = ua),
    (RP.control.Control = ca),
    (RP.control.FullScreen = dl),
    (RP.control.MousePosition = pl),
    (RP.control.OverviewMap = Wl),
    (RP.control.Rotate = da),
    (RP.control.ScaleLine = Pl),
    (RP.control.Zoom = ga),
    (RP.control.ZoomSlider = Il),
    (RP.control.ZoomToExtent = Ll),
    (RP.control.defaults = {}),
    (RP.control.defaults.defaults = fa),
    (RP.coordinate = {}),
    (RP.coordinate.add = Ei),
    (RP.coordinate.closestOnCircle = Ri),
    (RP.coordinate.closestOnSegment = Ti),
    (RP.coordinate.createStringXY = function (t) {
      return function (e) {
        return Ai(e, t);
      };
    }),
    (RP.coordinate.degreesToStringHDMS = Pi),
    (RP.coordinate.distance = Oi),
    (RP.coordinate.equals = Fi),
    (RP.coordinate.format = bi),
    (RP.coordinate.getWorldsAway = Di),
    (RP.coordinate.rotate = Ii),
    (RP.coordinate.scale = Li),
    (RP.coordinate.squaredDistance = Mi),
    (RP.coordinate.squaredDistanceToSegment = ki),
    (RP.coordinate.toStringHDMS = function (t, e) {
      return t ? Pi("NS", t[1], e) + " " + Pi("EW", t[0], e) : "";
    }),
    (RP.coordinate.toStringXY = Ai),
    (RP.coordinate.wrapX = Ni),
    (RP.css = {}),
    (RP.css.CLASS_COLLAPSED = go),
    (RP.css.CLASS_CONTROL = uo),
    (RP.css.CLASS_HIDDEN = ao),
    (RP.css.CLASS_SELECTABLE = lo),
    (RP.css.CLASS_UNSELECTABLE = ho),
    (RP.css.CLASS_UNSUPPORTED = co),
    (RP.css.getFontParameters = mo),
    (RP.dom = {}),
    (RP.dom.createCanvasContext2D = mt),
    (RP.dom.outerHeight = xt),
    (RP.dom.outerWidth = yt),
    (RP.dom.releaseCanvas = _t),
    (RP.dom.removeChildren = Ct),
    (RP.dom.removeNode = St),
    (RP.dom.replaceChildren = wt),
    (RP.dom.replaceNode = vt),
    (RP.easing = {}),
    (RP.easing.easeIn = tt),
    (RP.easing.easeOut = et),
    (RP.easing.inAndOut = it),
    (RP.easing.linear = nt),
    (RP.easing.upAndDown = function (t) {
      return t < 0.5 ? it(2 * t) : 1 - it(2 * (t - 0.5));
    }),
    (RP.events = {}),
    (RP.events.Event = e),
    (RP.events.Event.preventDefault = function (t) {
      t.preventDefault();
    }),
    (RP.events.Event.stopPropagation = t),
    (RP.events.SnapEvent = {}),
    (RP.events.SnapEvent.SnapEvent = kv),
    (RP.events.Target = x),
    (RP.events.condition = {}),
    (RP.events.condition.all = Ca),
    (RP.events.condition.altKeyOnly = wa),
    (RP.events.condition.altShiftKeysOnly = Wa),
    (RP.events.condition.always = Ta),
    (RP.events.condition.click = function (t) {
      return t.type == Vo.CLICK;
    }),
    (RP.events.condition.doubleClick = function (t) {
      return t.type == Vo.DBLCLICK;
    }),
    (RP.events.condition.focus = Ea),
    (RP.events.condition.focusWithTabindex = Ra),
    (RP.events.condition.mouseActionButton = Pa),
    (RP.events.condition.mouseOnly = ka),
    (RP.events.condition.never = ba),
    (RP.events.condition.noModifierKeys = Ia),
    (RP.events.condition.penOnly = function (t) {
      const e = t.originalEvent;
      return (
        Ft(void 0 !== e, "mapBrowserEvent must originate from a pointer event"),
        "pen" === e.pointerType
      );
    }),
    (RP.events.condition.platformModifierKey = La),
    (RP.events.condition.platformModifierKeyOnly = function (t) {
      const e = t.originalEvent;
      return !e.altKey && (ct ? e.metaKey : e.ctrlKey) && !e.shiftKey;
    }),
    (RP.events.condition.pointerMove = function (t) {
      return "pointermove" == t.type;
    }),
    (RP.events.condition.primaryAction = Aa),
    (RP.events.condition.shiftKeyOnly = Ma),
    (RP.events.condition.singleClick = Fa),
    (RP.events.condition.targetNotEditable = Oa),
    (RP.events.condition.touchOnly = function (t) {
      const e = t.originalEvent;
      return (
        Ft(void 0 !== e, "mapBrowserEvent must originate from a pointer event"),
        "touch" === e.pointerType
      );
    }),
    (RP.events.listen = M),
    (RP.events.listenOnce = O),
    (RP.events.unlistenByKey = k),
    (RP.expr = {}),
    (RP.expr.cpu = {}),
    (RP.expr.cpu.buildExpression = Qh),
    (RP.expr.cpu.newEvaluationContext = Yh),
    (RP.expr.expression = {}),
    (RP.expr.expression.AnyType = Ah),
    (RP.expr.expression.BooleanType = Ih),
    (RP.expr.expression.CallExpression = Uh),
    (RP.expr.expression.ColorType = Oh),
    (RP.expr.expression.LiteralExpression = zh),
    (RP.expr.expression.NoneType = 0),
    (RP.expr.expression.NumberArrayType = kh),
    (RP.expr.expression.NumberType = Lh),
    (RP.expr.expression.Ops = Xh),
    (RP.expr.expression.StringType = Mh),
    (RP.expr.expression.includesType = Bh),
    (RP.expr.expression.isType = function (t, e) {
      return t === e;
    }),
    (RP.expr.expression.newParsingContext = qh),
    (RP.expr.expression.overlapsType = jh),
    (RP.expr.expression.parse = Vh),
    (RP.expr.expression.typeName = Gh),
    (RP.extent = {}),
    (RP.extent.applyTransform = Ae),
    (RP.extent.approximatelyEquals = ue),
    (RP.extent.boundingExtent = Qt),
    (RP.extent.buffer = $t),
    (RP.extent.clone = Jt),
    (RP.extent.closestSquaredDistanceXY = te),
    (RP.extent.containsCoordinate = ee),
    (RP.extent.containsExtent = ie),
    (RP.extent.containsXY = ne),
    (RP.extent.coordinateRelationship = re),
    (RP.extent.createEmpty = se),
    (RP.extent.createOrUpdate = oe),
    (RP.extent.createOrUpdateEmpty = ae),
    (RP.extent.createOrUpdateFromCoordinate = le),
    (RP.extent.createOrUpdateFromCoordinates = function (t, e) {
      return fe(ae(e), t);
    }),
    (RP.extent.createOrUpdateFromFlatCoordinates = he),
    (RP.extent.createOrUpdateFromRings = function (t, e) {
      return me(ae(e), t);
    }),
    (RP.extent.equals = ce),
    (RP.extent.extend = de),
    (RP.extent.extendCoordinate = ge),
    (RP.extent.extendCoordinates = fe),
    (RP.extent.extendFlatCoordinates = pe),
    (RP.extent.extendRings = me),
    (RP.extent.extendXY = _e),
    (RP.extent.forEachCorner = ye),
    (RP.extent.getArea = xe),
    (RP.extent.getBottomLeft = ve),
    (RP.extent.getBottomRight = Se),
    (RP.extent.getCenter = Ce),
    (RP.extent.getCorner = we),
    (RP.extent.getEnlargedArea = function (t, e) {
      const i = Math.min(t[0], e[0]),
        n = Math.min(t[1], e[1]);
      return (Math.max(t[2], e[2]) - i) * (Math.max(t[3], e[3]) - n);
    }),
    (RP.extent.getForViewAndSize = We),
    (RP.extent.getHeight = Re),
    (RP.extent.getIntersection = Te),
    (RP.extent.getIntersectionArea = function (t, e) {
      return xe(Te(t, e));
    }),
    (RP.extent.getMargin = function (t) {
      return Fe(t) + Re(t);
    }),
    (RP.extent.getRotatedViewport = Ee),
    (RP.extent.getSize = function (t) {
      return [t[2] - t[0], t[3] - t[1]];
    }),
    (RP.extent.getTopLeft = Pe),
    (RP.extent.getTopRight = be),
    (RP.extent.getWidth = Fe),
    (RP.extent.intersects = Ie),
    (RP.extent.intersectsSegment = ke),
    (RP.extent.isEmpty = Le),
    (RP.extent.returnOrUpdate = Me),
    (RP.extent.scaleFromCenter = Oe),
    (RP.extent.wrapAndSliceX = De),
    (RP.extent.wrapX = Ne),
    (RP.featureloader = {}),
    (RP.featureloader.loadFeaturesXhr = ju),
    (RP.featureloader.setWithCredentials = function (t) {
      Bu = t;
    }),
    (RP.featureloader.xhr = zu),
    (RP.format = {}),
    (RP.format.EsriJSON = iS),
    (RP.format.Feature = Vv),
    (RP.format.Feature.transformExtentWithOptions = Zv),
    (RP.format.Feature.transformGeometryWithOptions = Xv),
    (RP.format.GML = IS),
    (RP.format.GML2 = ES),
    (RP.format.GML3 = bS),
    (RP.format.GML32 = MS),
    (RP.format.GMLBase = aS),
    (RP.format.GMLBase.GMLNS = rS),
    (RP.format.GPX = gC),
    (RP.format.GeoJSON = mC),
    (RP.format.IGC = wC),
    (RP.format.IIIFInfo = am),
    (RP.format.JSONFeature = Hv),
    (RP.format.KML = WW),
    (RP.format.KML.getDefaultFillStyle = function () {
      return BC;
    }),
    (RP.format.KML.getDefaultImageStyle = function () {
      return zC;
    }),
    (RP.format.KML.getDefaultStrokeStyle = function () {
      return qC;
    }),
    (RP.format.KML.getDefaultStyle = function () {
      return XC;
    }),
    (RP.format.KML.getDefaultStyleArray = function () {
      return KC;
    }),
    (RP.format.KML.getDefaultTextStyle = function () {
      return VC;
    }),
    (RP.format.KML.readFlatCoordinates = JC),
    (RP.format.MVT = $W),
    (RP.format.OSMXML = rE),
    (RP.format.OWS = wE),
    (RP.format.Polyline = ME),
    (RP.format.Polyline.decodeDeltas = EE),
    (RP.format.Polyline.decodeFloats = TE),
    (RP.format.Polyline.decodeSignedIntegers = bE),
    (RP.format.Polyline.decodeUnsignedIntegers = IE),
    (RP.format.Polyline.encodeDeltas = WE),
    (RP.format.Polyline.encodeFloats = RE),
    (RP.format.Polyline.encodeSignedIntegers = PE),
    (RP.format.Polyline.encodeUnsignedInteger = LE),
    (RP.format.Polyline.encodeUnsignedIntegers = FE),
    (RP.format.TextFeature = yC),
    (RP.format.TopoJSON = BE),
    (RP.format.WFS = rT),
    (RP.format.WFS.writeFilter = function (t, e) {
      const i = Fy(nT((e = e || "1.1.0")), "Filter"),
        n = { node: i };
      return Object.assign(n, { version: e, filter: t }), jR(i, t, [n]), i;
    }),
    (RP.format.WKB = yT),
    (RP.format.WKT = DT),
    (RP.format.WMSCapabilities = lP),
    (RP.format.WMSGetFeatureInfo = hP),
    (RP.format.WMTSCapabilities = EP),
    (RP.format.XML = sE),
    (RP.format.XMLFeature = nS),
    (RP.format.filter = {}),
    (RP.format.filter.And = UE),
    (RP.format.filter.Bbox = qE),
    (RP.format.filter.Comparison = HE),
    (RP.format.filter.ComparisonBinary = QE),
    (RP.format.filter.Contains = XE),
    (RP.format.filter.DWithin = ZE),
    (RP.format.filter.Disjoint = KE),
    (RP.format.filter.During = YE),
    (RP.format.filter.EqualTo = $E),
    (RP.format.filter.Filter = jE),
    (RP.format.filter.GreaterThan = JE),
    (RP.format.filter.GreaterThanOrEqualTo = tR),
    (RP.format.filter.Intersects = eR),
    (RP.format.filter.IsBetween = iR),
    (RP.format.filter.IsLike = nR),
    (RP.format.filter.IsNull = rR),
    (RP.format.filter.LessThan = sR),
    (RP.format.filter.LessThanOrEqualTo = oR),
    (RP.format.filter.LogicalNary = zE),
    (RP.format.filter.Not = aR),
    (RP.format.filter.NotEqualTo = lR),
    (RP.format.filter.Or = hR),
    (RP.format.filter.ResourceId = cR),
    (RP.format.filter.Spatial = VE),
    (RP.format.filter.Within = uR),
    (RP.format.filter.and = dR),
    (RP.format.filter.bbox = gR),
    (RP.format.filter.between = function (t, e, i) {
      return new iR(t, e, i);
    }),
    (RP.format.filter.contains = function (t, e, i) {
      return new XE(t, e, i);
    }),
    (RP.format.filter.disjoint = function (t, e, i) {
      return new KE(t, e, i);
    }),
    (RP.format.filter.during = function (t, e, i) {
      return new YE(t, e, i);
    }),
    (RP.format.filter.dwithin = function (t, e, i, n, r) {
      return new ZE(t, e, i, n, r);
    }),
    (RP.format.filter.equalTo = function (t, e, i) {
      return new $E(t, e, i);
    }),
    (RP.format.filter.greaterThan = function (t, e) {
      return new JE(t, e);
    }),
    (RP.format.filter.greaterThanOrEqualTo = function (t, e) {
      return new tR(t, e);
    }),
    (RP.format.filter.intersects = function (t, e, i) {
      return new eR(t, e, i);
    }),
    (RP.format.filter.isNull = function (t) {
      return new rR(t);
    }),
    (RP.format.filter.lessThan = function (t, e) {
      return new sR(t, e);
    }),
    (RP.format.filter.lessThanOrEqualTo = function (t, e) {
      return new oR(t, e);
    }),
    (RP.format.filter.like = function (t, e, i, n, r, s) {
      return new nR(t, e, i, n, r, s);
    }),
    (RP.format.filter.not = function (t) {
      return new aR(t);
    }),
    (RP.format.filter.notEqualTo = function (t, e, i) {
      return new lR(t, e, i);
    }),
    (RP.format.filter.or = function (t) {
      const e = [null].concat(Array.prototype.slice.call(arguments));
      return new (Function.prototype.bind.apply(hR, e))();
    }),
    (RP.format.filter.resourceId = function (t) {
      return new cR(t);
    }),
    (RP.format.filter.within = function (t, e, i) {
      return new uR(t, e, i);
    }),
    (RP.format.xlink = {}),
    (RP.format.xlink.readHref = aE),
    (RP.format.xsd = {}),
    (RP.format.xsd.readBoolean = lS),
    (RP.format.xsd.readBooleanString = hS),
    (RP.format.xsd.readDateTime = cS),
    (RP.format.xsd.readDecimal = uS),
    (RP.format.xsd.readDecimalString = dS),
    (RP.format.xsd.readNonNegativeIntegerString = fS),
    (RP.format.xsd.readPositiveInteger = gS),
    (RP.format.xsd.readString = pS),
    (RP.format.xsd.writeBooleanTextNode = mS),
    (RP.format.xsd.writeCDATASection = _S),
    (RP.format.xsd.writeDateTimeTextNode = yS),
    (RP.format.xsd.writeDecimalTextNode = xS),
    (RP.format.xsd.writeNonNegativeIntegerTextNode = vS),
    (RP.format.xsd.writeStringTextNode = SS),
    (RP.functions = {}),
    (RP.functions.FALSE = g),
    (RP.functions.TRUE = d),
    (RP.functions.VOID = f),
    (RP.functions.memoizeOne = p),
    (RP.functions.toPromise = m),
    (RP.geom = {}),
    (RP.geom.Circle = Wx),
    (RP.geom.Geometry = bn),
    (RP.geom.GeometryCollection = Tx),
    (RP.geom.LineString = Bl),
    (RP.geom.LinearRing = rr),
    (RP.geom.MultiLineString = bx),
    (RP.geom.MultiPoint = Ix),
    (RP.geom.MultiPolygon = Ox),
    (RP.geom.Point = or),
    (RP.geom.Polygon = Tr),
    (RP.geom.Polygon.circular = Pr),
    (RP.geom.Polygon.fromCircle = Fr),
    (RP.geom.Polygon.fromExtent = br),
    (RP.geom.Polygon.makeRegular = Ir),
    (RP.geom.SimpleGeometry = Ln),
    (RP.geom.SimpleGeometry.getStrideForLayout = Fn),
    (RP.geom.SimpleGeometry.transformGeom2D = In),
    (RP.geom.flat = {}),
    (RP.geom.flat.area = {}),
    (RP.geom.flat.area.linearRing = tr),
    (RP.geom.flat.area.linearRings = er),
    (RP.geom.flat.area.linearRingss = ir),
    (RP.geom.flat.center = {}),
    (RP.geom.flat.center.linearRingss = Lx),
    (RP.geom.flat.closest = {}),
    (RP.geom.flat.closest.arrayMaxSquaredDelta = kn),
    (RP.geom.flat.closest.assignClosestArrayPoint = Dn),
    (RP.geom.flat.closest.assignClosestMultiArrayPoint = Gn),
    (RP.geom.flat.closest.assignClosestPoint = Nn),
    (RP.geom.flat.closest.maxSquaredDelta = On),
    (RP.geom.flat.closest.multiArrayMaxSquaredDelta = An),
    (RP.geom.flat.contains = {}),
    (RP.geom.flat.contains.linearRingContainsExtent = ar),
    (RP.geom.flat.contains.linearRingContainsXY = lr),
    (RP.geom.flat.contains.linearRingsContainsXY = hr),
    (RP.geom.flat.contains.linearRingssContainsXY = cr),
    (RP.geom.flat.deflate = {}),
    (RP.geom.flat.deflate.deflateCoordinate = Bn),
    (RP.geom.flat.deflate.deflateCoordinates = jn),
    (RP.geom.flat.deflate.deflateCoordinatesArray = zn),
    (RP.geom.flat.deflate.deflateMultiCoordinatesArray = Un),
    (RP.geom.flat.flip = {}),
    (RP.geom.flat.flip.flipXY = qv),
    (RP.geom.flat.geodesic = {}),
    (RP.geom.flat.geodesic.greatCircleArc = function (t, e, i, n, r, s) {
      const o = tn("EPSG:4326"),
        a = Math.cos(mi(e)),
        l = Math.sin(mi(e)),
        h = Math.cos(mi(n)),
        c = Math.sin(mi(n)),
        u = Math.cos(mi(i - t)),
        d = Math.sin(mi(i - t)),
        g = l * c + a * h * u;
      return Xu(
        function (e) {
          if (1 <= g) return [i, n];
          const r = e * Math.acos(g),
            s = Math.cos(r),
            o = Math.sin(r),
            f = d * h,
            p = a * c - l * h * u,
            m = Math.atan2(f, p),
            _ = Math.asin(l * s + a * o * Math.cos(m));
          return [
            pi(mi(t) + Math.atan2(Math.sin(m) * o * a, s - l * Math.sin(_))),
            pi(_),
          ];
        },
        cn(o, r),
        s
      );
    }),
    (RP.geom.flat.geodesic.meridian = Zu),
    (RP.geom.flat.geodesic.parallel = Ku),
    (RP.geom.flat.inflate = {}),
    (RP.geom.flat.inflate.inflateCoordinates = Qn),
    (RP.geom.flat.inflate.inflateCoordinatesArray = $n),
    (RP.geom.flat.inflate.inflateMultiCoordinatesArray = Jn),
    (RP.geom.flat.interiorpoint = {}),
    (RP.geom.flat.interiorpoint.getInteriorPointOfArray = ur),
    (RP.geom.flat.interiorpoint.getInteriorPointsOfMultiArray = dr),
    (RP.geom.flat.interpolate = {}),
    (RP.geom.flat.interpolate.interpolatePoint = kl),
    (RP.geom.flat.interpolate.lineStringCoordinateAtM = Al),
    (RP.geom.flat.interpolate.lineStringsCoordinateAtM = Nl),
    (RP.geom.flat.intersectsextent = {}),
    (RP.geom.flat.intersectsextent.intersectsLineString = fr),
    (RP.geom.flat.intersectsextent.intersectsLineStringArray = pr),
    (RP.geom.flat.intersectsextent.intersectsLinearRing = mr),
    (RP.geom.flat.intersectsextent.intersectsLinearRingArray = _r),
    (RP.geom.flat.intersectsextent.intersectsLinearRingMultiArray = yr),
    (RP.geom.flat.length = {}),
    (RP.geom.flat.length.lineStringLength = Dl),
    (RP.geom.flat.length.linearRingLength = function (t, e, i, n) {
      let r = Dl(t, e, i, n);
      const s = t[i - n] - t[e],
        o = t[i - n + 1] - t[e + 1];
      return (r += Math.sqrt(s * s + o * o)), r;
    }),
    (RP.geom.flat.orient = {}),
    (RP.geom.flat.orient.inflateEnds = Er),
    (RP.geom.flat.orient.linearRingIsClockwise = vr),
    (RP.geom.flat.orient.linearRingsAreOriented = Sr),
    (RP.geom.flat.orient.linearRingssAreOriented = Cr),
    (RP.geom.flat.orient.orientLinearRings = wr),
    (RP.geom.flat.orient.orientLinearRingsArray = Wr),
    (RP.geom.flat.reverse = {}),
    (RP.geom.flat.reverse.coordinates = xr),
    (RP.geom.flat.segments = {}),
    (RP.geom.flat.segments.forEach = gr),
    (RP.geom.flat.simplify = {}),
    (RP.geom.flat.simplify.douglasPeucker = qn),
    (RP.geom.flat.simplify.douglasPeuckerArray = Vn),
    (RP.geom.flat.simplify.douglasPeuckerMultiArray = function (
      t,
      e,
      i,
      n,
      r,
      s,
      o,
      a
    ) {
      for (let l = 0, h = i.length; l < h; ++l) {
        const h = i[l],
          c = [];
        (o = Vn(t, e, h, n, r, s, o, c)), a.push(c), (e = h[h.length - 1]);
      }
      return o;
    }),
    (RP.geom.flat.simplify.quantize = Kn),
    (RP.geom.flat.simplify.quantizeArray = Hn),
    (RP.geom.flat.simplify.quantizeMultiArray = Yn),
    (RP.geom.flat.simplify.radialDistance = Xn),
    (RP.geom.flat.simplify.simplifyLineString = function (t, e, i, n, r, s, o) {
      return (
        (o = void 0 !== o ? o : []),
        s || ((i = Xn(t, e, i, n, r, o, 0)), (t = o), (e = 0), (n = 2)),
        (o.length = qn(t, e, i, n, r, o, 0)),
        o
      );
    }),
    (RP.geom.flat.simplify.snap = Zn),
    (RP.geom.flat.straightchunk = {}),
    (RP.geom.flat.straightchunk.matchingChunk = Xc),
    (RP.geom.flat.textpath = {}),
    (RP.geom.flat.textpath.drawTextOnPath = eu),
    (RP.geom.flat.topology = {}),
    (RP.geom.flat.topology.lineStringIsClosed = function (t, e, i, n) {
      const r = i - n;
      return (
        t[e] === t[r] &&
        t[e + 1] === t[r + 1] &&
        (i - e) / n > 3 &&
        !!tr(t, e, i, n)
      );
    }),
    (RP.geom.flat.transform = {}),
    (RP.geom.flat.transform.rotate = En),
    (RP.geom.flat.transform.scale = Rn),
    (RP.geom.flat.transform.transform2D = Wn),
    (RP.geom.flat.transform.translate = Tn),
    (RP.has = {}),
    (RP.has.CREATE_IMAGE_BITMAP = ft),
    (RP.has.DEVICE_PIXEL_RATIO = ut),
    (RP.has.FIREFOX = ot),
    (RP.has.IMAGE_DECODE = gt),
    (RP.has.MAC = ct),
    (RP.has.PASSIVE_EVENT_LISTENERS = pt),
    (RP.has.SAFARI = at),
    (RP.has.SAFARI_BUG_237906 = lt),
    (RP.has.WEBKIT = ht),
    (RP.has.WORKER_OFFSCREEN_CANVAS = dt),
    (RP.interaction = {}),
    (RP.interaction.DblClickDragZoom = zx),
    (RP.interaction.DoubleClickZoom = xa),
    (RP.interaction.DragAndDrop = Vx),
    (RP.interaction.DragAndDrop.DragAndDropEvent = qx),
    (RP.interaction.DragBox = Va),
    (RP.interaction.DragBox.DragBoxEvent = qa),
    (RP.interaction.DragPan = Na),
    (RP.interaction.DragRotate = Da),
    (RP.interaction.DragRotateAndZoom = Xx),
    (RP.interaction.DragZoom = Xa),
    (RP.interaction.Draw = av),
    (RP.interaction.Draw.DrawEvent = Yx),
    (RP.interaction.Draw.createBox = function () {
      return function (t, e, i) {
        const n = Qt(
            [t[0], t[t.length - 1]].map(function (t) {
              return _n(t, i);
            })
          ),
          r = [[ve(n), Se(n), be(n), Pe(n), ve(n)]];
        e ? e.setCoordinates(r) : (e = new Tr(r));
        const s = pn();
        return s && e.transform(i, s), e;
      };
    }),
    (RP.interaction.Draw.createRegularPolygon = function (t, e) {
      return function (i, n, r) {
        const s = _n(i[0], r),
          o = _n(i[i.length - 1], r),
          a = Math.sqrt(Mi(s, o));
        n = n || Fr(new Wx(s), t);
        let l = e;
        if (!e && 0 !== e) {
          const t = o[0] - s[0],
            e = o[1] - s[1];
          l = Math.atan2(e, t);
        }
        Ir(n, s, a, l);
        const h = pn();
        return h && n.transform(r, h), n;
      };
    }),
    (RP.interaction.Extent = fv),
    (RP.interaction.Extent.ExtentEvent = hv),
    (RP.interaction.Interaction = ya),
    (RP.interaction.Interaction.pan = ma),
    (RP.interaction.Interaction.zoomByDelta = _a),
    (RP.interaction.KeyboardPan = Qa),
    (RP.interaction.KeyboardZoom = $a),
    (RP.interaction.Link = yv),
    (RP.interaction.Modify = Pv),
    (RP.interaction.Modify.ModifyEvent = wv),
    (RP.interaction.MouseWheelZoom = Ja),
    (RP.interaction.PinchRotate = tl),
    (RP.interaction.PinchZoom = el),
    (RP.interaction.Pointer = Sa),
    (RP.interaction.Pointer.centroid = va),
    (RP.interaction.Select = Mv),
    (RP.interaction.Select.SelectEvent = Fv),
    (RP.interaction.Snap = Dv),
    (RP.interaction.Translate = Uv),
    (RP.interaction.Translate.TranslateEvent = zv),
    (RP.interaction.defaults = {}),
    (RP.interaction.defaults.defaults = il),
    (RP.layer = {}),
    (RP.layer.Base = Ts),
    (RP.layer.BaseImage = Af),
    (RP.layer.BaseTile = jf),
    (RP.layer.BaseVector = Cc),
    (RP.layer.Graticule = Qu),
    (RP.layer.Group = zo),
    (RP.layer.Group.GroupEvent = Go),
    (RP.layer.Heatmap = kf),
    (RP.layer.Image = Df),
    (RP.layer.Layer = no),
    (RP.layer.Layer.inView = io),
    (RP.layer.Tile = Uf),
    (RP.layer.Vector = Pu),
    (RP.layer.VectorImage = Xf),
    (RP.layer.VectorTile = Yf),
    (RP.layer.WebGLPoints = np),
    (RP.layer.WebGLTile = op),
    (RP.loadingstrategy = {}),
    (RP.loadingstrategy.all = Gu),
    (RP.loadingstrategy.bbox = function (t, e) {
      return [t];
    }),
    (RP.loadingstrategy.tile = function (t) {
      return function (e, i, n) {
        const r = t.getZForResolution(Sn(i, n)),
          s = t.getTileRangeForExtentAndZ(xn(e, n), r),
          o = [],
          a = [r, 0, 0];
        for (a[1] = s.minX; a[1] <= s.maxX; ++a[1])
          for (a[2] = s.minY; a[2] <= s.maxY; ++a[2])
            o.push(yn(t.getTileCoordExtent(a), n));
        return o;
      };
    }),
    (RP.math = {}),
    (RP.math.ceil = Ci),
    (RP.math.clamp = ui),
    (RP.math.floor = Si),
    (RP.math.lerp = yi),
    (RP.math.modulo = _i),
    (RP.math.round = vi),
    (RP.math.solveLinearSystem = fi),
    (RP.math.squaredDistance = gi),
    (RP.math.squaredSegmentDistance = di),
    (RP.math.toDegrees = pi),
    (RP.math.toFixed = xi),
    (RP.math.toRadians = mi),
    (RP.net = {}),
    (RP.net.ClientError = Dm),
    (RP.net.ResponseError = Nm),
    (RP.net.getJSON = Gm),
    (RP.net.jsonp = Am),
    (RP.net.overrideXHR = function (t) {
      "undefined" != typeof XMLHttpRequest && (jm = XMLHttpRequest),
        (global.XMLHttpRequest = t);
    }),
    (RP.net.resolveUrl = Bm),
    (RP.net.restoreXHR = function () {
      global.XMLHttpRequest = jm;
    }),
    (RP.obj = {}),
    (RP.obj.clear = _),
    (RP.obj.isEmpty = y),
    (RP.proj = {}),
    (RP.proj.Projection = ze),
    (RP.proj.Units = {}),
    (RP.proj.Units.METERS_PER_UNIT = je),
    (RP.proj.Units.fromCode = Be),
    (RP.proj.addCommon = wn),
    (RP.proj.addCoordinateTransforms = an),
    (RP.proj.addEquivalentProjections = nn),
    (RP.proj.addEquivalentTransforms = rn),
    (RP.proj.addProjection = $i),
    (RP.proj.addProjections = Ji),
    (RP.proj.clearAllProjections = function () {
      ri(), li();
    }),
    (RP.proj.clearUserProjection = function () {
      gn = null;
    }),
    (RP.proj.cloneTransform = Yi),
    (RP.proj.createProjection = sn),
    (RP.proj.createSafeCoordinateTransform = Cn),
    (RP.proj.createTransformFromCoordinateTransform = on),
    (RP.proj.disableCoordinateWarning = Hi),
    (RP.proj.epsg3857 = {}),
    (RP.proj.epsg3857.EXTENT = Ve),
    (RP.proj.epsg3857.HALF_SIZE = qe),
    (RP.proj.epsg3857.MAX_SAFE_Y = Ze),
    (RP.proj.epsg3857.PROJECTIONS = He),
    (RP.proj.epsg3857.RADIUS = Ue),
    (RP.proj.epsg3857.WORLD_EXTENT = Xe),
    (RP.proj.epsg3857.fromEPSG4326 = Ye),
    (RP.proj.epsg3857.toEPSG4326 = Qe),
    (RP.proj.epsg4326 = {}),
    (RP.proj.epsg4326.EXTENT = Je),
    (RP.proj.epsg4326.METERS_PER_UNIT = ti),
    (RP.proj.epsg4326.PROJECTIONS = ii),
    (RP.proj.epsg4326.RADIUS = $e),
    (RP.proj.equivalent = ln),
    (RP.proj.fromLonLat = function (t, e) {
      return Hi(), un(t, "EPSG:4326", void 0 !== e ? e : "EPSG:3857");
    }),
    (RP.proj.fromUserCoordinate = _n),
    (RP.proj.fromUserExtent = xn),
    (RP.proj.fromUserResolution = Sn),
    (RP.proj.get = tn),
    (RP.proj.getPointResolution = en),
    (RP.proj.getTransform = cn),
    (RP.proj.getTransformFromProjections = hn),
    (RP.proj.getUserProjection = pn),
    (RP.proj.identityTransform = Qi),
    (RP.proj.proj4 = {}),
    (RP.proj.proj4.epsgLookupMapTiler = function (t) {
      return async function (e) {
        const i = await fetch(
          `https://api.maptiler.com/coordinates/search/code:${e}.json?transformations=true&exports=true&key=${t}`
        );
        if (!i.ok)
          throw new Error(`Unexpected response from maptiler.com: ${i.status}`);
        return i.json().then((t) => {
          const i = t.results;
          if (i?.length > 0) {
            const t = i.filter(
              (t) => "EPSG" === t.id?.authority && t.id?.code === e
            )[0];
            if (t) {
              const e = t.transformations;
              if (e?.length > 0) {
                const i = t.default_transformation;
                if (
                  e.filter(
                    (t) =>
                      t.id?.authority === i?.authority &&
                      t.id?.code === i?.code &&
                      0 === t.grids?.length
                  ).length > 0
                )
                  return t.exports?.proj4;
                const n = e
                  .filter(
                    (t) =>
                      0 === t.grids?.length &&
                      "EPSG" === t.target_crs?.authority &&
                      4326 === t.target_crs?.code &&
                      !1 === t.deprecated &&
                      !0 === t.usable
                  )
                  .sort((t, e) => t.accuracy - e.accuracy)[0]?.exports?.proj4;
                if (n) return n;
              }
              return t.exports?.proj4;
            }
          }
        });
      };
    }),
    (RP.proj.proj4.fromEPSGCode = async function (t) {
      "string" == typeof t && (t = parseInt(t.split(":").pop(), 10));
      const e = Gx;
      if (!e)
        throw new Error("Proj4 must be registered first with register(proj4)");
      const i = "EPSG:" + t;
      return e.defs(i) || (e.defs(i, await jx(t)), Bx(e)), tn(i);
    }),
    (RP.proj.proj4.getEPSGLookup = function () {
      return jx;
    }),
    (RP.proj.proj4.isRegistered = function () {
      return !!Gx;
    }),
    (RP.proj.proj4.register = Bx),
    (RP.proj.proj4.setEPSGLookup = function (t) {
      jx = t;
    }),
    (RP.proj.proj4.unregister = function () {
      Gx = null;
    }),
    (RP.proj.projections = {}),
    (RP.proj.projections.add = oi),
    (RP.proj.projections.clear = ri),
    (RP.proj.projections.get = si),
    (RP.proj.setUserProjection = fn),
    (RP.proj.toLonLat = function (t, e) {
      const i = un(t, void 0 !== e ? e : "EPSG:3857", "EPSG:4326"),
        n = i[0];
      return (n < -180 || n > 180) && (i[0] = _i(n + 180, 360) - 180), i;
    }),
    (RP.proj.toUserCoordinate = mn),
    (RP.proj.toUserExtent = yn),
    (RP.proj.toUserResolution = vn),
    (RP.proj.transform = un),
    (RP.proj.transformExtent = dn),
    (RP.proj.transformWithProjections = function (t, e, i) {
      return hn(e, i)(t);
    }),
    (RP.proj.transforms = {}),
    (RP.proj.transforms.add = hi),
    (RP.proj.transforms.clear = li),
    (RP.proj.transforms.get = ci),
    (RP.proj.transforms.remove = function (t, e) {
      const i = t.getCode(),
        n = e.getCode(),
        r = ai[i][n];
      return delete ai[i][n], y(ai[i]) && delete ai[i], r;
    }),
    (RP.proj.useGeographic = function () {
      fn("EPSG:4326");
    }),
    (RP.render = {}),
    (RP.render.Box = Ga),
    (RP.render.Event = oo),
    (RP.render.Feature = Dx),
    (RP.render.Feature.toFeature = function (t, e) {
      const i = t.getId(),
        n = Nx(t),
        r = t.getProperties(),
        s = new Mt();
      return (
        void 0 !== e && s.setGeometryName(e),
        s.setGeometry(n),
        void 0 !== i && s.setId(i),
        s.setProperties(r, !0),
        s
      );
    }),
    (RP.render.Feature.toGeometry = Nx),
    (RP.render.VectorContext = Bc),
    (RP.render.canvas = {}),
    (RP.render.canvas.Builder = jc),
    (RP.render.canvas.BuilderGroup = Yc),
    (RP.render.canvas.Executor = uu),
    (RP.render.canvas.ExecutorGroup = pu),
    (RP.render.canvas.ExecutorGroup.getPixelIndexArray = fu),
    (RP.render.canvas.ImageBuilder = zc),
    (RP.render.canvas.Immediate = mu),
    (RP.render.canvas.Instruction = {}),
    (RP.render.canvas.Instruction.beginPathInstruction = Dc),
    (RP.render.canvas.Instruction.closePathInstruction = Gc),
    (RP.render.canvas.Instruction.fillInstruction = Ac),
    (RP.render.canvas.Instruction.strokeInstruction = Nc),
    (RP.render.canvas.LineStringBuilder = Uc),
    (RP.render.canvas.PolygonBuilder = qc),
    (RP.render.canvas.TextBuilder = Kc),
    (RP.render.canvas.TextBuilder.TEXT_ALIGN = Zc),
    (RP.render.canvas.checkedFonts = To),
    (RP.render.canvas.defaultFillStyle = yo),
    (RP.render.canvas.defaultFont = _o),
    (RP.render.canvas.defaultLineCap = xo),
    (RP.render.canvas.defaultLineDash = vo),
    (RP.render.canvas.defaultLineDashOffset = 0),
    (RP.render.canvas.defaultLineJoin = So),
    (RP.render.canvas.defaultLineWidth = 1),
    (RP.render.canvas.defaultMiterLimit = Co),
    (RP.render.canvas.defaultPadding = Ro),
    (RP.render.canvas.defaultStrokeStyle = wo),
    (RP.render.canvas.defaultTextAlign = Wo),
    (RP.render.canvas.defaultTextBaseline = Eo),
    (RP.render.canvas.drawImageOrLabel = No),
    (RP.render.canvas.getTextDimensions = Ao),
    (RP.render.canvas.hitdetect = {}),
    (RP.render.canvas.hitdetect.HIT_DETECT_RESOLUTION = _u),
    (RP.render.canvas.hitdetect.createHitDetectionImageData = yu),
    (RP.render.canvas.hitdetect.hitDetect = xu),
    (RP.render.canvas.measureAndCacheTextWidth = ko),
    (RP.render.canvas.measureTextHeight = Lo),
    (RP.render.canvas.measureTextWidth = Oo),
    (RP.render.canvas.registerFont = Io),
    (RP.render.canvas.rotateAtOffset = function (t, e, i, n) {
      0 !== e && (t.translate(i, n), t.rotate(e), t.translate(-i, -n));
    }),
    (RP.render.canvas.style = {}),
    (RP.render.canvas.style.buildRuleSet = ic),
    (RP.render.canvas.style.buildStyle = nc),
    (RP.render.canvas.style.flatStylesToStyleFunction = ec),
    (RP.render.canvas.style.rulesToStyleFunction = tc),
    (RP.render.canvas.textHeights = Fo),
    (RP.render.getRenderPixel = function (t, e) {
      return Bt(t.inversePixelTransform, e.slice(0));
    }),
    (RP.render.getVectorContext = Vu),
    (RP.render.toContext = function (t, e) {
      const i = t.canvas,
        n = (e = e || {}).pixelRatio || ut,
        r = e.size;
      r &&
        ((i.width = r[0] * n),
        (i.height = r[1] * n),
        (i.style.width = r[0] + "px"),
        (i.style.height = r[1] + "px"));
      const s = [0, 0, i.width, i.height],
        o = zt([1, 0, 0, 1, 0, 0], n, n);
      return new mu(t, n, s, o, 0);
    }),
    (RP.render.webgl = {}),
    (RP.render.webgl.MixedGeometryBatch = ix),
    (RP.render.webgl.VectorStyleRenderer = xx),
    (RP.render.webgl.renderinstructions = {}),
    (RP.render.webgl.renderinstructions.generateLineStringRenderInstructions =
      lx),
    (RP.render.webgl.renderinstructions.generatePointRenderInstructions = ax),
    (RP.render.webgl.renderinstructions.generatePolygonRenderInstructions = hx),
    (RP.render.webgl.renderinstructions.getCustomAttributesSize = ox),
    (RP.render.webgl.utils = {}),
    (RP.render.webgl.utils.colorDecodeId = lg),
    (RP.render.webgl.utils.colorEncodeId = ag),
    (RP.render.webgl.utils.getBlankImageData = function () {
      const t = document
        .createElement("canvas")
        .getContext("2d")
        .createImageData(1, 1);
      return (
        (t.data[0] = 255),
        (t.data[1] = 255),
        (t.data[2] = 255),
        (t.data[3] = 255),
        t
      );
    }),
    (RP.render.webgl.utils.writeLineSegmentToBuffers = function (
      t,
      e,
      i,
      n,
      r,
      s,
      o,
      a,
      l,
      h
    ) {
      const c = 8 + a.length,
        u = s.length / c,
        d = [t[e + 0], t[e + 1]],
        g = [t[i], t[i + 1]],
        f = Bt(l, [...d]),
        p = Bt(l, [...g]);
      function m(t, e, i) {
        const n = Math.sqrt(
            (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1])
          ),
          r = [(e[0] - t[0]) / n, (e[1] - t[1]) / n],
          s = [-r[1], r[0]],
          o = Math.sqrt(
            (i[0] - t[0]) * (i[0] - t[0]) + (i[1] - t[1]) * (i[1] - t[1])
          ),
          a = [(i[0] - t[0]) / o, (i[1] - t[1]) / o],
          l =
            0 === n || 0 === o
              ? 0
              : Math.acos(ui(a[0] * r[0] + a[1] * r[1], -1, 1));
        return a[0] * s[0] + a[1] * s[1] > 0 ? l : 2 * Math.PI - l;
      }
      let _ = -1,
        y = -1;
      const x = null !== r;
      if (null !== n) {
        _ = m(f, p, Bt(l, [...[t[n], t[n + 1]]]));
      }
      if (x) {
        y = m(p, f, Bt(l, [...[t[r], t[r + 1]]]));
      }
      return (
        s.push(d[0], d[1], g[0], g[1], _, y, h, 0),
        s.push(...a),
        s.push(d[0], d[1], g[0], g[1], _, y, h, 1),
        s.push(...a),
        s.push(d[0], d[1], g[0], g[1], _, y, h, 2),
        s.push(...a),
        s.push(d[0], d[1], g[0], g[1], _, y, h, 3),
        s.push(...a),
        o.push(u, u + 1, u + 2, u + 1, u + 3, u + 2),
        h +
          Math.sqrt(
            (p[0] - f[0]) * (p[0] - f[0]) + (p[1] - f[1]) * (p[1] - f[1])
          )
      );
    }),
    (RP.render.webgl.utils.writePointFeatureToBuffers = function (
      t,
      e,
      i,
      n,
      r,
      s
    ) {
      const o = 3 + r,
        a = t[e + 0],
        l = t[e + 1],
        h = rg;
      h.length = r;
      for (let i = 0; i < h.length; i++) h[i] = t[e + 2 + i];
      let c = s ? s.vertexPosition : 0,
        u = s ? s.indexPosition : 0;
      const d = c / o;
      return (
        og(i, c, a, l, 0),
        h.length && i.set(h, c + 3),
        (c += o),
        og(i, c, a, l, 1),
        h.length && i.set(h, c + 3),
        (c += o),
        og(i, c, a, l, 2),
        h.length && i.set(h, c + 3),
        (c += o),
        og(i, c, a, l, 3),
        h.length && i.set(h, c + 3),
        (c += o),
        (n[u++] = d),
        (n[u++] = d + 1),
        (n[u++] = d + 3),
        (n[u++] = d + 1),
        (n[u++] = d + 2),
        (n[u++] = d + 3),
        (sg.vertexPosition = c),
        (sg.indexPosition = u),
        sg
      );
    }),
    (RP.render.webgl.utils.writePolygonTrianglesToBuffers = function (
      t,
      e,
      i,
      n,
      r
    ) {
      const s = 2 + r;
      let o = e;
      const a = t.slice(o, o + r);
      o += r;
      const l = t[o++];
      let h = 0;
      const c = new Array(l - 1);
      for (let e = 0; e < l; e++) (h += t[o++]), e < l - 1 && (c[e] = h);
      const u = t.slice(o, o + 2 * h),
        d = ng(u, c, 2);
      for (let t = 0; t < d.length; t++) n.push(d[t] + i.length / s);
      for (let t = 0; t < u.length; t += 2) i.push(u[t], u[t + 1], ...a);
      return o + 2 * h;
    }),
    (RP.renderer = {}),
    (RP.renderer.Composite = Do),
    (RP.renderer.Layer = Qc),
    (RP.renderer.Map = so),
    (RP.renderer.canvas = {}),
    (RP.renderer.canvas.ImageLayer = Nf),
    (RP.renderer.canvas.Layer = tu),
    (RP.renderer.canvas.Layer.canvasPool = $c),
    (RP.renderer.canvas.TileLayer = zf),
    (RP.renderer.canvas.VectorImageLayer = Vf),
    (RP.renderer.canvas.VectorLayer = Tu),
    (RP.renderer.canvas.VectorTileLayer = Hf),
    (RP.renderer.vector = {}),
    (RP.renderer.vector.defaultOrder = Cu),
    (RP.renderer.vector.getSquaredTolerance = wu),
    (RP.renderer.vector.getTolerance = Wu),
    (RP.renderer.vector.renderFeature = Eu),
    (RP.renderer.webgl = {}),
    (RP.renderer.webgl.Layer = wd),
    (RP.renderer.webgl.PointsLayer = cg),
    (RP.renderer.webgl.TileLayer = Yg),
    (RP.renderer.webgl.TileLayer.Attributes = Kg),
    (RP.renderer.webgl.TileLayer.Uniforms = Zg),
    (RP.renderer.webgl.TileLayerBase = Xg),
    (RP.renderer.webgl.TileLayerBase.Uniforms = Gg),
    (RP.renderer.webgl.TileLayerBase.getCacheKey = Vg),
    (RP.renderer.webgl.TileLayerBase.newTileRepresentationLookup = jg),
    (RP.renderer.webgl.VectorLayer = Sx),
    (RP.renderer.webgl.VectorLayer.Uniforms = vx),
    (RP.renderer.webgl.VectorTileLayer = Cx),
    (RP.reproj = {}),
    (RP.reproj.DataTile = Sg),
    (RP.reproj.Image = cm),
    (RP.reproj.Tile = Cg),
    (RP.reproj.Triangulation = gg),
    (RP.reproj.calculateSourceExtentResolution = xg),
    (RP.reproj.calculateSourceResolution = yg),
    (RP.reproj.canvasPool = pg),
    (RP.reproj.common = {}),
    (RP.reproj.common.ERROR_THRESHOLD = dg),
    (RP.reproj.render = vg),
    (RP.resolution = {}),
    (RP.resolution.fromResolutionLike = qf),
    (RP.resolutionconstraint = {}),
    (RP.resolutionconstraint.createMinMaxResolution = qs),
    (RP.resolutionconstraint.createSnapToPower = Us),
    (RP.resolutionconstraint.createSnapToResolutions = zs),
    (RP.rotationconstraint = {}),
    (RP.rotationconstraint.createSnapToN = Zs),
    (RP.rotationconstraint.createSnapToZero = Ks),
    (RP.rotationconstraint.disable = Vs),
    (RP.rotationconstraint.none = Xs),
    (RP.size = {}),
    (RP.size.buffer = function (t, e, i) {
      return (
        void 0 === i && (i = [0, 0]),
        (i[0] = t[0] + 2 * e),
        (i[1] = t[1] + 2 * e),
        i
      );
    }),
    (RP.size.hasArea = nl),
    (RP.size.scale = rl),
    (RP.size.toSize = sl),
    (RP.source = {}),
    (RP.source.BingMaps = Lp),
    (RP.source.BingMaps.quadKey = Ip),
    (RP.source.CartoDB = Op),
    (RP.source.Cluster = kp),
    (RP.source.DataTile = Ap),
    (RP.source.GeoTIFF = Yp),
    (RP.source.IIIF = hm),
    (RP.source.Image = ym),
    (RP.source.Image.ImageSourceEvent = pm),
    (RP.source.Image.defaultImageLoadFunction = mm),
    (RP.source.Image.getRequestExtent = _m),
    (RP.source.ImageArcGISRest = Cm),
    (RP.source.ImageCanvas = wm),
    (RP.source.ImageMapGuide = Rm),
    (RP.source.ImageStatic = Pm),
    (RP.source.ImageWMS = km),
    (RP.source.OGCMapTile = Km),
    (RP.source.OGCVectorTile = t_),
    (RP.source.OSM = i_),
    (RP.source.OSM.ATTRIBUTION = e_),
    (RP.source.Raster = m_),
    (RP.source.Raster.Processor = l_),
    (RP.source.Raster.RasterSourceEvent = u_),
    (RP.source.Raster.newImageData = s_),
    (RP.source.Source = Iu),
    (RP.source.StadiaMaps = x_),
    (RP.source.Tile = Sp),
    (RP.source.Tile.TileSourceEvent = vp),
    (RP.source.TileArcGISRest = v_),
    (RP.source.TileDebug = S_),
    (RP.source.TileImage = Fp),
    (RP.source.TileJSON = C_),
    (RP.source.TileWMS = w_),
    (RP.source.UTFGrid = E_),
    (RP.source.UTFGrid.CustomTile = W_),
    (RP.source.UrlTile = Pp),
    (RP.source.Vector = qu),
    (RP.source.Vector.VectorSourceEvent = Uu),
    (RP.source.VectorTile = $m),
    (RP.source.VectorTile.defaultLoadFunction = Jm),
    (RP.source.WMTS = b_),
    (RP.source.WMTS.optionsFromCapabilities = function (t, e) {
      const i = t.Contents.Layer.find(function (t) {
        return t.Identifier == e.layer;
      });
      if (!i) return null;
      const n = t.Contents.TileMatrixSet;
      let r;
      (r =
        i.TileMatrixSetLink.length > 1
          ? "projection" in e
            ? i.TileMatrixSetLink.findIndex(function (t) {
                const i = n.find(function (e) {
                    return e.Identifier == t.TileMatrixSet;
                  }).SupportedCRS,
                  r = tn(i),
                  s = tn(e.projection);
                return r && s ? ln(r, s) : i == e.projection;
              })
            : i.TileMatrixSetLink.findIndex(function (t) {
                return t.TileMatrixSet == e.matrixSet;
              })
          : 0),
        r < 0 && (r = 0);
      const s = i.TileMatrixSetLink[r].TileMatrixSet,
        o = i.TileMatrixSetLink[r].TileMatrixSetLimits;
      let a = i.Format[0];
      "format" in e && (a = e.format),
        (r = i.Style.findIndex(function (t) {
          return "style" in e ? t.Title == e.style : t.isDefault;
        })),
        r < 0 && (r = 0);
      const l = i.Style[r].Identifier,
        h = {};
      "Dimension" in i &&
        i.Dimension.forEach(function (t, e, i) {
          const n = t.Identifier;
          let r = t.Default;
          void 0 === r && (r = t.Value[0]), (h[n] = r);
        });
      const c = t.Contents.TileMatrixSet.find(function (t) {
        return t.Identifier == s;
      });
      let u;
      const d = c.SupportedCRS;
      if ((d && (u = tn(d)), "projection" in e)) {
        const t = tn(e.projection);
        t && ((u && !ln(t, u)) || (u = t));
      }
      let g = !1;
      const f = "ne" == u.getAxisOrientation().substr(0, 2);
      let p = c.TileMatrix[0],
        m = {
          MinTileCol: 0,
          MinTileRow: 0,
          MaxTileCol: p.MatrixWidth - 1,
          MaxTileRow: p.MatrixHeight - 1,
        };
      if (o) {
        m = o[o.length - 1];
        const t = c.TileMatrix.find(
          (t) =>
            t.Identifier === m.TileMatrix ||
            c.Identifier + ":" + t.Identifier === m.TileMatrix
        );
        t && (p = t);
      }
      const _ = (28e-5 * p.ScaleDenominator) / u.getMetersPerUnit(),
        y = f ? [p.TopLeftCorner[1], p.TopLeftCorner[0]] : p.TopLeftCorner,
        x = p.TileWidth * _,
        v = p.TileHeight * _;
      let S = c.BoundingBox;
      S && f && (S = [S[1], S[0], S[3], S[2]]);
      let C = [
        y[0] + x * m.MinTileCol,
        y[1] - v * (1 + m.MaxTileRow),
        y[0] + x * (1 + m.MaxTileCol),
        y[1] - v * m.MinTileRow,
      ];
      if (void 0 !== S && !ie(S, C)) {
        const t = i.WGS84BoundingBox,
          e = tn("EPSG:4326").getExtent();
        if (((C = S), t)) g = t[0] === e[0] && t[2] === e[2];
        else {
          const t = dn(S, c.SupportedCRS, "EPSG:4326");
          g = t[0] - 1e-10 <= e[0] && t[2] + 1e-10 >= e[2];
        }
      }
      const w = P_(c, C, o),
        W = [];
      let E = e.requestEncoding;
      if (
        ((E = void 0 !== E ? E : ""),
        "OperationsMetadata" in t && "GetTile" in t.OperationsMetadata)
      ) {
        const e = t.OperationsMetadata.GetTile.DCP.HTTP.Get;
        for (let t = 0, i = e.length; t < i; ++t)
          if (e[t].Constraint) {
            const i = e[t].Constraint.find(function (t) {
              return "GetEncoding" == t.name;
            }).AllowedValues.Value;
            if (("" === E && (E = i[0]), "KVP" !== E)) break;
            i.includes("KVP") && W.push(e[t].href);
          } else e[t].href && ((E = "KVP"), W.push(e[t].href));
      }
      return (
        0 === W.length &&
          ((E = "REST"),
          i.ResourceURL.forEach(function (t) {
            "tile" === t.resourceType && ((a = t.format), W.push(t.template));
          })),
        {
          urls: W,
          layer: e.layer,
          matrixSet: s,
          format: a,
          projection: u,
          requestEncoding: E,
          tileGrid: w,
          style: l,
          dimensions: h,
          wrapX: g,
          crossOrigin: e.crossOrigin,
        }
      );
    }),
    (RP.source.XYZ = Mp),
    (RP.source.Zoomify = $p),
    (RP.source.Zoomify.CustomTile = Qp),
    (RP.source.arcgisRest = {}),
    (RP.source.arcgisRest.createLoader = Sm),
    (RP.source.arcgisRest.getRequestUrl = vm),
    (RP.source.common = {}),
    (RP.source.common.DECIMALS = um),
    (RP.source.common.DEFAULT_WMS_VERSION = "1.3.0"),
    (RP.source.mapguide = {}),
    (RP.source.mapguide.createLoader = Em),
    (RP.source.ogcTileUtil = {}),
    (RP.source.ogcTileUtil.getMapTileUrlTemplate = qm),
    (RP.source.ogcTileUtil.getTileSetInfo = Zm),
    (RP.source.ogcTileUtil.getVectorTileUrlTemplate = Vm),
    (RP.source.sourcesFromTileGrid = function (t, e) {
      const i = new Pg(32),
        n = t.getExtent();
      return function (r, s) {
        i.expireCache(), n && (r = Te(n, r));
        const o = t.getZForResolution(s),
          a = [];
        return (
          t.forEachTileCoord(r, o, (t) => {
            const n = t.toString();
            if (!i.containsKey(n)) {
              const r = e(t);
              i.set(n, r);
            }
            a.push(i.get(n));
          }),
          a
        );
      };
    }),
    (RP.source.static = {}),
    (RP.source.static.createLoader = Tm),
    (RP.source.wms = {}),
    (RP.source.wms.DEFAULT_VERSION = bm),
    (RP.source.wms.createLoader = Mm),
    (RP.source.wms.getImageSrc = Im),
    (RP.source.wms.getRequestParams = Lm),
    (RP.source.wms.getRequestUrl = Fm),
    (RP.sphere = {}),
    (RP.sphere.DEFAULT_RADIUS = Gi),
    (RP.sphere.getArea = function t(e, i) {
      const n = (i = i || {}).radius || Gi,
        r = i.projection || "EPSG:3857",
        s = e.getType();
      "GeometryCollection" !== s && (e = e.clone().transform(r, "EPSG:4326"));
      let o,
        a,
        l,
        h,
        c,
        u,
        d = 0;
      switch (s) {
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
        case "LinearRing":
          break;
        case "Polygon":
          for (
            o = e.getCoordinates(),
              d = Math.abs(zi(o[0], n)),
              l = 1,
              h = o.length;
            l < h;
            ++l
          )
            d -= Math.abs(zi(o[l], n));
          break;
        case "MultiPolygon":
          for (o = e.getCoordinates(), l = 0, h = o.length; l < h; ++l)
            for (
              a = o[l], d += Math.abs(zi(a[0], n)), c = 1, u = a.length;
              c < u;
              ++c
            )
              d -= Math.abs(zi(a[c], n));
          break;
        case "GeometryCollection": {
          const n = e.getGeometries();
          for (l = 0, h = n.length; l < h; ++l) d += t(n[l], i);
          break;
        }
        default:
          throw new Error("Unsupported geometry type: " + s);
      }
      return d;
    }),
    (RP.sphere.getDistance = Bi),
    (RP.sphere.getLength = function t(e, i) {
      const n = (i = i || {}).radius || Gi,
        r = i.projection || "EPSG:3857",
        s = e.getType();
      "GeometryCollection" !== s && (e = e.clone().transform(r, "EPSG:4326"));
      let o,
        a,
        l,
        h,
        c,
        u,
        d = 0;
      switch (s) {
        case "Point":
        case "MultiPoint":
          break;
        case "LineString":
        case "LinearRing":
          (o = e.getCoordinates()), (d = ji(o, n));
          break;
        case "MultiLineString":
        case "Polygon":
          for (o = e.getCoordinates(), l = 0, h = o.length; l < h; ++l)
            d += ji(o[l], n);
          break;
        case "MultiPolygon":
          for (o = e.getCoordinates(), l = 0, h = o.length; l < h; ++l)
            for (a = o[l], c = 0, u = a.length; c < u; ++c) d += ji(a[c], n);
          break;
        case "GeometryCollection": {
          const n = e.getGeometries();
          for (l = 0, h = n.length; l < h; ++l) d += t(n[l], i);
          break;
        }
        default:
          throw new Error("Unsupported geometry type: " + s);
      }
      return d;
    }),
    (RP.sphere.offset = Ui),
    (RP.string = {}),
    (RP.string.compareVersions = Wi),
    (RP.string.padNumber = wi),
    (RP.structs = {}),
    (RP.structs.LRUCache = Pg),
    (RP.structs.LinkedList = rx),
    (RP.structs.PriorityQueue = aa),
    (RP.structs.PriorityQueue.DROP = oa),
    (RP.structs.RBush = bu),
    (RP.style = {}),
    (RP.style.Circle = Hl),
    (RP.style.Fill = Ol),
    (RP.style.Icon = bh),
    (RP.style.IconImage = Rh),
    (RP.style.IconImage.get = Eh),
    (RP.style.IconImageCache = ps),
    (RP.style.IconImageCache.shared = ms),
    (RP.style.Image = ql),
    (RP.style.RegularShape = Zl),
    (RP.style.Stroke = zl),
    (RP.style.Style = ih),
    (RP.style.Style.createDefaultStyle = Jl),
    (RP.style.Style.createEditingStyle = th),
    (RP.style.Style.toFunction = Ql),
    (RP.style.Text = rh),
    (RP.style.expressions = {}),
    (RP.style.expressions.Operators = $g),
    (RP.style.expressions.PALETTE_TEXTURE_ARRAY = wf),
    (RP.style.expressions.arrayToGlsl = rf),
    (RP.style.expressions.colorToGlsl = sf),
    (RP.style.expressions.expressionToGlsl = cf),
    (RP.style.expressions.getStringNumberEquivalent = lf),
    (RP.style.expressions.getValueType = Jg),
    (RP.style.expressions.isTypeUnique = tf),
    (RP.style.expressions.numberToGlsl = nf),
    (RP.style.expressions.stringToGlsl = hf),
    (RP.style.expressions.uniformNameForVariable = Cf),
    (RP.style.flat = {}),
    (RP.style.flat.createDefaultStyle = Tf),
    (RP.tilecoord = {}),
    (RP.tilecoord.createOrUpdate = Lg),
    (RP.tilecoord.fromKey = Ag),
    (RP.tilecoord.getCacheKeyForTileKey = kg),
    (RP.tilecoord.getKey = Og),
    (RP.tilecoord.getKeyZXY = Mg),
    (RP.tilecoord.hash = Ng),
    (RP.tilecoord.withinExtentAndZ = Dg),
    (RP.tilegrid = {}),
    (RP.tilegrid.TileGrid = dp),
    (RP.tilegrid.WMTS = T_),
    (RP.tilegrid.WMTS.createFromCapabilitiesMatrixSet = P_),
    (RP.tilegrid.common = {}),
    (RP.tilegrid.common.DEFAULT_MAX_ZOOM = As),
    (RP.tilegrid.common.DEFAULT_TILE_SIZE = Ns),
    (RP.tilegrid.createForExtent = pp),
    (RP.tilegrid.createForProjection = yp),
    (RP.tilegrid.createXYZ = mp),
    (RP.tilegrid.extentFromProjection = xp),
    (RP.tilegrid.getForProjection = gp),
    (RP.tilegrid.wrapX = fp),
    (RP.tileurlfunction = {}),
    (RP.tileurlfunction.createFromTemplate = Cp),
    (RP.tileurlfunction.createFromTemplates = wp),
    (RP.tileurlfunction.createFromTileUrlFunctions = Wp),
    (RP.tileurlfunction.expandUrl = Rp),
    (RP.tileurlfunction.nullTileUrlFunction = Ep),
    (RP.transform = {}),
    (RP.transform.apply = Bt),
    (RP.transform.compose = Vt),
    (RP.transform.composeCssTransform = function (t, e, i, n, r, s, o) {
      return Ht(Vt([1, 0, 0, 1, 0, 0], t, e, i, n, r, s, o));
    }),
    (RP.transform.create = kt),
    (RP.transform.determinant = Zt),
    (RP.transform.invert = function (t) {
      return Xt(t, t);
    }),
    (RP.transform.makeInverse = Xt),
    (RP.transform.makeScale = Ut),
    (RP.transform.multiply = Nt),
    (RP.transform.reset = At),
    (RP.transform.rotate = jt),
    (RP.transform.scale = zt),
    (RP.transform.set = Dt),
    (RP.transform.setFromArray = Gt),
    (RP.transform.toString = Ht),
    (RP.transform.translate = qt),
    (RP.uri = {}),
    (RP.uri.appendParams = xm),
    (RP.util = {}),
    (RP.util.VERSION = "ol:8.1.0--neshan_sdk:1.0.5"),
    (RP.util.abstract = G),
    (RP.util.getUid = j),
    (RP.vec = {}),
    (RP.vec.mat4 = {}),
    (RP.vec.mat4.create = dd),
    (RP.vec.mat4.fromTransform = gd),
    (RP.webgl = {}),
    (RP.webgl.ARRAY_BUFFER = $u),
    (RP.webgl.BaseTileRepresentation = wg),
    (RP.webgl.Buffer = ld),
    (RP.webgl.Buffer.getArrayClassForType = ad),
    (RP.webgl.DYNAMIC_DRAW = ed),
    (RP.webgl.ELEMENT_ARRAY_BUFFER = Ju),
    (RP.webgl.FLOAT = id),
    (RP.webgl.Helper = Sd),
    (RP.webgl.Helper.computeAttributesStride = xd),
    (RP.webgl.PaletteTexture = ug),
    (RP.webgl.PostProcessingPass = ud),
    (RP.webgl.RenderTarget = Ed),
    (RP.webgl.STATIC_DRAW = td),
    (RP.webgl.STREAM_DRAW = 35040),
    (RP.webgl.ShaderBuilder = {}),
    (RP.webgl.ShaderBuilder.ShaderBuilder = Ff),
    (RP.webgl.TileGeometry = nx),
    (RP.webgl.TileTexture = Tg),
    (RP.webgl.UNSIGNED_BYTE = 5121),
    (RP.webgl.UNSIGNED_INT = 5125),
    (RP.webgl.UNSIGNED_SHORT = 5123),
    (RP.webgl.getContext = rd),
    (RP.webgl.getSupportedExtensions = function () {
      if (!sd) {
        const t = rd(document.createElement("canvas"));
        t && (sd = t.getSupportedExtensions());
      }
      return sd;
    }),
    (RP.webgl.styleparser = {}),
    (RP.webgl.styleparser.packColor = Qf),
    (RP.webgl.styleparser.parseLiteralStyle = ip),
    (RP.xml = {}),
    (RP.xml.OBJECT_PROPERTY_NODE_FACTORY = qy),
    (RP.xml.XML_SCHEMA_INSTANCE_URI = by),
    (RP.xml.createElementNS = Fy),
    (RP.xml.getAllTextContent = Iy),
    (RP.xml.getAllTextContent_ = Ly),
    (RP.xml.getAttributeNS = Oy),
    (RP.xml.getDocument = tx),
    (RP.xml.getXMLSerializer = Jy),
    (RP.xml.isDocument = My),
    (RP.xml.makeArrayExtender = Ay),
    (RP.xml.makeArrayPusher = Ny),
    (RP.xml.makeArraySerializer = zy),
    (RP.xml.makeChildAppender = jy),
    (RP.xml.makeObjectPropertyPusher = Gy),
    (RP.xml.makeObjectPropertySetter = By),
    (RP.xml.makeReplacer = Dy),
    (RP.xml.makeSequence = Vy),
    (RP.xml.makeSimpleNodeFactory = Uy),
    (RP.xml.makeStructureNS = Xy),
    (RP.xml.parse = ky),
    (RP.xml.parseNode = Zy),
    (RP.xml.pushParseAndPop = Ky),
    (RP.xml.pushSerializeAndPop = Yy),
    (RP.xml.registerDocument = function (t) {
      $y = t;
    }),
    (RP.xml.registerXMLSerializer = function (t) {
      Qy = t;
    }),
    (RP.xml.serialize = Hy),
    RP
  );
})();
